"Id","Tool Detection","Repository","File","Type","Lines","Method Lines","Prompt","Original Method","Refactored Method","Refactored","Removed smell","Test passed","Added smell","Test After","Coverage 
after","Observation"
1,"snutsjs","verlok/vanilla-lazyload","/tests/unit/cancelOnExit.test.js","SubOptimalAssert","{""startLine"":91,""endLine"":91}","start: 87 end: 92","In this test file, the following lines contain a bad design pattern (also known as a test smell):

Lines {""startLine"":91,""endLine"":91}  – SubOptimalAssert
Occurs when the assertions used in tests are not ideal for verifying the specific condition being tested. Using more specific and expressive assertions can improve test clarity and make results more useful
To improve test quality and maintainability, can you refactor the method to eliminate ConditionalTestLogic while ensuring the test remains clear and effective?","test(""Resets internal status"", () => {
 img.setAttribute(""src"", url200);
 setSources(img, settings, instance);
 cancelLoading(img, entry, settings, instance);
 expect(getStatus(img)).toBe(null);
 });",,"FALSE","FALSE","FALSE","FALSE",,,
2,"steel","verlok/vanilla-lazyload","/tests/unit/cancelOnExit.test.js","Duplicate Assert","{'line': 68, 'column': 4, 'index': 1968}","start: 61 end: 71","In this test file, the following lines contain a bad design pattern (also known as a test smell):

Lines {'line': 68, 'column': 4, 'index': 1968}  – Duplicate Assert
This issue occurs when a test method verifies the same condition more than once within its scope, making the test harder to read and maintain. Identical assertions within the same method do not explicitly convey the purpose of the test method.
To improve test quality and maintainability, can you refactor the method to eliminate ConditionalTestLogic while ensuring the test remains clear and effective?","test(""Restores original attributes"", () => {
 img.setAttribute(""src"", url1);
 img.setAttribute(""data-src"", url100);
 img.setAttribute(""data-srcset"", url200);
 img.setAttribute(""data-sizes"", sizes100);
 setSources(img, settings, instance);
 cancelLoading(img, entry, settings, instance);
 expect(img).toHaveAttribute(""src"", url1);
 expect(img).not.toHaveAttribute(""srcset"");
 expect(img).not.toHaveAttribute(""sizes"");
 });",,"FALSE","FALSE","FALSE","FALSE",,,
3,"steel","verlok/vanilla-lazyload","/tests/unit/cancelOnExit.test.js","Duplicate Assert","{'line': 69, 'column': 4, 'index': 2014}","start: 61 end: 71","In this test file, the following lines contain a bad design pattern (also known as a test smell):

Lines {'line': 69, 'column': 4, 'index': 2014}  – Duplicate Assert
This issue occurs when a test method verifies the same condition more than once within its scope, making the test harder to read and maintain. Identical assertions within the same method do not explicitly convey the purpose of the test method.
To improve test quality and maintainability, can you refactor the method to eliminate ConditionalTestLogic while ensuring the test remains clear and effective?","test(""Restores original attributes"", () => {
 img.setAttribute(""src"", url1);
 img.setAttribute(""data-src"", url100);
 img.setAttribute(""data-srcset"", url200);
 img.setAttribute(""data-sizes"", sizes100);
 setSources(img, settings, instance);
 cancelLoading(img, entry, settings, instance);
 expect(img).toHaveAttribute(""src"", url1);
 expect(img).not.toHaveAttribute(""srcset"");
 expect(img).not.toHaveAttribute(""sizes"");
 });",,"FALSE","FALSE","FALSE","FALSE",,,
4,"steel","verlok/vanilla-lazyload","/tests/unit/cancelOnExit.test.js","Duplicate Assert","{'line': 70, 'column': 4, 'index': 2061}","start: 61 end: 71","In this test file, the following lines contain a bad design pattern (also known as a test smell):

Lines {'line': 70, 'column': 4, 'index': 2061}  – Duplicate Assert
This issue occurs when a test method verifies the same condition more than once within its scope, making the test harder to read and maintain. Identical assertions within the same method do not explicitly convey the purpose of the test method.
To improve test quality and maintainability, can you refactor the method to eliminate ConditionalTestLogic while ensuring the test remains clear and effective?","test(""Restores original attributes"", () => {
 img.setAttribute(""src"", url1);
 img.setAttribute(""data-src"", url100);
 img.setAttribute(""data-srcset"", url200);
 img.setAttribute(""data-sizes"", sizes100);
 setSources(img, settings, instance);
 cancelLoading(img, entry, settings, instance);
 expect(img).toHaveAttribute(""src"", url1);
 expect(img).not.toHaveAttribute(""srcset"");
 expect(img).not.toHaveAttribute(""sizes"");
 });",,"FALSE","FALSE","FALSE","FALSE",,,
5,"steel","verlok/vanilla-lazyload","/tests/unit/cancelOnExit.test.js","Duplicate Assert","{'line': 99, 'column': 4, 'index': 2957}","start: 94 end: 101","In this test file, the following lines contain a bad design pattern (also known as a test smell):

Lines {'line': 99, 'column': 4, 'index': 2957}  – Duplicate Assert
This issue occurs when a test method verifies the same condition more than once within its scope, making the test harder to read and maintain. Identical assertions within the same method do not explicitly convey the purpose of the test method.
To improve test quality and maintainability, can you refactor the method to eliminate ConditionalTestLogic while ensuring the test remains clear and effective?","test(""Callbacks are called"", () => {
 const cancelCb = jest.fn();
 settings.callback_cancel = cancelCb;
 setSources(img, settings, instance);
 cancelLoading(img, entry, settings, instance);
 expect(cancelCb).toHaveBeenCalledTimes(1);
 expect(cancelCb).toHaveBeenCalledWith(img, entry, instance);
 });",,"FALSE","FALSE","FALSE","FALSE",,,
6,"steel","verlok/vanilla-lazyload","/tests/unit/cancelOnExit.test.js","Duplicate Assert","{'line': 100, 'column': 4, 'index': 3004}","start: 94 end: 101","In this test file, the following lines contain a bad design pattern (also known as a test smell):

Lines {'line': 100, 'column': 4, 'index': 3004}  – Duplicate Assert
This issue occurs when a test method verifies the same condition more than once within its scope, making the test harder to read and maintain. Identical assertions within the same method do not explicitly convey the purpose of the test method.
To improve test quality and maintainability, can you refactor the method to eliminate ConditionalTestLogic while ensuring the test remains clear and effective?","test(""Callbacks are called"", () => {
 const cancelCb = jest.fn();
 settings.callback_cancel = cancelCb;
 setSources(img, settings, instance);
 cancelLoading(img, entry, settings, instance);
 expect(cancelCb).toHaveBeenCalledTimes(1);
 expect(cancelCb).toHaveBeenCalledWith(img, entry, instance);
 });",,"FALSE","FALSE","FALSE","FALSE",,,
7,"steel","verlok/vanilla-lazyload","/tests/unit/cancelOnExit.test.js","Magic Number","{'line': 84, 'column': 39, 'index': 2522}","start: 80 end: 85","In this test file, the following lines contain a bad design pattern (also known as a test smell):

Lines {'line': 84, 'column': 39, 'index': 2522}  – Magic Number
Occurs when numeric literals are used directly in tests without explanation or documentation. These numbers lack clear context, making the code less readable and harder to maintain, as it is not obvious why such values are used.
To improve test quality and maintainability, can you refactor the method to eliminate ConditionalTestLogic while ensuring the test remains clear and effective?","test(""Decreases loading count"", () => {
 img.setAttribute(""src"", url200);
 setSources(img, settings, instance);
 cancelLoading(img, entry, settings, instance);
 expect(instance.loadingCount).toBe(0);
 });",,"FALSE","FALSE","FALSE","FALSE",,,
8,"steel","verlok/vanilla-lazyload","/tests/unit/set.test.js","Magic Number","{'line': 29, 'column': 42, 'index': 889}","start: 26 end: 30","In this test file, the following lines contain a bad design pattern (also known as a test smell):

Lines {'line': 29, 'column': 42, 'index': 889}  – Magic Number
Occurs when numeric literals are used directly in tests without explanation or documentation. These numbers lack clear context, making the code less readable and harder to maintain, as it is not obvious why such values are used.
To improve test quality and maintainability, can you refactor the method to eliminate ConditionalTestLogic while ensuring the test remains clear and effective?","test('decreaseToLoadCount decreases toLoadCount by 1', () => {
 const mockInstance = { toLoadCount: 5 };
 decreaseToLoadCount(mockInstance);
 expect(mockInstance.toLoadCount).toBe(4);
 });",,"FALSE","FALSE","FALSE","FALSE",,,
9,"steel","verlok/vanilla-lazyload","/tests/unit/set.test.js","Magic Number","{'line': 35, 'column': 42, 'index': 1078}","start: 32 end: 36","In this test file, the following lines contain a bad design pattern (also known as a test smell):

Lines {'line': 35, 'column': 42, 'index': 1078}  – Magic Number
Occurs when numeric literals are used directly in tests without explanation or documentation. These numbers lack clear context, making the code less readable and harder to maintain, as it is not obvious why such values are used.
To improve test quality and maintainability, can you refactor the method to eliminate ConditionalTestLogic while ensuring the test remains clear and effective?","test('setToLoadCount sets toLoadCount to the given value', () => {
 const mockInstance = {};
 setToLoadCount(mockInstance, 10);
 expect(mockInstance.toLoadCount).toBe(10);
 });",,"FALSE","FALSE","FALSE","FALSE",,,
10,"snutsjs","vercel/ncc","/test/watcher.test.js","ConditionalTestLogic","{""startLine"":120,""endLine"":126}","start: 112 end: 157","In this test file, the following lines contain a bad design pattern (also known as a test smell):

Lines {""startLine"":120,""endLine"":126}  – ConditionalTestLogic
Occurs due to the presence of test methods that contain conditional statements, such as the use of if-else or loops like for or while. Test methods that include conditional statements can compromise the effectiveness of tests
To improve test quality and maintainability, can you refactor the method to eliminate ConditionalTestLogic while ensuring the test remains clear and effective?","it('Should support custom watch API', async () => {
 let buildCnt = 0;
 const buildFile = path.resolve('./test/integration/twilio.js');
 const initialBuildFileContents = fs.readFileSync(buildFile).toString();

 await new Promise((resolve, reject) => {
 const watcher = new CustomWatchFileSystem(function watchStart (files, dirs, missing) {
 expect(files._set.size).toBeGreaterThan(100);
 if (buildCnt < 3) {
 setTimeout(() => {
 // NOTE: We actually have to make the change for the rebuild to happen!
 fs.writeFileSync(buildFile, fs.readFileSync(buildFile).toString() + '\n');
 watcher.triggerChanges([buildFile], []);
 }, 100);
 }
 }, function watchEnd () {
 resolve();
 });

 console.time('First Build');
 const { handler, rebuild, close } = ncc(buildFile, {
 assetBuilds: true,
 watch: watcher
 });
 
 handler(({ err, code, map, assets, permissions }) => {
 if (err) return reject(err);
 buildCnt++;
 if (buildCnt === 1) {
 console.timeEnd('First Build');
 }
 else {
 console.timeEnd('Watched Build');
 }
 if (buildCnt === 3) {
 close();
 fs.writeFileSync(buildFile, fs.readFileSync(buildFile).toString().slice(0, -2));
 }
 });
 rebuild(() => {
 console.time('Watched Build');
 });
 });

 fs.writeFileSync(buildFile, initialBuildFileContents);
});",,"FALSE","FALSE","FALSE","FALSE",,,
11,"snutsjs","vercel/ncc","/test/watcher.test.js","ConditionalTestLogic","{""startLine"":138,""endLine"":138}","start: 112 end: 157","In this test file, the following lines contain a bad design pattern (also known as a test smell):

Lines {""startLine"":138,""endLine"":138}  – ConditionalTestLogic
Occurs due to the presence of test methods that contain conditional statements, such as the use of if-else or loops like for or while. Test methods that include conditional statements can compromise the effectiveness of tests
To improve test quality and maintainability, can you refactor the method to eliminate ConditionalTestLogic while ensuring the test remains clear and effective?","it('Should support custom watch API', async () => {
 let buildCnt = 0;
 const buildFile = path.resolve('./test/integration/twilio.js');
 const initialBuildFileContents = fs.readFileSync(buildFile).toString();

 await new Promise((resolve, reject) => {
 const watcher = new CustomWatchFileSystem(function watchStart (files, dirs, missing) {
 expect(files._set.size).toBeGreaterThan(100);
 if (buildCnt < 3) {
 setTimeout(() => {
 // NOTE: We actually have to make the change for the rebuild to happen!
 fs.writeFileSync(buildFile, fs.readFileSync(buildFile).toString() + '\n');
 watcher.triggerChanges([buildFile], []);
 }, 100);
 }
 }, function watchEnd () {
 resolve();
 });

 console.time('First Build');
 const { handler, rebuild, close } = ncc(buildFile, {
 assetBuilds: true,
 watch: watcher
 });
 
 handler(({ err, code, map, assets, permissions }) => {
 if (err) return reject(err);
 buildCnt++;
 if (buildCnt === 1) {
 console.timeEnd('First Build');
 }
 else {
 console.timeEnd('Watched Build');
 }
 if (buildCnt === 3) {
 close();
 fs.writeFileSync(buildFile, fs.readFileSync(buildFile).toString().slice(0, -2));
 }
 });
 rebuild(() => {
 console.time('Watched Build');
 });
 });

 fs.writeFileSync(buildFile, initialBuildFileContents);
});",,"FALSE","FALSE","FALSE","FALSE",,,
12,"snutsjs","vercel/ncc","/test/watcher.test.js","ConditionalTestLogic","{""startLine"":140,""endLine"":145}","start: 112 end: 157","In this test file, the following lines contain a bad design pattern (also known as a test smell):

Lines {""startLine"":140,""endLine"":145}  – ConditionalTestLogic
Occurs due to the presence of test methods that contain conditional statements, such as the use of if-else or loops like for or while. Test methods that include conditional statements can compromise the effectiveness of tests
To improve test quality and maintainability, can you refactor the method to eliminate ConditionalTestLogic while ensuring the test remains clear and effective?","it('Should support custom watch API', async () => {
 let buildCnt = 0;
 const buildFile = path.resolve('./test/integration/twilio.js');
 const initialBuildFileContents = fs.readFileSync(buildFile).toString();

 await new Promise((resolve, reject) => {
 const watcher = new CustomWatchFileSystem(function watchStart (files, dirs, missing) {
 expect(files._set.size).toBeGreaterThan(100);
 if (buildCnt < 3) {
 setTimeout(() => {
 // NOTE: We actually have to make the change for the rebuild to happen!
 fs.writeFileSync(buildFile, fs.readFileSync(buildFile).toString() + '\n');
 watcher.triggerChanges([buildFile], []);
 }, 100);
 }
 }, function watchEnd () {
 resolve();
 });

 console.time('First Build');
 const { handler, rebuild, close } = ncc(buildFile, {
 assetBuilds: true,
 watch: watcher
 });
 
 handler(({ err, code, map, assets, permissions }) => {
 if (err) return reject(err);
 buildCnt++;
 if (buildCnt === 1) {
 console.timeEnd('First Build');
 }
 else {
 console.timeEnd('Watched Build');
 }
 if (buildCnt === 3) {
 close();
 fs.writeFileSync(buildFile, fs.readFileSync(buildFile).toString().slice(0, -2));
 }
 });
 rebuild(() => {
 console.time('Watched Build');
 });
 });

 fs.writeFileSync(buildFile, initialBuildFileContents);
});",,"FALSE","FALSE","FALSE","FALSE",,,
13,"snutsjs","vercel/ncc","/test/watcher.test.js","ConditionalTestLogic","{""startLine"":146,""endLine"":149}","start: 112 end: 157","In this test file, the following lines contain a bad design pattern (also known as a test smell):

Lines {""startLine"":146,""endLine"":149}  – ConditionalTestLogic
Occurs due to the presence of test methods that contain conditional statements, such as the use of if-else or loops like for or while. Test methods that include conditional statements can compromise the effectiveness of tests
To improve test quality and maintainability, can you refactor the method to eliminate ConditionalTestLogic while ensuring the test remains clear and effective?","it('Should support custom watch API', async () => {
 let buildCnt = 0;
 const buildFile = path.resolve('./test/integration/twilio.js');
 const initialBuildFileContents = fs.readFileSync(buildFile).toString();

 await new Promise((resolve, reject) => {
 const watcher = new CustomWatchFileSystem(function watchStart (files, dirs, missing) {
 expect(files._set.size).toBeGreaterThan(100);
 if (buildCnt < 3) {
 setTimeout(() => {
 // NOTE: We actually have to make the change for the rebuild to happen!
 fs.writeFileSync(buildFile, fs.readFileSync(buildFile).toString() + '\n');
 watcher.triggerChanges([buildFile], []);
 }, 100);
 }
 }, function watchEnd () {
 resolve();
 });

 console.time('First Build');
 const { handler, rebuild, close } = ncc(buildFile, {
 assetBuilds: true,
 watch: watcher
 });
 
 handler(({ err, code, map, assets, permissions }) => {
 if (err) return reject(err);
 buildCnt++;
 if (buildCnt === 1) {
 console.timeEnd('First Build');
 }
 else {
 console.timeEnd('Watched Build');
 }
 if (buildCnt === 3) {
 close();
 fs.writeFileSync(buildFile, fs.readFileSync(buildFile).toString().slice(0, -2));
 }
 });
 rebuild(() => {
 console.time('Watched Build');
 });
 });

 fs.writeFileSync(buildFile, initialBuildFileContents);
});",,"FALSE","FALSE","FALSE","FALSE",,,
14,"snutsjs","vercel/ncc","/test/watcher.test.js","SensitiveEquality","{""startLine"":123,""endLine"":123}",,"#N/A",,,"FALSE","FALSE","FALSE","FALSE",,,
15,"snutsjs","vercel/ncc","/test/unit.test.js","SensitiveEquality","{""startLine"":54,""endLine"":54}",,"#N/A",,,"FALSE","FALSE","FALSE","FALSE",,,
16,"steel","vercel/ncc","/test/watcher.test.js","Magic Number","{""startLine"":120,""endLine"":126}","start: 112 end: 157","In this test file, the following lines contain a bad design pattern (also known as a test smell):

Lines {""startLine"":120,""endLine"":126}  – Magic Number
Occurs when numeric literals are used directly in tests without explanation or documentation. These numbers lack clear context, making the code less readable and harder to maintain, as it is not obvious why such values are used.
To improve test quality and maintainability, can you refactor the method to eliminate ConditionalTestLogic while ensuring the test remains clear and effective?","it('Should support custom watch API', async () => {
 let buildCnt = 0;
 const buildFile = path.resolve('./test/integration/twilio.js');
 const initialBuildFileContents = fs.readFileSync(buildFile).toString();

 await new Promise((resolve, reject) => {
 const watcher = new CustomWatchFileSystem(function watchStart (files, dirs, missing) {
 expect(files._set.size).toBeGreaterThan(100);
 if (buildCnt < 3) {
 setTimeout(() => {
 // NOTE: We actually have to make the change for the rebuild to happen!
 fs.writeFileSync(buildFile, fs.readFileSync(buildFile).toString() + '\n');
 watcher.triggerChanges([buildFile], []);
 }, 100);
 }
 }, function watchEnd () {
 resolve();
 });

 console.time('First Build');
 const { handler, rebuild, close } = ncc(buildFile, {
 assetBuilds: true,
 watch: watcher
 });
 
 handler(({ err, code, map, assets, permissions }) => {
 if (err) return reject(err);
 buildCnt++;
 if (buildCnt === 1) {
 console.timeEnd('First Build');
 }
 else {
 console.timeEnd('Watched Build');
 }
 if (buildCnt === 3) {
 close();
 fs.writeFileSync(buildFile, fs.readFileSync(buildFile).toString().slice(0, -2));
 }
 });
 rebuild(() => {
 console.time('Watched Build');
 });
 });

 fs.writeFileSync(buildFile, initialBuildFileContents);
});",,"FALSE","FALSE","FALSE","FALSE",,,
17,"snutsjs","chrisleekr/binance-trading-bot","/app/__tests__/error-handler.test.js","ConditionalTestLogic","{""startLine"":207,""endLine"":212}","start: 204 end: 218","In this test file, the following lines contain a bad design pattern (also known as a test smell):

Lines {""startLine"":207,""endLine"":212}  – ConditionalTestLogic
Occurs due to the presence of test methods that contain conditional statements, such as the use of if-else or loops like for or while. Test methods that include conditional statements can compromise the effectiveness of tests
To improve test quality and maintainability, can you refactor the method to eliminate ConditionalTestLogic while ensuring the test remains clear and effective?","it('throws an error', async () => {
 expect(() => {
 process.on = jest.fn().mockImplementation((event, error) => {
 if (event === 'unhandledRejection') {
 error({
 message: `something-unhandled`,
 code: 2000
 });
 }
 });

 const { runErrorHandler } = require('../error-handler');
 runErrorHandler(mockLogger);
 }).toThrow(`something-unhandled`);
 });",,"FALSE","FALSE","FALSE","FALSE",,,
18,"snutsjs","chrisleekr/binance-trading-bot","/app/__tests__/error-handler.test.js","ConditionalTestLogic","{""startLine"":225,""endLine"":230}","start: 222 end: 236","In this test file, the following lines contain a bad design pattern (also known as a test smell):

Lines {""startLine"":225,""endLine"":230}  – ConditionalTestLogic
Occurs due to the presence of test methods that contain conditional statements, such as the use of if-else or loops like for or while. Test methods that include conditional statements can compromise the effectiveness of tests
To improve test quality and maintainability, can you refactor the method to eliminate ConditionalTestLogic while ensuring the test remains clear and effective?","it('does not throws an error', async () => {
 expect(() => {
 process.on = jest.fn().mockImplementation((event, error) => {
 if (event === 'uncaughtException') {
 error({
 message: `redlock:lock-XRPBUSD`,
 code: 500
 });
 }
 });

 const { runErrorHandler } = require('../error-handler');
 runErrorHandler(mockLogger);
 }).not.toThrow();
 });",,"FALSE","FALSE","FALSE","FALSE",,,
19,"snutsjs","chrisleekr/binance-trading-bot","/app/frontend/webserver/handlers/__tests__/grid-trade-logs-export.test.js","SubOptimalAssert","{""startLine"":201,""endLine"":201}","start: 199 end: 202","In this test file, the following lines contain a bad design pattern (also known as a test smell):

Lines {""startLine"":201,""endLine"":201}  – SubOptimalAssert
Occurs when the assertions used in tests are not ideal for verifying the specific condition being tested. Using more specific and expressive assertions can improve test clarity and make results more useful
To improve test quality and maintainability, can you refactor the method to eliminate ConditionalTestLogic while ensuring the test remains clear and effective?","it('keeps 10 logs in the folder', () => {
 const files = fs.readdirSync(fileFolder);
 expect(files.length).toBe(10);
 });",,"FALSE","FALSE","FALSE","FALSE",,,
20,"steel","chrisleekr/binance-trading-bot","/app/__tests__/server-binance.test.js","Duplicate Assert","{'line': 189, 'column': 8, 'index': 5619}","start: 188 end: 199","In this test file, the following lines contain a bad design pattern (also known as a test smell):

Lines {'line': 189, 'column': 8, 'index': 5619}  – Duplicate Assert
This issue occurs when a test method verifies the same condition more than once within its scope, making the test harder to read and maintain. Identical assertions within the same method do not explicitly convey the purpose of the test method.
To improve test quality and maintainability, can you refactor the method to eliminate ConditionalTestLogic while ensuring the test remains clear and effective?","it('triggers refreshCandles', () => {
 expect(mockMongo.deleteAll).toHaveBeenCalledWith(
 logger,
 'trailing-trade-candles',
 {}
 );
 expect(mockMongo.deleteAll).toHaveBeenCalledWith(
 logger,
 'trailing-trade-ath-candles',
 {}
 );
 });",,"FALSE","FALSE","FALSE","FALSE",,,
21,"steel","chrisleekr/binance-trading-bot","/app/__tests__/server-binance.test.js","Duplicate Assert","{'line': 194, 'column': 8, 'index': 5755}","start: 188 end: 199","In this test file, the following lines contain a bad design pattern (also known as a test smell):

Lines {'line': 194, 'column': 8, 'index': 5755}  – Duplicate Assert
This issue occurs when a test method verifies the same condition more than once within its scope, making the test harder to read and maintain. Identical assertions within the same method do not explicitly convey the purpose of the test method.
To improve test quality and maintainability, can you refactor the method to eliminate ConditionalTestLogic while ensuring the test remains clear and effective?","it('triggers refreshCandles', () => {
 expect(mockMongo.deleteAll).toHaveBeenCalledWith(
 logger,
 'trailing-trade-candles',
 {}
 );
 expect(mockMongo.deleteAll).toHaveBeenCalledWith(
 logger,
 'trailing-trade-ath-candles',
 {}
 );
 });",,"FALSE","FALSE","FALSE","FALSE",,,
22,"steel","chrisleekr/binance-trading-bot","/app/__tests__/server-binance.test.js","Duplicate Assert","{'line': 691, 'column': 6, 'index': 22289}","start: 690 end: 701","In this test file, the following lines contain a bad design pattern (also known as a test smell):

Lines {'line': 691, 'column': 6, 'index': 22289}  – Duplicate Assert
This issue occurs when a test method verifies the same condition more than once within its scope, making the test harder to read and maintain. Identical assertions within the same method do not explicitly convey the purpose of the test method.
To improve test quality and maintainability, can you refactor the method to eliminate ConditionalTestLogic while ensuring the test remains clear and effective?","it('triggers refreshCandles', () => {
 expect(mockMongo.deleteAll).toHaveBeenCalledWith(
 logger,
 'trailing-trade-candles',
 {}
 );
 expect(mockMongo.deleteAll).toHaveBeenCalledWith(
 logger,
 'trailing-trade-ath-candles',
 {}
 );
 });",,"FALSE","FALSE","FALSE","FALSE",,,
23,"steel","chrisleekr/binance-trading-bot","/app/__tests__/server-binance.test.js","Duplicate Assert","{'line': 696, 'column': 6, 'index': 22415}","start: 690 end: 701","In this test file, the following lines contain a bad design pattern (also known as a test smell):

Lines {'line': 696, 'column': 6, 'index': 22415}  – Duplicate Assert
This issue occurs when a test method verifies the same condition more than once within its scope, making the test harder to read and maintain. Identical assertions within the same method do not explicitly convey the purpose of the test method.
To improve test quality and maintainability, can you refactor the method to eliminate ConditionalTestLogic while ensuring the test remains clear and effective?","it('triggers refreshCandles', () => {
 expect(mockMongo.deleteAll).toHaveBeenCalledWith(
 logger,
 'trailing-trade-candles',
 {}
 );
 expect(mockMongo.deleteAll).toHaveBeenCalledWith(
 logger,
 'trailing-trade-ath-candles',
 {}
 );
 });",,"FALSE","FALSE","FALSE","FALSE",,,
24,"steel","chrisleekr/binance-trading-bot","/app/__tests__/server-binance.test.js","Magic Number","{'line': 230, 'column': 10, 'index': 6700}","start: 226 end: 232","In this test file, the following lines contain a bad design pattern (also known as a test smell):

Lines {'line': 230, 'column': 10, 'index': 6700}  – Magic Number
Occurs when numeric literals are used directly in tests without explanation or documentation. These numbers lack clear context, making the code less readable and harder to maintain, as it is not obvious why such values are used.
To improve test quality and maintainability, can you refactor the method to eliminate ConditionalTestLogic while ensuring the test remains clear and effective?","it('triggers cache.hset', () => {
 expect(mockCache.hset).toHaveBeenCalledWith(
 'trailing-trade-streams',
 `count`,
 1
 );
 });",,"FALSE","FALSE","FALSE","FALSE",,,
25,"steel","chrisleekr/binance-trading-bot","/app/__tests__/server-binance.test.js","Magic Number","{'line': 739, 'column': 8, 'index': 23471}","start: 735 end: 741","In this test file, the following lines contain a bad design pattern (also known as a test smell):

Lines {'line': 739, 'column': 8, 'index': 23471}  – Magic Number
Occurs when numeric literals are used directly in tests without explanation or documentation. These numbers lack clear context, making the code less readable and harder to maintain, as it is not obvious why such values are used.
To improve test quality and maintainability, can you refactor the method to eliminate ConditionalTestLogic while ensuring the test remains clear and effective?","it('triggers cache.hset', () => {
 expect(mockCache.hset).toHaveBeenCalledWith(
 'trailing-trade-streams',
 `count`,
 1
 );
 });",,"FALSE","FALSE","FALSE","FALSE",,,
26,"steel","chrisleekr/binance-trading-bot","/app/__tests__/server-frontend.test.js","Magic Number","{'line': 314, 'column': 74, 'index': 9174}","start: 313 end: 315","In this test file, the following lines contain a bad design pattern (also known as a test smell):

Lines {'line': 314, 'column': 74, 'index': 9174}  – Magic Number
Occurs when numeric literals are used directly in tests without explanation or documentation. These numbers lack clear context, making the code less readable and harder to maintain, as it is not obvious why such values are used.
To improve test quality and maintainability, can you refactor the method to eliminate ConditionalTestLogic while ensuring the test remains clear and effective?","it('triggers status', () => {
 expect(mockRateLimiterMiddlewareResStatus).toHaveBeenCalledWith(403);
 });",,"FALSE","FALSE","FALSE","FALSE",,,
27,"steel","chrisleekr/binance-trading-bot","/app/binance/__tests__/orders.test.js","Magic Number","{'line': 137, 'column': 56, 'index': 3912}","start: 136 end: 138","In this test file, the following lines contain a bad design pattern (also known as a test smell):

Lines {'line': 137, 'column': 56, 'index': 3912}  – Magic Number
Occurs when numeric literals are used directly in tests without explanation or documentation. These numbers lack clear context, making the code less readable and harder to maintain, as it is not obvious why such values are used.
To improve test quality and maintainability, can you refactor the method to eliminate ConditionalTestLogic while ensuring the test remains clear and effective?","it('triggers clearInterval', () => {
 expect(spyOnClearInterval).toHaveBeenCalledWith(33);
 });",,"FALSE","FALSE","FALSE","FALSE",,,
28,"steel","chrisleekr/binance-trading-bot","/app/binance/__tests__/user.test.js","Magic Number","{'line': 142, 'column': 10, 'index': 4072}","start: 138 end: 144","In this test file, the following lines contain a bad design pattern (also known as a test smell):

Lines {'line': 142, 'column': 10, 'index': 4072}  – Magic Number
Occurs when numeric literals are used directly in tests without explanation or documentation. These numbers lack clear context, making the code less readable and harder to maintain, as it is not obvious why such values are used.
To improve test quality and maintainability, can you refactor the method to eliminate ConditionalTestLogic while ensuring the test remains clear and effective?","it('triggers updateAccountInfo', () => {
 expect(mockUpdateAccountInfo).toHaveBeenCalledWith(
 loggerMock,
 [{ asset: 'ADA', free: '0.00000000', locked: '13.82000000' }],
 1625585531721
 );
 });",,"FALSE","FALSE","FALSE","FALSE",,,
29,"steel","chrisleekr/binance-trading-bot","/app/cronjob/trailingTradeHelper/__tests__/common.test.js","Duplicate Assert","{'line': 2469, 'column': 8, 'index': 67424}","start: 2468 end: 2486","In this test file, the following lines contain a bad design pattern (also known as a test smell):

Lines {'line': 2469, 'column': 8, 'index': 67424}  – Duplicate Assert
This issue occurs when a test method verifies the same condition more than once within its scope, making the test harder to read and maintain. Identical assertions within the same method do not explicitly convey the purpose of the test method.
To improve test quality and maintainability, can you refactor the method to eliminate ConditionalTestLogic while ensuring the test remains clear and effective?","it('triggers slack.sendMessage', () => {
 expect(slackMock.sendMessage).toHaveBeenCalledWith(
 expect.stringContaining('BTCUSDT'),
 {
 apiLimit: 0,
 symbol: 'BTCUSDT'
 }
 );

 expect(slackMock.sendMessage).toHaveBeenCalledWith(
 expect.stringContaining(
 'The bot queued to trigger the grid trade for buying'
 ),
 {
 apiLimit: 0,
 symbol: 'BTCUSDT'
 }
 );
 });",,"FALSE","FALSE","FALSE","FALSE",,,
30,"steel","prettier/prettier","/scripts/release/tests/publish-to-npm.test.js","Lazy Test","{'line': 21, 'column': 21, 'index': 739}","start: 20 end: 30","In this test file, the following lines contain a bad design pattern (also known as a test smell):

Lines {'line': 21, 'column': 21, 'index': 739}  – Lazy Test
Lazy Test occurs when a single test is written superficially and verifies multiple functionalities of a class without going into detail about each one.
To improve test quality and maintainability, can you refactor the method to eliminate ConditionalTestLogic while ensuring the test remains clear and effective?","it(""returns URL for patch releasing"", () => {
 const result = getReleaseUrl(""2.3.1"", ""2.3.0"");
 assert.equal(
 result,
 getExpectedReleaseUrl({
 tag: ""2.3.1"",
 title: ""2.3.1"",
 body: ""🔗 [Changelog](https://github.com/prettier/prettier/blob/main/CHANGELOG.md#231)"",
 }),
 );
 });",,"FALSE","FALSE","FALSE","FALSE",,,
31,"steel","prettier/prettier","/scripts/release/tests/publish-to-npm.test.js","Lazy Test","{'line': 33, 'column': 21, 'index': 1090}","start: 32 end: 47","In this test file, the following lines contain a bad design pattern (also known as a test smell):

Lines {'line': 33, 'column': 21, 'index': 1090}  – Lazy Test
Lazy Test occurs when a single test is written superficially and verifies multiple functionalities of a class without going into detail about each one.
To improve test quality and maintainability, can you refactor the method to eliminate ConditionalTestLogic while ensuring the test remains clear and effective?","it(""returns URL for minor releasing"", () => {
 const result = getReleaseUrl(""2.4.0"", ""2.3.0"");
 assert.equal(
 result,
 getExpectedReleaseUrl({
 tag: ""2.4.0"",
 title: ""2.4.0"",
 body: [
 ""[diff](https://github.com/prettier/prettier/compare/2.3.0...2.4.0)"",
 `🔗 [Release note](https://prettier.io/blog/${getDateParts().join(
 ""/"",
 )}/2.4.0)`,
 ].join(""\n\n""),
 }),
 );
 });",,"FALSE","FALSE","FALSE","FALSE",,,
32,"steel","prettier/prettier","/scripts/release/tests/publish-to-npm.test.js","Lazy Test","{'line': 50, 'column': 21, 'index': 1590}","start: 49 end: 64","In this test file, the following lines contain a bad design pattern (also known as a test smell):

Lines {'line': 50, 'column': 21, 'index': 1590}  – Lazy Test
Lazy Test occurs when a single test is written superficially and verifies multiple functionalities of a class without going into detail about each one.
To improve test quality and maintainability, can you refactor the method to eliminate ConditionalTestLogic while ensuring the test remains clear and effective?","it(""returns URL for major releasing"", () => {
 const result = getReleaseUrl(""2.3.0"", ""2.2.0"");
 assert.equal(
 result,
 getExpectedReleaseUrl({
 tag: ""2.3.0"",
 title: ""2.3.0"",
 body: [
 ""[diff](https://github.com/prettier/prettier/compare/2.2.0...2.3.0)"",
 `🔗 [Release note](https://prettier.io/blog/${getDateParts().join(
 ""/"",
 )}/2.3.0)`,
 ].join(""\n\n""),
 }),
 );
 });",,"FALSE","FALSE","FALSE","FALSE",,,
33,"steel","prettier/prettier","/scripts/release/tests/version-check.test.js","Lazy Test","{'line': 7, 'column': 20, 'index': 268}","start: 6 end: 8","In this test file, the following lines contain a bad design pattern (also known as a test smell):

Lines {'line': 7, 'column': 20, 'index': 268}  – Lazy Test
Lazy Test occurs when a single test is written superficially and verifies multiple functionalities of a class without going into detail about each one.
To improve test quality and maintainability, can you refactor the method to eliminate ConditionalTestLogic while ensuring the test remains clear and effective?","it(""returns true for existing version"", async () => {
 assert.ok(await isVersionReleased(""1.0.0""));
 });",,"FALSE","FALSE","FALSE","FALSE",,,
34,"steel","prettier/prettier","/scripts/release/tests/version-check.test.js","Lazy Test","{'line': 10, 'column': 31, 'index': 389}","start: 9 end: 13","In this test file, the following lines contain a bad design pattern (also known as a test smell):

Lines {'line': 10, 'column': 31, 'index': 389}  – Lazy Test
Lazy Test occurs when a single test is written superficially and verifies multiple functionalities of a class without going into detail about each one.
To improve test quality and maintainability, can you refactor the method to eliminate ConditionalTestLogic while ensuring the test remains clear and effective?","it(""rejects for non-existing version"", async () => {
 await assert.rejects(() => isVersionReleased(""999.0.0""), {
 message: ""prettier@999.0.0 doesn't exit."",
 });
 });",,"FALSE","FALSE","FALSE","FALSE",,,
35,"snutsjs","atlassian/react-beautiful-dnd","/test/unit/view/use-droppable-publisher/scroll-watching.spec.js","OvercommentedTest","{""startLine"":59,""endLine"":100}","start: 59 end: 100","In this test file, the following lines contain a bad design pattern (also known as a test smell):

Lines {""startLine"":59,""endLine"":100}  – OvercommentedTest
A test method that has been excessively commented on
To improve test quality and maintainability, can you refactor the method to eliminate ConditionalTestLogic while ensuring the test remains clear and effective?","it('should not fire a scroll if the value has not changed since the previous call', () => {
 // this can happen if you scroll backward and forward super quick
 const marshal: DimensionMarshal = getMarshalStub();
 const registry: Registry = createRegistry();
 const registerSpy = jest.spyOn(registry.droppable, 'register');
 const wrapper = mount(
 <WithAppContext marshal={marshal} registry={registry}>
 <ScrollableItem />
 </WithAppContext>,
 );
 const container: ?HTMLElement = wrapper
 .find('.scroll-container')
 .getDOMNode();
 invariant(container);
 // tell the droppable to watch for scrolling
 const callbacks: DroppableCallbacks =
 registerSpy.mock.calls[0][0].callbacks;

 // watch scroll will only be called after the dimension is requested
 callbacks.getDimensionAndWatchScroll(preset.windowScroll, immediate);

 // first event
 scroll(container, { x: 500, y: 1000 });
 expect(marshal.updateDroppableScroll).toHaveBeenCalledTimes(1);
 expect(marshal.updateDroppableScroll).toHaveBeenCalledWith(
 preset.home.descriptor.id,
 { x: 500, y: 1000 },
 );
 // $ExpectError
 marshal.updateDroppableScroll.mockReset();

 // second event - scroll to same spot
 scroll(container, { x: 500, y: 1000 });
 expect(marshal.updateDroppableScroll).not.toHaveBeenCalled();

 // third event - new value
 scroll(container, { x: 500, y: 1001 });
 expect(marshal.updateDroppableScroll).toHaveBeenCalledWith(
 preset.home.descriptor.id,
 { x: 500, y: 1001 },
 );
 });",,"FALSE","FALSE","FALSE","FALSE",,,
36,"snutsjs","atlassian/react-beautiful-dnd","/test/unit/view/use-droppable-publisher/scroll-watching.spec.js","OvercommentedTest","{""startLine"":134,""endLine"":171}","start: 134 end: 171","In this test file, the following lines contain a bad design pattern (also known as a test smell):

Lines {""startLine"":134,""endLine"":171}  – OvercommentedTest
A test method that has been excessively commented on
To improve test quality and maintainability, can you refactor the method to eliminate ConditionalTestLogic while ensuring the test remains clear and effective?","it('should throttle multiple scrolls into a animation frame', () => {
 const marshal: DimensionMarshal = getMarshalStub();
 const registry: Registry = createRegistry();
 const registerSpy = jest.spyOn(registry.droppable, 'register');
 const wrapper = mount(
 <WithAppContext marshal={marshal} registry={registry}>
 <ScrollableItem />
 </WithAppContext>,
 );
 const container: ?HTMLElement = wrapper
 .find('.scroll-container')
 .getDOMNode();
 invariant(container);
 // tell the droppable to watch for scrolling
 const callbacks: DroppableCallbacks =
 registerSpy.mock.calls[0][0].callbacks;

 // watch scroll will only be called after the dimension is requested
 callbacks.getDimensionAndWatchScroll(preset.windowScroll, scheduled);

 // first event
 scroll(container, { x: 500, y: 1000 });
 // second event in same frame
 scroll(container, { x: 200, y: 800 });

 // release the update animation frame
 requestAnimationFrame.step();

 expect(marshal.updateDroppableScroll).toHaveBeenCalledTimes(1);
 expect(marshal.updateDroppableScroll).toHaveBeenCalledWith(
 preset.home.descriptor.id,
 { x: 200, y: 800 },
 );

 // also checking that no loose frames are stored up
 requestAnimationFrame.flush();
 expect(marshal.updateDroppableScroll).toHaveBeenCalledTimes(1);
 });",,"FALSE","FALSE","FALSE","FALSE",,,
37,"snutsjs","atlassian/react-beautiful-dnd","/test/unit/view/use-droppable-publisher/scroll-watching.spec.js","OvercommentedTest","{""startLine"":173,""endLine"":215}","start: 173 end: 215","In this test file, the following lines contain a bad design pattern (also known as a test smell):

Lines {""startLine"":173,""endLine"":215}  – OvercommentedTest
A test method that has been excessively commented on
To improve test quality and maintainability, can you refactor the method to eliminate ConditionalTestLogic while ensuring the test remains clear and effective?","it('should not fire a scroll if the value has not changed since the previous frame', () => {
 // this can happen if you scroll backward and forward super quick
 const marshal: DimensionMarshal = getMarshalStub();
 const registry: Registry = createRegistry();
 const registerSpy = jest.spyOn(registry.droppable, 'register');
 const wrapper = mount(
 <WithAppContext marshal={marshal} registry={registry}>
 <ScrollableItem />
 </WithAppContext>,
 );
 const container: ?HTMLElement = wrapper
 .find('.scroll-container')
 .getDOMNode();
 invariant(container);
 // tell the droppable to watch for scrolling
 const callbacks: DroppableCallbacks =
 registerSpy.mock.calls[0][0].callbacks;

 // watch scroll will only be called after the dimension is requested
 callbacks.getDimensionAndWatchScroll(preset.windowScroll, scheduled);

 // first event
 scroll(container, { x: 500, y: 1000 });
 // release the frame
 requestAnimationFrame.step();
 expect(marshal.updateDroppableScroll).toHaveBeenCalledTimes(1);
 expect(marshal.updateDroppableScroll).toHaveBeenCalledWith(
 preset.home.descriptor.id,
 { x: 500, y: 1000 },
 );
 // $ExpectError
 marshal.updateDroppableScroll.mockReset();

 // second event
 scroll(container, { x: 501, y: 1001 });
 // no frame to release change yet

 // third event - back to original value
 scroll(container, { x: 500, y: 1000 });
 // release the frame
 requestAnimationFrame.step();
 expect(marshal.updateDroppableScroll).not.toHaveBeenCalled();
 });",,"FALSE","FALSE","FALSE","FALSE",,,
38,"snutsjs","atlassian/react-beautiful-dnd","/test/unit/view/use-droppable-publisher/scroll-watching.spec.js","OvercommentedTest","{""startLine"":217,""endLine"":254}","start: 217 end: 254","In this test file, the following lines contain a bad design pattern (also known as a test smell):

Lines {""startLine"":217,""endLine"":254}  – OvercommentedTest
A test method that has been excessively commented on
To improve test quality and maintainability, can you refactor the method to eliminate ConditionalTestLogic while ensuring the test remains clear and effective?","it('should not publish a scroll update after requested not to update while an animation frame is occurring', () => {
 const marshal: DimensionMarshal = getMarshalStub();
 const registry: Registry = createRegistry();
 const registerSpy = jest.spyOn(registry.droppable, 'register');
 const wrapper = mount(
 <WithAppContext marshal={marshal} registry={registry}>
 <ScrollableItem />
 </WithAppContext>,
 );
 const container: ?HTMLElement = wrapper
 .find('.scroll-container')
 .getDOMNode();
 invariant(container);
 // tell the droppable to watch for scrolling
 const callbacks: DroppableCallbacks =
 registerSpy.mock.calls[0][0].callbacks;

 // watch scroll will only be called after the dimension is requested
 callbacks.getDimensionAndWatchScroll(preset.windowScroll, scheduled);

 // first event
 scroll(container, { x: 500, y: 1000 });
 requestAnimationFrame.step();
 expect(marshal.updateDroppableScroll).toHaveBeenCalledTimes(1);
 // $ExpectError
 marshal.updateDroppableScroll.mockReset();

 // second event
 scroll(container, { x: 400, y: 100 });
 // no animation frame to release event fired yet

 // unwatching before frame fired
 callbacks.dragStopped();

 // flushing any frames
 requestAnimationFrame.flush();
 expect(marshal.updateDroppableScroll).not.toHaveBeenCalled();
 });",,"FALSE","FALSE","FALSE","FALSE",,,
39,"snutsjs","atlassian/react-beautiful-dnd","/test/unit/view/use-droppable-publisher/scroll-watching.spec.js","OvercommentedTest","{""startLine"":257,""endLine"":288}","start: 257 end: 288","In this test file, the following lines contain a bad design pattern (also known as a test smell):

Lines {""startLine"":257,""endLine"":288}  – OvercommentedTest
A test method that has been excessively commented on
To improve test quality and maintainability, can you refactor the method to eliminate ConditionalTestLogic while ensuring the test remains clear and effective?","it('should stop watching scroll when no longer required to publish', () => {
 // this can happen if you scroll backward and forward super quick
 const marshal: DimensionMarshal = getMarshalStub();
 const registry: Registry = createRegistry();
 const registerSpy = jest.spyOn(registry.droppable, 'register');
 const wrapper = mount(
 <WithAppContext marshal={marshal} registry={registry}>
 <ScrollableItem />
 </WithAppContext>,
 );
 const container: ?HTMLElement = wrapper
 .find('.scroll-container')
 .getDOMNode();
 invariant(container);
 // tell the droppable to watch for scrolling
 const callbacks: DroppableCallbacks = registerSpy.mock.calls[0][0].callbacks;

 // watch scroll will only be called after the dimension is requested
 callbacks.getDimensionAndWatchScroll(preset.windowScroll, immediate);

 // first event
 scroll(container, { x: 500, y: 1000 });
 expect(marshal.updateDroppableScroll).toHaveBeenCalledTimes(1);
 // $ExpectError
 marshal.updateDroppableScroll.mockReset();

 callbacks.dragStopped();

 // scroll event after no longer watching
 scroll(container, { x: 190, y: 400 });
 expect(marshal.updateDroppableScroll).not.toHaveBeenCalled();
});",,"FALSE","FALSE","FALSE","FALSE",,,
40,"snutsjs","atlassian/react-beautiful-dnd","/test/unit/health/src-file-name-convention.spec.js","ConditionalTestLogic","{""startLine"":28,""endLine"":30}","start: 18 end: 41","In this test file, the following lines contain a bad design pattern (also known as a test smell):

Lines {""startLine"":28,""endLine"":30}  – ConditionalTestLogic
Occurs due to the presence of test methods that contain conditional statements, such as the use of if-else or loops like for or while. Test methods that include conditional statements can compromise the effectiveness of tests
To improve test quality and maintainability, can you refactor the method to eliminate ConditionalTestLogic while ensuring the test remains clear and effective?","it('should have every prettier target following the file name convention', async () => {
 const targets: string[] = pkg.config.prettier_target.split(' ');
 const paths: string[] = await globby(targets);

 invariant(
 paths.length,
 'Could not find files to test against file name convention',
 );

 paths.forEach((filePath: string) => {
 if (exceptions.includes(filePath)) {
 return;
 }

 const isMatching: boolean = isSnakeCase(filePath);

 invariant(
 isMatching,
 `${filePath} does not follow the file path convention (snake-case.js) ${convention.toString()}`,
 );

 expect(isMatching).toBe(true);
 });
});",,"FALSE","FALSE","FALSE","FALSE",,,
41,"snutsjs","atlassian/react-beautiful-dnd","/test/unit/docs/content.spec.js","ConditionalTestLogic","{""startLine"":20,""endLine"":25}","start: 8 end: 30","In this test file, the following lines contain a bad design pattern (also known as a test smell):

Lines {""startLine"":20,""endLine"":25}  – ConditionalTestLogic
Occurs due to the presence of test methods that contain conditional statements, such as the use of if-else or loops like for or while. Test methods that include conditional statements can compromise the effectiveness of tests
To improve test quality and maintainability, can you refactor the method to eliminate ConditionalTestLogic while ensuring the test remains clear and effective?","it('should end all nested docs with a link back to the documentation root', async () => {
 const files: string[] = await globby('docs/**/*.md');
 expect(files.length).toBeGreaterThan(0);
 const backLink: string =
 '[← Back to documentation](/README.md#documentation-)';

 for (const file of files) {
 const contents: string = await fs.readFile(file, 'utf8');

 // Printing a nice message to allow for quick fixing
 const endsWithBacklink: boolean = contents.trim().endsWith(backLink);

 if (!endsWithBacklink) {
 expect(`
 File: ""${file}""
 Did not end with back link
 `).toBe(true);
 }

 // need at least one assertion
 expect(true).toBe(true);
 }
});",,"FALSE","FALSE","FALSE","FALSE",,,
42,"snutsjs","atlassian/react-beautiful-dnd","/test/unit/view/use-droppable-publisher/is-element-scrollable.spec.js","SubOptimalAssert","{""startLine"":21,""endLine"":21}","start: 16 end: 23","In this test file, the following lines contain a bad design pattern (also known as a test smell):

Lines {""startLine"":21,""endLine"":21}  – SubOptimalAssert
Occurs when the assertions used in tests are not ideal for verifying the specific condition being tested. Using more specific and expressive assertions can improve test clarity and make results more useful
To improve test quality and maintainability, can you refactor the method to eliminate ConditionalTestLogic while ensuring the test remains clear and effective?","it('should return false if an element has overflow:visible', () => {
 ['overflowY', 'overflowX'].forEach((overflow: string) => {
 const el: HTMLElement = document.createElement('div');
 // $ExpectError - flow being mean
 el.style[overflow] = 'visible';
 expect(getClosestScrollable(el)).toBe(null);
 });
});",,"FALSE","FALSE","FALSE","FALSE",,,
43,"snutsjs","atlassian/react-beautiful-dnd","/test/unit/view/use-droppable-publisher/is-element-scrollable.spec.js","SubOptimalAssert","{""startLine"":64,""endLine"":64}","start: 60 end: 66","In this test file, the following lines contain a bad design pattern (also known as a test smell):

Lines {""startLine"":64,""endLine"":64}  – SubOptimalAssert
Occurs when the assertions used in tests are not ideal for verifying the specific condition being tested. Using more specific and expressive assertions can improve test clarity and make results more useful
To improve test quality and maintainability, can you refactor the method to eliminate ConditionalTestLogic while ensuring the test remains clear and effective?","it('should warn if the body might be a scroll container', () => {
 body.style.overflowX = 'auto';
 html.style.overflowY = 'auto';

 expect(getClosestScrollable(body)).toBe(null);
 expect(console.warn).toHaveBeenCalled();
 });",,"FALSE","FALSE","FALSE","FALSE",,,
44,"snutsjs","atlassian/react-beautiful-dnd","/test/unit/view/use-droppable-publisher/is-element-scrollable.spec.js","SubOptimalAssert","{""startLine"":70,""endLine"":70}","start: 68 end: 72","In this test file, the following lines contain a bad design pattern (also known as a test smell):

Lines {""startLine"":70,""endLine"":70}  – SubOptimalAssert
Occurs when the assertions used in tests are not ideal for verifying the specific condition being tested. Using more specific and expressive assertions can improve test clarity and make results more useful
To improve test quality and maintainability, can you refactor the method to eliminate ConditionalTestLogic while ensuring the test remains clear and effective?","it('should not mark the body as a scroll container if it does not have any overflow set', () => {
 body.style.overflowX = 'visible';
 expect(getClosestScrollable(body)).toBe(null);
 expect(console.warn).not.toHaveBeenCalled();
 });",,"FALSE","FALSE","FALSE","FALSE",,,
45,"snutsjs","atlassian/react-beautiful-dnd","/test/unit/view/use-droppable-publisher/is-element-scrollable.spec.js","SubOptimalAssert","{""startLine"":77,""endLine"":77}","start: 74 end: 79","In this test file, the following lines contain a bad design pattern (also known as a test smell):

Lines {""startLine"":77,""endLine"":77}  – SubOptimalAssert
Occurs when the assertions used in tests are not ideal for verifying the specific condition being tested. Using more specific and expressive assertions can improve test clarity and make results more useful
To improve test quality and maintainability, can you refactor the method to eliminate ConditionalTestLogic while ensuring the test remains clear and effective?","it('should not mark the body as a scroll container if the html element has visible overflow', () => {
 body.style.overflowX = 'auto';
 html.style.overflowY = 'visible';
 expect(getClosestScrollable(body)).toBe(null);
 expect(console.warn).not.toHaveBeenCalled();
 });",,"FALSE","FALSE","FALSE","FALSE",,,
46,"snutsjs","atlassian/react-beautiful-dnd","/test/unit/view/placeholder/animated-mount.spec.js","SubOptimalAssert","{""startLine"":42,""endLine"":42}","start: 31 end: 58","In this test file, the following lines contain a bad design pattern (also known as a test smell):

Lines {""startLine"":42,""endLine"":42}  – SubOptimalAssert
Occurs when the assertions used in tests are not ideal for verifying the specific condition being tested. Using more specific and expressive assertions can improve test clarity and make results more useful
To improve test quality and maintainability, can you refactor the method to eliminate ConditionalTestLogic while ensuring the test remains clear and effective?","it('should animate a mount', () => {
 const wrapper: ReactWrapper<*> = mount(
 <Placeholder
 contextId={contextId}
 animate=""open""
 placeholder={placeholder}
 onClose={jest.fn()}
 onTransitionEnd={jest.fn()}
 />,
 );

 expect(getCreatePlaceholderCalls().length).toBe(1);

 // first call had an empty size
 const onMount: PlaceholderStyle = getPlaceholderStyle(wrapper);
 expectIsEmpty(onMount);

 // Will trigger a .setState
 act(() => {
 jest.runOnlyPendingTimers();
 });

 // tell enzyme that something has changed
 wrapper.update();

 const postMount: PlaceholderStyle = getPlaceholderStyle(wrapper);
 expectIsFull(postMount);
});",,"FALSE","FALSE","FALSE","FALSE",,,
47,"snutsjs","atlassian/react-beautiful-dnd","/test/unit/state/middleware/responders/announcements.spec.js","ConditionalTestLogic","{""startLine"":143,""endLine"":146}","start: 141 end: 151","In this test file, the following lines contain a bad design pattern (also known as a test smell):

Lines {""startLine"":143,""endLine"":146}  – ConditionalTestLogic
Occurs due to the presence of test methods that contain conditional statements, such as the use of if-else or loops like for or while. Test methods that include conditional statements can compromise the effectiveness of tests
To improve test quality and maintainability, can you refactor the method to eliminate ConditionalTestLogic while ensuring the test remains clear and effective?","it('should announce with the default message if no responder is provided', () => {
 // This test is not relevant for onDragEnd as it must always be provided
 if (current.responder === 'onDragEnd') {
 expect(true).toBe(true);
 return;
 }
 // unsetting responder
 responders[current.responder] = undefined;
 current.execute(store);
 expect(announce).toHaveBeenCalledWith(current.defaultMessage);
 });",,"FALSE","FALSE","FALSE","FALSE",,,
48,"snutsjs","atlassian/react-beautiful-dnd","/test/unit/integration/drag-drop-context/error-handling/error-in-react-tree.spec.js","ConditionalTestLogic","{""startLine"":13,""endLine"":16}","start: 10 end: 32","In this test file, the following lines contain a bad design pattern (also known as a test smell):

Lines {""startLine"":13,""endLine"":16}  – ConditionalTestLogic
Occurs due to the presence of test methods that contain conditional statements, such as the use of if-else or loops like for or while. Test methods that include conditional statements can compromise the effectiveness of tests
To improve test quality and maintainability, can you refactor the method to eliminate ConditionalTestLogic while ensuring the test remains clear and effective?","it('should recover from rbd errors', () => {
 let hasThrown: boolean = false;
 function CanThrow(props: { shouldThrow: boolean }) {
 if (!hasThrown && props.shouldThrow) {
 hasThrown = true;
 invariant(false, 'throwing');
 }
 return null;
 }

 const { rerender, getByTestId } = render(
 <App anotherChild={<CanThrow shouldThrow={false} />} />,
 );

 simpleLift(keyboard, getByTestId('0'));
 expect(isDragging(getByTestId('0'))).toBe(true);

 withError(() => {
 rerender(<App anotherChild={<CanThrow shouldThrow />} />);
 });

 expect(isDragging(getByTestId('0'))).toBe(false);
});",,"FALSE","FALSE","FALSE","FALSE",,,
49,"snutsjs","atlassian/react-beautiful-dnd","/test/unit/integration/drag-drop-context/error-handling/error-in-react-tree.spec.js","ConditionalTestLogic","{""startLine"":37,""endLine"":40}","start: 34 end: 56","In this test file, the following lines contain a bad design pattern (also known as a test smell):

Lines {""startLine"":37,""endLine"":40}  – ConditionalTestLogic
Occurs due to the presence of test methods that contain conditional statements, such as the use of if-else or loops like for or while. Test methods that include conditional statements can compromise the effectiveness of tests
To improve test quality and maintainability, can you refactor the method to eliminate ConditionalTestLogic while ensuring the test remains clear and effective?","it('should not recover from non-rbd errors', () => {
 let hasThrown: boolean = false;
 function CanThrow(props: { shouldThrow: boolean }) {
 if (!hasThrown && props.shouldThrow) {
 hasThrown = true;
 throw new Error('Boom');
 }
 return null;
 }

 const { rerender, getByTestId } = render(
 <App anotherChild={<CanThrow shouldThrow={false} />} />,
 );

 simpleLift(keyboard, getByTestId('0'));
 expect(isDragging(getByTestId('0'))).toBe(true);

 withError(() => {
 expect(() => {
 rerender(<App anotherChild={<CanThrow shouldThrow />} />);
 }).toThrow();
 });
});",,"FALSE","FALSE","FALSE","FALSE",,,
50,"steel","atlassian/react-beautiful-dnd","/test/unit/dev-warning.spec.js","Duplicate Assert","{'line': 23, 'column': 2, 'index': 467}","start: 16 end: 32","In this test file, the following lines contain a bad design pattern (also known as a test smell):

Lines {'line': 23, 'column': 2, 'index': 467}  – Duplicate Assert
This issue occurs when a test method verifies the same condition more than once within its scope, making the test harder to read and maintain. Identical assertions within the same method do not explicitly convey the purpose of the test method.
To improve test quality and maintainability, can you refactor the method to eliminate ConditionalTestLogic while ensuring the test remains clear and effective?","it('should not log a warning if warnings are disabled', () => {
 window['__react-beautiful-dnd-disable-dev-warnings'] = true;

 warning('hey');
 warning('sup');
 warning('hi');

 expect(warn).not.toHaveBeenCalled();

 // re-enable

 window['__react-beautiful-dnd-disable-dev-warnings'] = false;

 warning('hey');

 expect(warn).toHaveBeenCalled();
});",,"FALSE","FALSE","FALSE","FALSE",,,
51,"steel","atlassian/react-beautiful-dnd","/test/unit/dev-warning.spec.js","Duplicate Assert","{'line': 31, 'column': 2, 'index': 607}","start: 16 end: 32","In this test file, the following lines contain a bad design pattern (also known as a test smell):

Lines {'line': 31, 'column': 2, 'index': 607}  – Duplicate Assert
This issue occurs when a test method verifies the same condition more than once within its scope, making the test harder to read and maintain. Identical assertions within the same method do not explicitly convey the purpose of the test method.
To improve test quality and maintainability, can you refactor the method to eliminate ConditionalTestLogic while ensuring the test remains clear and effective?","it('should not log a warning if warnings are disabled', () => {
 window['__react-beautiful-dnd-disable-dev-warnings'] = true;

 warning('hey');
 warning('sup');
 warning('hi');

 expect(warn).not.toHaveBeenCalled();

 // re-enable

 window['__react-beautiful-dnd-disable-dev-warnings'] = false;

 warning('hey');

 expect(warn).toHaveBeenCalled();
});",,"FALSE","FALSE","FALSE","FALSE",,,
52,"steel","atlassian/react-beautiful-dnd","/test/unit/view/use-draggable-publisher.spec.js","Duplicate Assert","{'line': 100, 'column': 4, 'index': 2698}","start: 87 end: 102","In this test file, the following lines contain a bad design pattern (also known as a test smell):

Lines {'line': 100, 'column': 4, 'index': 2698}  – Duplicate Assert
This issue occurs when a test method verifies the same condition more than once within its scope, making the test harder to read and maintain. Identical assertions within the same method do not explicitly convey the purpose of the test method.
To improve test quality and maintainability, can you refactor the method to eliminate ConditionalTestLogic while ensuring the test remains clear and effective?","it('should register itself when mounting', () => {
 const registry: Registry = createRegistry();
 const registerSpy = jest.spyOn(registry.draggable, 'register');
 mount(<Item registry={registry} />);

 const expected: DraggableEntry = {
 // $ExpectError
 uniqueId: expect.any(String),
 descriptor: preset.inHome1.descriptor,
 options: defaultOptions,
 // $ExpectError
 getDimension: expect.any(Function),
 };
 expect(registerSpy).toHaveBeenCalledTimes(1);
 expect(registerSpy).toHaveBeenCalledWith(expected);
 });",,"FALSE","FALSE","FALSE","FALSE",,,
53,"steel","atlassian/react-beautiful-dnd","/test/unit/view/use-draggable-publisher.spec.js","Duplicate Assert","{'line': 101, 'column': 4, 'index': 2748}","start: 87 end: 102","In this test file, the following lines contain a bad design pattern (also known as a test smell):

Lines {'line': 101, 'column': 4, 'index': 2748}  – Duplicate Assert
This issue occurs when a test method verifies the same condition more than once within its scope, making the test harder to read and maintain. Identical assertions within the same method do not explicitly convey the purpose of the test method.
To improve test quality and maintainability, can you refactor the method to eliminate ConditionalTestLogic while ensuring the test remains clear and effective?","it('should register itself when mounting', () => {
 const registry: Registry = createRegistry();
 const registerSpy = jest.spyOn(registry.draggable, 'register');
 mount(<Item registry={registry} />);

 const expected: DraggableEntry = {
 // $ExpectError
 uniqueId: expect.any(String),
 descriptor: preset.inHome1.descriptor,
 options: defaultOptions,
 // $ExpectError
 getDimension: expect.any(Function),
 };
 expect(registerSpy).toHaveBeenCalledTimes(1);
 expect(registerSpy).toHaveBeenCalledWith(expected);
 });",,"FALSE","FALSE","FALSE","FALSE",,,
54,"steel","atlassian/react-beautiful-dnd","/test/unit/view/use-draggable-publisher.spec.js","Duplicate Assert","{'line': 119, 'column': 4, 'index': 3360}","start: 104 end: 128","In this test file, the following lines contain a bad design pattern (also known as a test smell):

Lines {'line': 119, 'column': 4, 'index': 3360}  – Duplicate Assert
This issue occurs when a test method verifies the same condition more than once within its scope, making the test harder to read and maintain. Identical assertions within the same method do not explicitly convey the purpose of the test method.
To improve test quality and maintainability, can you refactor the method to eliminate ConditionalTestLogic while ensuring the test remains clear and effective?","it('should unregister itself when unmounting', () => {
 const registry: Registry = createRegistry();
 const registerSpy = jest.spyOn(registry.draggable, 'register');
 const unregisterSpy = jest.spyOn(registry.draggable, 'unregister');
 const wrapper = mount(<Item registry={registry} />);

 const expected: DraggableEntry = {
 // $ExpectError
 uniqueId: expect.any(String),
 descriptor: preset.inHome1.descriptor,
 options: defaultOptions,
 // $ExpectError
 getDimension: expect.any(Function),
 };

 expect(unregisterSpy).not.toHaveBeenCalled();
 expect(registerSpy).toHaveBeenCalledTimes(1);
 expect(registerSpy).toHaveBeenCalledWith(expected);
 const entry = registerSpy.mock.calls[0][0];
 expect(entry).toEqual(expected);

 wrapper.unmount();
 expect(unregisterSpy).toHaveBeenCalledTimes(1);
 expect(unregisterSpy.mock.calls[0][0]).toBe(entry);
 });",,"FALSE","FALSE","FALSE","FALSE",,,
55,"steel","atlassian/react-beautiful-dnd","/test/unit/view/announcer.spec.js","Lazy Test","{'line': 40, 'column': 2, 'index': 1310}","start: 36 end: 47","In this test file, the following lines contain a bad design pattern (also known as a test smell):

Lines {'line': 40, 'column': 2, 'index': 1310}  – Lazy Test
Lazy Test occurs when a single test is written superficially and verifies multiple functionalities of a class without going into detail about each one.
To improve test quality and maintainability, can you refactor the method to eliminate ConditionalTestLogic while ensuring the test remains clear and effective?","it('should apply the appropriate aria attributes and non visibility styles', () => {
 render(<WithAnnouncer contextId=""5"">{getMock()}</WithAnnouncer>);

 const el: ?HTMLElement = getElement('5');
 invariant(el, 'Cannot find node');

 expect(el.getAttribute('aria-live')).toBe('assertive');
 expect(el.getAttribute('aria-atomic')).toBe('true');

 // not checking all the styles - just enough to know we are doing something
 expect(el.style.overflow).toBe('hidden');
});",,"FALSE","FALSE","FALSE","FALSE",,,
56,"steel","atlassian/react-beautiful-dnd","/test/unit/view/announcer.spec.js","Lazy Test","{'line': 67, 'column': 2, 'index': 2142}","start: 62 end: 75","In this test file, the following lines contain a bad design pattern (also known as a test smell):

Lines {'line': 67, 'column': 2, 'index': 2142}  – Lazy Test
Lazy Test occurs when a single test is written superficially and verifies multiple functionalities of a class without going into detail about each one.
To improve test quality and maintainability, can you refactor the method to eliminate ConditionalTestLogic while ensuring the test remains clear and effective?","it('should set the text content of the announcement element', () => {
 // arrange
 const mock = getMock();
 render(<WithAnnouncer contextId=""6"">{mock}</WithAnnouncer>);
 const el: ?HTMLElement = getElement('6');
 invariant(el, 'Could not find announcer');

 // act
 const announce: Announce = getAnnounce(mock);
 announce('test');

 // assert
 expect(el.textContent).toBe('test');
});",,"FALSE","FALSE","FALSE","FALSE",,,
57,"steel","atlassian/react-beautiful-dnd","/test/unit/view/use-droppable-publisher/forced-scroll.spec.js","Magic Number","{'line': 53, 'column': 32, 'index': 1757}","start: 31 end: 70","In this test file, the following lines contain a bad design pattern (also known as a test smell):

Lines {'line': 53, 'column': 32, 'index': 1757}  – Magic Number
Occurs when numeric literals are used directly in tests without explanation or documentation. These numbers lack clear context, making the code less readable and harder to maintain, as it is not obvious why such values are used.
To improve test quality and maintainability, can you refactor the method to eliminate ConditionalTestLogic while ensuring the test remains clear and effective?","it('should throw if the droppable has no closest scrollable', () => {
 const marshal: DimensionMarshal = getMarshalStub();
 const registry: Registry = createRegistry();
 const registerSpy = jest.spyOn(registry.droppable, 'register');
 // no scroll parent
 const wrapper = mount(
 <WithAppContext marshal={marshal} registry={registry}>
 <App parentIsScrollable={false} droppableIsScrollable={false} />,
 </WithAppContext>,
 );
 const droppable: ?HTMLElement = wrapper.find('.droppable').getDOMNode();
 invariant(droppable);
 const parent: ?HTMLElement = wrapper.find('.scroll-parent').getDOMNode();
 invariant(parent);
 jest
 .spyOn(droppable, 'getBoundingClientRect')
 .mockImplementation(() => smallFrameClient.borderBox);
 jest
 .spyOn(parent, 'getBoundingClientRect')
 .mockImplementation(() => bigClient.borderBox);

 // validating no initial scroll
 expect(parent.scrollTop).toBe(0);
 expect(parent.scrollLeft).toBe(0);
 expect(droppable.scrollTop).toBe(0);
 expect(droppable.scrollLeft).toBe(0);

 const callbacks: DroppableCallbacks = registerSpy.mock.calls[0][0].callbacks;
 // request the droppable start listening for scrolling
 callbacks.getDimensionAndWatchScroll(preset.windowScroll, scheduled);

 // ask it to scroll
 expect(() => callbacks.scroll({ x: 100, y: 100 })).toThrow();

 // no scroll changes
 expect(parent.scrollTop).toBe(0);
 expect(parent.scrollLeft).toBe(0);
 expect(droppable.scrollTop).toBe(0);
 expect(droppable.scrollLeft).toBe(0);
});",,"FALSE","FALSE","FALSE","FALSE",,,
58,"steel","atlassian/react-beautiful-dnd","/test/unit/view/use-droppable-publisher/forced-scroll.spec.js","Magic Number","{'line': 54, 'column': 33, 'index': 1794}","start: 31 end: 70","In this test file, the following lines contain a bad design pattern (also known as a test smell):

Lines {'line': 54, 'column': 33, 'index': 1794}  – Magic Number
Occurs when numeric literals are used directly in tests without explanation or documentation. These numbers lack clear context, making the code less readable and harder to maintain, as it is not obvious why such values are used.
To improve test quality and maintainability, can you refactor the method to eliminate ConditionalTestLogic while ensuring the test remains clear and effective?","it('should throw if the droppable has no closest scrollable', () => {
 const marshal: DimensionMarshal = getMarshalStub();
 const registry: Registry = createRegistry();
 const registerSpy = jest.spyOn(registry.droppable, 'register');
 // no scroll parent
 const wrapper = mount(
 <WithAppContext marshal={marshal} registry={registry}>
 <App parentIsScrollable={false} droppableIsScrollable={false} />,
 </WithAppContext>,
 );
 const droppable: ?HTMLElement = wrapper.find('.droppable').getDOMNode();
 invariant(droppable);
 const parent: ?HTMLElement = wrapper.find('.scroll-parent').getDOMNode();
 invariant(parent);
 jest
 .spyOn(droppable, 'getBoundingClientRect')
 .mockImplementation(() => smallFrameClient.borderBox);
 jest
 .spyOn(parent, 'getBoundingClientRect')
 .mockImplementation(() => bigClient.borderBox);

 // validating no initial scroll
 expect(parent.scrollTop).toBe(0);
 expect(parent.scrollLeft).toBe(0);
 expect(droppable.scrollTop).toBe(0);
 expect(droppable.scrollLeft).toBe(0);

 const callbacks: DroppableCallbacks = registerSpy.mock.calls[0][0].callbacks;
 // request the droppable start listening for scrolling
 callbacks.getDimensionAndWatchScroll(preset.windowScroll, scheduled);

 // ask it to scroll
 expect(() => callbacks.scroll({ x: 100, y: 100 })).toThrow();

 // no scroll changes
 expect(parent.scrollTop).toBe(0);
 expect(parent.scrollLeft).toBe(0);
 expect(droppable.scrollTop).toBe(0);
 expect(droppable.scrollLeft).toBe(0);
});",,"FALSE","FALSE","FALSE","FALSE",,,
59,"steel","atlassian/react-beautiful-dnd","/test/unit/view/use-droppable-publisher/forced-scroll.spec.js","Magic Number","{'line': 55, 'column': 35, 'index': 1833}","start: 31 end: 70","In this test file, the following lines contain a bad design pattern (also known as a test smell):

Lines {'line': 55, 'column': 35, 'index': 1833}  – Magic Number
Occurs when numeric literals are used directly in tests without explanation or documentation. These numbers lack clear context, making the code less readable and harder to maintain, as it is not obvious why such values are used.
To improve test quality and maintainability, can you refactor the method to eliminate ConditionalTestLogic while ensuring the test remains clear and effective?","it('should throw if the droppable has no closest scrollable', () => {
 const marshal: DimensionMarshal = getMarshalStub();
 const registry: Registry = createRegistry();
 const registerSpy = jest.spyOn(registry.droppable, 'register');
 // no scroll parent
 const wrapper = mount(
 <WithAppContext marshal={marshal} registry={registry}>
 <App parentIsScrollable={false} droppableIsScrollable={false} />,
 </WithAppContext>,
 );
 const droppable: ?HTMLElement = wrapper.find('.droppable').getDOMNode();
 invariant(droppable);
 const parent: ?HTMLElement = wrapper.find('.scroll-parent').getDOMNode();
 invariant(parent);
 jest
 .spyOn(droppable, 'getBoundingClientRect')
 .mockImplementation(() => smallFrameClient.borderBox);
 jest
 .spyOn(parent, 'getBoundingClientRect')
 .mockImplementation(() => bigClient.borderBox);

 // validating no initial scroll
 expect(parent.scrollTop).toBe(0);
 expect(parent.scrollLeft).toBe(0);
 expect(droppable.scrollTop).toBe(0);
 expect(droppable.scrollLeft).toBe(0);

 const callbacks: DroppableCallbacks = registerSpy.mock.calls[0][0].callbacks;
 // request the droppable start listening for scrolling
 callbacks.getDimensionAndWatchScroll(preset.windowScroll, scheduled);

 // ask it to scroll
 expect(() => callbacks.scroll({ x: 100, y: 100 })).toThrow();

 // no scroll changes
 expect(parent.scrollTop).toBe(0);
 expect(parent.scrollLeft).toBe(0);
 expect(droppable.scrollTop).toBe(0);
 expect(droppable.scrollLeft).toBe(0);
});",,"FALSE","FALSE","FALSE","FALSE",,,
60,"steel","atlassian/react-beautiful-dnd","/test/unit/view/use-droppable-publisher/forced-scroll.spec.js","Magic Number","{'line': 56, 'column': 36, 'index': 1873}","start: 31 end: 70","In this test file, the following lines contain a bad design pattern (also known as a test smell):

Lines {'line': 56, 'column': 36, 'index': 1873}  – Magic Number
Occurs when numeric literals are used directly in tests without explanation or documentation. These numbers lack clear context, making the code less readable and harder to maintain, as it is not obvious why such values are used.
To improve test quality and maintainability, can you refactor the method to eliminate ConditionalTestLogic while ensuring the test remains clear and effective?","it('should throw if the droppable has no closest scrollable', () => {
 const marshal: DimensionMarshal = getMarshalStub();
 const registry: Registry = createRegistry();
 const registerSpy = jest.spyOn(registry.droppable, 'register');
 // no scroll parent
 const wrapper = mount(
 <WithAppContext marshal={marshal} registry={registry}>
 <App parentIsScrollable={false} droppableIsScrollable={false} />,
 </WithAppContext>,
 );
 const droppable: ?HTMLElement = wrapper.find('.droppable').getDOMNode();
 invariant(droppable);
 const parent: ?HTMLElement = wrapper.find('.scroll-parent').getDOMNode();
 invariant(parent);
 jest
 .spyOn(droppable, 'getBoundingClientRect')
 .mockImplementation(() => smallFrameClient.borderBox);
 jest
 .spyOn(parent, 'getBoundingClientRect')
 .mockImplementation(() => bigClient.borderBox);

 // validating no initial scroll
 expect(parent.scrollTop).toBe(0);
 expect(parent.scrollLeft).toBe(0);
 expect(droppable.scrollTop).toBe(0);
 expect(droppable.scrollLeft).toBe(0);

 const callbacks: DroppableCallbacks = registerSpy.mock.calls[0][0].callbacks;
 // request the droppable start listening for scrolling
 callbacks.getDimensionAndWatchScroll(preset.windowScroll, scheduled);

 // ask it to scroll
 expect(() => callbacks.scroll({ x: 100, y: 100 })).toThrow();

 // no scroll changes
 expect(parent.scrollTop).toBe(0);
 expect(parent.scrollLeft).toBe(0);
 expect(droppable.scrollTop).toBe(0);
 expect(droppable.scrollLeft).toBe(0);
});",,"FALSE","FALSE","FALSE","FALSE",,,
61,"steel","atlassian/react-beautiful-dnd","/test/unit/view/use-droppable-publisher/forced-scroll.spec.js","Magic Number","{'line': 66, 'column': 32, 'index': 2230}","start: 31 end: 70","In this test file, the following lines contain a bad design pattern (also known as a test smell):

Lines {'line': 66, 'column': 32, 'index': 2230}  – Magic Number
Occurs when numeric literals are used directly in tests without explanation or documentation. These numbers lack clear context, making the code less readable and harder to maintain, as it is not obvious why such values are used.
To improve test quality and maintainability, can you refactor the method to eliminate ConditionalTestLogic while ensuring the test remains clear and effective?","it('should throw if the droppable has no closest scrollable', () => {
 const marshal: DimensionMarshal = getMarshalStub();
 const registry: Registry = createRegistry();
 const registerSpy = jest.spyOn(registry.droppable, 'register');
 // no scroll parent
 const wrapper = mount(
 <WithAppContext marshal={marshal} registry={registry}>
 <App parentIsScrollable={false} droppableIsScrollable={false} />,
 </WithAppContext>,
 );
 const droppable: ?HTMLElement = wrapper.find('.droppable').getDOMNode();
 invariant(droppable);
 const parent: ?HTMLElement = wrapper.find('.scroll-parent').getDOMNode();
 invariant(parent);
 jest
 .spyOn(droppable, 'getBoundingClientRect')
 .mockImplementation(() => smallFrameClient.borderBox);
 jest
 .spyOn(parent, 'getBoundingClientRect')
 .mockImplementation(() => bigClient.borderBox);

 // validating no initial scroll
 expect(parent.scrollTop).toBe(0);
 expect(parent.scrollLeft).toBe(0);
 expect(droppable.scrollTop).toBe(0);
 expect(droppable.scrollLeft).toBe(0);

 const callbacks: DroppableCallbacks = registerSpy.mock.calls[0][0].callbacks;
 // request the droppable start listening for scrolling
 callbacks.getDimensionAndWatchScroll(preset.windowScroll, scheduled);

 // ask it to scroll
 expect(() => callbacks.scroll({ x: 100, y: 100 })).toThrow();

 // no scroll changes
 expect(parent.scrollTop).toBe(0);
 expect(parent.scrollLeft).toBe(0);
 expect(droppable.scrollTop).toBe(0);
 expect(droppable.scrollLeft).toBe(0);
});",,"FALSE","FALSE","FALSE","FALSE",,,
62,"steel","atlassian/react-beautiful-dnd","/test/unit/view/placeholder/on-close.spec.js","Assertion Roulette","{'column': 2, 'line': 72}","start: 50 end: 76","In this test file, the following lines contain a bad design pattern (also known as a test smell):

Lines {'column': 2, 'line': 72}  – Assertion Roulette
This issue occurs due to the presence of multiple assertions in a test method without associated explanations. If one of these assertions fails, it will not be possible to identify which one is problematic.
To improve test quality and maintainability, can you refactor the method to eliminate ConditionalTestLogic while ensuring the test remains clear and effective?","it('should not fire an onClose if not closing when a transitionend occurs', () => {
 const onClose = jest.fn();

 const wrapper: ReactWrapper<*> = mount(
 <Placeholder
 animate=""none""
 contextId=""1""
 placeholder={placeholder}
 onClose={onClose}
 onTransitionEnd={jest.fn()}
 />,
 );
 const assert = () => {
 // $ExpectError - not a complete event
 const height: TransitionEvent = {
 propertyName: 'height',
 };
 wrapper.simulate('transitionend', height);
 expect(onClose).not.toHaveBeenCalled();
 onClose.mockClear();
 };
 expectIsFull(getPlaceholderStyle(wrapper));
 assert();

 wrapper.setProps({ animate: 'open' });
 assert();
});",,"FALSE","FALSE","FALSE","FALSE",,,
63,"steel","atlassian/react-beautiful-dnd","/test/unit/view/placeholder/on-close.spec.js","Assertion Roulette","{'column': 2, 'line': 75}","start: 50 end: 76","In this test file, the following lines contain a bad design pattern (also known as a test smell):

Lines {'column': 2, 'line': 75}  – Assertion Roulette
This issue occurs due to the presence of multiple assertions in a test method without associated explanations. If one of these assertions fails, it will not be possible to identify which one is problematic.
To improve test quality and maintainability, can you refactor the method to eliminate ConditionalTestLogic while ensuring the test remains clear and effective?","it('should not fire an onClose if not closing when a transitionend occurs', () => {
 const onClose = jest.fn();

 const wrapper: ReactWrapper<*> = mount(
 <Placeholder
 animate=""none""
 contextId=""1""
 placeholder={placeholder}
 onClose={onClose}
 onTransitionEnd={jest.fn()}
 />,
 );
 const assert = () => {
 // $ExpectError - not a complete event
 const height: TransitionEvent = {
 propertyName: 'height',
 };
 wrapper.simulate('transitionend', height);
 expect(onClose).not.toHaveBeenCalled();
 onClose.mockClear();
 };
 expectIsFull(getPlaceholderStyle(wrapper));
 assert();

 wrapper.setProps({ animate: 'open' });
 assert();
});",,"FALSE","FALSE","FALSE","FALSE",,,
64,"steel","atlassian/react-beautiful-dnd","/test/unit/view/dimension-marshal/publish-while-dragging.spec.js","Lazy Test","{'line': 142, 'column': 6, 'index': 3763}","start: 112 end: 158","In this test file, the following lines contain a bad design pattern (also known as a test smell):

Lines {'line': 142, 'column': 6, 'index': 3763}  – Lazy Test
Lazy Test occurs when a single test is written superficially and verifies multiple functionalities of a class without going into detail about each one.
To improve test quality and maintainability, can you refactor the method to eliminate ConditionalTestLogic while ensuring the test remains clear and effective?","it('should collect and publish the draggables', () => {
 const beforeInHome1: DraggableDimension = {
 ...preset.inHome1,
 descriptor: {
 ...preset.inHome1.descriptor,
 id: 'addition1',
 index: 0,
 },
 };
 const beforeInHome2: DraggableDimension = {
 ...preset.inHome2,
 descriptor: {
 ...preset.inHome2.descriptor,
 id: 'addition2',
 index: 1,
 },
 };
 const registry: Registry = createRegistry();
 const callbacks: Callbacks = getCallbacksStub();
 const marshal: DimensionMarshal = createDimensionMarshal(
 registry,
 callbacks,
 );
 populate(registry, withScrollables);

 // A publish has started
 marshal.startPublishing(defaultRequest);
 expect(callbacks.publishWhileDragging).not.toHaveBeenCalled();

 registry.draggable.register(
 getDraggableEntry({ dimension: beforeInHome1 }),
 );
 registry.draggable.register(
 getDraggableEntry({ dimension: beforeInHome2 }),
 );
 expect(callbacks.collectionStarting).toHaveBeenCalled();
 expect(callbacks.publishWhileDragging).not.toHaveBeenCalled();

 // Fire the collection / publish step
 requestAnimationFrame.step();
 const expected: Published = {
 ...empty,
 additions: [beforeInHome1, beforeInHome2],
 modified: [{ droppableId: scrollableHome.descriptor.id, scroll: origin }],
 };
 expect(callbacks.publishWhileDragging).toHaveBeenCalledWith(expected);
 });",,"FALSE","FALSE","FALSE","FALSE",,,
65,"steel","atlassian/react-beautiful-dnd","/test/unit/view/dimension-marshal/publish-while-dragging.spec.js","Lazy Test","{'line': 176, 'column': 6, 'index': 4997}","start: 160 end: 179","In this test file, the following lines contain a bad design pattern (also known as a test smell):

Lines {'line': 176, 'column': 6, 'index': 4997}  – Lazy Test
Lazy Test occurs when a single test is written superficially and verifies multiple functionalities of a class without going into detail about each one.
To improve test quality and maintainability, can you refactor the method to eliminate ConditionalTestLogic while ensuring the test remains clear and effective?","it('should not do anything if trying to add a draggable that does not have the same type as the dragging item', () => {
 const callbacks: Callbacks = getCallbacksStub();
 const registry: Registry = createRegistry();
 const marshal: DimensionMarshal = createDimensionMarshal(
 registry,
 callbacks,
 );
 populate(registry, withScrollables);

 // A publish has started
 marshal.startPublishing(defaultRequest);
 expect(callbacks.collectionStarting).not.toHaveBeenCalled();

 // Registering a new draggable (inserted before inHome1)

 registry.draggable.register(
 getDraggableEntry({ dimension: inAnotherType }),
 );
 expect(callbacks.collectionStarting).not.toHaveBeenCalled();
 });",,"FALSE","FALSE","FALSE","FALSE",,,
66,"steel","atlassian/react-beautiful-dnd","/test/unit/view/dimension-marshal/publish-while-dragging.spec.js","Lazy Test","{'line': 213, 'column': 6, 'index': 6080}","start: 181 end: 230","In this test file, the following lines contain a bad design pattern (also known as a test smell):

Lines {'line': 213, 'column': 6, 'index': 6080}  – Lazy Test
Lazy Test occurs when a single test is written superficially and verifies multiple functionalities of a class without going into detail about each one.
To improve test quality and maintainability, can you refactor the method to eliminate ConditionalTestLogic while ensuring the test remains clear and effective?","it('should order published draggables by their index', () => {
 const beforeInHome1: DraggableDimension = {
 ...preset.inHome1,
 descriptor: {
 ...preset.inHome1.descriptor,
 id: 'b',
 index: 0,
 },
 };
 const beforeInHome2: DraggableDimension = {
 ...preset.inHome2,
 descriptor: {
 ...preset.inHome2.descriptor,
 // if ordered by a key, this would be first
 id: 'a',
 index: 1,
 },
 };
 const callbacks: Callbacks = getCallbacksStub();
 const registry: Registry = createRegistry();
 const marshal: DimensionMarshal = createDimensionMarshal(
 registry,
 callbacks,
 );
 populate(registry, withScrollables);

 // A publish has started
 marshal.startPublishing(defaultRequest);
 expect(callbacks.publishWhileDragging).not.toHaveBeenCalled();

 // publishing the higher index value first
 registry.draggable.register(
 getDraggableEntry({ dimension: beforeInHome2 }),
 );
 // publishing the lower index value second
 registry.draggable.register(
 getDraggableEntry({ dimension: beforeInHome1 }),
 );
 expect(callbacks.publishWhileDragging).not.toHaveBeenCalled();

 // Fire the collection / publish step
 requestAnimationFrame.step();
 const expected: Published = {
 ...empty,
 // we expect this to be ordered by index
 additions: [beforeInHome1, beforeInHome2],
 modified: [{ droppableId: scrollableHome.descriptor.id, scroll: origin }],
 };
 expect(callbacks.publishWhileDragging).toHaveBeenCalledWith(expected);
 });",,"FALSE","FALSE","FALSE","FALSE",,,
67,"steel","jackocnr/intl-tel-input","/tests/static/attachUtils.test.js","Duplicate Assert","{'line': 26, 'column': 6, 'index': 687}","start: 25 end: 28","In this test file, the following lines contain a bad design pattern (also known as a test smell):

Lines {'line': 26, 'column': 6, 'index': 687}  – Duplicate Assert
This issue occurs when a test method verifies the same condition more than once within its scope, making the test harder to read and maintain. Identical assertions within the same method do not explicitly convey the purpose of the test method.
To improve test quality and maintainability, can you refactor the method to eliminate ConditionalTestLogic while ensuring the test remains clear and effective?","it(""resolves the promise"", async () => {
 expect(loadResult).toBeAPromise();
 await expect(loadResult).resolves.toBe(true);
 });",,"FALSE","FALSE","FALSE","FALSE",,,
68,"steel","jackocnr/intl-tel-input","/tests/static/attachUtils.test.js","Duplicate Assert","{'line': 27, 'column': 12, 'index': 734}","start: 25 end: 28","In this test file, the following lines contain a bad design pattern (also known as a test smell):

Lines {'line': 27, 'column': 12, 'index': 734}  – Duplicate Assert
This issue occurs when a test method verifies the same condition more than once within its scope, making the test harder to read and maintain. Identical assertions within the same method do not explicitly convey the purpose of the test method.
To improve test quality and maintainability, can you refactor the method to eliminate ConditionalTestLogic while ensuring the test remains clear and effective?","it(""resolves the promise"", async () => {
 expect(loadResult).toBeAPromise();
 await expect(loadResult).resolves.toBe(true);
 });",,"FALSE","FALSE","FALSE","FALSE",,,
69,"steel","jackocnr/intl-tel-input","/tests/options/separateDialCode.test.js","Duplicate Assert","{'line': 156, 'column': 4, 'index': 4180}","start: 153 end: 169","In this test file, the following lines contain a bad design pattern (also known as a test smell):

Lines {'line': 156, 'column': 4, 'index': 4180}  – Duplicate Assert
This issue occurs when a test method verifies the same condition more than once within its scope, making the test harder to read and maintain. Identical assertions within the same method do not explicitly convey the purpose of the test method.
To improve test quality and maintainability, can you refactor the method to eliminate ConditionalTestLogic while ensuring the test remains clear and effective?","test(""typing/deleting different area codes should update the selected country"", async () => {
 // typing area code starting with 1 changes to Russia
 await user.type(input, ""1"");
 expect(checkFlagSelected(container, ""ru"")).toBe(true);

 // deleting area code keeps Russia selected
 await user.type(input, ""{backspace}"");
 expect(checkFlagSelected(container, ""ru"")).toBe(true);

 // typing area code starting with 7 changes to Kazakhstan
 await user.type(input, ""7"");
 expect(checkFlagSelected(container, ""kz"")).toBe(true);

 // deleting area code keeps Kazakhstan selected
 await user.type(input, ""{backspace}"");
 expect(checkFlagSelected(container, ""kz"")).toBe(true);
 });",,"FALSE","FALSE","FALSE","FALSE",,,
70,"steel","jackocnr/intl-tel-input","/tests/options/separateDialCode.test.js","Duplicate Assert","{'line': 156, 'column': 4, 'index': 4180}","start: 153 end: 169","In this test file, the following lines contain a bad design pattern (also known as a test smell):

Lines {'line': 156, 'column': 4, 'index': 4180}  – Duplicate Assert
This issue occurs when a test method verifies the same condition more than once within its scope, making the test harder to read and maintain. Identical assertions within the same method do not explicitly convey the purpose of the test method.
To improve test quality and maintainability, can you refactor the method to eliminate ConditionalTestLogic while ensuring the test remains clear and effective?","test(""typing/deleting different area codes should update the selected country"", async () => {
 // typing area code starting with 1 changes to Russia
 await user.type(input, ""1"");
 expect(checkFlagSelected(container, ""ru"")).toBe(true);

 // deleting area code keeps Russia selected
 await user.type(input, ""{backspace}"");
 expect(checkFlagSelected(container, ""ru"")).toBe(true);

 // typing area code starting with 7 changes to Kazakhstan
 await user.type(input, ""7"");
 expect(checkFlagSelected(container, ""kz"")).toBe(true);

 // deleting area code keeps Kazakhstan selected
 await user.type(input, ""{backspace}"");
 expect(checkFlagSelected(container, ""kz"")).toBe(true);
 });",,"FALSE","FALSE","FALSE","FALSE",,,
71,"steel","jackocnr/intl-tel-input","/tests/options/separateDialCode.test.js","Duplicate Assert","{'line': 160, 'column': 4, 'index': 4331}","start: 153 end: 169","In this test file, the following lines contain a bad design pattern (also known as a test smell):

Lines {'line': 160, 'column': 4, 'index': 4331}  – Duplicate Assert
This issue occurs when a test method verifies the same condition more than once within its scope, making the test harder to read and maintain. Identical assertions within the same method do not explicitly convey the purpose of the test method.
To improve test quality and maintainability, can you refactor the method to eliminate ConditionalTestLogic while ensuring the test remains clear and effective?","test(""typing/deleting different area codes should update the selected country"", async () => {
 // typing area code starting with 1 changes to Russia
 await user.type(input, ""1"");
 expect(checkFlagSelected(container, ""ru"")).toBe(true);

 // deleting area code keeps Russia selected
 await user.type(input, ""{backspace}"");
 expect(checkFlagSelected(container, ""ru"")).toBe(true);

 // typing area code starting with 7 changes to Kazakhstan
 await user.type(input, ""7"");
 expect(checkFlagSelected(container, ""kz"")).toBe(true);

 // deleting area code keeps Kazakhstan selected
 await user.type(input, ""{backspace}"");
 expect(checkFlagSelected(container, ""kz"")).toBe(true);
 });",,"FALSE","FALSE","FALSE","FALSE",,,
72,"steel","jackocnr/intl-tel-input","/tests/core/multipleInstances.test.js","Magic Number","{'line': 35, 'column': 53, 'index': 886}","start: 34 end: 37","In this test file, the following lines contain a bad design pattern (also known as a test smell):

Lines {'line': 35, 'column': 53, 'index': 886}  – Magic Number
Occurs when numeric literals are used directly in tests without explanation or documentation. These numbers lack clear context, making the code less readable and harder to maintain, as it is not obvious why such values are used.
To improve test quality and maintainability, can you refactor the method to eliminate ConditionalTestLogic while ensuring the test remains clear and effective?","test(""instances have different country lists"", () => {
 expect(getCountryListLength(container1)).toEqual(2);
 expect(getCountryListLength(container2)).toEqual(4);
 });",,"FALSE","FALSE","FALSE","FALSE",,,
73,"steel","jackocnr/intl-tel-input","/tests/core/multipleInstances.test.js","Magic Number","{'line': 36, 'column': 53, 'index': 943}","start: 34 end: 37","In this test file, the following lines contain a bad design pattern (also known as a test smell):

Lines {'line': 36, 'column': 53, 'index': 943}  – Magic Number
Occurs when numeric literals are used directly in tests without explanation or documentation. These numbers lack clear context, making the code less readable and harder to maintain, as it is not obvious why such values are used.
To improve test quality and maintainability, can you refactor the method to eliminate ConditionalTestLogic while ensuring the test remains clear and effective?","test(""instances have different country lists"", () => {
 expect(getCountryListLength(container1)).toEqual(2);
 expect(getCountryListLength(container2)).toEqual(4);
 });",,"FALSE","FALSE","FALSE","FALSE",,,
74,"steel","jackocnr/intl-tel-input","/tests/core/countrySearch.test.js","Magic Number","{'line': 55, 'column': 51, 'index': 1582}","start: 54 end: 56","In this test file, the following lines contain a bad design pattern (also known as a test smell):

Lines {'line': 55, 'column': 51, 'index': 1582}  – Magic Number
Occurs when numeric literals are used directly in tests without explanation or documentation. These numbers lack clear context, making the code less readable and harder to maintain, as it is not obvious why such values are used.
To improve test quality and maintainability, can you refactor the method to eliminate ConditionalTestLogic while ensuring the test remains clear and effective?","test(""shows the right number of results"", () => {
 expect(getCountryListLength(container)).toBe(6);
 });",,"FALSE","FALSE","FALSE","FALSE",,,
75,"snutsjs","miragejs/miragejs","/__tests__/internal/move-after-handle-request/route-handlers/put-shorthand-test.js","SubOptimalAssert","{""startLine"":56,""endLine"":56}","start: 40 end: 59","In this test file, the following lines contain a bad design pattern (also known as a test smell):

Lines {""startLine"":56,""endLine"":56}  – SubOptimalAssert
Occurs when the assertions used in tests are not ideal for verifying the specific condition being tested. Using more specific and expressive assertions can improve test clarity and make results more useful
To improve test quality and maintainability, can you refactor the method to eliminate ConditionalTestLogic while ensuring the test remains clear and effective?","test(""undefined shorthand updates the record and returns the model"", () => {
 let handler = new PutShorthandRouteHandler(
 schema,
 serializer,
 undefined,
 ""/authors/:id""
 );
 let request = {
 requestBody: JSON.stringify(body),
 url: ""/authors/1"",
 params: { id: ""1"" },
 };

 let model = handler.handle(request);

 expect(schema.db.authors).toHaveLength(1);
 expect(model instanceof Model).toBeTruthy();
 expect(model.modelName).toBe(""author"");
 expect(model.firstName).toBe(""Ganondorf"");
 });",,"FALSE","FALSE","FALSE","FALSE",,,
76,"snutsjs","miragejs/miragejs","/__tests__/internal/move-after-handle-request/route-handlers/put-shorthand-test.js","SubOptimalAssert","{""startLine"":73,""endLine"":73}","start: 61 end: 76","In this test file, the following lines contain a bad design pattern (also known as a test smell):

Lines {""startLine"":73,""endLine"":73}  – SubOptimalAssert
Occurs when the assertions used in tests are not ideal for verifying the specific condition being tested. Using more specific and expressive assertions can improve test clarity and make results more useful
To improve test quality and maintainability, can you refactor the method to eliminate ConditionalTestLogic while ensuring the test remains clear and effective?","test(""query params are ignored"", () => {
 let handler = new PutShorthandRouteHandler(schema, serializer, ""author"");
 let request = {
 requestBody: JSON.stringify(body),
 url: ""/authors/1?foo=bar"",
 params: { id: ""1"" },
 queryParams: { foo: ""bar"" },
 };

 let model = handler.handle(request);

 expect(schema.db.authors).toHaveLength(1);
 expect(model instanceof Model).toBeTruthy();
 expect(model.modelName).toBe(""author"");
 expect(model.firstName).toBe(""Ganondorf"");
 });",,"FALSE","FALSE","FALSE","FALSE",,,
77,"snutsjs","miragejs/miragejs","/__tests__/internal/move-after-handle-request/route-handlers/put-shorthand-test.js","SubOptimalAssert","{""startLine"":94,""endLine"":94}","start: 78 end: 97","In this test file, the following lines contain a bad design pattern (also known as a test smell):

Lines {""startLine"":94,""endLine"":94}  – SubOptimalAssert
Occurs when the assertions used in tests are not ideal for verifying the specific condition being tested. Using more specific and expressive assertions can improve test clarity and make results more useful
To improve test quality and maintainability, can you refactor the method to eliminate ConditionalTestLogic while ensuring the test remains clear and effective?","test(""string shorthand updates the record of the specified type and returns the model"", () => {
 let handler = new PutShorthandRouteHandler(
 schema,
 serializer,
 undefined,
 ""/authors/:id""
 );
 let request = {
 requestBody: JSON.stringify(body),
 url: ""/authors/1"",
 params: { id: ""1"" },
 };

 let model = handler.handle(request);

 expect(schema.db.authors).toHaveLength(1);
 expect(model instanceof Model).toBeTruthy();
 expect(model.modelName).toBe(""author"");
 expect(model.firstName).toBe(""Ganondorf"");
 });",,"FALSE","FALSE","FALSE","FALSE",,,
78,"snutsjs","miragejs/miragejs","/__tests__/internal/move-after-handle-request/route-handlers/post-shorthand-test.js","SubOptimalAssert","{""startLine"":42,""endLine"":42}","start: 35 end: 45","In this test file, the following lines contain a bad design pattern (also known as a test smell):

Lines {""startLine"":42,""endLine"":42}  – SubOptimalAssert
Occurs when the assertions used in tests are not ideal for verifying the specific condition being tested. Using more specific and expressive assertions can improve test clarity and make results more useful
To improve test quality and maintainability, can you refactor the method to eliminate ConditionalTestLogic while ensuring the test remains clear and effective?","test(""string shorthand creates a record of the specified type and returns the new model"", () => {
 let request = { requestBody: JSON.stringify(body), url: ""/people"" };
 let handler = new PostShorthandRouteHandler(schema, serializer, ""author"");

 let model = handler.handle(request);

 expect(schema.db.authors).toHaveLength(1);
 expect(model instanceof Model).toBeTruthy();
 expect(model.modelName).toBe(""author"");
 expect(model.firstName).toBe(""Ganon"");
 });",,"FALSE","FALSE","FALSE","FALSE",,,
79,"snutsjs","miragejs/miragejs","/__tests__/internal/move-after-handle-request/route-handlers/post-shorthand-test.js","SubOptimalAssert","{""startLine"":58,""endLine"":58}","start: 47 end: 61","In this test file, the following lines contain a bad design pattern (also known as a test smell):

Lines {""startLine"":58,""endLine"":58}  – SubOptimalAssert
Occurs when the assertions used in tests are not ideal for verifying the specific condition being tested. Using more specific and expressive assertions can improve test clarity and make results more useful
To improve test quality and maintainability, can you refactor the method to eliminate ConditionalTestLogic while ensuring the test remains clear and effective?","test(""query params are ignored"", () => {
 let request = {
 requestBody: JSON.stringify(body),
 url: ""/authors?foo=bar"",
 queryParams: { foo: ""bar"" },
 };
 let handler = new PostShorthandRouteHandler(schema, serializer, ""author"");

 let model = handler.handle(request);

 expect(schema.db.authors).toHaveLength(1);
 expect(model instanceof Model).toBeTruthy();
 expect(model.modelName).toBe(""author"");
 expect(model.firstName).toBe(""Ganon"");
 });",,"FALSE","FALSE","FALSE","FALSE",,,
80,"steel","miragejs/miragejs","/__tests__/internal/unit/server-test.js","Duplicate Assert","{'line': 622, 'column': 4, 'index': 14567}","start: 578 end: 636","In this test file, the following lines contain a bad design pattern (also known as a test smell):

Lines {'line': 622, 'column': 4, 'index': 14567}  – Duplicate Assert
This issue occurs when a test method verifies the same condition more than once within its scope, making the test harder to read and maintain. Identical assertions within the same method do not explicitly convey the purpose of the test method.
To improve test quality and maintainability, can you refactor the method to eliminate ConditionalTestLogic while ensuring the test remains clear and effective?","test(""create allows to create objects with associations"", () => {
 let AuthorFactory = Factory.extend({
 name: ""Sam"",
 });
 let CategoryFactory = Factory.extend({
 name: ""splendid software"",
 });
 let ArticleFactory = Factory.extend({
 title: ""Lorem ipsum"",

 withCategory: trait({
 awesomeCategory: association(),
 }),

 author: association(),
 });

 let server = new Server({
 environment: ""test"",
 models: {
 author: Model.extend({
 articles: hasMany(),
 }),
 category: Model.extend({}),
 article: Model.extend({
 author: belongsTo(),
 awesomeCategory: belongsTo(""category""),
 }),
 },
 factories: {
 article: ArticleFactory,
 author: AuthorFactory,
 category: CategoryFactory,
 },
 });

 let article = server.create(""article"", ""withCategory"");

 expect(article.attrs).toEqual({
 title: ""Lorem ipsum"",
 id: ""1"",
 authorId: ""1"",
 awesomeCategoryId: ""1"",
 });
 expect(server.db.authors).toHaveLength(1);
 expect(server.db.categories).toHaveLength(1);

 let anotherArticle = server.create(""article"", ""withCategory"");
 expect(anotherArticle.attrs).toEqual({
 title: ""Lorem ipsum"",
 id: ""2"",
 authorId: ""2"",
 awesomeCategoryId: ""2"",
 });
 expect(server.db.authors).toHaveLength(2);
 expect(server.db.categories).toHaveLength(2);

 server.shutdown();
 });",,"FALSE","FALSE","FALSE","FALSE",,,
81,"steel","miragejs/miragejs","/__tests__/internal/unit/server-test.js","Duplicate Assert","{'line': 623, 'column': 4, 'index': 14614}","start: 578 end: 636","In this test file, the following lines contain a bad design pattern (also known as a test smell):

Lines {'line': 623, 'column': 4, 'index': 14614}  – Duplicate Assert
This issue occurs when a test method verifies the same condition more than once within its scope, making the test harder to read and maintain. Identical assertions within the same method do not explicitly convey the purpose of the test method.
To improve test quality and maintainability, can you refactor the method to eliminate ConditionalTestLogic while ensuring the test remains clear and effective?","test(""create allows to create objects with associations"", () => {
 let AuthorFactory = Factory.extend({
 name: ""Sam"",
 });
 let CategoryFactory = Factory.extend({
 name: ""splendid software"",
 });
 let ArticleFactory = Factory.extend({
 title: ""Lorem ipsum"",

 withCategory: trait({
 awesomeCategory: association(),
 }),

 author: association(),
 });

 let server = new Server({
 environment: ""test"",
 models: {
 author: Model.extend({
 articles: hasMany(),
 }),
 category: Model.extend({}),
 article: Model.extend({
 author: belongsTo(),
 awesomeCategory: belongsTo(""category""),
 }),
 },
 factories: {
 article: ArticleFactory,
 author: AuthorFactory,
 category: CategoryFactory,
 },
 });

 let article = server.create(""article"", ""withCategory"");

 expect(article.attrs).toEqual({
 title: ""Lorem ipsum"",
 id: ""1"",
 authorId: ""1"",
 awesomeCategoryId: ""1"",
 });
 expect(server.db.authors).toHaveLength(1);
 expect(server.db.categories).toHaveLength(1);

 let anotherArticle = server.create(""article"", ""withCategory"");
 expect(anotherArticle.attrs).toEqual({
 title: ""Lorem ipsum"",
 id: ""2"",
 authorId: ""2"",
 awesomeCategoryId: ""2"",
 });
 expect(server.db.authors).toHaveLength(2);
 expect(server.db.categories).toHaveLength(2);

 server.shutdown();
 });",,"FALSE","FALSE","FALSE","FALSE",,,
82,"steel","miragejs/miragejs","/__tests__/internal/unit/server-test.js","Duplicate Assert","{'line': 632, 'column': 4, 'index': 14877}","start: 578 end: 636","In this test file, the following lines contain a bad design pattern (also known as a test smell):

Lines {'line': 632, 'column': 4, 'index': 14877}  – Duplicate Assert
This issue occurs when a test method verifies the same condition more than once within its scope, making the test harder to read and maintain. Identical assertions within the same method do not explicitly convey the purpose of the test method.
To improve test quality and maintainability, can you refactor the method to eliminate ConditionalTestLogic while ensuring the test remains clear and effective?","test(""create allows to create objects with associations"", () => {
 let AuthorFactory = Factory.extend({
 name: ""Sam"",
 });
 let CategoryFactory = Factory.extend({
 name: ""splendid software"",
 });
 let ArticleFactory = Factory.extend({
 title: ""Lorem ipsum"",

 withCategory: trait({
 awesomeCategory: association(),
 }),

 author: association(),
 });

 let server = new Server({
 environment: ""test"",
 models: {
 author: Model.extend({
 articles: hasMany(),
 }),
 category: Model.extend({}),
 article: Model.extend({
 author: belongsTo(),
 awesomeCategory: belongsTo(""category""),
 }),
 },
 factories: {
 article: ArticleFactory,
 author: AuthorFactory,
 category: CategoryFactory,
 },
 });

 let article = server.create(""article"", ""withCategory"");

 expect(article.attrs).toEqual({
 title: ""Lorem ipsum"",
 id: ""1"",
 authorId: ""1"",
 awesomeCategoryId: ""1"",
 });
 expect(server.db.authors).toHaveLength(1);
 expect(server.db.categories).toHaveLength(1);

 let anotherArticle = server.create(""article"", ""withCategory"");
 expect(anotherArticle.attrs).toEqual({
 title: ""Lorem ipsum"",
 id: ""2"",
 authorId: ""2"",
 awesomeCategoryId: ""2"",
 });
 expect(server.db.authors).toHaveLength(2);
 expect(server.db.categories).toHaveLength(2);

 server.shutdown();
 });",,"FALSE","FALSE","FALSE","FALSE",,,
83,"steel","miragejs/miragejs","/__tests__/internal/unit/server-test.js","Duplicate Assert","{'line': 633, 'column': 4, 'index': 14924}","start: 578 end: 636","In this test file, the following lines contain a bad design pattern (also known as a test smell):

Lines {'line': 633, 'column': 4, 'index': 14924}  – Duplicate Assert
This issue occurs when a test method verifies the same condition more than once within its scope, making the test harder to read and maintain. Identical assertions within the same method do not explicitly convey the purpose of the test method.
To improve test quality and maintainability, can you refactor the method to eliminate ConditionalTestLogic while ensuring the test remains clear and effective?","test(""create allows to create objects with associations"", () => {
 let AuthorFactory = Factory.extend({
 name: ""Sam"",
 });
 let CategoryFactory = Factory.extend({
 name: ""splendid software"",
 });
 let ArticleFactory = Factory.extend({
 title: ""Lorem ipsum"",

 withCategory: trait({
 awesomeCategory: association(),
 }),

 author: association(),
 });

 let server = new Server({
 environment: ""test"",
 models: {
 author: Model.extend({
 articles: hasMany(),
 }),
 category: Model.extend({}),
 article: Model.extend({
 author: belongsTo(),
 awesomeCategory: belongsTo(""category""),
 }),
 },
 factories: {
 article: ArticleFactory,
 author: AuthorFactory,
 category: CategoryFactory,
 },
 });

 let article = server.create(""article"", ""withCategory"");

 expect(article.attrs).toEqual({
 title: ""Lorem ipsum"",
 id: ""1"",
 authorId: ""1"",
 awesomeCategoryId: ""1"",
 });
 expect(server.db.authors).toHaveLength(1);
 expect(server.db.categories).toHaveLength(1);

 let anotherArticle = server.create(""article"", ""withCategory"");
 expect(anotherArticle.attrs).toEqual({
 title: ""Lorem ipsum"",
 id: ""2"",
 authorId: ""2"",
 awesomeCategoryId: ""2"",
 });
 expect(server.db.authors).toHaveLength(2);
 expect(server.db.categories).toHaveLength(2);

 server.shutdown();
 });",,"FALSE","FALSE","FALSE","FALSE",,,
84,"steel","miragejs/miragejs","/__tests__/internal/unit/server-test.js","Magic Number","{'line': 26, 'column': 39, 'index': 502}","start: 21 end: 29","In this test file, the following lines contain a bad design pattern (also known as a test smell):

Lines {'line': 26, 'column': 39, 'index': 502}  – Magic Number
Occurs when numeric literals are used directly in tests without explanation or documentation. These numbers lack clear context, making the code less readable and harder to maintain, as it is not obvious why such values are used.
To improve test quality and maintainability, can you refactor the method to eliminate ConditionalTestLogic while ensuring the test remains clear and effective?","test(""routes return pretender handler"", () => {
 let server = new Server({ environment: ""test"" });

 let handler = server.post(""foo"");

 expect(handler.numberOfCalls).toBe(0);

 server.shutdown();
 });",,"FALSE","FALSE","FALSE","FALSE",,,
85,"steel","miragejs/miragejs","/__tests__/internal/unit/server-test.js","Magic Number","{'line': 59, 'column': 39, 'index': 1191}","start: 54 end: 62","In this test file, the following lines contain a bad design pattern (also known as a test smell):

Lines {'line': 59, 'column': 39, 'index': 1191}  – Magic Number
Occurs when numeric literals are used directly in tests without explanation or documentation. These numbers lack clear context, making the code less readable and harder to maintain, as it is not obvious why such values are used.
To improve test quality and maintainability, can you refactor the method to eliminate ConditionalTestLogic while ensuring the test remains clear and effective?","test(""routes return pretender handler"", async () => {
 let server = createServer({ environment: ""test"" });

 let handler = server.post(""foo"");

 expect(handler.numberOfCalls).toBe(0);

 server.shutdown();
 });",,"FALSE","FALSE","FALSE","FALSE",,,
86,"steel","miragejs/miragejs","/__tests__/internal/unit/server-test.js","Magic Number","{'line': 80, 'column': 31, 'index': 1650}","start: 77 end: 83","In this test file, the following lines contain a bad design pattern (also known as a test smell):

Lines {'line': 80, 'column': 31, 'index': 1650}  – Magic Number
Occurs when numeric literals are used directly in tests without explanation or documentation. These numbers lack clear context, making the code less readable and harder to maintain, as it is not obvious why such values are used.
To improve test quality and maintainability, can you refactor the method to eliminate ConditionalTestLogic while ensuring the test remains clear and effective?","test(""forces timing to be 0 in test environment"", async () => {
 let server = createServer({ environment: ""test"" });

 expect(server.timing).toBe(0);

 server.shutdown();
 });",,"FALSE","FALSE","FALSE","FALSE",,,
87,"steel","miragejs/miragejs","/__tests__/internal/unit/server-test.js","Magic Number","{'line': 88, 'column': 31, 'index': 1818}","start: 85 end: 91","In this test file, the following lines contain a bad design pattern (also known as a test smell):

Lines {'line': 88, 'column': 31, 'index': 1818}  – Magic Number
Occurs when numeric literals are used directly in tests without explanation or documentation. These numbers lack clear context, making the code less readable and harder to maintain, as it is not obvious why such values are used.
To improve test quality and maintainability, can you refactor the method to eliminate ConditionalTestLogic while ensuring the test remains clear and effective?","test(""allows setting the timing to 0"", async () => {
 let server = createServer({ timing: 0 });

 expect(server.timing).toBe(0);

 server.shutdown();
 });",,"FALSE","FALSE","FALSE","FALSE",,,
88,"steel","miragejs/miragejs","/__tests__/internal/unit/server-test.js","Magic Number","{'line': 102, 'column': 31, 'index': 2121}","start: 95 end: 105","In this test file, the following lines contain a bad design pattern (also known as a test smell):

Lines {'line': 102, 'column': 31, 'index': 2121}  – Magic Number
Occurs when numeric literals are used directly in tests without explanation or documentation. These numbers lack clear context, making the code less readable and harder to maintain, as it is not obvious why such values are used.
To improve test quality and maintainability, can you refactor the method to eliminate ConditionalTestLogic while ensuring the test remains clear and effective?","test(""forces timing to 0 in test environment"", () => {
 let server = new Server({ environment: ""test"" });

 server.loadConfig(function () {
 this.timing = 50;
 });

 expect(server.timing).toBe(0);

 server.shutdown();
 });",,"FALSE","FALSE","FALSE","FALSE",,,
89,"steel","miragejs/miragejs","/__tests__/internal/unit/schema-test.js","Duplicate Assert","{'line': 42, 'column': 4, 'index': 1188}","start: 33 end: 47","In this test file, the following lines contain a bad design pattern (also known as a test smell):

Lines {'line': 42, 'column': 4, 'index': 1188}  – Duplicate Assert
This issue occurs when a test method verifies the same condition more than once within its scope, making the test harder to read and maintain. Identical assertions within the same method do not explicitly convey the purpose of the test method.
To improve test quality and maintainability, can you refactor the method to eliminate ConditionalTestLogic while ensuring the test remains clear and effective?","test(""`first()` returns null when nothing is found"", () => {
 expect.assertions(2);

 let db = new Db();
 let schema = new Schema(db);

 let authorModel = Model.extend({});
 schema.registerModel(""author"", authorModel);

 expect(schema.first(""author"")).toBeNull();

 let record = schema.create(""author"", { id: 1, name: ""Mary Roach"" });

 expect(schema.first(""author"")).toEqual(record);
 });",,"FALSE","FALSE","FALSE","FALSE",,,
90,"snutsjs","brookhong/surfingkeys","/tests/content_scripts/uiframe.test.js","TestWithoutDescription","{""startLine"":42,""endLine"":44}","start: 42 end: 44","In this test file, the following lines contain a bad design pattern (also known as a test smell):

Lines {""startLine"":42,""endLine"":44}  – TestWithoutDescription
A test case that is defined without a descriptive name or message, making it unclear what functionality is being tested.
To improve test quality and maintainability, can you refactor the method to eliminate ConditionalTestLogic while ensuring the test remains clear and effective?","it("""", () => {
 uiframe.default();
 });",,"FALSE","FALSE","FALSE","FALSE",,,
91,"snutsjs","brookhong/surfingkeys","/tests/content_scripts/markdown.test.js","SubOptimalAssert","{""startLine"":65,""endLine"":65}","start: 62 end: 76","In this test file, the following lines contain a bad design pattern (also known as a test smell):

Lines {""startLine"":65,""endLine"":65}  – SubOptimalAssert
Occurs when the assertions used in tests are not ideal for verifying the specific condition being tested. Using more specific and expressive assertions can improve test clarity and make results more useful
To improve test quality and maintainability, can you refactor the method to eliminate ConditionalTestLogic while ensuring the test remains clear and effective?","test(""verify local shortcuts for markdown preview"", async () => {
 document.execCommand = jest.fn();

 expect(normal.mappings.find('of')).toBe(undefined);
 expect(document.execCommand).toHaveBeenCalledTimes(0);

 await waitForEvent(document, ""surfingkeys:defaultSettingsLoaded"", () => {
 return true;
 }, () => {
 dispatchSKEvent('defaultSettingsLoaded', {normal, api});
 });

 expect(normal.mappings.find('of').meta.word).toBe('of');
 expect(document.execCommand).toHaveBeenCalledTimes(1);
 });",,"FALSE","FALSE","FALSE","FALSE",,,
92,"snutsjs","brookhong/surfingkeys","/tests/content_scripts/markdown.test.js","SubOptimalAssert","{""startLine"":88,""endLine"":88}","start: 78 end: 90","In this test file, the following lines contain a bad design pattern (also known as a test smell):

Lines {""startLine"":88,""endLine"":88}  – SubOptimalAssert
Occurs when the assertions used in tests are not ideal for verifying the specific condition being tested. Using more specific and expressive assertions can improve test clarity and make results more useful
To improve test quality and maintainability, can you refactor the method to eliminate ConditionalTestLogic while ensuring the test remains clear and effective?","test(""render markdown from clipboard"", async () => {
 jest.spyOn(clipboard, 'read').mockImplementationOnce((onReady) => {
 onReady({data: ""* [github](https://github.com)\n* [google](https://google.com)""});
 });
 await waitForEvent(document, ""surfingkeys:defaultSettingsLoaded"", () => {
 return true;
 }, () => {
 dispatchSKEvent('defaultSettingsLoaded', {normal, api});
 });
 const links = document.querySelectorAll(""a"");
 expect(links.length).toBe(2);
 expect(links[0].href).toBe(""https://github.com/"");
 });",,"FALSE","FALSE","FALSE","FALSE",,,
93,"snutsjs","brookhong/surfingkeys","/tests/content_scripts/markdown.test.js","SubOptimalAssert","{""startLine"":111,""endLine"":111}","start: 92 end: 118","In this test file, the following lines contain a bad design pattern (also known as a test smell):

Lines {""startLine"":111,""endLine"":111}  – SubOptimalAssert
Occurs when the assertions used in tests are not ideal for verifying the specific condition being tested. Using more specific and expressive assertions can improve test clarity and make results more useful
To improve test quality and maintainability, can you refactor the method to eliminate ConditionalTestLogic while ensuring the test remains clear and effective?","test(""follow links generated from markdown"", async () => {
 jest.spyOn(clipboard, 'read').mockImplementationOnce((onReady) => {
 onReady({data: ""* [github](https://github.com)\n* [google](https://google.com)""});
 });
 await waitForEvent(document, ""surfingkeys:defaultSettingsLoaded"", () => {
 return true;
 }, () => {
 dispatchSKEvent('defaultSettingsLoaded', {normal, api});
 });

 const links = document.querySelectorAll(""a"");
 links.forEach((l, i) => {
 l.getBoundingClientRect = jest.fn(() => {
 return { width: 100, height: 10, top: 100 * i, left: 0, bottom: 0, right: 0 };
 });
 });
 document.elementFromPoint = jest.fn(() => {
 return null;
 });
 expect(document.querySelector(""div.surfingkeys_hints_host"")).toBe(null);

 document.body.dispatchEvent(new KeyboardEvent('keydown', {'key': 'f'}));
 const hint_labels = document.querySelector(""div.surfingkeys_hints_host"").shadowRoot.querySelectorAll(""section>div"");
 expect(hint_labels.length).toBe(2);
 expect(hint_labels[0].label).toBe(""A"");
 expect(hint_labels[1].label).toBe(""S"");
 });",,"FALSE","FALSE","FALSE","FALSE",,,
94,"snutsjs","brookhong/surfingkeys","/tests/content_scripts/markdown.test.js","SubOptimalAssert","{""startLine"":115,""endLine"":115}","start: 92 end: 118","In this test file, the following lines contain a bad design pattern (also known as a test smell):

Lines {""startLine"":115,""endLine"":115}  – SubOptimalAssert
Occurs when the assertions used in tests are not ideal for verifying the specific condition being tested. Using more specific and expressive assertions can improve test clarity and make results more useful
To improve test quality and maintainability, can you refactor the method to eliminate ConditionalTestLogic while ensuring the test remains clear and effective?","test(""follow links generated from markdown"", async () => {
 jest.spyOn(clipboard, 'read').mockImplementationOnce((onReady) => {
 onReady({data: ""* [github](https://github.com)\n* [google](https://google.com)""});
 });
 await waitForEvent(document, ""surfingkeys:defaultSettingsLoaded"", () => {
 return true;
 }, () => {
 dispatchSKEvent('defaultSettingsLoaded', {normal, api});
 });

 const links = document.querySelectorAll(""a"");
 links.forEach((l, i) => {
 l.getBoundingClientRect = jest.fn(() => {
 return { width: 100, height: 10, top: 100 * i, left: 0, bottom: 0, right: 0 };
 });
 });
 document.elementFromPoint = jest.fn(() => {
 return null;
 });
 expect(document.querySelector(""div.surfingkeys_hints_host"")).toBe(null);

 document.body.dispatchEvent(new KeyboardEvent('keydown', {'key': 'f'}));
 const hint_labels = document.querySelector(""div.surfingkeys_hints_host"").shadowRoot.querySelectorAll(""section>div"");
 expect(hint_labels.length).toBe(2);
 expect(hint_labels[0].label).toBe(""A"");
 expect(hint_labels[1].label).toBe(""S"");
 });",,"FALSE","FALSE","FALSE","FALSE",,,
95,"snutsjs","brookhong/surfingkeys","/tests/content_scripts/common/normal.test.js","ConditionalTestLogic","{""startLine"":29,""endLine"":31}","start: 25 end: 35","In this test file, the following lines contain a bad design pattern (also known as a test smell):

Lines {""startLine"":29,""endLine"":31}  – ConditionalTestLogic
Occurs due to the presence of test methods that contain conditional statements, such as the use of if-else or loops like for or while. Test methods that include conditional statements can compromise the effectiveness of tests
To improve test quality and maintainability, can you refactor the method to eliminate ConditionalTestLogic while ensuring the test remains clear and effective?","test(""normal /"", async () => {
 normal.enter();
 await new Promise((r) => {
 document.addEventListener(""surfingkeys:front"", function(evt) {
 if (evt.detail.length && evt.detail[0] === ""openFinder"") {
 r(evt);
 }
 });
 document.body.dispatchEvent(new KeyboardEvent('keydown',{'key':'/'}));
 });
 });",,"FALSE","FALSE","FALSE","FALSE",,,
96,"snutsjs","brookhong/surfingkeys","/tests/content_scripts/common/normal.test.js","ConditionalTestLogic","{""startLine"":66,""endLine"":68}","start: 62 end: 77","In this test file, the following lines contain a bad design pattern (also known as a test smell):

Lines {""startLine"":66,""endLine"":68}  – ConditionalTestLogic
Occurs due to the presence of test methods that contain conditional statements, such as the use of if-else or loops like for or while. Test methods that include conditional statements can compromise the effectiveness of tests
To improve test quality and maintainability, can you refactor the method to eliminate ConditionalTestLogic while ensuring the test remains clear and effective?","test(""normal mouse up"", async () => {
 runtime.conf.mouseSelectToQuery = [ ""http://localhost"" ];
 await new Promise((r) => {
 document.addEventListener(""surfingkeys:front"", function(evt) {
 if (evt.detail.length && evt.detail[0] === ""querySelectedWord"") {
 r(evt);
 }
 });
 document.body.dispatchEvent(new MouseEvent('mouseup', {
 bubbles: true,
 cancelable: true,
 view: window,
 button: 0
 }));
 });
 });",,"FALSE","FALSE","FALSE","FALSE",,,
97,"steel","brookhong/surfingkeys","/tests/content_scripts/markdown.test.js","Duplicate Assert","{'line': 66, 'column': 8, 'index': 2706}","start: 62 end: 76","In this test file, the following lines contain a bad design pattern (also known as a test smell):

Lines {'line': 66, 'column': 8, 'index': 2706}  – Duplicate Assert
This issue occurs when a test method verifies the same condition more than once within its scope, making the test harder to read and maintain. Identical assertions within the same method do not explicitly convey the purpose of the test method.
To improve test quality and maintainability, can you refactor the method to eliminate ConditionalTestLogic while ensuring the test remains clear and effective?","test(""verify local shortcuts for markdown preview"", async () => {
 document.execCommand = jest.fn();

 expect(normal.mappings.find('of')).toBe(undefined);
 expect(document.execCommand).toHaveBeenCalledTimes(0);

 await waitForEvent(document, ""surfingkeys:defaultSettingsLoaded"", () => {
 return true;
 }, () => {
 dispatchSKEvent('defaultSettingsLoaded', {normal, api});
 });

 expect(normal.mappings.find('of').meta.word).toBe('of');
 expect(document.execCommand).toHaveBeenCalledTimes(1);
 });",,"FALSE","FALSE","FALSE","FALSE",,,
98,"steel","brookhong/surfingkeys","/tests/content_scripts/markdown.test.js","Duplicate Assert","{'line': 75, 'column': 8, 'index': 3043}","start: 62 end: 76","In this test file, the following lines contain a bad design pattern (also known as a test smell):

Lines {'line': 75, 'column': 8, 'index': 3043}  – Duplicate Assert
This issue occurs when a test method verifies the same condition more than once within its scope, making the test harder to read and maintain. Identical assertions within the same method do not explicitly convey the purpose of the test method.
To improve test quality and maintainability, can you refactor the method to eliminate ConditionalTestLogic while ensuring the test remains clear and effective?","test(""verify local shortcuts for markdown preview"", async () => {
 document.execCommand = jest.fn();

 expect(normal.mappings.find('of')).toBe(undefined);
 expect(document.execCommand).toHaveBeenCalledTimes(0);

 await waitForEvent(document, ""surfingkeys:defaultSettingsLoaded"", () => {
 return true;
 }, () => {
 dispatchSKEvent('defaultSettingsLoaded', {normal, api});
 });

 expect(normal.mappings.find('of').meta.word).toBe('of');
 expect(document.execCommand).toHaveBeenCalledTimes(1);
 });",,"FALSE","FALSE","FALSE","FALSE",,,
99,"steel","brookhong/surfingkeys","/tests/content_scripts/markdown.test.js","Magic Number","{'line': 88, 'column': 34, 'index': 3642}","start: 78 end: 90","In this test file, the following lines contain a bad design pattern (also known as a test smell):

Lines {'line': 88, 'column': 34, 'index': 3642}  – Magic Number
Occurs when numeric literals are used directly in tests without explanation or documentation. These numbers lack clear context, making the code less readable and harder to maintain, as it is not obvious why such values are used.
To improve test quality and maintainability, can you refactor the method to eliminate ConditionalTestLogic while ensuring the test remains clear and effective?","test(""render markdown from clipboard"", async () => {
 jest.spyOn(clipboard, 'read').mockImplementationOnce((onReady) => {
 onReady({data: ""* [github](https://github.com)\n* [google](https://google.com)""});
 });
 await waitForEvent(document, ""surfingkeys:defaultSettingsLoaded"", () => {
 return true;
 }, () => {
 dispatchSKEvent('defaultSettingsLoaded', {normal, api});
 });
 const links = document.querySelectorAll(""a"");
 expect(links.length).toBe(2);
 expect(links[0].href).toBe(""https://github.com/"");
 });",,"FALSE","FALSE","FALSE","FALSE",,,
100,"steel","brookhong/surfingkeys","/tests/content_scripts/markdown.test.js","Magic Number","{'line': 115, 'column': 40, 'index': 4850}","start: 92 end: 118","In this test file, the following lines contain a bad design pattern (also known as a test smell):

Lines {'line': 115, 'column': 40, 'index': 4850}  – Magic Number
Occurs when numeric literals are used directly in tests without explanation or documentation. These numbers lack clear context, making the code less readable and harder to maintain, as it is not obvious why such values are used.
To improve test quality and maintainability, can you refactor the method to eliminate ConditionalTestLogic while ensuring the test remains clear and effective?","test(""follow links generated from markdown"", async () => {
 jest.spyOn(clipboard, 'read').mockImplementationOnce((onReady) => {
 onReady({data: ""* [github](https://github.com)\n* [google](https://google.com)""});
 });
 await waitForEvent(document, ""surfingkeys:defaultSettingsLoaded"", () => {
 return true;
 }, () => {
 dispatchSKEvent('defaultSettingsLoaded', {normal, api});
 });

 const links = document.querySelectorAll(""a"");
 links.forEach((l, i) => {
 l.getBoundingClientRect = jest.fn(() => {
 return { width: 100, height: 10, top: 100 * i, left: 0, bottom: 0, right: 0 };
 });
 });
 document.elementFromPoint = jest.fn(() => {
 return null;
 });
 expect(document.querySelector(""div.surfingkeys_hints_host"")).toBe(null);

 document.body.dispatchEvent(new KeyboardEvent('keydown', {'key': 'f'}));
 const hint_labels = document.querySelector(""div.surfingkeys_hints_host"").shadowRoot.querySelectorAll(""section>div"");
 expect(hint_labels.length).toBe(2);
 expect(hint_labels[0].label).toBe(""A"");
 expect(hint_labels[1].label).toBe(""S"");
 });",,"FALSE","FALSE","FALSE","FALSE",,,
101,"steel","brookhong/surfingkeys","/tests/content_scripts/ui/omnibar.test.js","Duplicate Assert","{'line': 80, 'column': 8, 'index': 3134}","start: 76 end: 86","In this test file, the following lines contain a bad design pattern (also known as a test smell):

Lines {'line': 80, 'column': 8, 'index': 3134}  – Duplicate Assert
This issue occurs when a test method verifies the same condition more than once within its scope, making the test harder to read and maintain. Identical assertions within the same method do not explicitly convey the purpose of the test method.
To improve test quality and maintainability, can you refactor the method to eliminate ConditionalTestLogic while ensuring the test remains clear and effective?","test(""toggle Omnibar's position"", async () => {
 const elmOmnibarClass = document.getElementById(""sk_omnibar"").classList;
 window.postMessage({surfingkeys_frontend_data: { action: ""openOmnibar"", type: ""URLs"", extra: ""getAllSites"" }}, document.location.origin);
 await new Promise((r) => setTimeout(r, 100));
 expect(elmOmnibarClass.value).toContain('sk_omnibar_middle');
 Mode.handleMapKey.call(omnibar, {
 sk_keyName: KeyboardUtils.encodeKeystroke(""<Ctrl-j>"")
 });
 await new Promise((r) => setTimeout(r, 100));
 expect(elmOmnibarClass.value).toContain('sk_omnibar_bottom');
 });",,"FALSE","FALSE","FALSE","FALSE",,,
102,"steel","brookhong/surfingkeys","/tests/content_scripts/ui/omnibar.test.js","Duplicate Assert","{'line': 85, 'column': 8, 'index': 3378}","start: 76 end: 86","In this test file, the following lines contain a bad design pattern (also known as a test smell):

Lines {'line': 85, 'column': 8, 'index': 3378}  – Duplicate Assert
This issue occurs when a test method verifies the same condition more than once within its scope, making the test harder to read and maintain. Identical assertions within the same method do not explicitly convey the purpose of the test method.
To improve test quality and maintainability, can you refactor the method to eliminate ConditionalTestLogic while ensuring the test remains clear and effective?","test(""toggle Omnibar's position"", async () => {
 const elmOmnibarClass = document.getElementById(""sk_omnibar"").classList;
 window.postMessage({surfingkeys_frontend_data: { action: ""openOmnibar"", type: ""URLs"", extra: ""getAllSites"" }}, document.location.origin);
 await new Promise((r) => setTimeout(r, 100));
 expect(elmOmnibarClass.value).toContain('sk_omnibar_middle');
 Mode.handleMapKey.call(omnibar, {
 sk_keyName: KeyboardUtils.encodeKeystroke(""<Ctrl-j>"")
 });
 await new Promise((r) => setTimeout(r, 100));
 expect(elmOmnibarClass.value).toContain('sk_omnibar_bottom');
 });",,"FALSE","FALSE","FALSE","FALSE",,,
103,"steel","brookhong/surfingkeys","/tests/content_scripts/ui/frontend.test.js","Duplicate Assert","{'line': 40, 'column': 8, 'index': 1331}","start: 38 end: 47","In this test file, the following lines contain a bad design pattern (also known as a test smell):

Lines {'line': 40, 'column': 8, 'index': 1331}  – Duplicate Assert
This issue occurs when a test method verifies the same condition more than once within its scope, making the test harder to read and maintain. Identical assertions within the same method do not explicitly convey the purpose of the test method.
To improve test quality and maintainability, can you refactor the method to eliminate ConditionalTestLogic while ensuring the test remains clear and effective?","test('show omnibar', async () => {
 const elmOmnibarStyle = document.getElementById(""sk_omnibar"").style;
 expect(elmOmnibarStyle).toHaveProperty('display', 'none');
 await waitForEvent(window, ""message"", (_msg) => {
 return _msg.surfingkeys_uihost_data && _msg.surfingkeys_uihost_data.action === ""setFrontFrame"";
 }, () => {
 window.postMessage({surfingkeys_frontend_data: { action: ""openOmnibar"", type: ""SearchEngine"", extra: ""b"" }}, document.location.origin);
 });
 expect(elmOmnibarStyle).not.toHaveProperty('display', 'none');
 });",,"FALSE","FALSE","FALSE","FALSE",,,
104,"steel","shipshapecode/tether","/test/unit/tether.spec.js","Duplicate Assert","{'line': 59, 'column': 6, 'index': 1898}","start: 46 end: 70","In this test file, the following lines contain a bad design pattern (also known as a test smell):

Lines {'line': 59, 'column': 6, 'index': 1898}  – Duplicate Assert
This issue occurs when a test method verifies the same condition more than once within its scope, making the test harder to read and maintain. Identical assertions within the same method do not explicitly convey the purpose of the test method.
To improve test quality and maintainability, can you refactor the method to eliminate ConditionalTestLogic while ensuring the test remains clear and effective?","it('gets default classes when no options set', () => {
 expect(element.classList.length, 'element - only one class').toEqual(1);
 expect(target.classList.length, 'target - only one class').toEqual(1);
 const tether = new Tether({
 element: '.element',
 target: '.target',
 attachment: 'top left',
 targetAttachment: 'top right'
 });

 tether.enable();

 expect(element.classList.length, 'element - tether classes added').toEqual(12);
 expect(element).toHaveClass('tether-element');
 expect(element).not.toHaveClass('tether-target');

 expect(target.classList.length, 'target - tether classes added').toEqual(12);
 expect(target).toHaveClass('tether-target');
 expect(target).not.toHaveClass('tether-element');

 tether.destroy();

 expect(element.classList.length, 'element - destroy sets classes back to initial state').toEqual(1);
 expect(target.classList.length, 'target - destroy sets classes back to initial state').toEqual(1);
 });",,"FALSE","FALSE","FALSE","FALSE",,,
105,"steel","shipshapecode/tether","/test/unit/tether.spec.js","Duplicate Assert","{'line': 60, 'column': 6, 'index': 1951}","start: 46 end: 70","In this test file, the following lines contain a bad design pattern (also known as a test smell):

Lines {'line': 60, 'column': 6, 'index': 1951}  – Duplicate Assert
This issue occurs when a test method verifies the same condition more than once within its scope, making the test harder to read and maintain. Identical assertions within the same method do not explicitly convey the purpose of the test method.
To improve test quality and maintainability, can you refactor the method to eliminate ConditionalTestLogic while ensuring the test remains clear and effective?","it('gets default classes when no options set', () => {
 expect(element.classList.length, 'element - only one class').toEqual(1);
 expect(target.classList.length, 'target - only one class').toEqual(1);
 const tether = new Tether({
 element: '.element',
 target: '.target',
 attachment: 'top left',
 targetAttachment: 'top right'
 });

 tether.enable();

 expect(element.classList.length, 'element - tether classes added').toEqual(12);
 expect(element).toHaveClass('tether-element');
 expect(element).not.toHaveClass('tether-target');

 expect(target.classList.length, 'target - tether classes added').toEqual(12);
 expect(target).toHaveClass('tether-target');
 expect(target).not.toHaveClass('tether-element');

 tether.destroy();

 expect(element.classList.length, 'element - destroy sets classes back to initial state').toEqual(1);
 expect(target.classList.length, 'target - destroy sets classes back to initial state').toEqual(1);
 });",,"FALSE","FALSE","FALSE","FALSE",,,
106,"steel","shipshapecode/tether","/test/unit/tether.spec.js","Duplicate Assert","{'line': 63, 'column': 6, 'index': 2092}","start: 46 end: 70","In this test file, the following lines contain a bad design pattern (also known as a test smell):

Lines {'line': 63, 'column': 6, 'index': 2092}  – Duplicate Assert
This issue occurs when a test method verifies the same condition more than once within its scope, making the test harder to read and maintain. Identical assertions within the same method do not explicitly convey the purpose of the test method.
To improve test quality and maintainability, can you refactor the method to eliminate ConditionalTestLogic while ensuring the test remains clear and effective?","it('gets default classes when no options set', () => {
 expect(element.classList.length, 'element - only one class').toEqual(1);
 expect(target.classList.length, 'target - only one class').toEqual(1);
 const tether = new Tether({
 element: '.element',
 target: '.target',
 attachment: 'top left',
 targetAttachment: 'top right'
 });

 tether.enable();

 expect(element.classList.length, 'element - tether classes added').toEqual(12);
 expect(element).toHaveClass('tether-element');
 expect(element).not.toHaveClass('tether-target');

 expect(target.classList.length, 'target - tether classes added').toEqual(12);
 expect(target).toHaveClass('tether-target');
 expect(target).not.toHaveClass('tether-element');

 tether.destroy();

 expect(element.classList.length, 'element - destroy sets classes back to initial state').toEqual(1);
 expect(target.classList.length, 'target - destroy sets classes back to initial state').toEqual(1);
 });",,"FALSE","FALSE","FALSE","FALSE",,,
107,"steel","shipshapecode/tether","/test/unit/tether.spec.js","Duplicate Assert","{'line': 64, 'column': 6, 'index': 2143}","start: 46 end: 70","In this test file, the following lines contain a bad design pattern (also known as a test smell):

Lines {'line': 64, 'column': 6, 'index': 2143}  – Duplicate Assert
This issue occurs when a test method verifies the same condition more than once within its scope, making the test harder to read and maintain. Identical assertions within the same method do not explicitly convey the purpose of the test method.
To improve test quality and maintainability, can you refactor the method to eliminate ConditionalTestLogic while ensuring the test remains clear and effective?","it('gets default classes when no options set', () => {
 expect(element.classList.length, 'element - only one class').toEqual(1);
 expect(target.classList.length, 'target - only one class').toEqual(1);
 const tether = new Tether({
 element: '.element',
 target: '.target',
 attachment: 'top left',
 targetAttachment: 'top right'
 });

 tether.enable();

 expect(element.classList.length, 'element - tether classes added').toEqual(12);
 expect(element).toHaveClass('tether-element');
 expect(element).not.toHaveClass('tether-target');

 expect(target.classList.length, 'target - tether classes added').toEqual(12);
 expect(target).toHaveClass('tether-target');
 expect(target).not.toHaveClass('tether-element');

 tether.destroy();

 expect(element.classList.length, 'element - destroy sets classes back to initial state').toEqual(1);
 expect(target.classList.length, 'target - destroy sets classes back to initial state').toEqual(1);
 });",,"FALSE","FALSE","FALSE","FALSE",,,
108,"steel","shipshapecode/tether","/test/unit/tether.spec.js","Duplicate Assert","{'line': 86, 'column': 6, 'index': 2969}","start: 72 end: 97","In this test file, the following lines contain a bad design pattern (also known as a test smell):

Lines {'line': 86, 'column': 6, 'index': 2969}  – Duplicate Assert
This issue occurs when a test method verifies the same condition more than once within its scope, making the test harder to read and maintain. Identical assertions within the same method do not explicitly convey the purpose of the test method.
To improve test quality and maintainability, can you refactor the method to eliminate ConditionalTestLogic while ensuring the test remains clear and effective?","it('gets prefixed classes when classPrefix set', () => {
 expect(element.classList.length, 'element - only one class').toEqual(1);
 expect(target.classList.length, 'target - only one class').toEqual(1);
 const tether = new Tether({
 element: '.element',
 target: '.target',
 attachment: 'top left',
 targetAttachment: 'top right',
 classPrefix: 'foo'
 });

 tether.enable();

 expect(element.classList.length, 'element - foo classes added').toEqual(12);
 expect(element).toHaveClass('foo-element');
 expect(element).not.toHaveClass('foo-target');

 expect(target.classList.length, 'target - foo classes added').toEqual(12);
 expect(target).toHaveClass('foo-target');
 expect(target).not.toHaveClass('foo-element');

 tether.destroy();

 expect(element.classList.length, 'element - destroy sets classes back to initial state').toEqual(1);
 expect(target.classList.length, 'target - destroy sets classes back to initial state').toEqual(1);
 });",,"FALSE","FALSE","FALSE","FALSE",,,
109,"steel","shipshapecode/tether","/test/unit/tether.spec.js","Magic Number","{'line': 24, 'column': 75, 'index': 664}","start: 23 end: 42","In this test file, the following lines contain a bad design pattern (also known as a test smell):

Lines {'line': 24, 'column': 75, 'index': 664}  – Magic Number
Occurs when numeric literals are used directly in tests without explanation or documentation. These numbers lack clear context, making the code less readable and harder to maintain, as it is not obvious why such values are used.
To improve test quality and maintainability, can you refactor the method to eliminate ConditionalTestLogic while ensuring the test remains clear and effective?","it('removes classes on destroy', () => {
 expect(element.classList.length, 'element - only one class').toEqual(1);
 expect(target.classList.length, 'target - only one class').toEqual(1);
 const tether = new Tether({
 element: '.element',
 target: '.target',
 attachment: 'top left',
 targetAttachment: 'top right'
 });

 tether.enable();

 expect(element.classList.length, 'element - tether classes added').toEqual(12);
 expect(target.classList.length, 'target - tether classes added').toEqual(12);

 tether.destroy();

 expect(element.classList.length, 'element - destroy sets classes back to initial state').toEqual(1);
 expect(target.classList.length, 'target - destroy sets classes back to initial state').toEqual(1);
 });",,"FALSE","FALSE","FALSE","FALSE",,,
110,"steel","shipshapecode/tether","/test/unit/tether.spec.js","Magic Number","{'line': 25, 'column': 73, 'index': 741}","start: 23 end: 42","In this test file, the following lines contain a bad design pattern (also known as a test smell):

Lines {'line': 25, 'column': 73, 'index': 741}  – Magic Number
Occurs when numeric literals are used directly in tests without explanation or documentation. These numbers lack clear context, making the code less readable and harder to maintain, as it is not obvious why such values are used.
To improve test quality and maintainability, can you refactor the method to eliminate ConditionalTestLogic while ensuring the test remains clear and effective?","it('removes classes on destroy', () => {
 expect(element.classList.length, 'element - only one class').toEqual(1);
 expect(target.classList.length, 'target - only one class').toEqual(1);
 const tether = new Tether({
 element: '.element',
 target: '.target',
 attachment: 'top left',
 targetAttachment: 'top right'
 });

 tether.enable();

 expect(element.classList.length, 'element - tether classes added').toEqual(12);
 expect(target.classList.length, 'target - tether classes added').toEqual(12);

 tether.destroy();

 expect(element.classList.length, 'element - destroy sets classes back to initial state').toEqual(1);
 expect(target.classList.length, 'target - destroy sets classes back to initial state').toEqual(1);
 });",,"FALSE","FALSE","FALSE","FALSE",,,
111,"steel","shipshapecode/tether","/test/unit/tether.spec.js","Magic Number","{'line': 35, 'column': 81, 'index': 1021}","start: 23 end: 42","In this test file, the following lines contain a bad design pattern (also known as a test smell):

Lines {'line': 35, 'column': 81, 'index': 1021}  – Magic Number
Occurs when numeric literals are used directly in tests without explanation or documentation. These numbers lack clear context, making the code less readable and harder to maintain, as it is not obvious why such values are used.
To improve test quality and maintainability, can you refactor the method to eliminate ConditionalTestLogic while ensuring the test remains clear and effective?","it('removes classes on destroy', () => {
 expect(element.classList.length, 'element - only one class').toEqual(1);
 expect(target.classList.length, 'target - only one class').toEqual(1);
 const tether = new Tether({
 element: '.element',
 target: '.target',
 attachment: 'top left',
 targetAttachment: 'top right'
 });

 tether.enable();

 expect(element.classList.length, 'element - tether classes added').toEqual(12);
 expect(target.classList.length, 'target - tether classes added').toEqual(12);

 tether.destroy();

 expect(element.classList.length, 'element - destroy sets classes back to initial state').toEqual(1);
 expect(target.classList.length, 'target - destroy sets classes back to initial state').toEqual(1);
 });",,"FALSE","FALSE","FALSE","FALSE",,,
112,"steel","shipshapecode/tether","/test/unit/tether.spec.js","Magic Number","{'line': 36, 'column': 79, 'index': 1105}","start: 23 end: 42","In this test file, the following lines contain a bad design pattern (also known as a test smell):

Lines {'line': 36, 'column': 79, 'index': 1105}  – Magic Number
Occurs when numeric literals are used directly in tests without explanation or documentation. These numbers lack clear context, making the code less readable and harder to maintain, as it is not obvious why such values are used.
To improve test quality and maintainability, can you refactor the method to eliminate ConditionalTestLogic while ensuring the test remains clear and effective?","it('removes classes on destroy', () => {
 expect(element.classList.length, 'element - only one class').toEqual(1);
 expect(target.classList.length, 'target - only one class').toEqual(1);
 const tether = new Tether({
 element: '.element',
 target: '.target',
 attachment: 'top left',
 targetAttachment: 'top right'
 });

 tether.enable();

 expect(element.classList.length, 'element - tether classes added').toEqual(12);
 expect(target.classList.length, 'target - tether classes added').toEqual(12);

 tether.destroy();

 expect(element.classList.length, 'element - destroy sets classes back to initial state').toEqual(1);
 expect(target.classList.length, 'target - destroy sets classes back to initial state').toEqual(1);
 });",,"FALSE","FALSE","FALSE","FALSE",,,
113,"steel","shipshapecode/tether","/test/unit/tether.spec.js","Magic Number","{'line': 40, 'column': 103, 'index': 1239}","start: 23 end: 42","In this test file, the following lines contain a bad design pattern (also known as a test smell):

Lines {'line': 40, 'column': 103, 'index': 1239}  – Magic Number
Occurs when numeric literals are used directly in tests without explanation or documentation. These numbers lack clear context, making the code less readable and harder to maintain, as it is not obvious why such values are used.
To improve test quality and maintainability, can you refactor the method to eliminate ConditionalTestLogic while ensuring the test remains clear and effective?","it('removes classes on destroy', () => {
 expect(element.classList.length, 'element - only one class').toEqual(1);
 expect(target.classList.length, 'target - only one class').toEqual(1);
 const tether = new Tether({
 element: '.element',
 target: '.target',
 attachment: 'top left',
 targetAttachment: 'top right'
 });

 tether.enable();

 expect(element.classList.length, 'element - tether classes added').toEqual(12);
 expect(target.classList.length, 'target - tether classes added').toEqual(12);

 tether.destroy();

 expect(element.classList.length, 'element - destroy sets classes back to initial state').toEqual(1);
 expect(target.classList.length, 'target - destroy sets classes back to initial state').toEqual(1);
 });",,"FALSE","FALSE","FALSE","FALSE",,,
114,"steel","shipshapecode/tether","/test/unit/utils/offset.spec.js","Lazy Test","{'line': 14, 'column': 13, 'index': 502}","start: 13 end: 15","In this test file, the following lines contain a bad design pattern (also known as a test smell):

Lines {'line': 14, 'column': 13, 'index': 502}  – Lazy Test
Lazy Test occurs when a single test is written superficially and verifies multiple functionalities of a class without going into detail about each one.
To improve test quality and maintainability, can you refactor the method to eliminate ConditionalTestLogic while ensuring the test remains clear and effective?","it('top left', () => {
 expect(attachmentToOffset({ left: 'left', top: 'top' })).toStrictEqual({ left: 0, top: 0 });
 });",,"FALSE","FALSE","FALSE","FALSE",,,
115,"steel","shipshapecode/tether","/test/unit/utils/offset.spec.js","Lazy Test","{'line': 18, 'column': 13, 'index': 642}","start: 17 end: 19","In this test file, the following lines contain a bad design pattern (also known as a test smell):

Lines {'line': 18, 'column': 13, 'index': 642}  – Lazy Test
Lazy Test occurs when a single test is written superficially and verifies multiple functionalities of a class without going into detail about each one.
To improve test quality and maintainability, can you refactor the method to eliminate ConditionalTestLogic while ensuring the test remains clear and effective?","it('middle center', () => {
 expect(attachmentToOffset({ left: 'center', top: 'middle' })).toStrictEqual({ left: '50%', top: '50%' });
 });",,"FALSE","FALSE","FALSE","FALSE",,,
116,"steel","shipshapecode/tether","/test/unit/utils/offset.spec.js","Lazy Test","{'line': 22, 'column': 13, 'index': 794}","start: 21 end: 23","In this test file, the following lines contain a bad design pattern (also known as a test smell):

Lines {'line': 22, 'column': 13, 'index': 794}  – Lazy Test
Lazy Test occurs when a single test is written superficially and verifies multiple functionalities of a class without going into detail about each one.
To improve test quality and maintainability, can you refactor the method to eliminate ConditionalTestLogic while ensuring the test remains clear and effective?","it('bottom right', () => {
 expect(attachmentToOffset({ left: 'right', top: 'bottom' })).toStrictEqual({ left: '100%', top: '100%' });
 });",,"FALSE","FALSE","FALSE","FALSE",,,
117,"steel","shipshapecode/tether","/test/unit/utils/offset.spec.js","Lazy Test","{'line': 28, 'column': 13, 'index': 996}","start: 27 end: 32","In this test file, the following lines contain a bad design pattern (also known as a test smell):

Lines {'line': 28, 'column': 13, 'index': 996}  – Lazy Test
Lazy Test occurs when a single test is written superficially and verifies multiple functionalities of a class without going into detail about each one.
To improve test quality and maintainability, can you refactor the method to eliminate ConditionalTestLogic while ensuring the test remains clear and effective?","it('mirror left', () => {
 expect(autoToFixedAttachment(
 { left: 'auto', top: 'top' },
 { left: 'left', top: 'top' }
 )).toStrictEqual({ left: 'right', top: 'top' });
 });",,"FALSE","FALSE","FALSE","FALSE",,,
118,"steel","shipshapecode/tether","/test/unit/utils/offset.spec.js","Lazy Test","{'line': 35, 'column': 13, 'index': 1203}","start: 34 end: 39","In this test file, the following lines contain a bad design pattern (also known as a test smell):

Lines {'line': 35, 'column': 13, 'index': 1203}  – Lazy Test
Lazy Test occurs when a single test is written superficially and verifies multiple functionalities of a class without going into detail about each one.
To improve test quality and maintainability, can you refactor the method to eliminate ConditionalTestLogic while ensuring the test remains clear and effective?","it('mirror center', () => {
 expect(autoToFixedAttachment(
 { left: 'auto', top: 'top' },
 { left: 'center', top: 'top' }
 )).toStrictEqual({ left: 'center', top: 'top' });
 });",,"FALSE","FALSE","FALSE","FALSE",,,
119,"snutsjs","katex/katex","/test/unicode-spec.js","ConditionalTestLogic","{""startLine"":157,""endLine"":160}","start: 151 end: 166","In this test file, the following lines contain a bad design pattern (also known as a test smell):

Lines {""startLine"":157,""endLine"":160}  – ConditionalTestLogic
Occurs due to the presence of test methods that contain conditional statements, such as the use of if-else or loops like for or while. Test methods that include conditional statements can compromise the effectiveness of tests
To improve test quality and maintainability, can you refactor the method to eliminate ConditionalTestLogic while ensuring the test remains clear and effective?","it(""scriptFromCodepoint() should return correct values"", () => {
 outer: for (let codepoint = 0; codepoint <= 0xffff; codepoint++) {
 const character = String.fromCharCode(codepoint);
 const script = scriptFromCodepoint(codepoint);

 for (const scriptName of scriptNames) {
 if (scriptRegExps[scriptName].test(character)) {
 expect(script).toEqual(scriptName);
 continue outer;
 }
 }

 expect(script).toBe(null);
 expect(supportedCodepoint(codepoint)).toBe(false);
 }
 });",,"FALSE","FALSE","FALSE","FALSE",,,
120,"snutsjs","katex/katex","/test/unicode-spec.js","SubOptimalAssert","{""startLine"":163,""endLine"":163}","start: 151 end: 166","In this test file, the following lines contain a bad design pattern (also known as a test smell):

Lines {""startLine"":163,""endLine"":163}  – SubOptimalAssert
Occurs when the assertions used in tests are not ideal for verifying the specific condition being tested. Using more specific and expressive assertions can improve test clarity and make results more useful
To improve test quality and maintainability, can you refactor the method to eliminate ConditionalTestLogic while ensuring the test remains clear and effective?","it(""scriptFromCodepoint() should return correct values"", () => {
 outer: for (let codepoint = 0; codepoint <= 0xffff; codepoint++) {
 const character = String.fromCharCode(codepoint);
 const script = scriptFromCodepoint(codepoint);

 for (const scriptName of scriptNames) {
 if (scriptRegExps[scriptName].test(character)) {
 expect(script).toEqual(scriptName);
 continue outer;
 }
 }

 expect(script).toBe(null);
 expect(supportedCodepoint(codepoint)).toBe(false);
 }
 });",,"FALSE","FALSE","FALSE","FALSE",,,
121,"snutsjs","katex/katex","/test/katex-spec.js","OvercommentedTest","{""startLine"":4010,""endLine"":4045}","start: 4010 end: 4045","In this test file, the following lines contain a bad design pattern (also known as a test smell):

Lines {""startLine"":4010,""endLine"":4045}  – OvercommentedTest
A test method that has been excessively commented on
To improve test quality and maintainability, can you refactor the method to eliminate ConditionalTestLogic while ensuring the test remains clear and effective?","it(""should build some surrogate pairs"", function() {
 let wideCharStr = """";
 wideCharStr += String.fromCharCode(0xD835, 0xDC00); // bold A
 wideCharStr += String.fromCharCode(0xD835, 0xDC68); // bold italic A
 wideCharStr += String.fromCharCode(0xD835, 0xDD04); // Fraktur A
 wideCharStr += String.fromCharCode(0xD835, 0xDD6C); // bold Fraktur A
 wideCharStr += String.fromCharCode(0xD835, 0xDD38); // double-struck
 wideCharStr += String.fromCharCode(0xD835, 0xDC9C); // script A
 wideCharStr += String.fromCharCode(0xD835, 0xDDA0); // sans serif A
 wideCharStr += String.fromCharCode(0xD835, 0xDDD4); // bold sans A
 wideCharStr += String.fromCharCode(0xD835, 0xDE08); // italic sans A
 wideCharStr += String.fromCharCode(0xD835, 0xDE70); // monospace A
 wideCharStr += String.fromCharCode(0xD835, 0xDFCE); // bold zero
 wideCharStr += String.fromCharCode(0xD835, 0xDFE2); // sans serif zero
 wideCharStr += String.fromCharCode(0xD835, 0xDFEC); // bold sans zero
 wideCharStr += String.fromCharCode(0xD835, 0xDFF6); // monospace zero
 expect(wideCharStr).toBuild(strictSettings);

 let wideCharText = ""\text{"";
 wideCharText += String.fromCharCode(0xD835, 0xDC00); // bold A
 wideCharText += String.fromCharCode(0xD835, 0xDC68); // bold italic A
 wideCharText += String.fromCharCode(0xD835, 0xDD04); // Fraktur A
 wideCharStr += String.fromCharCode(0xD835, 0xDD6C); // bold Fraktur A
 wideCharText += String.fromCharCode(0xD835, 0xDD38); // double-struck
 wideCharText += String.fromCharCode(0xD835, 0xDC9C); // script A
 wideCharText += String.fromCharCode(0xD835, 0xDDA0); // sans serif A
 wideCharText += String.fromCharCode(0xD835, 0xDDD4); // bold sans A
 wideCharText += String.fromCharCode(0xD835, 0xDE08); // italic sans A
 wideCharText += String.fromCharCode(0xD835, 0xDE70); // monospace A
 wideCharText += String.fromCharCode(0xD835, 0xDFCE); // bold zero
 wideCharText += String.fromCharCode(0xD835, 0xDFE2); // sans serif zero
 wideCharText += String.fromCharCode(0xD835, 0xDFEC); // bold sans zero
 wideCharText += String.fromCharCode(0xD835, 0xDFF6); // monospace zero
 wideCharText += ""}"";
 expect(wideCharText).toBuild(strictSettings);
 });",,"FALSE","FALSE","FALSE","FALSE",,,
122,"snutsjs","katex/katex","/test/katex-spec.js","ConditionalTestLogic","{""startLine"":91,""endLine"":94}","start: 86 end: 102","In this test file, the following lines contain a bad design pattern (also known as a test smell):

Lines {""startLine"":91,""endLine"":94}  – ConditionalTestLogic
Occurs due to the presence of test methods that contain conditional statements, such as the use of if-else or loops like for or while. Test methods that include conditional statements can compromise the effectiveness of tests
To improve test quality and maintainability, can you refactor the method to eliminate ConditionalTestLogic while ensuring the test remains clear and effective?","it(""should build a list of rels"", function() {
 const parse = getParsed(expression);

 for (let i = 0; i < parse.length; i++) {
 let group = parse[i];
 if (group.type === ""htmlmathml"") {
 expect(group.html).toHaveLength(1);
 group = group.html[0];
 }
 if (group.type === ""mclass"") {
 expect(group.mclass).toEqual(""mrel"");
 } else {
 expect(group.type).toEqual(""atom"");
 expect(group.family).toEqual(""rel"");
 }
 }
 });",,"FALSE","FALSE","FALSE","FALSE",,,
123,"snutsjs","katex/katex","/test/katex-spec.js","ConditionalTestLogic","{""startLine"":95,""endLine"":100}","start: 86 end: 102","In this test file, the following lines contain a bad design pattern (also known as a test smell):

Lines {""startLine"":95,""endLine"":100}  – ConditionalTestLogic
Occurs due to the presence of test methods that contain conditional statements, such as the use of if-else or loops like for or while. Test methods that include conditional statements can compromise the effectiveness of tests
To improve test quality and maintainability, can you refactor the method to eliminate ConditionalTestLogic while ensuring the test remains clear and effective?","it(""should build a list of rels"", function() {
 const parse = getParsed(expression);

 for (let i = 0; i < parse.length; i++) {
 let group = parse[i];
 if (group.type === ""htmlmathml"") {
 expect(group.html).toHaveLength(1);
 group = group.html[0];
 }
 if (group.type === ""mclass"") {
 expect(group.mclass).toEqual(""mrel"");
 } else {
 expect(group.type).toEqual(""atom"");
 expect(group.family).toEqual(""rel"");
 }
 }
 });",,"FALSE","FALSE","FALSE","FALSE",,,
124,"snutsjs","katex/katex","/test/katex-spec.js","SubOptimalAssert","{""startLine"":1759,""endLine"":1761}","start: 1758 end: 1762","In this test file, the following lines contain a bad design pattern (also known as a test smell):

Lines {""startLine"":1759,""endLine"":1761}  – SubOptimalAssert
Occurs when the assertions used in tests are not ideal for verifying the specific condition being tested. Using more specific and expressive assertions can improve test clarity and make results more useful
To improve test quality and maintainability, can you refactor the method to eliminate ConditionalTestLogic while ensuring the test remains clear and effective?","it(""should parse comments before and between \\hline"", () => {
 expect(""\\begin{matrix}a&b\\\\ %hline\n"" +
 ""\\hline %hline\n"" +
 ""\\hline c&d\\end{matrix}"").toParse();
 });",,"FALSE","FALSE","FALSE","FALSE",,,
125,"snutsjs","katex/katex","/test/katex-spec.js","SubOptimalAssert","{""startLine"":1894,""endLine"":1895}","start: 1890 end: 1897","In this test file, the following lines contain a bad design pattern (also known as a test smell):

Lines {""startLine"":1894,""endLine"":1895}  – SubOptimalAssert
Occurs when the assertions used in tests are not ideal for verifying the specific condition being tested. Using more specific and expressive assertions can improve test clarity and make results more useful
To improve test quality and maintainability, can you refactor the method to eliminate ConditionalTestLogic while ensuring the test remains clear and effective?","it(""should render wide characters with mord and with the correct font"", function() {
 const markup = katex.renderToString(String.fromCharCode(0xD835, 0xDC00));
 expect(markup).toContain(""<span class=\""mord mathbf\"">A</span>"");

 expect(String.fromCharCode(0xD835, 0xDC00) +
 "" = "" + String.fromCharCode(0xD835, 0xDC1A))
 .toBuildLike`\mathbf A = \mathbf a`;
 });",,"FALSE","FALSE","FALSE","FALSE",,,
126,"snutsjs","katex/katex","/test/katex-spec.js","SubOptimalAssert","{""startLine"":3167,""endLine"":3167}","start: 3156 end: 3169","In this test file, the following lines contain a bad design pattern (also known as a test smell):

Lines {""startLine"":3167,""endLine"":3167}  – SubOptimalAssert
Occurs when the assertions used in tests are not ideal for verifying the specific condition being tested. Using more specific and expressive assertions can improve test clarity and make results more useful
To improve test quality and maintainability, can you refactor the method to eliminate ConditionalTestLogic while ensuring the test remains clear and effective?","it(""should contain affected position and length information"", function() {
 try {
 katex.renderToString(""1 + \\fraq{}{}"");

 // Render is expected to throw, so this should not be called.
 expect(true).toBe(false);
 } catch (error) {
 expect(error).toBeInstanceOf(ParseError);
 expect(error.message).toBe(""KaTeX parse error: Undefined control sequence: \\fraq at position 5: 1 + \\̲f̲r̲a̲q̲{}{}"");
 expect(error.rawMessage).toBe(""Undefined control sequence: \\fraq"");
 expect(error.position).toBe(4);
 expect(error.length).toBe(5);
 }
 });",,"FALSE","FALSE","FALSE","FALSE",,,
127,"snutsjs","katex/katex","/test/katex-spec.js","SubOptimalAssert","{""startLine"":3182,""endLine"":3182}","start: 3171 end: 3184","In this test file, the following lines contain a bad design pattern (also known as a test smell):

Lines {""startLine"":3182,""endLine"":3182}  – SubOptimalAssert
Occurs when the assertions used in tests are not ideal for verifying the specific condition being tested. Using more specific and expressive assertions can improve test clarity and make results more useful
To improve test quality and maintainability, can you refactor the method to eliminate ConditionalTestLogic while ensuring the test remains clear and effective?","it(""should contain position and length information at end of input"", function() {
 try {
 katex.renderToString(""\\frac{}"");

 // Render is expected to throw, so this should not be called.
 expect(true).toBe(false);
 } catch (error) {
 expect(error).toBeInstanceOf(ParseError);
 expect(error.message).toBe(""KaTeX parse error: Unexpected end of input in a macro argument, expected '}' at end of input: \\frac{}"");
 expect(error.rawMessage).toBe(""Unexpected end of input in a macro argument, expected '}'"");
 expect(error.position).toBe(7);
 expect(error.length).toBe(0);
 }
 });",,"FALSE","FALSE","FALSE","FALSE",,,
128,"snutsjs","katex/katex","/test/unicode-spec.js","ConditionalTestLogic","{""startLine"":157,""endLine"":160}","start: 151 end: 166","In this test file, the following lines contain a bad design pattern (also known as a test smell):

Lines {""startLine"":157,""endLine"":160}  – ConditionalTestLogic
Occurs due to the presence of test methods that contain conditional statements, such as the use of if-else or loops like for or while. Test methods that include conditional statements can compromise the effectiveness of tests
To improve test quality and maintainability, can you refactor the method to eliminate ConditionalTestLogic while ensuring the test remains clear and effective?","it(""scriptFromCodepoint() should return correct values"", () => {
 outer: for (let codepoint = 0; codepoint <= 0xffff; codepoint++) {
 const character = String.fromCharCode(codepoint);
 const script = scriptFromCodepoint(codepoint);

 for (const scriptName of scriptNames) {
 if (scriptRegExps[scriptName].test(character)) {
 expect(script).toEqual(scriptName);
 continue outer;
 }
 }

 expect(script).toBe(null);
 expect(supportedCodepoint(codepoint)).toBe(false);
 }
 });",,"FALSE","FALSE","FALSE","FALSE",,,
129,"snutsjs","katex/katex","/test/katex-spec.js","OvercommentedTest","{""startLine"":4010,""endLine"":4045}","start: 4010 end: 4045","In this test file, the following lines contain a bad design pattern (also known as a test smell):

Lines {""startLine"":4010,""endLine"":4045}  – OvercommentedTest
A test method that has been excessively commented on
To improve test quality and maintainability, can you refactor the method to eliminate ConditionalTestLogic while ensuring the test remains clear and effective?","it(""should build some surrogate pairs"", function() {
 let wideCharStr = """";
 wideCharStr += String.fromCharCode(0xD835, 0xDC00); // bold A
 wideCharStr += String.fromCharCode(0xD835, 0xDC68); // bold italic A
 wideCharStr += String.fromCharCode(0xD835, 0xDD04); // Fraktur A
 wideCharStr += String.fromCharCode(0xD835, 0xDD6C); // bold Fraktur A
 wideCharStr += String.fromCharCode(0xD835, 0xDD38); // double-struck
 wideCharStr += String.fromCharCode(0xD835, 0xDC9C); // script A
 wideCharStr += String.fromCharCode(0xD835, 0xDDA0); // sans serif A
 wideCharStr += String.fromCharCode(0xD835, 0xDDD4); // bold sans A
 wideCharStr += String.fromCharCode(0xD835, 0xDE08); // italic sans A
 wideCharStr += String.fromCharCode(0xD835, 0xDE70); // monospace A
 wideCharStr += String.fromCharCode(0xD835, 0xDFCE); // bold zero
 wideCharStr += String.fromCharCode(0xD835, 0xDFE2); // sans serif zero
 wideCharStr += String.fromCharCode(0xD835, 0xDFEC); // bold sans zero
 wideCharStr += String.fromCharCode(0xD835, 0xDFF6); // monospace zero
 expect(wideCharStr).toBuild(strictSettings);

 let wideCharText = ""\text{"";
 wideCharText += String.fromCharCode(0xD835, 0xDC00); // bold A
 wideCharText += String.fromCharCode(0xD835, 0xDC68); // bold italic A
 wideCharText += String.fromCharCode(0xD835, 0xDD04); // Fraktur A
 wideCharStr += String.fromCharCode(0xD835, 0xDD6C); // bold Fraktur A
 wideCharText += String.fromCharCode(0xD835, 0xDD38); // double-struck
 wideCharText += String.fromCharCode(0xD835, 0xDC9C); // script A
 wideCharText += String.fromCharCode(0xD835, 0xDDA0); // sans serif A
 wideCharText += String.fromCharCode(0xD835, 0xDDD4); // bold sans A
 wideCharText += String.fromCharCode(0xD835, 0xDE08); // italic sans A
 wideCharText += String.fromCharCode(0xD835, 0xDE70); // monospace A
 wideCharText += String.fromCharCode(0xD835, 0xDFCE); // bold zero
 wideCharText += String.fromCharCode(0xD835, 0xDFE2); // sans serif zero
 wideCharText += String.fromCharCode(0xD835, 0xDFEC); // bold sans zero
 wideCharText += String.fromCharCode(0xD835, 0xDFF6); // monospace zero
 wideCharText += ""}"";
 expect(wideCharText).toBuild(strictSettings);
 });",,"FALSE","FALSE","FALSE","FALSE",,,
130,"snutsjs","katex/katex","/test/katex-spec.js","ConditionalTestLogic","{""startLine"":91,""endLine"":94}","start: 86 end: 102","In this test file, the following lines contain a bad design pattern (also known as a test smell):

Lines {""startLine"":91,""endLine"":94}  – ConditionalTestLogic
Occurs due to the presence of test methods that contain conditional statements, such as the use of if-else or loops like for or while. Test methods that include conditional statements can compromise the effectiveness of tests
To improve test quality and maintainability, can you refactor the method to eliminate ConditionalTestLogic while ensuring the test remains clear and effective?","it(""should build a list of rels"", function() {
 const parse = getParsed(expression);

 for (let i = 0; i < parse.length; i++) {
 let group = parse[i];
 if (group.type === ""htmlmathml"") {
 expect(group.html).toHaveLength(1);
 group = group.html[0];
 }
 if (group.type === ""mclass"") {
 expect(group.mclass).toEqual(""mrel"");
 } else {
 expect(group.type).toEqual(""atom"");
 expect(group.family).toEqual(""rel"");
 }
 }
 });",,"FALSE","FALSE","FALSE","FALSE",,,
131,"steel","katex/katex","/test/unicode-spec.js","Duplicate Assert","{'line': 158, 'column': 20, 'index': 5760}","start: 151 end: 166","In this test file, the following lines contain a bad design pattern (also known as a test smell):

Lines {'line': 158, 'column': 20, 'index': 5760}  – Duplicate Assert
This issue occurs when a test method verifies the same condition more than once within its scope, making the test harder to read and maintain. Identical assertions within the same method do not explicitly convey the purpose of the test method.
To improve test quality and maintainability, can you refactor the method to eliminate ConditionalTestLogic while ensuring the test remains clear and effective?","it(""scriptFromCodepoint() should return correct values"", () => {
 outer: for (let codepoint = 0; codepoint <= 0xffff; codepoint++) {
 const character = String.fromCharCode(codepoint);
 const script = scriptFromCodepoint(codepoint);

 for (const scriptName of scriptNames) {
 if (scriptRegExps[scriptName].test(character)) {
 expect(script).toEqual(scriptName);
 continue outer;
 }
 }

 expect(script).toBe(null);
 expect(supportedCodepoint(codepoint)).toBe(false);
 }
 });",,"FALSE","FALSE","FALSE","FALSE",,,
132,"steel","katex/katex","/test/unicode-spec.js","Duplicate Assert","{'line': 163, 'column': 12, 'index': 5877}","start: 151 end: 166","In this test file, the following lines contain a bad design pattern (also known as a test smell):

Lines {'line': 163, 'column': 12, 'index': 5877}  – Duplicate Assert
This issue occurs when a test method verifies the same condition more than once within its scope, making the test harder to read and maintain. Identical assertions within the same method do not explicitly convey the purpose of the test method.
To improve test quality and maintainability, can you refactor the method to eliminate ConditionalTestLogic while ensuring the test remains clear and effective?","it(""scriptFromCodepoint() should return correct values"", () => {
 outer: for (let codepoint = 0; codepoint <= 0xffff; codepoint++) {
 const character = String.fromCharCode(codepoint);
 const script = scriptFromCodepoint(codepoint);

 for (const scriptName of scriptNames) {
 if (scriptRegExps[scriptName].test(character)) {
 expect(script).toEqual(scriptName);
 continue outer;
 }
 }

 expect(script).toBe(null);
 expect(supportedCodepoint(codepoint)).toBe(false);
 }
 });",,"FALSE","FALSE","FALSE","FALSE",,,
133,"steel","katex/katex","/test/unicode-spec.js","Lazy Test","{'line': 145, 'column': 19, 'index': 5223}","start: 143 end: 149","In this test file, the following lines contain a bad design pattern (also known as a test smell):

Lines {'line': 145, 'column': 19, 'index': 5223}  – Lazy Test
Lazy Test occurs when a single test is written superficially and verifies multiple functionalities of a class without going into detail about each one.
To improve test quality and maintainability, can you refactor the method to eliminate ConditionalTestLogic while ensuring the test remains clear and effective?","it(""supportedCodepoint() should return the correct values"", () => {
 for (let codepoint = 0; codepoint <= 0xffff; codepoint++) {
 expect(supportedCodepoint(codepoint)).toBe(
 allRegExp.test(String.fromCharCode(codepoint))
 );
 }
 });",,"FALSE","FALSE","FALSE","FALSE",,,
134,"steel","katex/katex","/test/unicode-spec.js","Lazy Test","{'line': 164, 'column': 19, 'index': 5923}","start: 151 end: 166","In this test file, the following lines contain a bad design pattern (also known as a test smell):

Lines {'line': 164, 'column': 19, 'index': 5923}  – Lazy Test
Lazy Test occurs when a single test is written superficially and verifies multiple functionalities of a class without going into detail about each one.
To improve test quality and maintainability, can you refactor the method to eliminate ConditionalTestLogic while ensuring the test remains clear and effective?","it(""scriptFromCodepoint() should return correct values"", () => {
 outer: for (let codepoint = 0; codepoint <= 0xffff; codepoint++) {
 const character = String.fromCharCode(codepoint);
 const script = scriptFromCodepoint(codepoint);

 for (const scriptName of scriptNames) {
 if (scriptRegExps[scriptName].test(character)) {
 expect(script).toEqual(scriptName);
 continue outer;
 }
 }

 expect(script).toBe(null);
 expect(supportedCodepoint(codepoint)).toBe(false);
 }
 });",,"FALSE","FALSE","FALSE","FALSE",,,
135,"steel","katex/katex","/test/katex-spec.js","Duplicate Assert","{'line': 574, 'column': 8, 'index': 17088}","start: 569 end: 599","In this test file, the following lines contain a bad design pattern (also known as a test smell):

Lines {'line': 574, 'column': 8, 'index': 17088}  – Duplicate Assert
This issue occurs when a test method verifies the same condition more than once within its scope, making the test harder to read and maintain. Identical assertions within the same method do not explicitly convey the purpose of the test method.
To improve test quality and maintainability, can you refactor the method to eliminate ConditionalTestLogic while ensuring the test remains clear and effective?","it(""should produce a frac"", function() {
 let parse;

 parse = getParsed(simpleOver)[0];

 expect(parse.type).toEqual(""genfrac"");
 expect(parse.numer).toBeDefined();
 expect(parse.denom).toBeDefined();

 parse = getParsed(complexOver)[0];

 expect(parse.type).toEqual(""genfrac"");
 expect(parse.numer).toBeDefined();
 expect(parse.denom).toBeDefined();

 const parseBraceFrac = getParsed(braceFrac)[0];

 expect(parseBraceFrac.type).toEqual(""genfrac"");
 expect(parseBraceFrac.numer).toBeDefined();
 expect(parseBraceFrac.denom).toBeDefined();
 expect(parseBraceFrac.leftDelim).toBeDefined();
 expect(parseBraceFrac.rightDelim).toBeDefined();

 const parseBrackFrac = getParsed(brackFrac)[0];

 expect(parseBrackFrac.type).toEqual(""genfrac"");
 expect(parseBrackFrac.numer).toBeDefined();
 expect(parseBrackFrac.denom).toBeDefined();
 expect(parseBrackFrac.leftDelim).toBeDefined();
 expect(parseBrackFrac.rightDelim).toBeDefined();
 });",,"FALSE","FALSE","FALSE","FALSE",,,
136,"steel","katex/katex","/test/katex-spec.js","Duplicate Assert","{'line': 574, 'column': 8, 'index': 17088}","start: 569 end: 599","In this test file, the following lines contain a bad design pattern (also known as a test smell):

Lines {'line': 574, 'column': 8, 'index': 17088}  – Duplicate Assert
This issue occurs when a test method verifies the same condition more than once within its scope, making the test harder to read and maintain. Identical assertions within the same method do not explicitly convey the purpose of the test method.
To improve test quality and maintainability, can you refactor the method to eliminate ConditionalTestLogic while ensuring the test remains clear and effective?","it(""should produce a frac"", function() {
 let parse;

 parse = getParsed(simpleOver)[0];

 expect(parse.type).toEqual(""genfrac"");
 expect(parse.numer).toBeDefined();
 expect(parse.denom).toBeDefined();

 parse = getParsed(complexOver)[0];

 expect(parse.type).toEqual(""genfrac"");
 expect(parse.numer).toBeDefined();
 expect(parse.denom).toBeDefined();

 const parseBraceFrac = getParsed(braceFrac)[0];

 expect(parseBraceFrac.type).toEqual(""genfrac"");
 expect(parseBraceFrac.numer).toBeDefined();
 expect(parseBraceFrac.denom).toBeDefined();
 expect(parseBraceFrac.leftDelim).toBeDefined();
 expect(parseBraceFrac.rightDelim).toBeDefined();

 const parseBrackFrac = getParsed(brackFrac)[0];

 expect(parseBrackFrac.type).toEqual(""genfrac"");
 expect(parseBrackFrac.numer).toBeDefined();
 expect(parseBrackFrac.denom).toBeDefined();
 expect(parseBrackFrac.leftDelim).toBeDefined();
 expect(parseBrackFrac.rightDelim).toBeDefined();
 });",,"FALSE","FALSE","FALSE","FALSE",,,
137,"steel","katex/katex","/test/katex-spec.js","Duplicate Assert","{'line': 575, 'column': 8, 'index': 17135}","start: 569 end: 599","In this test file, the following lines contain a bad design pattern (also known as a test smell):

Lines {'line': 575, 'column': 8, 'index': 17135}  – Duplicate Assert
This issue occurs when a test method verifies the same condition more than once within its scope, making the test harder to read and maintain. Identical assertions within the same method do not explicitly convey the purpose of the test method.
To improve test quality and maintainability, can you refactor the method to eliminate ConditionalTestLogic while ensuring the test remains clear and effective?","it(""should produce a frac"", function() {
 let parse;

 parse = getParsed(simpleOver)[0];

 expect(parse.type).toEqual(""genfrac"");
 expect(parse.numer).toBeDefined();
 expect(parse.denom).toBeDefined();

 parse = getParsed(complexOver)[0];

 expect(parse.type).toEqual(""genfrac"");
 expect(parse.numer).toBeDefined();
 expect(parse.denom).toBeDefined();

 const parseBraceFrac = getParsed(braceFrac)[0];

 expect(parseBraceFrac.type).toEqual(""genfrac"");
 expect(parseBraceFrac.numer).toBeDefined();
 expect(parseBraceFrac.denom).toBeDefined();
 expect(parseBraceFrac.leftDelim).toBeDefined();
 expect(parseBraceFrac.rightDelim).toBeDefined();

 const parseBrackFrac = getParsed(brackFrac)[0];

 expect(parseBrackFrac.type).toEqual(""genfrac"");
 expect(parseBrackFrac.numer).toBeDefined();
 expect(parseBrackFrac.denom).toBeDefined();
 expect(parseBrackFrac.leftDelim).toBeDefined();
 expect(parseBrackFrac.rightDelim).toBeDefined();
 });",,"FALSE","FALSE","FALSE","FALSE",,,
138,"steel","katex/katex","/test/katex-spec.js","Lazy Test","{'line': 44, 'column': 22, 'index': 1225}","start: 43 end: 50","In this test file, the following lines contain a bad design pattern (also known as a test smell):

Lines {'line': 44, 'column': 22, 'index': 1225}  – Lazy Test
Lazy Test occurs when a single test is written superficially and verifies multiple functionalities of a class without going into detail about each one.
To improve test quality and maintainability, can you refactor the method to eliminate ConditionalTestLogic while ensuring the test remains clear and effective?","it(""should build a list of ords"", function() {
 const parse = getParsed(expression);

 for (let i = 0; i < parse.length; i++) {
 const group = parse[i];
 expect(group.type).toMatch(""ord"");
 }
 });",,"FALSE","FALSE","FALSE","FALSE",,,
139,"steel","katex/katex","/test/katex-spec.js","Lazy Test","{'line': 53, 'column': 22, 'index': 1483}","start: 52 end: 56","In this test file, the following lines contain a bad design pattern (also known as a test smell):

Lines {'line': 53, 'column': 22, 'index': 1483}  – Lazy Test
Lazy Test occurs when a single test is written superficially and verifies multiple functionalities of a class without going into detail about each one.
To improve test quality and maintainability, can you refactor the method to eliminate ConditionalTestLogic while ensuring the test remains clear and effective?","it(""should parse the right number of ords"", function() {
 const parse = getParsed(expression);

 expect(parse).toHaveLength(expression.length);
 });",,"FALSE","FALSE","FALSE","FALSE",,,
140,"steel","katex/katex","/test/katex-spec.js","Lazy Test","{'line': 67, 'column': 22, 'index': 1816}","start: 66 end: 74","In this test file, the following lines contain a bad design pattern (also known as a test smell):

Lines {'line': 67, 'column': 22, 'index': 1816}  – Lazy Test
Lazy Test occurs when a single test is written superficially and verifies multiple functionalities of a class without going into detail about each one.
To improve test quality and maintainability, can you refactor the method to eliminate ConditionalTestLogic while ensuring the test remains clear and effective?","it(""should build a list of bins"", function() {
 const parse = getParsed(expression);

 for (let i = 0; i < parse.length; i++) {
 const group = parse[i];
 expect(group.type).toEqual(""atom"");
 expect(group.family).toEqual(""bin"");
 }
 });",,"FALSE","FALSE","FALSE","FALSE",,,
141,"steel","katex/katex","/test/katex-spec.js","Magic Number","{'line': 92, 'column': 48, 'index': 2613}","start: 86 end: 102","In this test file, the following lines contain a bad design pattern (also known as a test smell):

Lines {'line': 92, 'column': 48, 'index': 2613}  – Magic Number
Occurs when numeric literals are used directly in tests without explanation or documentation. These numbers lack clear context, making the code less readable and harder to maintain, as it is not obvious why such values are used.
To improve test quality and maintainability, can you refactor the method to eliminate ConditionalTestLogic while ensuring the test remains clear and effective?","it(""should build a list of rels"", function() {
 const parse = getParsed(expression);

 for (let i = 0; i < parse.length; i++) {
 let group = parse[i];
 if (group.type === ""htmlmathml"") {
 expect(group.html).toHaveLength(1);
 group = group.html[0];
 }
 if (group.type === ""mclass"") {
 expect(group.mclass).toEqual(""mrel"");
 } else {
 expect(group.type).toEqual(""atom"");
 expect(group.family).toEqual(""rel"");
 }
 }
 });",,"FALSE","FALSE","FALSE","FALSE",,,
142,"steel","katex/katex","/test/katex-spec.js","Magic Number","{'line': 114, 'column': 44, 'index': 3404}","start: 111 end: 115","In this test file, the following lines contain a bad design pattern (also known as a test smell):

Lines {'line': 114, 'column': 44, 'index': 3404}  – Magic Number
Occurs when numeric literals are used directly in tests without explanation or documentation. These numbers lack clear context, making the code less readable and harder to maintain, as it is not obvious why such values are used.
To improve test quality and maintainability, can you refactor the method to eliminate ConditionalTestLogic while ensuring the test remains clear and effective?","it(""should return one group, not a fragment"", function() {
 const contents = ""\\mathinner{\\langle{\\psi}\\rangle}"";
 const mml = buildMathML(getParsed(contents), contents, defaultOptions);
 expect(mml.children.length).toEqual(1);
 });",,"FALSE","FALSE","FALSE","FALSE",,,
143,"steel","katex/katex","/test/katex-spec.js","Magic Number","{'line': 346, 'column': 35, 'index': 10074}","start: 343 end: 352","In this test file, the following lines contain a bad design pattern (also known as a test smell):

Lines {'line': 346, 'column': 35, 'index': 10074}  – Magic Number
Occurs when numeric literals are used directly in tests without explanation or documentation. These numbers lack clear context, making the code less readable and harder to maintain, as it is not obvious why such values are used.
To improve test quality and maintainability, can you refactor the method to eliminate ConditionalTestLogic while ensuring the test remains clear and effective?","it(""should produce a single ord"", function() {
 const parse = getParsed`{xy}`;

 expect(parse).toHaveLength(1);

 const ord = parse[0];

 expect(ord.type).toMatch(""ord"");
 expect(ord.body).toBeTruthy();
 });",,"FALSE","FALSE","FALSE","FALSE",,,
144,"steel","katex/katex","/test/katex-spec.js","Magic Number","{'line': 368, 'column': 35, 'index': 10676}","start: 365 end: 375","In this test file, the following lines contain a bad design pattern (also known as a test smell):

Lines {'line': 368, 'column': 35, 'index': 10676}  – Magic Number
Occurs when numeric literals are used directly in tests without explanation or documentation. These numbers lack clear context, making the code less readable and harder to maintain, as it is not obvious why such values are used.
To improve test quality and maintainability, can you refactor the method to eliminate ConditionalTestLogic while ensuring the test remains clear and effective?","it(""should produce a semi-simple group"", function() {
 const parse = getParsed`\begingroup xy \endgroup`;

 expect(parse).toHaveLength(1);

 const ord = parse[0];

 expect(ord.type).toMatch(""ord"");
 expect(ord.body).toBeTruthy();
 expect(ord.semisimple).toBeTruthy();
 });",,"FALSE","FALSE","FALSE","FALSE",,,
145,"steel","katex/katex","/test/katex-spec.js","Magic Number","{'line': 391, 'column': 35, 'index': 11303}","start: 388 end: 398","In this test file, the following lines contain a bad design pattern (also known as a test smell):

Lines {'line': 391, 'column': 35, 'index': 11303}  – Magic Number
Occurs when numeric literals are used directly in tests without explanation or documentation. These numbers lack clear context, making the code less readable and harder to maintain, as it is not obvious why such values are used.
To improve test quality and maintainability, can you refactor the method to eliminate ConditionalTestLogic while ensuring the test remains clear and effective?","it(""should produce a single object"", function() {
 const parse = getParsed`\Large abc`;

 expect(parse).toHaveLength(1);

 const sizing = parse[0];

 expect(sizing.type).toEqual(""sizing"");
 expect(sizing.body).toBeTruthy();
 expect(sizing.size).toBeDefined();
 });",,"FALSE","FALSE","FALSE","FALSE",,,
