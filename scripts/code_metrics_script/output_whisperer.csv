number,original_method,SLOC_Logical,Cyclomatic,CyclomaticDensity,Halstead_Effort,Halstead_Bugs,Maintainability,refactored_method,SLOC_Logical,Cyclomatic,CyclomaticDensity,Halstead_Effort,Halstead_Bugs,Maintainability
1,"test(""Resets internal status"", () => {\n img.setAttribute(""src"", url200);\n setSources(img, settings, instance);\n cancelLoading(img, entry, settings, instance);\n expect(getStatus(img)).toBe(null);\n });",6,1,16.666666666666664,152,0.007745047644751603,100,"  test(""Resets internal status"", () => {\n    img.setAttribute(""src"", url200);\n    setSources(img, settings, instance);\n    cancelLoading(img, entry, settings, instance);\n    // Using more specific assertion to check for null status\n    expect(getStatus(img)).toBeNull();\n  });",6,1,16.666666666666664,152,0.007745047644751603,100
2,"test(""Restores original attributes"", () => {\n img.setAttribute(""src"", url1);\n img.setAttribute(""data-src"", url100);\n img.setAttribute(""data-srcset"", url200);\n img.setAttribute(""data-sizes"", sizes100);\n setSources(img, settings, instance);\n cancelLoading(img, entry, settings, instance);\n expect(img).toHaveAttribute(""src"", url1);\n expect(img).not.toHaveAttribute(""srcset"");\n expect(img).not.toHaveAttribute(""sizes"");\n });",11,1,9.090909090909092,560.1990546335667,0.014719371051336319,100,"  test(""Restores original attributes"", () => {\n    // Setup\n    img.setAttribute(""src"", url1);\n    img.setAttribute(""data-src"", url100);\n    img.setAttribute(""data-srcset"", url200);\n    img.setAttribute(""data-sizes"", sizes100);\n    setSources(img, settings, instance);\n\n    // Act\n    cancelLoading(img, entry, settings, instance);\n\n    // Assert\n    const expectedAttributes = {\n      src: url1,\n      srcset: undefined,\n      sizes: undefined\n    };\n\n    expect(img).toHaveAttribute(""src"", expectedAttributes.src);\n    expect(img).not.toHaveAttribute(""srcset""); \n    expect(img).not.toHaveAttribute(""sizes"");\n  });",12,1,8.333333333333332,714.8585404672912,0.016337526696714903,100
3,"test(""Restores original attributes"", () => {\n img.setAttribute(""src"", url1);\n img.setAttribute(""data-src"", url100);\n img.setAttribute(""data-srcset"", url200);\n img.setAttribute(""data-sizes"", sizes100);\n setSources(img, settings, instance);\n cancelLoading(img, entry, settings, instance);\n expect(img).toHaveAttribute(""src"", url1);\n expect(img).not.toHaveAttribute(""srcset"");\n expect(img).not.toHaveAttribute(""sizes"");\n });",11,1,9.090909090909092,560.1990546335667,0.014719371051336319,100,"  test(""Restores original attributes"", () => {\n    // Setup\n    img.setAttribute(""src"", url1);\n    img.setAttribute(""data-src"", url100);\n    img.setAttribute(""data-srcset"", url200);\n    img.setAttribute(""data-sizes"", sizes100);\n    setSources(img, settings, instance);\n\n    // Act\n    cancelLoading(img, entry, settings, instance);\n\n    // Assert\n    const expectedAttributes = {\n      src: url1,\n      srcset: undefined,\n      sizes: undefined\n    };\n\n    expect(img).toHaveAttribute(""src"", expectedAttributes.src);\n    expect(img).not.toHaveAttribute(""srcset""); \n    expect(img).not.toHaveAttribute(""sizes"");\n  });",12,1,8.333333333333332,714.8585404672912,0.016337526696714903,100
4,"test(""Restores original attributes"", () => {\n img.setAttribute(""src"", url1);\n img.setAttribute(""data-src"", url100);\n img.setAttribute(""data-srcset"", url200);\n img.setAttribute(""data-sizes"", sizes100);\n setSources(img, settings, instance);\n cancelLoading(img, entry, settings, instance);\n expect(img).toHaveAttribute(""src"", url1);\n expect(img).not.toHaveAttribute(""srcset"");\n expect(img).not.toHaveAttribute(""sizes"");\n });",11,1,9.090909090909092,560.1990546335667,0.014719371051336319,100,"  test(""Restores original attributes"", () => {\n    // Setup\n    img.setAttribute(""src"", url1);\n    img.setAttribute(""data-src"", url100);\n    img.setAttribute(""data-srcset"", url200);\n    img.setAttribute(""data-sizes"", sizes100);\n    setSources(img, settings, instance);\n\n    // Act\n    cancelLoading(img, entry, settings, instance);\n\n    // Assert\n    const expectedAttributes = {\n      src: url1,\n      srcset: undefined,\n      sizes: undefined\n    };\n\n    expect(img).toHaveAttribute(""src"", expectedAttributes.src);\n    expect(img).not.toHaveAttribute(""srcset""); \n    expect(img).not.toHaveAttribute(""sizes"");\n  });",12,1,8.333333333333332,714.8585404672912,0.016337526696714903,100
5,"test(""Callbacks are called"", () => {\n const cancelCb = jest.fn();\n settings.callback_cancel = cancelCb;\n setSources(img, settings, instance);\n cancelLoading(img, entry, settings, instance);\n expect(cancelCb).toHaveBeenCalledTimes(1);\n expect(cancelCb).toHaveBeenCalledWith(img, entry, instance);\n });",8,1,12.5,430.102660736163,0.010225945435769426,100,"  test(""Callback is called once with correct parameters"", () => {\n    const cancelCb = jest.fn();\n    settings.callback_cancel = cancelCb;\n    setSources(img, settings, instance);\n    cancelLoading(img, entry, settings, instance);\n    expect(cancelCb).toHaveBeenCalledOnceWith(img, entry, instance);\n  });",7,1,14.285714285714285,332.3983174831079,0.008767126040623019,100
6,"test(""Callbacks are called"", () => {\n const cancelCb = jest.fn();\n settings.callback_cancel = cancelCb;\n setSources(img, settings, instance);\n cancelLoading(img, entry, settings, instance);\n expect(cancelCb).toHaveBeenCalledTimes(1);\n expect(cancelCb).toHaveBeenCalledWith(img, entry, instance);\n });",8,1,12.5,430.102660736163,0.010225945435769426,100,"  test(""Callback is called once with correct parameters"", () => {\n    const cancelCb = jest.fn();\n    settings.callback_cancel = cancelCb;\n    setSources(img, settings, instance);\n    cancelLoading(img, entry, settings, instance);\n    expect(cancelCb).toHaveBeenCalledOnceWith(img, entry, instance);\n  });",7,1,14.285714285714285,332.3983174831079,0.008767126040623019,100
7,"test(""Decreases loading count"", () => {\n img.setAttribute(""src"", url200);\n setSources(img, settings, instance);\n cancelLoading(img, entry, settings, instance);\n expect(instance.loadingCount).toBe(0);\n });",6,1,16.666666666666664,158.04856319501312,0.008043528820279,100,"  test(""Decreases loading count"", () => {\n    // Initial loading count is 1 after setting sources, should be reset to 0 after canceling\n    const EXPECTED_LOADING_COUNT = 0;\n    img.setAttribute(""src"", url200);\n    setSources(img, settings, instance);\n    cancelLoading(img, entry, settings, instance);\n    expect(instance.loadingCount).toBe(EXPECTED_LOADING_COUNT);\n  });",7,1,14.285714285714285,177.74305318647853,0.008521944546104623,100
8,"test('decreaseToLoadCount decreases toLoadCount by 1', () => {\n const mockInstance = { toLoadCount: 5 };\n decreaseToLoadCount(mockInstance);\n expect(mockInstance.toLoadCount).toBe(4);\n });",5,1,20,83.02635884729513,0.005236770992579965,100,"  // Initial count value used for testing counter decrease\n  const INITIAL_COUNT = 5;\n  // Expected count after decrease operation\n  const EXPECTED_COUNT = 4;\n  \n  test('decreaseToLoadCount decreases toLoadCount by 1', () => {\n    const mockInstance = { toLoadCount: INITIAL_COUNT };\n    decreaseToLoadCount(mockInstance);\n    expect(mockInstance.toLoadCount).toBe(EXPECTED_COUNT);\n  });",7,1,14.285714285714285,118.41407098051495,0.006261274657482988,100
9,"test('setToLoadCount sets toLoadCount to the given value', () => {\n const mockInstance = {};\n setToLoadCount(mockInstance, 10);\n expect(mockInstance.toLoadCount).toBe(10);\n });",5,1,20,77.6500692179921,0.004906496702463663,100,"  test('setToLoadCount sets toLoadCount to the given value', () => {\n    // Define a meaningful constant for the test value\n    const EXPECTED_LOAD_COUNT = 10;\n    const mockInstance = {};\n    setToLoadCount(mockInstance, EXPECTED_LOAD_COUNT);\n    expect(mockInstance.toLoadCount).toBe(EXPECTED_LOAD_COUNT);\n  });",6,1,16.666666666666664,94.94217886704583,0.0054289725556949725,100
10,"    describe(`when unhandledRejection received`, () => {\n      it('throws an error', async () => {\n        expect(() => {\n          process.on = jest.fn().mockImplementation((event, error) => {\n            if (event === 'unhandledRejection') {\n              error({\n                message: `something-unhandled`,\n                code: 2000\n              });\n            }\n          });\n\n          const { runErrorHandler } = require('../error-handler');\n          runErrorHandler(mockLogger);\n        }).toThrow(`something-unhandled`);\n      });\n    });",13,2,15.384615384615385,429.1524900675002,0.010579837777895349,100,"    describe(`when unhandledRejection received`, () => {\n      it('throws an error', async () => {\n        expect(() => {\n          process.on = jest.fn().mockImplementation((event, error) => {\n            // Remove conditional and directly call error handler for unhandledRejection\n            error({\n              message: `something-unhandled`, \n              code: 2000\n            });\n          });\n\n          const { runErrorHandler } = require('../error-handler');\n          runErrorHandler(mockLogger);\n        }).toThrow(`something-unhandled`);\n      });\n    });",11,1,9.090909090909092,278.83182962847945,0.0098461568913087,100
11,"it('does not throws an error', async () => {\n expect(() => {\n process.on = jest.fn().mockImplementation((event, error) => {\n if (event === 'uncaughtException') {\n error({\n message: `redlock:lock-XRPBUSD`,\n code: 500\n });\n }\n });\n\n const { runErrorHandler } = require('../error-handler');\n runErrorHandler(mockLogger);\n }).not.toThrow();\n });",11,2,18.181818181818183,429.1524900675002,0.010579837777895349,100,"      it('does not throws an error', async () => {\n        expect(() => {\n          process.on = jest.fn().mockImplementation((_event, error) => {\n            error({\n              message: `redlock:lock-XRPBUSD`, \n              code: 500\n            });\n          });\n\n          const { runErrorHandler } = require('../error-handler');\n          runErrorHandler(mockLogger);\n        }).not.toThrow();\n      });",9,1,11.11111111111111,278.83182962847945,0.0098461568913087,100
12,"it('keeps 10 logs in the folder', () => {\n const files = fs.readdirSync(fileFolder);\n expect(files.length).toBe(10);\n });",4,1,25,70.9822575142789,0.0053626998907691775,100,"      it('keeps 10 logs in the folder', () => {\n        const files = fs.readdirSync(fileFolder);\n        // Use more specific assertion to check exact array length\n        expect(files).toHaveLength(10);\n      });",4,1,25,61.50100655355195,0.004841298945196911,100
13,"it('triggers refreshCandles', () => {\n expect(mockMongo.deleteAll).toHaveBeenCalledWith(\n logger,\n 'trailing-trade-candles',\n {}\n );\n expect(mockMongo.deleteAll).toHaveBeenCalledWith(\n logger,\n 'trailing-trade-ath-candles',\n {}\n );\n });",4,1,25,123.7707756890233,0.006166429958809705,100,"      it('triggers refreshCandles by deleting all candle records', () => {\n        const expectedParams = [logger, {}, ];\n        expect(mockMongo.deleteAll).toHaveBeenNthCalledWith(1, 'trailing-trade-candles', ...expectedParams);\n        expect(mockMongo.deleteAll).toHaveBeenNthCalledWith(2, 'trailing-trade-ath-candles', ...expectedParams);\n      });",5,1,20,154.19787434333296,0.007314817532785559,100
14,"it('triggers refreshCandles', () => {\n expect(mockMongo.deleteAll).toHaveBeenCalledWith(\n logger,\n 'trailing-trade-candles',\n {}\n );\n expect(mockMongo.deleteAll).toHaveBeenCalledWith(\n logger,\n 'trailing-trade-ath-candles',\n {}\n );\n });",4,1,25,123.7707756890233,0.006166429958809705,100,"      it('triggers refreshCandles by clearing candles collections', () => {\n        const expectedParams = [logger, expect.any(String), {}];\n        const collections = ['trailing-trade-candles', 'trailing-trade-ath-candles'];\n\n        collections.forEach(collection => {\n          expect(mockMongo.deleteAll).toHaveBeenCalledWith(logger, collection, {});\n        });\n      });",7,1,14.285714285714285,144.96868210301201,0.007857540796220268,100
15,"it('triggers refreshCandles', () => {\n expect(mockMongo.deleteAll).toHaveBeenCalledWith(\n logger,\n 'trailing-trade-candles',\n {}\n );\n expect(mockMongo.deleteAll).toHaveBeenCalledWith(\n logger,\n 'trailing-trade-ath-candles',\n {}\n );\n });",4,1,25,123.7707756890233,0.006166429958809705,100,"    it('triggers refreshCandles by clearing candles collections', () => {\n      const expectedCalls = [\n        ['trailing-trade-candles', {}],\n        ['trailing-trade-ath-candles', {}]\n      ];\n\n      expectedCalls.forEach(([collection, query]) => {\n        expect(mockMongo.deleteAll).toHaveBeenCalledWith(\n          logger,\n          collection,\n          query\n        );\n      });\n    });",6,1,16.666666666666664,110.59505686030269,0.006687310203092252,100
16,"it('triggers refreshCandles', () => {\n expect(mockMongo.deleteAll).toHaveBeenCalledWith(\n logger,\n 'trailing-trade-candles',\n {}\n );\n expect(mockMongo.deleteAll).toHaveBeenCalledWith(\n logger,\n 'trailing-trade-ath-candles',\n {}\n );\n });",4,1,25,123.7707756890233,0.006166429958809705,100,"    it('triggers refreshCandles by deleting candles collections', () => {\n      const expectedCalls = [\n        ['trailing-trade-candles', {}],\n        ['trailing-trade-ath-candles', {}]\n      ];\n\n      expectedCalls.forEach(([collection, query]) => {\n        expect(mockMongo.deleteAll).toHaveBeenCalledWith(\n          logger,\n          collection,\n          query\n        );\n      });\n    });",6,1,16.666666666666664,110.59505686030269,0.006687310203092252,100
17,"it('triggers cache.hset', () => {\n expect(mockCache.hset).toHaveBeenCalledWith(\n 'trailing-trade-streams',\n `count`,\n 1\n );\n });",3,1,33.33333333333333,43.18506523353571,0.004102996362278855,100,"      it('triggers cache.hset', () => {\n        // Initial stream count is 1 for user websocket\n        const INITIAL_STREAM_COUNT = 1;\n\n        expect(mockCache.hset).toHaveBeenCalledWith(\n          'trailing-trade-streams',\n          `count`,\n          INITIAL_STREAM_COUNT\n        );\n      });",4,1,25,57.65719364395496,0.0046374163084266905,100
18,"it('triggers cache.hset', () => {\n expect(mockCache.hset).toHaveBeenCalledWith(\n 'trailing-trade-streams',\n `count`,\n 1\n );\n });",3,1,33.33333333333333,43.18506523353571,0.004102996362278855,100,"    it('triggers cache.hset', () => {\n      // Initial stream count is 1 for user websocket\n      const INITIAL_STREAM_COUNT = 1;\n      expect(mockCache.hset).toHaveBeenCalledWith(\n        'trailing-trade-streams',\n        `count`,\n        INITIAL_STREAM_COUNT\n      );\n    });",4,1,25,57.65719364395496,0.0046374163084266905,100
19,"it('triggers status', () => {\n expect(mockRateLimiterMiddlewareResStatus).toHaveBeenCalledWith(403);\n });",3,1,33.33333333333333,30,0.003218297948685432,100,"        // HTTP status code 403 represents Forbidden - used when access to a resource is denied\n        const HTTP_STATUS_FORBIDDEN = 403;\n        it('triggers status', () => {\n          expect(mockRateLimiterMiddlewareResStatus).toHaveBeenCalledWith(HTTP_STATUS_FORBIDDEN);\n        });\n",4,1,25,43.473257162637424,0.0037702102294917654,100
20,"it('triggers clearInterval', () => {\n expect(spyOnClearInterval).toHaveBeenCalledWith(33);\n });",3,1,33.33333333333333,30,0.003218297948685432,100,"      // The interval ID 33 represents the mocked return value from setInterval\n      // This value is used to verify that clearInterval is called with the correct ID\n      const mockIntervalId = 33;\n      it('triggers clearInterval', () => {\n        expect(spyOnClearInterval).toHaveBeenCalledWith(mockIntervalId);\n      });",4,1,25,43.473257162637424,0.0037702102294917654,100
21,"it('triggers updateAccountInfo', () => {\n expect(mockUpdateAccountInfo).toHaveBeenCalledWith(\n loggerMock,\n [{ asset: 'ADA', free: '0.00000000', locked: '13.82000000' }],\n 1625585531721\n );\n });",3,1,33.33333333333333,66.41714012534482,0.005466787500811506,100,"      // Define test constants for account balance data\n      it('triggers updateAccountInfo', () => {\n        const testBalances = [{ \n          asset: 'ADA', \n          free: '0.00000000', \n          locked: '13.82000000' \n        }];\n        const testTimestamp = 1625585531721;\n\n        expect(mockUpdateAccountInfo).toHaveBeenCalledWith(\n          loggerMock,\n          testBalances,\n          testTimestamp\n        );\n      });",5,1,20,97.28161562175808,0.006486257016085221,100
22,"it('triggers slack.sendMessage', () => {\n expect(slackMock.sendMessage).toHaveBeenCalledWith(\n expect.stringContaining('BTCUSDT'),\n {\n apiLimit: 0,\n symbol: 'BTCUSDT'\n }\n );\n\n expect(slackMock.sendMessage).toHaveBeenCalledWith(\n expect.stringContaining(\n 'The bot queued to trigger the grid trade for buying'\n ),\n {\n apiLimit: 0,\n symbol: 'BTCUSDT'\n }\n );\n });",4,1,25,281.7442642322627,0.009024617499561433,100,"      it('triggers slack.sendMessage with correct parameters', () => {\n        expect(slackMock.sendMessage).toHaveBeenCalledTimes(2);\n        expect(slackMock.sendMessage).toHaveBeenNthCalledWith(1,\n          expect.stringContaining('BTCUSDT'),\n          {\n            apiLimit: 0,\n            symbol: 'BTCUSDT'\n          }\n        );\n        expect(slackMock.sendMessage).toHaveBeenNthCalledWith(2,\n          expect.stringContaining('The bot queued to trigger the grid trade for buying'),\n          {\n            apiLimit: 0,\n            symbol: 'BTCUSDT'\n          }\n        );\n      });",5,1,20,405.4763138520337,0.011254912299311729,100
23,"it(""returns URL for patch releasing"", () => {\n const result = getReleaseUrl(""2.3.1"", ""2.3.0"");\n assert.equal(\n result,\n getExpectedReleaseUrl({\n tag: ""2.3.1"",\n title: ""2.3.1"",\n body: ""🔗 [Changelog](https://github.com/prettier/prettier/blob/main/CHANGELOG.md#231)"",\n }),\n );\n });",4,1,25,100.97809539418941,0.006293792806151423,100,"    // Test for URL generation with correct tag\n    it(""returns URL with correct tag for patch release"", () => {\n      const result = getReleaseUrl(""2.3.1"", ""2.3.0"");\n      assert.equal(\n        new URLSearchParams(new URL(result).search).get(""tag""),\n        ""2.3.1""\n      );\n    });\n\n    // Test for URL generation with correct title \n    it(""returns URL with correct title for patch release"", () => {\n      const result = getReleaseUrl(""2.3.1"", ""2.3.0"");\n      assert.equal(\n        new URLSearchParams(new URL(result).search).get(""title""),\n        ""2.3.1""\n      );\n    });\n\n    // Test for URL generation with correct changelog body\n    it(""returns URL with correct changelog link in body for patch release"", () => {\n      const result = getReleaseUrl(""2.3.1"", ""2.3.0"");\n      assert.equal(\n        new URLSearchParams(new URL(result).search).get(""body""),\n        ""🔗 [Changelog](https://github.com/prettier/prettier/blob/main/CHANGELOG.md#231)""\n      );\n    });",12,1,8.333333333333332,713.1181356564149,0.014444185605129391,100
24,"it(""returns URL for minor releasing"", () => {\n const result = getReleaseUrl(""2.4.0"", ""2.3.0"");\n assert.equal(\n result,\n getExpectedReleaseUrl({\n tag: ""2.4.0"",\n title: ""2.4.0"",\n body: [\n ""[diff](https://github.com/prettier/prettier/compare/2.3.0...2.4.0)"",\n `🔗 [Release note](https://prettier.io/blog/${getDateParts().join(\n ""/"",\n )}/2.4.0)`,\n ].join(""\n\n""),\n }),\n );\n });",4,1,25,162.6706359559867,0.008627890130576228,100,"    it(""returns URL with correct tag and title for minor release"", () => {\n      const result = getReleaseUrl(""2.4.0"", ""2.3.0"");\n      assert.equal(\n        result,\n        getExpectedReleaseUrl({\n          tag: ""2.4.0"", \n          title: ""2.4.0"",\n          body: [\n            ""[diff](https://github.com/prettier/prettier/compare/2.3.0...2.4.0)"",\n            `🔗 [Release note](https://prettier.io/blog/${getDateParts().join(""/"")}/2.4.0)`,\n          ].join(""\n\n""),\n        })\n      );\n    });\n\n    it(""returns URL with correct diff link for minor release"", () => {\n      const result = getReleaseUrl(""2.4.0"", ""2.3.0"");\n      assert.match(result, /compare\/2\.3\.0\.\.\.2\.4\.0/);\n    });\n\n    it(""returns URL with correct release note link for minor release"", () => {\n      const result = getReleaseUrl(""2.4.0"", ""2.3.0"");\n      const datePath = getDateParts().join(""/"");\n      assert.match(result, new RegExp(`blog\/${datePath}\/2\.4\.0`));\n    });",13,1,7.6923076923076925,618.9699375973561,0.0150244492474897,99.74314973024698
25,"it(""returns URL for major releasing"", () => {\n const result = getReleaseUrl(""2.3.0"", ""2.2.0"");\n assert.equal(\n result,\n getExpectedReleaseUrl({\n tag: ""2.3.0"",\n title: ""2.3.0"",\n body: [\n ""[diff](https://github.com/prettier/prettier/compare/2.2.0...2.3.0)"",\n `🔗 [Release note](https://prettier.io/blog/${getDateParts().join(\n ""/"",\n )}/2.3.0)`,\n ].join(""\n\n""),\n }),\n );\n });",4,1,25,162.6706359559867,0.008627890130576228,100,"    it(""returns URL with correct tag and title for major releasing"", () => {\n      const result = getReleaseUrl(""2.3.0"", ""2.2.0"");\n      const expectedUrl = getExpectedReleaseUrl({\n        tag: ""2.3.0"", \n        title: ""2.3.0""\n      });\n      assert.match(result, new RegExp(expectedUrl.split(""?"")[0]));\n      assert.match(result, /tag=2\.3\.0/);\n      assert.match(result, /title=2\.3\.0/);\n    });\n\n    it(""returns URL with correct diff link in body for major releasing"", () => {\n      const result = getReleaseUrl(""2.3.0"", ""2.2.0"");\n      assert.match(\n        result,\n        /body=.*\[diff\]\(https:\/\/github\.com\/prettier\/prettier\/compare\/2\.2\.0\.\.\.2\.3\.0\)/\n      );\n    });\n\n    it(""returns URL with correct release note link in body for major releasing"", () => {\n      const result = getReleaseUrl(""2.3.0"", ""2.2.0"");\n      const datePath = getDateParts().join(""/"");\n      assert.match(\n        result, \n        new RegExp(`body=.*Release note.*${datePath}\/2\.3\.0`)\n      );\n    });",16,1,6.25,760.6869603469191,0.01606883941841126,95.85520758540521
26,"it(""returns true for existing version"", async () => {\n assert.ok(await isVersionReleased(""1.0.0""));\n });",3,1,33.33333333333333,30,0.003218297948685432,100,"  it(""returns true when checking if version 1.0.0 exists in npm registry"", async () => {\n    // Explicitly test version existence check functionality\n    const version = ""1.0.0"";\n    const isReleased = await isVersionReleased(version);\n    assert.strictEqual(isReleased, true, `Version ${version} should exist in npm registry`);\n  });",5,1,20,68.51476695705185,0.00451370394047167,100
27,"it(""rejects for non-existing version"", async () => {\n await assert.rejects(() => isVersionReleased(""999.0.0""), {\n message: ""prettier@999.0.0 doesn't exit."",\n });\n });",3,1,33.33333333333333,39.86313713864835,0.0038897921399543107,100,"  it(""rejects with correct error message for non-existing version"", async () => {\n    await assert.rejects(() => isVersionReleased(""999.0.0""), {\n      message: ""prettier@999.0.0 doesn't exit."",\n    });\n  });\n\n  it(""rejects when attempting to check non-existing version number"", async () => {\n    await assert.rejects(() => isVersionReleased(""999.0.0""));\n  });",6,1,16.666666666666664,118.3894376155875,0.005986371980462904,100
28,"it('should not fire a scroll if the value has not changed since the previous call', () => {\n // this can happen if you scroll backward and forward super quick\n const marshal: DimensionMarshal = getMarshalStub();\n const registry: Registry = createRegistry();\n const registerSpy = jest.spyOn(registry.droppable, 'register');\n const wrapper = mount(\n <WithAppContext marshal={marshal} registry={registry}>\n <ScrollableItem />\n </WithAppContext>,\n );\n const container: ?HTMLElement = wrapper\n .find('.scroll-container')\n .getDOMNode();\n invariant(container);\n // tell the droppable to watch for scrolling\n const callbacks: DroppableCallbacks =\n registerSpy.mock.calls[0][0].callbacks;\n\n // watch scroll will only be called after the dimension is requested\n callbacks.getDimensionAndWatchScroll(preset.windowScroll, immediate);\n\n // first event\n scroll(container, { x: 500, y: 1000 });\n expect(marshal.updateDroppableScroll).toHaveBeenCalledTimes(1);\n expect(marshal.updateDroppableScroll).toHaveBeenCalledWith(\n preset.home.descriptor.id,\n { x: 500, y: 1000 },\n );\n // $ExpectError\n marshal.updateDroppableScroll.mockReset();\n\n // second event - scroll to same spot\n scroll(container, { x: 500, y: 1000 });\n expect(marshal.updateDroppableScroll).not.toHaveBeenCalled();\n\n // third event - new value\n scroll(container, { x: 500, y: 1001 });\n expect(marshal.updateDroppableScroll).toHaveBeenCalledWith(\n preset.home.descriptor.id,\n { x: 500, y: 1001 },\n );\n });",18,1,5.555555555555555,1605.8070154169495,0.028795258533030558,89.3971579037872,"  it('should not fire a scroll if the value has not changed since the previous call', () => {\n    const marshal: DimensionMarshal = getMarshalStub();\n    const registry: Registry = createRegistry();\n    const registerSpy = jest.spyOn(registry.droppable, 'register');\n    const wrapper = mount(\n      <WithAppContext marshal={marshal} registry={registry}>\n        <ScrollableItem />\n      </WithAppContext>,\n    );\n    const container: ?HTMLElement = wrapper\n      .find('.scroll-container')\n      .getDOMNode();\n    invariant(container);\n    \n    const callbacks: DroppableCallbacks =\n      registerSpy.mock.calls[0][0].callbacks;\n\n    callbacks.getDimensionAndWatchScroll(preset.windowScroll, immediate);\n\n    scroll(container, { x: 500, y: 1000 });\n    expect(marshal.updateDroppableScroll).toHaveBeenCalledTimes(1);\n    expect(marshal.updateDroppableScroll).toHaveBeenCalledWith(\n      preset.home.descriptor.id,\n      { x: 500, y: 1000 },\n    );\n    marshal.updateDroppableScroll.mockReset();\n\n    scroll(container, { x: 500, y: 1000 });\n    expect(marshal.updateDroppableScroll).not.toHaveBeenCalled();\n\n    scroll(container, { x: 500, y: 1001 });\n    expect(marshal.updateDroppableScroll).toHaveBeenCalledWith(\n      preset.home.descriptor.id,\n      { x: 500, y: 1001 },\n    );\n  });",18,1,5.555555555555555,1605.8070154169495,0.028795258533030558,89.3971579037872
29,"it('should throttle multiple scrolls into a animation frame', () => {\n const marshal: DimensionMarshal = getMarshalStub();\n const registry: Registry = createRegistry();\n const registerSpy = jest.spyOn(registry.droppable, 'register');\n const wrapper = mount(\n <WithAppContext marshal={marshal} registry={registry}>\n <ScrollableItem />\n </WithAppContext>,\n );\n const container: ?HTMLElement = wrapper\n .find('.scroll-container')\n .getDOMNode();\n invariant(container);\n // tell the droppable to watch for scrolling\n const callbacks: DroppableCallbacks =\n registerSpy.mock.calls[0][0].callbacks;\n\n // watch scroll will only be called after the dimension is requested\n callbacks.getDimensionAndWatchScroll(preset.windowScroll, scheduled);\n\n // first event\n scroll(container, { x: 500, y: 1000 });\n // second event in same frame\n scroll(container, { x: 200, y: 800 });\n\n // release the update animation frame\n requestAnimationFrame.step();\n\n expect(marshal.updateDroppableScroll).toHaveBeenCalledTimes(1);\n expect(marshal.updateDroppableScroll).toHaveBeenCalledWith(\n preset.home.descriptor.id,\n { x: 200, y: 800 },\n );\n\n // also checking that no loose frames are stored up\n requestAnimationFrame.flush();\n expect(marshal.updateDroppableScroll).toHaveBeenCalledTimes(1);\n });",17,1,5.88235294117647,1068.3349445894405,0.02542049732668734,91.29543250102327,"  it('should throttle multiple scrolls into a animation frame', () => {\n    const marshal: DimensionMarshal = getMarshalStub();\n    const registry: Registry = createRegistry();\n    const registerSpy = jest.spyOn(registry.droppable, 'register');\n    const wrapper = mount(\n      <WithAppContext marshal={marshal} registry={registry}>\n        <ScrollableItem />\n      </WithAppContext>,\n    );\n    const container: ?HTMLElement = wrapper\n      .find('.scroll-container')\n      .getDOMNode();\n    invariant(container);\n    const callbacks: DroppableCallbacks =\n      registerSpy.mock.calls[0][0].callbacks;\n\n    // watch scroll will only be called after the dimension is requested\n\n    // first event\n    // second event in same frame\n\n    // release the update animation frame\n\n    expect(marshal.updateDroppableScroll).toHaveBeenCalledTimes(1);\n    expect(marshal.updateDroppableScroll).toHaveBeenCalledWith(\n      preset.home.descriptor.id,\n      { x: 200, y: 800 },\n    );\n\n    // also checking that no loose frames are stored up\n    expect(marshal.updateDroppableScroll).toHaveBeenCalledTimes(1);\n  });",12,1,8.333333333333332,676.9747763784081,0.020191943558564598,98.73412363110737
30,"it('should not fire a scroll if the value has not changed since the previous frame', () => {\n // this can happen if you scroll backward and forward super quick\n const marshal: DimensionMarshal = getMarshalStub();\n const registry: Registry = createRegistry();\n const registerSpy = jest.spyOn(registry.droppable, 'register');\n const wrapper = mount(\n <WithAppContext marshal={marshal} registry={registry}>\n <ScrollableItem />\n </WithAppContext>,\n );\n const container: ?HTMLElement = wrapper\n .find('.scroll-container')\n .getDOMNode();\n invariant(container);\n // tell the droppable to watch for scrolling\n const callbacks: DroppableCallbacks =\n registerSpy.mock.calls[0][0].callbacks;\n\n // watch scroll will only be called after the dimension is requested\n callbacks.getDimensionAndWatchScroll(preset.windowScroll, scheduled);\n\n // first event\n scroll(container, { x: 500, y: 1000 });\n // release the frame\n requestAnimationFrame.step();\n expect(marshal.updateDroppableScroll).toHaveBeenCalledTimes(1);\n expect(marshal.updateDroppableScroll).toHaveBeenCalledWith(\n preset.home.descriptor.id,\n { x: 500, y: 1000 },\n );\n // $ExpectError\n marshal.updateDroppableScroll.mockReset();\n\n // second event\n scroll(container, { x: 501, y: 1001 });\n // no frame to release change yet\n\n // third event - back to original value\n scroll(container, { x: 500, y: 1000 });\n // release the frame\n requestAnimationFrame.step();\n expect(marshal.updateDroppableScroll).not.toHaveBeenCalled();\n });",19,1,5.263157894736842,1294.2278336067534,0.027576148196781666,88.85869329998171,"  it('should not fire a scroll if the value has not changed since the previous frame', () => {\n    const marshal: DimensionMarshal = getMarshalStub();\n    const registry: Registry = createRegistry();\n    const registerSpy = jest.spyOn(registry.droppable, 'register');\n    const wrapper = mount(\n      <WithAppContext marshal={marshal} registry={registry}>\n        <ScrollableItem />\n      </WithAppContext>,\n    );\n    const container: ?HTMLElement = wrapper\n      .find('.scroll-container')\n      .getDOMNode();\n    invariant(container);\n    const callbacks: DroppableCallbacks =\n      registerSpy.mock.calls[0][0].callbacks;\n\n    // watch scroll will only be called after the dimension is requested\n\n    // first event\n    // release the frame\n    expect(marshal.updateDroppableScroll).toHaveBeenCalledTimes(1);\n    expect(marshal.updateDroppableScroll).toHaveBeenCalledWith(\n      preset.home.descriptor.id,\n      { x: 500, y: 1000 },\n    );\n    // $ExpectError\n\n    // second event\n    // no frame to release change yet\n    // release the frame\n    expect(marshal.updateDroppableScroll).not.toHaveBeenCalled();\n  });",12,1,8.333333333333332,659.6220374984209,0.020518206808719994,98.60909791566385
31,"it('should not publish a scroll update after requested not to update while an animation frame is occurring', () => {\n const marshal: DimensionMarshal = getMarshalStub();\n const registry: Registry = createRegistry();\n const registerSpy = jest.spyOn(registry.droppable, 'register');\n const wrapper = mount(\n <WithAppContext marshal={marshal} registry={registry}>\n <ScrollableItem />\n </WithAppContext>,\n );\n const container: ?HTMLElement = wrapper\n .find('.scroll-container')\n .getDOMNode();\n invariant(container);\n // tell the droppable to watch for scrolling\n const callbacks: DroppableCallbacks =\n registerSpy.mock.calls[0][0].callbacks;\n\n // watch scroll will only be called after the dimension is requested\n callbacks.getDimensionAndWatchScroll(preset.windowScroll, scheduled);\n\n // first event\n scroll(container, { x: 500, y: 1000 });\n requestAnimationFrame.step();\n expect(marshal.updateDroppableScroll).toHaveBeenCalledTimes(1);\n // $ExpectError\n marshal.updateDroppableScroll.mockReset();\n\n // second event\n scroll(container, { x: 400, y: 100 });\n // no animation frame to release event fired yet\n\n // unwatching before frame fired\n callbacks.dragStopped();\n\n // flushing any frames\n requestAnimationFrame.flush();\n expect(marshal.updateDroppableScroll).not.toHaveBeenCalled();\n });",18,1,5.555555555555555,905.3685971096953,0.024258158428388608,90.734528341917,"  it('should not publish scroll update when unsubscribed during animation frame', () => {\n    const marshal: DimensionMarshal = getMarshalStub();\n    const registry: Registry = createRegistry();\n    const registerSpy = jest.spyOn(registry.droppable, 'register');\n    const wrapper = mount(\n      <WithAppContext marshal={marshal} registry={registry}>\n        <ScrollableItem />\n      </WithAppContext>,\n    );\n    const container: ?HTMLElement = wrapper\n      .find('.scroll-container')\n      .getDOMNode();\n    invariant(container);\n    \n    const callbacks: DroppableCallbacks = registerSpy.mock.calls[0][0].callbacks;\n    callbacks.getDimensionAndWatchScroll(preset.windowScroll, scheduled);\n\n    scroll(container, { x: 500, y: 1000 });\n    requestAnimationFrame.step();\n    expect(marshal.updateDroppableScroll).toHaveBeenCalledTimes(1);\n    // $ExpectError\n    marshal.updateDroppableScroll.mockReset();\n\n    scroll(container, { x: 400, y: 100 });\n    callbacks.dragStopped();\n\n    requestAnimationFrame.flush();\n    expect(marshal.updateDroppableScroll).not.toHaveBeenCalled();\n  });",18,1,5.555555555555555,905.3685971096953,0.024258158428388608,90.734528341917
32,"it('should stop watching scroll when no longer required to publish', () => {\n // this can happen if you scroll backward and forward super quick\n const marshal: DimensionMarshal = getMarshalStub();\n const registry: Registry = createRegistry();\n const registerSpy = jest.spyOn(registry.droppable, 'register');\n const wrapper = mount(\n <WithAppContext marshal={marshal} registry={registry}>\n <ScrollableItem />\n </WithAppContext>,\n );\n const container: ?HTMLElement = wrapper\n .find('.scroll-container')\n .getDOMNode();\n invariant(container);\n // tell the droppable to watch for scrolling\n const callbacks: DroppableCallbacks = registerSpy.mock.calls[0][0].callbacks;\n\n // watch scroll will only be called after the dimension is requested\n callbacks.getDimensionAndWatchScroll(preset.windowScroll, immediate);\n\n // first event\n scroll(container, { x: 500, y: 1000 });\n expect(marshal.updateDroppableScroll).toHaveBeenCalledTimes(1);\n // $ExpectError\n marshal.updateDroppableScroll.mockReset();\n\n callbacks.dragStopped();\n\n // scroll event after no longer watching\n scroll(container, { x: 190, y: 400 });\n expect(marshal.updateDroppableScroll).not.toHaveBeenCalled();\n});",16,1,6.25,830.9664922109746,0.02282338932417839,93.11815715812183,"it('should stop watching scroll when no longer required to publish', () => {\n  const marshal: DimensionMarshal = getMarshalStub();\n  const registry: Registry = createRegistry();\n  const registerSpy = jest.spyOn(registry.droppable, 'register');\n  const wrapper = mount(\n    <WithAppContext marshal={marshal} registry={registry}>\n      <ScrollableItem />\n    </WithAppContext>,\n  );\n  const container: ?HTMLElement = wrapper\n    .find('.scroll-container')\n    .getDOMNode();\n  invariant(container);\n  \n  const callbacks: DroppableCallbacks = registerSpy.mock.calls[0][0].callbacks;\n  callbacks.getDimensionAndWatchScroll(preset.windowScroll, immediate);\n\n  scroll(container, { x: 500, y: 1000 });\n  expect(marshal.updateDroppableScroll).toHaveBeenCalledTimes(1);\n  marshal.updateDroppableScroll.mockReset();\n\n  callbacks.dragStopped();\n\n  scroll(container, { x: 190, y: 400 });\n  expect(marshal.updateDroppableScroll).not.toHaveBeenCalled();\n});",16,1,6.25,830.9664922109746,0.02282338932417839,93.11815715812183
33,"it('should have every prettier target following the file name convention', async () => {\n const targets: string[] = pkg.config.prettier_target.split(' ');\n const paths: string[] = await globby(targets);\n\n invariant(\n paths.length,\n 'Could not find files to test against file name convention',\n );\n\n paths.forEach((filePath: string) => {\n if (exceptions.includes(filePath)) {\n return;\n }\n\n const isMatching: boolean = isSnakeCase(filePath);\n\n invariant(\n isMatching,\n `${filePath} does not follow the file path convention (snake-case.js) ${convention.toString()}`,\n );\n\n expect(isMatching).toBe(true);\n });\n});",13,2,15.384615384615385,329.51188268314564,0.012759824587919761,100,"it('should have every prettier target following the file name convention', async () => {\n  const targets: string[] = pkg.config.prettier_target.split(' ');\n  const paths: string[] = await globby(targets);\n\n  invariant(\n    paths.length,\n    'Could not find files to test against file name convention',\n  );\n\n  const nonExceptionPaths = paths.filter(filePath => !exceptions.includes(filePath));\n  \n  nonExceptionPaths.forEach((filePath: string) => {\n    const isMatching: boolean = isSnakeCase(filePath);\n\n    invariant(\n      isMatching,\n      `${filePath} does not follow the file path convention (snake-case.js) ${convention.toString()}`,\n    );\n\n    expect(isMatching).toBe(true);\n  });\n});",11,1,9.090909090909092,602.2654246353767,0.014226613473282445,100
34,"it('should end all nested docs with a link back to the documentation root', async () => {\n const files: string[] = await globby('docs/**/*.md');\n expect(files.length).toBeGreaterThan(0);\n const backLink: string =\n '[← Back to documentation](/README.md#documentation-)';\n\n for (const file of files) {\n const contents: string = await fs.readFile(file, 'utf8');\n\n // Printing a nice message to allow for quick fixing\n const endsWithBacklink: boolean = contents.trim().endsWith(backLink);\n\n if (!endsWithBacklink) {\n expect(`\n File: ""${file}""\n Did not end with back link\n `).toBe(true);\n }\n\n // need at least one assertion\n expect(true).toBe(true);\n }\n});",14,3,21.428571428571427,498.72270565528567,0.012208523980002346,99.90876630390645,"it('should end all nested docs with a link back to the documentation root', async () => {\n  const files: string[] = await globby('docs/**/*.md');\n  expect(files.length).toBeGreaterThan(0);\n  const backLink: string =\n    '[← Back to documentation](/README.md#documentation-)';\n\n  for (const file of files) {\n    const contents: string = await fs.readFile(file, 'utf8');\n\n    // Printing a nice message to allow for quick fixing\n    const endsWithBacklink: boolean = contents.trim().endsWith(backLink);\n\n    expect(endsWithBacklink).toBe(true, `\n      File: ""${file}""\n      Did not end with back link\n    `);\n  }\n});",11,2,18.181818181818183,268.45778344196526,0.011084362529087817,100
35,"it('should return false if an element has overflow:visible', () => {\n ['overflowY', 'overflowX'].forEach((overflow: string) => {\n const el: HTMLElement = document.createElement('div');\n // $ExpectError - flow being mean\n el.style[overflow] = 'visible';\n expect(getClosestScrollable(el)).toBe(null);\n });\n});",7,1,14.285714285714285,234.56524738296298,0.008627890130576228,100,"it('should return false if an element has overflow:visible', () => {\n  ['overflowY', 'overflowX'].forEach((overflow: string) => {\n    const el: HTMLElement = document.createElement('div');\n    // $ExpectError - flow being mean\n    el.style[overflow] = 'visible';\n    expect(getClosestScrollable(el)).toBeNull();\n  });\n});",7,1,14.285714285714285,234.56524738296298,0.008627890130576228,100
36,"it('should warn if the body might be a scroll container', () => {\n body.style.overflowX = 'auto';\n html.style.overflowY = 'auto';\n\n expect(getClosestScrollable(body)).toBe(null);\n expect(console.warn).toHaveBeenCalled();\n });",6,1,16.666666666666664,260.1378136824323,0.008767126040623019,100,"  it('should warn if the body might be a scroll container', () => {\n    body.style.overflowX = 'auto';\n    html.style.overflowY = 'auto';\n\n    expect(getClosestScrollable(body)).toBe(null);\n    expect(console.warn).toHaveBeenCalledWith(\n      'We have detected that your <body> element might be a scroll container. ' +\n      'This has poor performance and accessibility implications. ' +\n      'We recommend setting overflow on the <html> element instead'\n    );\n  });",6,1,16.666666666666664,412.36109451499425,0.010104859709772587,100
37,"it('should not mark the body as a scroll container if it does not have any overflow set', () => {\n body.style.overflowX = 'visible';\n expect(getClosestScrollable(body)).toBe(null);\n expect(console.warn).not.toHaveBeenCalled();\n });",5,1,20,193.84615384615384,0.007745047644751603,100,"  it('should not mark the body as a scroll container if it does not have any overflow set', () => {\n    body.style.overflowX = 'visible';\n    // Use more specific assertion to check for null\n    expect(getClosestScrollable(body)).toBeNull();\n    expect(console.warn).not.toHaveBeenCalled();\n  });",5,1,20,193.84615384615384,0.007745047644751603,100
38,"it('should not mark the body as a scroll container if the html element has visible overflow', () => {\n body.style.overflowX = 'auto';\n html.style.overflowY = 'visible';\n expect(getClosestScrollable(body)).toBe(null);\n expect(console.warn).not.toHaveBeenCalled();\n });",6,1,16.666666666666664,264.8317309162485,0.0093549651308736,100,"  it('should not mark the body as a scroll container if the html element has visible overflow', () => {\n    body.style.overflowX = 'auto';\n    html.style.overflowY = 'visible';\n    // Using more specific assertion to check for null value\n    expect(getClosestScrollable(body)).toBeNull();\n    // Using more specific assertion to verify warning was not called\n    expect(console.warn).not.toHaveBeenCalled();\n  });",6,1,16.666666666666664,264.8317309162485,0.0093549651308736,100
39,"it('should animate a mount', () => {\n const wrapper: ReactWrapper<*> = mount(\n <Placeholder\n contextId={contextId}\n animate=""open""\n placeholder={placeholder}\n onClose={jest.fn()}\n onTransitionEnd={jest.fn()}\n />,\n );\n\n expect(getCreatePlaceholderCalls().length).toBe(1);\n\n // first call had an empty size\n const onMount: PlaceholderStyle = getPlaceholderStyle(wrapper);\n expectIsEmpty(onMount);\n\n // Will trigger a .setState\n act(() => {\n jest.runOnlyPendingTimers();\n });\n\n // tell enzyme that something has changed\n wrapper.update();\n\n const postMount: PlaceholderStyle = getPlaceholderStyle(wrapper);\n expectIsFull(postMount);\n});",12,1,8.333333333333332,359.5836384377935,0.013362885383856537,100,"it('should animate a mount', () => {\n  const wrapper: ReactWrapper<*> = mount(\n    <Placeholder\n      contextId={contextId}\n      animate=""open""\n      placeholder={placeholder}\n      onClose={jest.fn()}\n      onTransitionEnd={jest.fn()}\n    />,\n  );\n\n  expect(getCreatePlaceholderCalls()).toHaveLength(1);\n\n  // first call had an empty size\n  const onMount: PlaceholderStyle = getPlaceholderStyle(wrapper);\n  expectIsEmpty(onMount);\n\n  // Will trigger a .setState\n  act(() => {\n    jest.runOnlyPendingTimers();\n  });\n\n  // tell enzyme that something has changed\n  wrapper.update();\n\n  const postMount: PlaceholderStyle = getPlaceholderStyle(wrapper);\n  expectIsFull(postMount);\n});",12,1,8.333333333333332,346.4720531153664,0.012926079295108433,100
40,"it('should announce with the default message if no responder is provided', () => {\n // This test is not relevant for onDragEnd as it must always be provided\n if (current.responder === 'onDragEnd') {\n expect(true).toBe(true);\n return;\n }\n // unsetting responder\n responders[current.responder] = undefined;\n current.execute(store);\n expect(announce).toHaveBeenCalledWith(current.defaultMessage);\n });",9,2,22.22222222222222,384.82450727596193,0.009063240809455704,100,"    it('should announce with the default message if no responder is provided (non-onDragEnd)', () => {\n      // Skip test for onDragEnd since it must always be provided\n      if (current.responder === 'onDragEnd') {\n        return;\n      }\n      // unsetting responder\n      responders[current.responder] = undefined;\n      current.execute(store);\n      expect(announce).toHaveBeenCalledWith(current.defaultMessage);\n    });\n\n    it('should require onDragEnd responder to be provided', () => {\n      if (current.responder === 'onDragEnd') {\n        expect(responders.onDragEnd).toBeDefined();\n      }\n    });",13,3,23.076923076923077,662.6766920971993,0.011061274058044093,100
41,"it('should recover from rbd errors', () => {\n let hasThrown: boolean = false;\n function CanThrow(props: { shouldThrow: boolean }) {\n if (!hasThrown && props.shouldThrow) {\n hasThrown = true;\n invariant(false, 'throwing');\n }\n return null;\n }\n\n const { rerender, getByTestId } = render(\n <App anotherChild={<CanThrow shouldThrow={false} />} />,\n );\n\n simpleLift(keyboard, getByTestId('0'));\n expect(isDragging(getByTestId('0'))).toBe(true);\n\n withError(() => {\n rerender(<App anotherChild={<CanThrow shouldThrow />} />);\n });\n\n expect(isDragging(getByTestId('0'))).toBe(false);\n});",16,3,18.75,1119.5815841241106,0.013025516312370856,97.2403062514302,"it('should recover from rbd errors', () => {\n  const throwingComponent = (shouldThrow) => {\n    invariant(!shouldThrow, 'throwing');\n    return null;\n  };\n\n  const { rerender, getByTestId } = render(\n    <App anotherChild={throwingComponent(false)} />,\n  );\n\n  simpleLift(keyboard, getByTestId('0'));\n  expect(isDragging(getByTestId('0'))).toBe(true);\n\n  withError(() => {\n    rerender(<App anotherChild={throwingComponent(true)} />);\n  });\n\n  expect(isDragging(getByTestId('0'))).toBe(false);\n});",13,1,7.6923076923076925,597.3648065780042,0.01186615853695023,100
42,"it('should not recover from non-rbd errors', () => {\n let hasThrown: boolean = false;\n function CanThrow(props: { shouldThrow: boolean }) {\n if (!hasThrown && props.shouldThrow) {\n hasThrown = true;\n throw new Error('Boom');\n }\n return null;\n }\n\n const { rerender, getByTestId } = render(\n <App anotherChild={<CanThrow shouldThrow={false} />} />,\n );\n\n simpleLift(keyboard, getByTestId('0'));\n expect(isDragging(getByTestId('0'))).toBe(true);\n\n withError(() => {\n expect(() => {\n rerender(<App anotherChild={<CanThrow shouldThrow />} />);\n }).toThrow();\n });\n});",17,3,17.647058823529413,868.7297369787454,0.012150573090249537,96.8005517228359,"it('should not recover from non-rbd errors', () => {\n  const CanThrow = ({ shouldThrow }) => {\n    if (shouldThrow) {\n      throw new Error('Boom');\n    }\n    return null;\n  };\n\n  const { rerender, getByTestId } = render(\n    <App anotherChild={<CanThrow shouldThrow={false} />} />,\n  );\n\n  simpleLift(keyboard, getByTestId('0'));\n  expect(isDragging(getByTestId('0'))).toBe(true);\n\n  withError(() => {\n    expect(() => {\n      rerender(<App anotherChild={<CanThrow shouldThrow />} />);\n    }).toThrow();\n  });\n});",16,2,12.5,259.87321258713695,0.010225945435769426,99.22102334225478
43,"it('should not log a warning if warnings are disabled', () => {\n window['__react-beautiful-dnd-disable-dev-warnings'] = true;\n\n warning('hey');\n warning('sup');\n warning('hi');\n\n expect(warn).not.toHaveBeenCalled();\n\n // re-enable\n\n window['__react-beautiful-dnd-disable-dev-warnings'] = false;\n\n warning('hey');\n\n expect(warn).toHaveBeenCalled();\n});",10,1,10,379.45674909847736,0.0091812270577072,100,"it('should handle warning behavior based on disable flag', () => {\n  // Test when warnings are disabled\n  window['__react-beautiful-dnd-disable-dev-warnings'] = true;\n\n  warning('hey');\n  warning('sup'); \n  warning('hi');\n\n  expect(warn).not.toHaveBeenCalled();\n\n  // Test when warnings are re-enabled\n  window['__react-beautiful-dnd-disable-dev-warnings'] = false;\n\n  warning('hey');\n  expect(warn).toHaveBeenCalledTimes(1);\n});",10,1,10,366.1198859234232,0.009631716433155985,100
44,"it('should not log a warning if warnings are disabled', () => {\n window['__react-beautiful-dnd-disable-dev-warnings'] = true;\n\n warning('hey');\n warning('sup');\n warning('hi');\n\n expect(warn).not.toHaveBeenCalled();\n\n // re-enable\n\n window['__react-beautiful-dnd-disable-dev-warnings'] = false;\n\n warning('hey');\n\n expect(warn).toHaveBeenCalled();\n});",10,1,10,379.45674909847736,0.0091812270577072,100,"it('should toggle warning behavior based on disable flag', () => {\n  // Disable warnings and verify no warnings are logged\n  window['__react-beautiful-dnd-disable-dev-warnings'] = true;\n\n  warning('hey');\n  warning('sup'); \n  warning('hi');\n\n  expect(warn).not.toHaveBeenCalled();\n\n  // Re-enable warnings and verify they are logged\n  window['__react-beautiful-dnd-disable-dev-warnings'] = false;\n\n  warning('hey');\n\n  expect(warn).toHaveBeenCalled();\n});\n",10,1,10,379.45674909847736,0.0091812270577072,100
45,"it('should register itself when mounting', () => {\n const registry: Registry = createRegistry();\n const registerSpy = jest.spyOn(registry.draggable, 'register');\n mount(<Item registry={registry} />);\n\n const expected: DraggableEntry = {\n // $ExpectError\n uniqueId: expect.any(String),\n descriptor: preset.inHome1.descriptor,\n options: defaultOptions,\n // $ExpectError\n getDimension: expect.any(Function),\n };\n expect(registerSpy).toHaveBeenCalledTimes(1);\n expect(registerSpy).toHaveBeenCalledWith(expected);\n });",8,1,12.5,366.1478268549855,0.013827948261584615,100,"  it('should register itself when mounting', () => {\n  const registry: Registry = createRegistry();\n  const registerSpy = jest.spyOn(registry.draggable, 'register');\n  mount(<Item registry={registry} />);\n\n  const expected: DraggableEntry = {\n    // $ExpectError\n    uniqueId: expect.any(String), \n    descriptor: preset.inHome1.descriptor,\n    options: defaultOptions,\n    // $ExpectError\n    getDimension: expect.any(Function),\n  };\n  \n  expect(registerSpy).toHaveBeenCalledOnceWith(expected);\n});",7,1,14.285714285714285,301.26967213707735,0.012448959890820123,100
46,"it('should register itself when mounting', () => {\n const registry: Registry = createRegistry();\n const registerSpy = jest.spyOn(registry.draggable, 'register');\n mount(<Item registry={registry} />);\n\n const expected: DraggableEntry = {\n // $ExpectError\n uniqueId: expect.any(String),\n descriptor: preset.inHome1.descriptor,\n options: defaultOptions,\n // $ExpectError\n getDimension: expect.any(Function),\n };\n expect(registerSpy).toHaveBeenCalledTimes(1);\n expect(registerSpy).toHaveBeenCalledWith(expected);\n });",8,1,12.5,366.1478268549855,0.013827948261584615,100,"  it('should register itself when mounting', () => {\n  const registry: Registry = createRegistry();\n  const registerSpy = jest.spyOn(registry.draggable, 'register');\n  mount(<Item registry={registry} />);\n\n  const expected: DraggableEntry = {\n    // $ExpectError\n    uniqueId: expect.any(String),\n    descriptor: preset.inHome1.descriptor,\n    options: defaultOptions,\n    // $ExpectError\n    getDimension: expect.any(Function),\n  };\n  expect(registerSpy).toHaveBeenCalledWith(expected);\n});",7,1,14.285714285714285,301.26967213707735,0.012448959890820123,100
47,"it('should unregister itself when unmounting', () => {\n const registry: Registry = createRegistry();\n const registerSpy = jest.spyOn(registry.draggable, 'register');\n const unregisterSpy = jest.spyOn(registry.draggable, 'unregister');\n const wrapper = mount(<Item registry={registry} />);\n\n const expected: DraggableEntry = {\n // $ExpectError\n uniqueId: expect.any(String),\n descriptor: preset.inHome1.descriptor,\n options: defaultOptions,\n // $ExpectError\n getDimension: expect.any(Function),\n };\n\n expect(unregisterSpy).not.toHaveBeenCalled();\n expect(registerSpy).toHaveBeenCalledTimes(1);\n expect(registerSpy).toHaveBeenCalledWith(expected);\n const entry = registerSpy.mock.calls[0][0];\n expect(entry).toEqual(expected);\n\n wrapper.unmount();\n expect(unregisterSpy).toHaveBeenCalledTimes(1);\n expect(unregisterSpy.mock.calls[0][0]).toBe(entry);\n });",15,1,6.666666666666667,1147.3403677582114,0.02427513581153119,93.68268054135075,"  it('should unregister itself when unmounting', () => {\n  const registry: Registry = createRegistry();\n  const registerSpy = jest.spyOn(registry.draggable, 'register');\n  const unregisterSpy = jest.spyOn(registry.draggable, 'unregister');\n  const wrapper = mount(<Item registry={registry} />);\n\n  const expected: DraggableEntry = {\n    // $ExpectError\n    uniqueId: expect.any(String),\n    descriptor: preset.inHome1.descriptor,\n    options: defaultOptions,\n    // $ExpectError\n    getDimension: expect.any(Function),\n  };\n\n  // Verify initial registration state\n  expect(unregisterSpy).not.toHaveBeenCalled();\n  expect(registerSpy).toHaveBeenCalledTimes(1);\n  expect(registerSpy).toHaveBeenCalledWith(expected);\n\n  // Store registered entry for later verification\n  const entry = registerSpy.mock.calls[0][0];\n\n  // Verify unmounting behavior\n  wrapper.unmount();\n  expect(unregisterSpy).toHaveBeenCalledTimes(1);\n  expect(unregisterSpy.mock.calls[0][0]).toBe(entry);\n});",14,1,7.142857142857142,1038.056079981714,0.023185105631204864,95.15871683260778
48,"it('should apply the appropriate aria attributes and non visibility styles', () => {\n render(<WithAnnouncer contextId=""5"">{getMock()}</WithAnnouncer>);\n\n const el: ?HTMLElement = getElement('5');\n invariant(el, 'Cannot find node');\n\n expect(el.getAttribute('aria-live')).toBe('assertive');\n expect(el.getAttribute('aria-atomic')).toBe('true');\n\n // not checking all the styles - just enough to know we are doing something\n expect(el.style.overflow).toBe('hidden');\n});",8,1,12.5,334.4573713977973,0.012256837285571486,100,"it('should apply the appropriate aria attributes', () => {\n  render(<WithAnnouncer contextId=""5"">{getMock()}</WithAnnouncer>);\n\n  const el: ?HTMLElement = getElement('5');\n  invariant(el, 'Cannot find node');\n\n  expect(el.getAttribute('aria-live')).toBe('assertive');\n  expect(el.getAttribute('aria-atomic')).toBe('true');\n});\n\nit('should apply non visibility styles', () => {\n  render(<WithAnnouncer contextId=""5"">{getMock()}</WithAnnouncer>);\n  \n  const el: ?HTMLElement = getElement('5');\n  invariant(el, 'Cannot find node');\n\n  expect(el.style.overflow).toBe('hidden');\n});",13,1,7.6923076923076925,606.1573021116398,0.015040039459824938,99.73506020853262
49,"it('should set the text content of the announcement element', () => {\n // arrange\n const mock = getMock();\n render(<WithAnnouncer contextId=""6"">{mock}</WithAnnouncer>);\n const el: ?HTMLElement = getElement('6');\n invariant(el, 'Could not find announcer');\n\n // act\n const announce: Announce = getAnnounce(mock);\n announce('test');\n\n // assert\n expect(el.textContent).toBe('test');\n});",9,1,11.11111111111111,216.09640474436813,0.00964270255730497,100,"it('should create an announcer element when mounting', () => {\n  const mock = getMock();\n  render(<WithAnnouncer contextId=""6"">{mock}</WithAnnouncer>);\n  const el: ?HTMLElement = getElement('6');\n  invariant(el, 'Could not find announcer');\n  expect(el).toBeTruthy();\n});\n\nit('should allow setting announcement text content', () => {\n  const mock = getMock();\n  render(<WithAnnouncer contextId=""6"">{mock}</WithAnnouncer>);\n  const el: ?HTMLElement = getElement('6');\n  invariant(el, 'Could not find announcer');\n\n  const announce: Announce = getAnnounce(mock);\n  announce('test message');\n\n  expect(el.textContent).toBe('test message');\n});",16,1,6.25,571.2531903474378,0.013994314866946926,96.93340775166858
50,"it('should throw if the droppable has no closest scrollable', () => {\n const marshal: DimensionMarshal = getMarshalStub();\n const registry: Registry = createRegistry();\n const registerSpy = jest.spyOn(registry.droppable, 'register');\n // no scroll parent\n const wrapper = mount(\n <WithAppContext marshal={marshal} registry={registry}>\n <App parentIsScrollable={false} droppableIsScrollable={false} />,\n </WithAppContext>,\n );\n const droppable: ?HTMLElement = wrapper.find('.droppable').getDOMNode();\n invariant(droppable);\n const parent: ?HTMLElement = wrapper.find('.scroll-parent').getDOMNode();\n invariant(parent);\n jest\n .spyOn(droppable, 'getBoundingClientRect')\n .mockImplementation(() => smallFrameClient.borderBox);\n jest\n .spyOn(parent, 'getBoundingClientRect')\n .mockImplementation(() => bigClient.borderBox);\n\n // validating no initial scroll\n expect(parent.scrollTop).toBe(0);\n expect(parent.scrollLeft).toBe(0);\n expect(droppable.scrollTop).toBe(0);\n expect(droppable.scrollLeft).toBe(0);\n\n const callbacks: DroppableCallbacks = registerSpy.mock.calls[0][0].callbacks;\n // request the droppable start listening for scrolling\n callbacks.getDimensionAndWatchScroll(preset.windowScroll, scheduled);\n\n // ask it to scroll\n expect(() => callbacks.scroll({ x: 100, y: 100 })).toThrow();\n\n // no scroll changes\n expect(parent.scrollTop).toBe(0);\n expect(parent.scrollLeft).toBe(0);\n expect(droppable.scrollTop).toBe(0);\n expect(droppable.scrollLeft).toBe(0);\n});",23,1,4.3478260869565215,2435.2551878832915,0.03345279485656603,84.25676222684999,"it('should throw if the droppable has no closest scrollable', () => {\n  const marshal: DimensionMarshal = getMarshalStub();\n  const registry: Registry = createRegistry();\n  const registerSpy = jest.spyOn(registry.droppable, 'register');\n  // no scroll parent\n  const wrapper = mount(\n    <WithAppContext marshal={marshal} registry={registry}>\n      <App parentIsScrollable={false} droppableIsScrollable={false} />,\n    </WithAppContext>,\n  );\n  const droppable: ?HTMLElement = wrapper.find('.droppable').getDOMNode();\n  invariant(droppable);\n  const parent: ?HTMLElement = wrapper.find('.scroll-parent').getDOMNode();\n  invariant(parent);\n  jest\n    .spyOn(droppable, 'getBoundingClientRect')\n    .mockImplementation(() => smallFrameClient.borderBox);\n  jest\n    .spyOn(parent, 'getBoundingClientRect')\n    .mockImplementation(() => bigClient.borderBox);\n\n  // validating no initial scroll\n  expect(parent.scrollTop).toBe(0);\n  expect(parent.scrollLeft).toBe(0);\n  expect(droppable.scrollTop).toBe(0);\n  expect(droppable.scrollLeft).toBe(0);\n\n  const callbacks: DroppableCallbacks = registerSpy.mock.calls[0][0].callbacks;\n  // request the droppable start listening for scrolling\n  callbacks.getDimensionAndWatchScroll(preset.windowScroll, scheduled);\n\n  // Define test scroll values\n  const TEST_SCROLL_OFFSET = {\n    x: 100, // Pixels to scroll horizontally\n    y: 100  // Pixels to scroll vertically\n  };\n\n  // ask it to scroll\n  expect(() => callbacks.scroll(TEST_SCROLL_OFFSET)).toThrow();\n\n  // no scroll changes\n  expect(parent.scrollTop).toBe(0);\n  expect(parent.scrollLeft).toBe(0);\n  expect(droppable.scrollTop).toBe(0);\n  expect(droppable.scrollLeft).toBe(0);\n});",24,1,4.166666666666666,2466.2465929814966,0.03382150892080064,83.48179581887439
51,"it('should throw if the droppable has no closest scrollable', () => {\n const marshal: DimensionMarshal = getMarshalStub();\n const registry: Registry = createRegistry();\n const registerSpy = jest.spyOn(registry.droppable, 'register');\n // no scroll parent\n const wrapper = mount(\n <WithAppContext marshal={marshal} registry={registry}>\n <App parentIsScrollable={false} droppableIsScrollable={false} />,\n </WithAppContext>,\n );\n const droppable: ?HTMLElement = wrapper.find('.droppable').getDOMNode();\n invariant(droppable);\n const parent: ?HTMLElement = wrapper.find('.scroll-parent').getDOMNode();\n invariant(parent);\n jest\n .spyOn(droppable, 'getBoundingClientRect')\n .mockImplementation(() => smallFrameClient.borderBox);\n jest\n .spyOn(parent, 'getBoundingClientRect')\n .mockImplementation(() => bigClient.borderBox);\n\n // validating no initial scroll\n expect(parent.scrollTop).toBe(0);\n expect(parent.scrollLeft).toBe(0);\n expect(droppable.scrollTop).toBe(0);\n expect(droppable.scrollLeft).toBe(0);\n\n const callbacks: DroppableCallbacks = registerSpy.mock.calls[0][0].callbacks;\n // request the droppable start listening for scrolling\n callbacks.getDimensionAndWatchScroll(preset.windowScroll, scheduled);\n\n // ask it to scroll\n expect(() => callbacks.scroll({ x: 100, y: 100 })).toThrow();\n\n // no scroll changes\n expect(parent.scrollTop).toBe(0);\n expect(parent.scrollLeft).toBe(0);\n expect(droppable.scrollTop).toBe(0);\n expect(droppable.scrollLeft).toBe(0);\n});",23,1,4.3478260869565215,2435.2551878832915,0.03345279485656603,84.25676222684999,"it('should throw if the droppable has no closest scrollable', () => {\n  const marshal: DimensionMarshal = getMarshalStub();\n  const registry: Registry = createRegistry();\n  const registerSpy = jest.spyOn(registry.droppable, 'register');\n  // no scroll parent\n  const wrapper = mount(\n    <WithAppContext marshal={marshal} registry={registry}>\n      <App parentIsScrollable={false} droppableIsScrollable={false} />,\n    </WithAppContext>,\n  );\n  const droppable: ?HTMLElement = wrapper.find('.droppable').getDOMNode();\n  invariant(droppable);\n  const parent: ?HTMLElement = wrapper.find('.scroll-parent').getDOMNode();\n  invariant(parent);\n  jest\n    .spyOn(droppable, 'getBoundingClientRect')\n    .mockImplementation(() => smallFrameClient.borderBox);\n  jest\n    .spyOn(parent, 'getBoundingClientRect')\n    .mockImplementation(() => bigClient.borderBox);\n\n  // validating no initial scroll\n  expect(parent.scrollTop).toBe(0);\n  expect(parent.scrollLeft).toBe(0);\n  expect(droppable.scrollTop).toBe(0);\n  expect(droppable.scrollLeft).toBe(0);\n\n  const callbacks: DroppableCallbacks = registerSpy.mock.calls[0][0].callbacks;\n  // request the droppable start listening for scrolling\n  callbacks.getDimensionAndWatchScroll(preset.windowScroll, scheduled);\n\n  // Define test scroll values\n  const TEST_SCROLL_OFFSET = {\n    x: 100, // Scroll 100 pixels horizontally\n    y: 100  // Scroll 100 pixels vertically\n  };\n  \n  // ask it to scroll\n  expect(() => callbacks.scroll(TEST_SCROLL_OFFSET)).toThrow();\n\n  // no scroll changes\n  expect(parent.scrollTop).toBe(0);\n  expect(parent.scrollLeft).toBe(0);\n  expect(droppable.scrollTop).toBe(0);\n  expect(droppable.scrollLeft).toBe(0);\n});",24,1,4.166666666666666,2466.2465929814966,0.03382150892080064,83.48179581887439
52,"it('should throw if the droppable has no closest scrollable', () => {\n const marshal: DimensionMarshal = getMarshalStub();\n const registry: Registry = createRegistry();\n const registerSpy = jest.spyOn(registry.droppable, 'register');\n // no scroll parent\n const wrapper = mount(\n <WithAppContext marshal={marshal} registry={registry}>\n <App parentIsScrollable={false} droppableIsScrollable={false} />,\n </WithAppContext>,\n );\n const droppable: ?HTMLElement = wrapper.find('.droppable').getDOMNode();\n invariant(droppable);\n const parent: ?HTMLElement = wrapper.find('.scroll-parent').getDOMNode();\n invariant(parent);\n jest\n .spyOn(droppable, 'getBoundingClientRect')\n .mockImplementation(() => smallFrameClient.borderBox);\n jest\n .spyOn(parent, 'getBoundingClientRect')\n .mockImplementation(() => bigClient.borderBox);\n\n // validating no initial scroll\n expect(parent.scrollTop).toBe(0);\n expect(parent.scrollLeft).toBe(0);\n expect(droppable.scrollTop).toBe(0);\n expect(droppable.scrollLeft).toBe(0);\n\n const callbacks: DroppableCallbacks = registerSpy.mock.calls[0][0].callbacks;\n // request the droppable start listening for scrolling\n callbacks.getDimensionAndWatchScroll(preset.windowScroll, scheduled);\n\n // ask it to scroll\n expect(() => callbacks.scroll({ x: 100, y: 100 })).toThrow();\n\n // no scroll changes\n expect(parent.scrollTop).toBe(0);\n expect(parent.scrollLeft).toBe(0);\n expect(droppable.scrollTop).toBe(0);\n expect(droppable.scrollLeft).toBe(0);\n});",23,1,4.3478260869565215,2435.2551878832915,0.03345279485656603,84.25676222684999,"it('should throw if the droppable has no closest scrollable', () => {\n  const marshal: DimensionMarshal = getMarshalStub();\n  const registry: Registry = createRegistry();\n  const registerSpy = jest.spyOn(registry.droppable, 'register');\n  // no scroll parent\n  const wrapper = mount(\n    <WithAppContext marshal={marshal} registry={registry}>\n      <App parentIsScrollable={false} droppableIsScrollable={false} />,\n    </WithAppContext>,\n  );\n  const droppable: ?HTMLElement = wrapper.find('.droppable').getDOMNode();\n  invariant(droppable);\n  const parent: ?HTMLElement = wrapper.find('.scroll-parent').getDOMNode();\n  invariant(parent);\n  jest\n    .spyOn(droppable, 'getBoundingClientRect')\n    .mockImplementation(() => smallFrameClient.borderBox);\n  jest\n    .spyOn(parent, 'getBoundingClientRect')\n    .mockImplementation(() => bigClient.borderBox);\n\n  // validating no initial scroll\n  expect(parent.scrollTop).toBe(0);\n  expect(parent.scrollLeft).toBe(0);\n  expect(droppable.scrollTop).toBe(0);\n  expect(droppable.scrollLeft).toBe(0);\n\n  const callbacks: DroppableCallbacks = registerSpy.mock.calls[0][0].callbacks;\n  // request the droppable start listening for scrolling\n  callbacks.getDimensionAndWatchScroll(preset.windowScroll, scheduled);\n\n  // Test scroll values for x and y coordinates\n  const TEST_SCROLL_X = 100;\n  const TEST_SCROLL_Y = 100;\n  \n  // ask it to scroll\n  expect(() => callbacks.scroll({ x: TEST_SCROLL_X, y: TEST_SCROLL_Y })).toThrow();\n\n  // no scroll changes\n  expect(parent.scrollTop).toBe(0);\n  expect(parent.scrollLeft).toBe(0);\n  expect(droppable.scrollTop).toBe(0);\n  expect(droppable.scrollLeft).toBe(0);\n});",25,1,4,2497.3512615154987,0.03418834748496004,82.73633380578444
53,"it('should throw if the droppable has no closest scrollable', () => {\n const marshal: DimensionMarshal = getMarshalStub();\n const registry: Registry = createRegistry();\n const registerSpy = jest.spyOn(registry.droppable, 'register');\n // no scroll parent\n const wrapper = mount(\n <WithAppContext marshal={marshal} registry={registry}>\n <App parentIsScrollable={false} droppableIsScrollable={false} />,\n </WithAppContext>,\n );\n const droppable: ?HTMLElement = wrapper.find('.droppable').getDOMNode();\n invariant(droppable);\n const parent: ?HTMLElement = wrapper.find('.scroll-parent').getDOMNode();\n invariant(parent);\n jest\n .spyOn(droppable, 'getBoundingClientRect')\n .mockImplementation(() => smallFrameClient.borderBox);\n jest\n .spyOn(parent, 'getBoundingClientRect')\n .mockImplementation(() => bigClient.borderBox);\n\n // validating no initial scroll\n expect(parent.scrollTop).toBe(0);\n expect(parent.scrollLeft).toBe(0);\n expect(droppable.scrollTop).toBe(0);\n expect(droppable.scrollLeft).toBe(0);\n\n const callbacks: DroppableCallbacks = registerSpy.mock.calls[0][0].callbacks;\n // request the droppable start listening for scrolling\n callbacks.getDimensionAndWatchScroll(preset.windowScroll, scheduled);\n\n // ask it to scroll\n expect(() => callbacks.scroll({ x: 100, y: 100 })).toThrow();\n\n // no scroll changes\n expect(parent.scrollTop).toBe(0);\n expect(parent.scrollLeft).toBe(0);\n expect(droppable.scrollTop).toBe(0);\n expect(droppable.scrollLeft).toBe(0);\n});",23,1,4.3478260869565215,2435.2551878832915,0.03345279485656603,84.25676222684999,"it('should throw if the droppable has no closest scrollable', () => {\n  const marshal: DimensionMarshal = getMarshalStub();\n  const registry: Registry = createRegistry();\n  const registerSpy = jest.spyOn(registry.droppable, 'register');\n  // no scroll parent\n  const wrapper = mount(\n    <WithAppContext marshal={marshal} registry={registry}>\n      <App parentIsScrollable={false} droppableIsScrollable={false} />,\n    </WithAppContext>,\n  );\n  const droppable: ?HTMLElement = wrapper.find('.droppable').getDOMNode();\n  invariant(droppable);\n  const parent: ?HTMLElement = wrapper.find('.scroll-parent').getDOMNode();\n  invariant(parent);\n  jest\n    .spyOn(droppable, 'getBoundingClientRect')\n    .mockImplementation(() => smallFrameClient.borderBox);\n  jest\n    .spyOn(parent, 'getBoundingClientRect')\n    .mockImplementation(() => bigClient.borderBox);\n\n  // validating no initial scroll\n  expect(parent.scrollTop).toBe(0);\n  expect(parent.scrollLeft).toBe(0);\n  expect(droppable.scrollTop).toBe(0);\n  expect(droppable.scrollLeft).toBe(0);\n\n  const callbacks: DroppableCallbacks = registerSpy.mock.calls[0][0].callbacks;\n  // request the droppable start listening for scrolling\n  callbacks.getDimensionAndWatchScroll(preset.windowScroll, scheduled);\n\n  // Define test scroll values\n  const TEST_SCROLL_OFFSET = {\n    x: 100,\n    y: 100\n  };\n  \n  // ask it to scroll\n  expect(() => callbacks.scroll(TEST_SCROLL_OFFSET)).toThrow();\n\n  // no scroll changes\n  expect(parent.scrollTop).toBe(0);\n  expect(parent.scrollLeft).toBe(0);\n  expect(droppable.scrollTop).toBe(0);\n  expect(droppable.scrollLeft).toBe(0);\n});",24,1,4.166666666666666,2466.2465929814966,0.03382150892080064,83.48179581887439
54,"it('should throw if the droppable has no closest scrollable', () => {\n const marshal: DimensionMarshal = getMarshalStub();\n const registry: Registry = createRegistry();\n const registerSpy = jest.spyOn(registry.droppable, 'register');\n // no scroll parent\n const wrapper = mount(\n <WithAppContext marshal={marshal} registry={registry}>\n <App parentIsScrollable={false} droppableIsScrollable={false} />,\n </WithAppContext>,\n );\n const droppable: ?HTMLElement = wrapper.find('.droppable').getDOMNode();\n invariant(droppable);\n const parent: ?HTMLElement = wrapper.find('.scroll-parent').getDOMNode();\n invariant(parent);\n jest\n .spyOn(droppable, 'getBoundingClientRect')\n .mockImplementation(() => smallFrameClient.borderBox);\n jest\n .spyOn(parent, 'getBoundingClientRect')\n .mockImplementation(() => bigClient.borderBox);\n\n // validating no initial scroll\n expect(parent.scrollTop).toBe(0);\n expect(parent.scrollLeft).toBe(0);\n expect(droppable.scrollTop).toBe(0);\n expect(droppable.scrollLeft).toBe(0);\n\n const callbacks: DroppableCallbacks = registerSpy.mock.calls[0][0].callbacks;\n // request the droppable start listening for scrolling\n callbacks.getDimensionAndWatchScroll(preset.windowScroll, scheduled);\n\n // ask it to scroll\n expect(() => callbacks.scroll({ x: 100, y: 100 })).toThrow();\n\n // no scroll changes\n expect(parent.scrollTop).toBe(0);\n expect(parent.scrollLeft).toBe(0);\n expect(droppable.scrollTop).toBe(0);\n expect(droppable.scrollLeft).toBe(0);\n});",23,1,4.3478260869565215,2435.2551878832915,0.03345279485656603,84.25676222684999,"it('should throw if the droppable has no closest scrollable', () => {\n  const marshal: DimensionMarshal = getMarshalStub();\n  const registry: Registry = createRegistry();\n  const registerSpy = jest.spyOn(registry.droppable, 'register');\n  // no scroll parent\n  const wrapper = mount(\n    <WithAppContext marshal={marshal} registry={registry}>\n      <App parentIsScrollable={false} droppableIsScrollable={false} />,\n    </WithAppContext>,\n  );\n  const droppable: ?HTMLElement = wrapper.find('.droppable').getDOMNode();\n  invariant(droppable);\n  const parent: ?HTMLElement = wrapper.find('.scroll-parent').getDOMNode();\n  invariant(parent);\n  jest\n    .spyOn(droppable, 'getBoundingClientRect')\n    .mockImplementation(() => smallFrameClient.borderBox);\n  jest\n    .spyOn(parent, 'getBoundingClientRect')\n    .mockImplementation(() => bigClient.borderBox);\n\n  // validating no initial scroll\n  expect(parent.scrollTop).toBe(0);\n  expect(parent.scrollLeft).toBe(0);\n  expect(droppable.scrollTop).toBe(0);\n  expect(droppable.scrollLeft).toBe(0);\n\n  const callbacks: DroppableCallbacks = registerSpy.mock.calls[0][0].callbacks;\n  // request the droppable start listening for scrolling\n  callbacks.getDimensionAndWatchScroll(preset.windowScroll, scheduled);\n\n  // Define test scroll values\n  const TEST_SCROLL_OFFSET = {\n    x: 100, // Scroll offset for x axis\n    y: 100  // Scroll offset for y axis  \n  };\n\n  // ask it to scroll\n  expect(() => callbacks.scroll(TEST_SCROLL_OFFSET)).toThrow();\n\n  // no scroll changes\n  expect(parent.scrollTop).toBe(0);\n  expect(parent.scrollLeft).toBe(0);\n  expect(droppable.scrollTop).toBe(0);\n  expect(droppable.scrollLeft).toBe(0);\n});",24,1,4.166666666666666,2466.2465929814966,0.03382150892080064,83.48179581887439
55,"it('should not fire an onClose if not closing when a transitionend occurs', () => {\n const onClose = jest.fn();\n\n const wrapper: ReactWrapper<*> = mount(\n <Placeholder\n animate=""none""\n contextId=""1""\n placeholder={placeholder}\n onClose={onClose}\n onTransitionEnd={jest.fn()}\n />,\n );\n const assert = () => {\n // $ExpectError - not a complete event\n const height: TransitionEvent = {\n propertyName: 'height',\n };\n wrapper.simulate('transitionend', height);\n expect(onClose).not.toHaveBeenCalled();\n onClose.mockClear();\n };\n expectIsFull(getPlaceholderStyle(wrapper));\n assert();\n\n wrapper.setProps({ animate: 'open' });\n assert();\n});",14,1,7.142857142857142,407.5157787774984,0.014226613473282445,98.96820309823849,"it('should not fire an onClose if not closing when a transitionend occurs', () => {\n  const onClose = jest.fn();\n\n  const wrapper: ReactWrapper<*> = mount(\n    <Placeholder\n      animate=""none""\n      contextId=""1""\n      placeholder={placeholder}\n      onClose={onClose}\n      onTransitionEnd={jest.fn()}\n    />,\n  );\n\n  // Test initial state with animate=""none""\n  it('should not trigger onClose with animate=""none""', () => {\n    expectIsFull(getPlaceholderStyle(wrapper));\n    // $ExpectError - not a complete event\n    const height: TransitionEvent = {\n      propertyName: 'height',\n    };\n    wrapper.simulate('transitionend', height);\n    expect(onClose).not.toHaveBeenCalled();\n    onClose.mockClear();\n  });\n\n  // Test with animate=""open"" state\n  it('should not trigger onClose with animate=""open""', () => {\n    wrapper.setProps({ animate: 'open' });\n    // $ExpectError - not a complete event\n    const height: TransitionEvent = {\n      propertyName: 'height',\n    };\n    wrapper.simulate('transitionend', height);\n    expect(onClose).not.toHaveBeenCalled();\n    onClose.mockClear();\n  });\n});",18,1,5.555555555555555,772.4189782252839,0.017899434021628954,93.10560274161226
56,"it('should not fire an onClose if not closing when a transitionend occurs', () => {\n const onClose = jest.fn();\n\n const wrapper: ReactWrapper<*> = mount(\n <Placeholder\n animate=""none""\n contextId=""1""\n placeholder={placeholder}\n onClose={onClose}\n onTransitionEnd={jest.fn()}\n />,\n );\n const assert = () => {\n // $ExpectError - not a complete event\n const height: TransitionEvent = {\n propertyName: 'height',\n };\n wrapper.simulate('transitionend', height);\n expect(onClose).not.toHaveBeenCalled();\n onClose.mockClear();\n };\n expectIsFull(getPlaceholderStyle(wrapper));\n assert();\n\n wrapper.setProps({ animate: 'open' });\n assert();\n});",14,1,7.142857142857142,407.5157787774984,0.014226613473282445,98.96820309823849,"it('should not fire an onClose if not closing when a transitionend occurs', () => {\n  const onClose = jest.fn();\n\n  const wrapper: ReactWrapper<*> = mount(\n    <Placeholder\n      animate=""none""\n      contextId=""1""\n      placeholder={placeholder}\n      onClose={onClose}\n      onTransitionEnd={jest.fn()}\n    />,\n  );\n  \n  const assertNoOnCloseCall = (animateState) => {\n    // Test that onClose is not called for 'none' and 'open' animate states\n    expect(wrapper.prop('animate')).toBe(animateState);\n    \n    // $ExpectError - not a complete event\n    const height: TransitionEvent = {\n      propertyName: 'height',\n    };\n    wrapper.simulate('transitionend', height);\n    \n    expect(onClose).not.toHaveBeenCalled();\n    onClose.mockClear();\n  };\n\n  // Test initial state (animate: 'none')\n  expectIsFull(getPlaceholderStyle(wrapper));\n  assertNoOnCloseCall('none');\n\n  // Test after changing to 'open' state\n  wrapper.setProps({ animate: 'open' });\n  assertNoOnCloseCall('open');\n});",15,1,6.666666666666667,578.1034591154892,0.016765475831665867,96.56970114725311
57,"it('should collect and publish the draggables', () => {\n const beforeInHome1: DraggableDimension = {\n ...preset.inHome1,\n descriptor: {\n ...preset.inHome1.descriptor,\n id: 'addition1',\n index: 0,\n },\n };\n const beforeInHome2: DraggableDimension = {\n ...preset.inHome2,\n descriptor: {\n ...preset.inHome2.descriptor,\n id: 'addition2',\n index: 1,\n },\n };\n const registry: Registry = createRegistry();\n const callbacks: Callbacks = getCallbacksStub();\n const marshal: DimensionMarshal = createDimensionMarshal(\n registry,\n callbacks,\n );\n populate(registry, withScrollables);\n\n // A publish has started\n marshal.startPublishing(defaultRequest);\n expect(callbacks.publishWhileDragging).not.toHaveBeenCalled();\n\n registry.draggable.register(\n getDraggableEntry({ dimension: beforeInHome1 }),\n );\n registry.draggable.register(\n getDraggableEntry({ dimension: beforeInHome2 }),\n );\n expect(callbacks.collectionStarting).toHaveBeenCalled();\n expect(callbacks.publishWhileDragging).not.toHaveBeenCalled();\n\n // Fire the collection / publish step\n requestAnimationFrame.step();\n const expected: Published = {\n ...empty,\n additions: [beforeInHome1, beforeInHome2],\n modified: [{ droppableId: scrollableHome.descriptor.id, scroll: origin }],\n };\n expect(callbacks.publishWhileDragging).toHaveBeenCalledWith(expected);\n });",17,1,5.88235294117647,1359.9929166832883,0.027485726782689086,90.68616659266496,"  it('should start collection when registering new draggables', () => {\n  const beforeInHome1: DraggableDimension = {\n    ...preset.inHome1,\n    descriptor: {\n      ...preset.inHome1.descriptor,\n      id: 'addition1',\n      index: 0,\n    },\n  };\n  const beforeInHome2: DraggableDimension = {\n    ...preset.inHome2,\n    descriptor: {\n      ...preset.inHome2.descriptor,\n      id: 'addition2', \n      index: 1,\n    },\n  };\n  const registry: Registry = createRegistry();\n  const callbacks: Callbacks = getCallbacksStub();\n  const marshal: DimensionMarshal = createDimensionMarshal(registry, callbacks);\n  populate(registry, withScrollables);\n\n  marshal.startPublishing(defaultRequest);\n  expect(callbacks.publishWhileDragging).not.toHaveBeenCalled();\n\n  registry.draggable.register(getDraggableEntry({ dimension: beforeInHome1 }));\n  registry.draggable.register(getDraggableEntry({ dimension: beforeInHome2 }));\n\n  expect(callbacks.collectionStarting).toHaveBeenCalled();\n});\n\nit('should publish registered draggables after collection', () => {\n  const beforeInHome1: DraggableDimension = {\n    ...preset.inHome1,\n    descriptor: {\n      ...preset.inHome1.descriptor,\n      id: 'addition1',\n      index: 0,\n    },\n  };\n  const beforeInHome2: DraggableDimension = {\n    ...preset.inHome2,\n    descriptor: {\n      ...preset.inHome2.descriptor,\n      id: 'addition2',\n      index: 1,\n    },\n  };\n  const registry: Registry = createRegistry();\n  const callbacks: Callbacks = getCallbacksStub();\n  const marshal: DimensionMarshal = createDimensionMarshal(registry, callbacks);\n  populate(registry, withScrollables);\n\n  marshal.startPublishing(defaultRequest);\n  \n  registry.draggable.register(getDraggableEntry({ dimension: beforeInHome1 }));\n  registry.draggable.register(getDraggableEntry({ dimension: beforeInHome2 }));\n\n  requestAnimationFrame.step();\n  \n  const expected: Published = {\n    ...empty,\n    additions: [beforeInHome1, beforeInHome2],\n    modified: [{ droppableId: scrollableHome.descriptor.id, scroll: origin }],\n  };\n  expect(callbacks.publishWhileDragging).toHaveBeenCalledWith(expected);\n});",27,1,3.7037037037037033,3137.750038453582,0.03613497653607236,81.05762897104546
58,"it('should not do anything if trying to add a draggable that does not have the same type as the dragging item', () => {\n const callbacks: Callbacks = getCallbacksStub();\n const registry: Registry = createRegistry();\n const marshal: DimensionMarshal = createDimensionMarshal(\n registry,\n callbacks,\n );\n populate(registry, withScrollables);\n\n // A publish has started\n marshal.startPublishing(defaultRequest);\n expect(callbacks.collectionStarting).not.toHaveBeenCalled();\n\n // Registering a new draggable (inserted before inHome1)\n\n registry.draggable.register(\n getDraggableEntry({ dimension: inAnotherType }),\n );\n expect(callbacks.collectionStarting).not.toHaveBeenCalled();\n });",10,1,10,383.8692436481891,0.01369082927563323,100,"  it('should not start collection when adding draggable of different type', () => {\n  const callbacks: Callbacks = getCallbacksStub();\n  const registry: Registry = createRegistry();\n  const marshal: DimensionMarshal = createDimensionMarshal(\n    registry,\n    callbacks,\n  );\n  populate(registry, withScrollables);\n\n  marshal.startPublishing(defaultRequest);\n  expect(callbacks.collectionStarting).not.toHaveBeenCalled();\n\n  registry.draggable.register(\n    getDraggableEntry({ dimension: inAnotherType }),\n  );\n  expect(callbacks.collectionStarting).not.toHaveBeenCalled();\n});\n\nit('should ignore draggable registration when type does not match critical item', () => {\n  const callbacks: Callbacks = getCallbacksStub();\n  const registry: Registry = createRegistry();\n  const marshal: DimensionMarshal = createDimensionMarshal(\n    registry,\n    callbacks,\n  );\n  populate(registry, withScrollables);\n\n  marshal.startPublishing(defaultRequest);\n  \n  const beforeCount = Object.keys(registry.draggable.getAll()).length;\n  registry.draggable.register(\n    getDraggableEntry({ dimension: inAnotherType }),\n  );\n  const afterCount = Object.keys(registry.draggable.getAll()).length;\n\n  expect(afterCount).toBe(beforeCount + 1);\n  expect(callbacks.publishWhileDragging).not.toHaveBeenCalled();\n});",22,1,4.545454545454546,2644.8701175731453,0.026620766727584552,86.75874180510186
59,"it('should order published draggables by their index', () => {\n const beforeInHome1: DraggableDimension = {\n ...preset.inHome1,\n descriptor: {\n ...preset.inHome1.descriptor,\n id: 'b',\n index: 0,\n },\n };\n const beforeInHome2: DraggableDimension = {\n ...preset.inHome2,\n descriptor: {\n ...preset.inHome2.descriptor,\n // if ordered by a key, this would be first\n id: 'a',\n index: 1,\n },\n };\n const callbacks: Callbacks = getCallbacksStub();\n const registry: Registry = createRegistry();\n const marshal: DimensionMarshal = createDimensionMarshal(\n registry,\n callbacks,\n );\n populate(registry, withScrollables);\n\n // A publish has started\n marshal.startPublishing(defaultRequest);\n expect(callbacks.publishWhileDragging).not.toHaveBeenCalled();\n\n // publishing the higher index value first\n registry.draggable.register(\n getDraggableEntry({ dimension: beforeInHome2 }),\n );\n // publishing the lower index value second\n registry.draggable.register(\n getDraggableEntry({ dimension: beforeInHome1 }),\n );\n expect(callbacks.publishWhileDragging).not.toHaveBeenCalled();\n\n // Fire the collection / publish step\n requestAnimationFrame.step();\n const expected: Published = {\n ...empty,\n // we expect this to be ordered by index\n additions: [beforeInHome1, beforeInHome2],\n modified: [{ droppableId: scrollableHome.descriptor.id, scroll: origin }],\n };\n expect(callbacks.publishWhileDragging).toHaveBeenCalledWith(expected);\n });",16,1,6.25,1239.2967550046997,0.026275066754848315,92.01964728052478,"  it('should register draggables in correct order regardless of registration timing', () => {\n  const beforeInHome1: DraggableDimension = {\n    ...preset.inHome1,\n    descriptor: {\n      ...preset.inHome1.descriptor,\n      id: 'b',\n      index: 0,\n    },\n  };\n  const beforeInHome2: DraggableDimension = {\n    ...preset.inHome2,\n    descriptor: {\n      ...preset.inHome2.descriptor,\n      id: 'a', \n      index: 1,\n    },\n  };\n  const callbacks: Callbacks = getCallbacksStub();\n  const registry: Registry = createRegistry();\n  const marshal: DimensionMarshal = createDimensionMarshal(\n    registry,\n    callbacks,\n  );\n  populate(registry, withScrollables);\n\n  marshal.startPublishing(defaultRequest);\n  registry.draggable.register(\n    getDraggableEntry({ dimension: beforeInHome2 }),\n  );\n  registry.draggable.register(\n    getDraggableEntry({ dimension: beforeInHome1 }),\n  );\n\n  requestAnimationFrame.step();\n\n  const expected: Published = {\n    ...empty,\n    additions: [beforeInHome1, beforeInHome2],\n    modified: [{ droppableId: scrollableHome.descriptor.id, scroll: origin }],\n  };\n  expect(callbacks.publishWhileDragging).toHaveBeenCalledWith(expected);\n});\n\nit('should order draggables by index rather than registration order', () => {\n  const beforeInHome1: DraggableDimension = {\n    ...preset.inHome1,\n    descriptor: {\n      ...preset.inHome1.descriptor,\n      id: 'b',\n      index: 0,\n    },\n  };\n  const beforeInHome2: DraggableDimension = {\n    ...preset.inHome2,\n    descriptor: {\n      ...preset.inHome2.descriptor,\n      id: 'a',\n      index: 1,\n    },\n  };\n  const callbacks: Callbacks = getCallbacksStub();\n  const registry: Registry = createRegistry();\n  const marshal: DimensionMarshal = createDimensionMarshal(\n    registry,\n    callbacks,\n  );\n  populate(registry, withScrollables);\n\n  marshal.startPublishing(defaultRequest);\n  registry.draggable.register(\n    getDraggableEntry({ dimension: beforeInHome2 }),\n  );\n  registry.draggable.register(\n    getDraggableEntry({ dimension: beforeInHome1 }),\n  );\n\n  requestAnimationFrame.step();\n\n  const published = callbacks.publishWhileDragging.mock.calls[0][0];\n  expect(published.additions[0].descriptor.index).toBeLessThan(published.additions[1].descriptor.index);\n});",28,1,3.571428571428571,3714.0510100382435,0.038770923040160096,79.91928071943012
60,"it(""resolves the promise"", async () => {\n expect(loadResult).toBeAPromise();\n await expect(loadResult).resolves.toBe(true);\n });",4,1,25,69.2855036029534,0.004755658758365788,100,"    it(""resolves the promise"", async () => {\n      await expect(loadResult).resolves.toBe(true);\n    });",3,1,33.33333333333333,33,0.0034294254927005915,100
61,"it(""resolves the promise"", async () => {\n expect(loadResult).toBeAPromise();\n await expect(loadResult).resolves.toBe(true);\n });",4,1,25,69.2855036029534,0.004755658758365788,100,"    it(""resolves the promise"", async () => {\n      await expect(loadResult).resolves.toBe(true);\n    });",3,1,33.33333333333333,33,0.0034294254927005915,100
62,"test(""typing/deleting different area codes should update the selected country"", async () => {\n // typing area code starting with 1 changes to Russia\n await user.type(input, ""1"");\n expect(checkFlagSelected(container, ""ru"")).toBe(true);\n\n // deleting area code keeps Russia selected\n await user.type(input, ""{backspace}"");\n expect(checkFlagSelected(container, ""ru"")).toBe(true);\n\n // typing area code starting with 7 changes to Kazakhstan\n await user.type(input, ""7"");\n expect(checkFlagSelected(container, ""kz"")).toBe(true);\n\n // deleting area code keeps Kazakhstan selected\n await user.type(input, ""{backspace}"");\n expect(checkFlagSelected(container, ""kz"")).toBe(true);\n });",10,1,10,684,0.013298799522301948,100,"  test(""typing/deleting different area codes should update the selected country"", async () => {\n    // Test Russia selection\n    await user.type(input, ""1"");\n    expect(checkFlagSelected(container, ""ru"")).toBe(true);\n    await user.type(input, ""{backspace}"");\n    expect(checkFlagSelected(container, ""ru"")).toBe(true);\n\n    // Test Kazakhstan selection \n    await user.type(input, ""7"");\n    expect(checkFlagSelected(container, ""kz"")).toBe(true);\n    await user.type(input, ""{backspace}"");\n    expect(checkFlagSelected(container, ""kz"")).toBe(true);\n  });",10,1,10,684,0.013298799522301948,100
63,"test(""typing/deleting different area codes should update the selected country"", async () => {\n // typing area code starting with 1 changes to Russia\n await user.type(input, ""1"");\n expect(checkFlagSelected(container, ""ru"")).toBe(true);\n\n // deleting area code keeps Russia selected\n await user.type(input, ""{backspace}"");\n expect(checkFlagSelected(container, ""ru"")).toBe(true);\n\n // typing area code starting with 7 changes to Kazakhstan\n await user.type(input, ""7"");\n expect(checkFlagSelected(container, ""kz"")).toBe(true);\n\n // deleting area code keeps Kazakhstan selected\n await user.type(input, ""{backspace}"");\n expect(checkFlagSelected(container, ""kz"")).toBe(true);\n });",10,1,10,684,0.013298799522301948,100,"  test(""typing/deleting different area codes should update the selected country"", async () => {\n    // Test area code starting with 1 (Russia)\n    await user.type(input, ""1"");\n    expect(checkFlagSelected(container, ""ru"")).toBe(true);\n    await user.type(input, ""{backspace}"");\n    expect(checkFlagSelected(container, ""ru"")).toBe(true);\n\n    // Test area code starting with 7 (Kazakhstan) \n    await user.type(input, ""7"");\n    expect(checkFlagSelected(container, ""kz"")).toBe(true);\n    await user.type(input, ""{backspace}"");\n    expect(checkFlagSelected(container, ""kz"")).toBe(true);\n  });",10,1,10,684,0.013298799522301948,100
64,"test(""instances have different country lists"", () => {\n expect(getCountryListLength(container1)).toEqual(2);\n expect(getCountryListLength(container2)).toEqual(4);\n });",4,1,25,96.86408532184431,0.005803563964543929,100,"  // The expected country list lengths are based on the onlyCountries options:\n  // container1: [""af"", ""cn""] = 2 countries\n  // container2: [""al"", ""cn"", ""kr"", ""ru""] = 4 countries\n  test(""instances have different country lists"", () => {\n    const expectedCountriesInFirstInstance = 2;\n    const expectedCountriesInSecondInstance = 4;\n    expect(getCountryListLength(container1)).toEqual(expectedCountriesInFirstInstance);\n    expect(getCountryListLength(container2)).toEqual(expectedCountriesInSecondInstance);\n  });",6,1,16.666666666666664,134.56144429603972,0.006818271755542721,100
65,"test(""instances have different country lists"", () => {\n expect(getCountryListLength(container1)).toEqual(2);\n expect(getCountryListLength(container2)).toEqual(4);\n });",4,1,25,96.86408532184431,0.005803563964543929,100,"  // The expected country list lengths are based on the onlyCountries arrays defined in beforeEach:\n  // container1: [""af"", ""cn""] = 2 countries\n  // container2: [""al"", ""cn"", ""kr"", ""ru""] = 4 countries\n  test(""instances have different country lists"", () => {\n    const expectedCountriesInFirstInstance = 2;\n    const expectedCountriesInSecondInstance = 4;\n    expect(getCountryListLength(container1)).toEqual(expectedCountriesInFirstInstance);\n    expect(getCountryListLength(container2)).toEqual(expectedCountriesInSecondInstance);\n  });",6,1,16.666666666666664,134.56144429603972,0.006818271755542721,100
66,"test(""shows the right number of results"", () => {\n expect(getCountryListLength(container)).toBe(6);\n });",3,1,33.33333333333333,38.039100017307746,0.0037702102294917654,100,"    // The number 6 represents the total count of countries containing 'x' in their name\n    const COUNTRIES_WITH_X = 6;\n    test(""shows the right number of results"", () => {\n      expect(getCountryListLength(container)).toBe(COUNTRIES_WITH_X);\n    });",4,1,25,52.32036749447595,0.004310797154389855,100
67,"test(""undefined shorthand updates the record and returns the model"", () => {\n let handler = new PutShorthandRouteHandler(\n schema,\n serializer,\n undefined,\n ""/authors/:id""\n );\n let request = {\n requestBody: JSON.stringify(body),\n url: ""/authors/1"",\n params: { id: ""1"" },\n };\n\n let model = handler.handle(request);\n\n expect(schema.db.authors).toHaveLength(1);\n expect(model instanceof Model).toBeTruthy();\n expect(model.modelName).toBe(""author"");\n expect(model.firstName).toBe(""Ganondorf"");\n });",9,1,11.11111111111111,661.698392771657,0.015776096763738867,100,"  test(""undefined shorthand updates the record and returns the model"", () => {\n    let handler = new PutShorthandRouteHandler(\n      schema,\n      serializer,\n      undefined,\n      ""/authors/:id""\n    );\n    let request = {\n      requestBody: JSON.stringify(body),\n      url: ""/authors/1"",\n      params: { id: ""1"" },\n    };\n\n    let model = handler.handle(request);\n\n    expect(schema.db.authors).toHaveLength(1);\n    expect(model).toBeInstanceOf(Model);\n    expect(model.modelName).toBe(""author"");\n    expect(model.firstName).toBe(""Ganondorf"");\n  });",9,1,11.11111111111111,430.56344644588603,0.015523099887158753,100
68,"test(""query params are ignored"", () => {\n let handler = new PutShorthandRouteHandler(schema, serializer, ""author"");\n let request = {\n requestBody: JSON.stringify(body),\n url: ""/authors/1?foo=bar"",\n params: { id: ""1"" },\n queryParams: { foo: ""bar"" },\n };\n\n let model = handler.handle(request);\n\n expect(schema.db.authors).toHaveLength(1);\n expect(model instanceof Model).toBeTruthy();\n expect(model.modelName).toBe(""author"");\n expect(model.firstName).toBe(""Ganondorf"");\n });",9,1,11.11111111111111,698.2236506816334,0.016191203977699763,100,"  test(""query params are ignored"", () => {\n    let handler = new PutShorthandRouteHandler(schema, serializer, ""author"");\n    let request = {\n      requestBody: JSON.stringify(body),\n      url: ""/authors/1?foo=bar"", \n      params: { id: ""1"" },\n      queryParams: { foo: ""bar"" },\n    };\n\n    let model = handler.handle(request);\n\n    expect(schema.db.authors).toHaveLength(1);\n    expect(model).toBeInstanceOf(Model);\n    expect(model.modelName).toBe(""author"");\n    expect(model.firstName).toBe(""Ganondorf"");\n  });",9,1,11.11111111111111,454.69199143674905,0.015940006096108274,100
69,"test(""string shorthand updates the record of the specified type and returns the model"", () => {\n let handler = new PutShorthandRouteHandler(\n schema,\n serializer,\n undefined,\n ""/authors/:id""\n );\n let request = {\n requestBody: JSON.stringify(body),\n url: ""/authors/1"",\n params: { id: ""1"" },\n };\n\n let model = handler.handle(request);\n\n expect(schema.db.authors).toHaveLength(1);\n expect(model instanceof Model).toBeTruthy();\n expect(model.modelName).toBe(""author"");\n expect(model.firstName).toBe(""Ganondorf"");\n });",9,1,11.11111111111111,661.698392771657,0.015776096763738867,100,"  test(""string shorthand updates the record of the specified type and returns the model"", () => {\n    let handler = new PutShorthandRouteHandler(\n      schema,\n      serializer,\n      undefined,\n      ""/authors/:id""\n    );\n    let request = {\n      requestBody: JSON.stringify(body),\n      url: ""/authors/1"",\n      params: { id: ""1"" },\n    };\n\n    let model = handler.handle(request);\n\n    expect(schema.db.authors).toHaveLength(1);\n    expect(model).toBeInstanceOf(Model);\n    expect(model.modelName).toBe(""author"");\n    expect(model.firstName).toBe(""Ganondorf"");\n  });",9,1,11.11111111111111,430.56344644588603,0.015523099887158753,100
70,"test(""string shorthand creates a record of the specified type and returns the new model"", () => {\n let request = { requestBody: JSON.stringify(body), url: ""/people"" };\n let handler = new PostShorthandRouteHandler(schema, serializer, ""author"");\n\n let model = handler.handle(request);\n\n expect(schema.db.authors).toHaveLength(1);\n expect(model instanceof Model).toBeTruthy();\n expect(model.modelName).toBe(""author"");\n expect(model.firstName).toBe(""Ganon"");\n });",9,1,11.11111111111111,621.5394754437457,0.014751986135897779,100,"  test(""string shorthand creates a record of the specified type and returns the new model"", () => {\n    let request = { requestBody: JSON.stringify(body), url: ""/people"" };\n    let handler = new PostShorthandRouteHandler(schema, serializer, ""author"");\n\n    let model = handler.handle(request);\n\n    expect(schema.db.authors).toHaveLength(1);\n    expect(model).toBeInstanceOf(Model); \n    expect(model.modelName).toBe(""author"");\n    expect(model.firstName).toBe(""Ganon"");\n  });",9,1,11.11111111111111,403.39234781763025,0.014490519668047711,100
71,"test(""query params are ignored"", () => {\n let request = {\n requestBody: JSON.stringify(body),\n url: ""/authors?foo=bar"",\n queryParams: { foo: ""bar"" },\n };\n let handler = new PostShorthandRouteHandler(schema, serializer, ""author"");\n\n let model = handler.handle(request);\n\n expect(schema.db.authors).toHaveLength(1);\n expect(model instanceof Model).toBeTruthy();\n expect(model.modelName).toBe(""author"");\n expect(model.firstName).toBe(""Ganon"");\n });",9,1,11.11111111111111,651.4835005151442,0.015523099887158753,100,"  test(""query params are ignored"", () => {\n    let request = {\n      requestBody: JSON.stringify(body),\n      url: ""/authors?foo=bar"", \n      queryParams: { foo: ""bar"" },\n    };\n    let handler = new PostShorthandRouteHandler(schema, serializer, ""author"");\n\n    let model = handler.handle(request);\n\n    expect(schema.db.authors).toHaveLength(1);\n    expect(model).toBeInstanceOf(Model);\n    expect(model.modelName).toBe(""author"");\n    expect(model.firstName).toBe(""Ganon"");\n  });",9,1,11.11111111111111,423.6666666666667,0.015268154331276774,100
72,"test(""create allows to create objects with associations"", () => {\n let AuthorFactory = Factory.extend({\n name: ""Sam"",\n });\n let CategoryFactory = Factory.extend({\n name: ""splendid software"",\n });\n let ArticleFactory = Factory.extend({\n title: ""Lorem ipsum"",\n\n withCategory: trait({\n awesomeCategory: association(),\n }),\n\n author: association(),\n });\n\n let server = new Server({\n environment: ""test"",\n models: {\n author: Model.extend({\n articles: hasMany(),\n }),\n category: Model.extend({}),\n article: Model.extend({\n author: belongsTo(),\n awesomeCategory: belongsTo(""category""),\n }),\n },\n factories: {\n article: ArticleFactory,\n author: AuthorFactory,\n category: CategoryFactory,\n },\n });\n\n let article = server.create(""article"", ""withCategory"");\n\n expect(article.attrs).toEqual({\n title: ""Lorem ipsum"",\n id: ""1"",\n authorId: ""1"",\n awesomeCategoryId: ""1"",\n });\n expect(server.db.authors).toHaveLength(1);\n expect(server.db.categories).toHaveLength(1);\n\n let anotherArticle = server.create(""article"", ""withCategory"");\n expect(anotherArticle.attrs).toEqual({\n title: ""Lorem ipsum"",\n id: ""2"",\n authorId: ""2"",\n awesomeCategoryId: ""2"",\n });\n expect(server.db.authors).toHaveLength(2);\n expect(server.db.categories).toHaveLength(2);\n\n server.shutdown();\n });",15,1,6.666666666666667,2324.9696224554746,0.031087604039888205,91.75329947526893,"  test(""create allows to create objects with associations"", () => {\n  let AuthorFactory = Factory.extend({\n    name: ""Sam"",\n  });\n  let CategoryFactory = Factory.extend({\n    name: ""splendid software"", \n  });\n  let ArticleFactory = Factory.extend({\n    title: ""Lorem ipsum"",\n\n    withCategory: trait({\n      awesomeCategory: association(),\n    }),\n\n    author: association(),\n  });\n\n  let server = new Server({\n    environment: ""test"",\n    models: {\n      author: Model.extend({\n        articles: hasMany(),\n      }),\n      category: Model.extend({}),\n      article: Model.extend({\n        author: belongsTo(),\n        awesomeCategory: belongsTo(""category""),\n      }),\n    },\n    factories: {\n      article: ArticleFactory,\n      author: AuthorFactory,\n      category: CategoryFactory,\n    },\n  });\n\n  // Create first article and verify initial state\n  let article = server.create(""article"", ""withCategory"");\n  expect(article.attrs).toEqual({\n    title: ""Lorem ipsum"",\n    id: ""1"", \n    authorId: ""1"",\n    awesomeCategoryId: ""1"",\n  });\n  let initialAuthorsCount = server.db.authors.length;\n  let initialCategoriesCount = server.db.categories.length;\n  expect(initialAuthorsCount).toBe(1);\n  expect(initialCategoriesCount).toBe(1);\n\n  // Create second article and verify incremental changes\n  let anotherArticle = server.create(""article"", ""withCategory"");\n  expect(anotherArticle.attrs).toEqual({\n    title: ""Lorem ipsum"",\n    id: ""2"",\n    authorId: ""2"", \n    awesomeCategoryId: ""2"",\n  });\n  expect(server.db.authors.length).toBe(initialAuthorsCount + 1);\n  expect(server.db.categories.length).toBe(initialCategoriesCount + 1);\n\n  server.shutdown();\n});",17,1,5.88235294117647,3987.664578418345,0.03356953255488046,89.12654066071678
73,"test(""create allows to create objects with associations"", () => {\n let AuthorFactory = Factory.extend({\n name: ""Sam"",\n });\n let CategoryFactory = Factory.extend({\n name: ""splendid software"",\n });\n let ArticleFactory = Factory.extend({\n title: ""Lorem ipsum"",\n\n withCategory: trait({\n awesomeCategory: association(),\n }),\n\n author: association(),\n });\n\n let server = new Server({\n environment: ""test"",\n models: {\n author: Model.extend({\n articles: hasMany(),\n }),\n category: Model.extend({}),\n article: Model.extend({\n author: belongsTo(),\n awesomeCategory: belongsTo(""category""),\n }),\n },\n factories: {\n article: ArticleFactory,\n author: AuthorFactory,\n category: CategoryFactory,\n },\n });\n\n let article = server.create(""article"", ""withCategory"");\n\n expect(article.attrs).toEqual({\n title: ""Lorem ipsum"",\n id: ""1"",\n authorId: ""1"",\n awesomeCategoryId: ""1"",\n });\n expect(server.db.authors).toHaveLength(1);\n expect(server.db.categories).toHaveLength(1);\n\n let anotherArticle = server.create(""article"", ""withCategory"");\n expect(anotherArticle.attrs).toEqual({\n title: ""Lorem ipsum"",\n id: ""2"",\n authorId: ""2"",\n awesomeCategoryId: ""2"",\n });\n expect(server.db.authors).toHaveLength(2);\n expect(server.db.categories).toHaveLength(2);\n\n server.shutdown();\n });",15,1,6.666666666666667,2324.9696224554746,0.031087604039888205,91.75329947526893,"  test(""create allows to create objects with associations"", () => {\n  let AuthorFactory = Factory.extend({\n    name: ""Sam"",\n  });\n  let CategoryFactory = Factory.extend({\n    name: ""splendid software"", \n  });\n  let ArticleFactory = Factory.extend({\n    title: ""Lorem ipsum"",\n\n    withCategory: trait({\n      awesomeCategory: association(),\n    }),\n\n    author: association(),\n  });\n\n  let server = new Server({\n    environment: ""test"",\n    models: {\n      author: Model.extend({\n        articles: hasMany(),\n      }),\n      category: Model.extend({}),\n      article: Model.extend({\n        author: belongsTo(),\n        awesomeCategory: belongsTo(""category""),\n      }),\n    },\n    factories: {\n      article: ArticleFactory,\n      author: AuthorFactory,\n      category: CategoryFactory,\n    },\n  });\n\n  // Create first article and verify initial state\n  let article = server.create(""article"", ""withCategory"");\n  expect(article.attrs).toEqual({\n    title: ""Lorem ipsum"",\n    id: ""1"", \n    authorId: ""1"",\n    awesomeCategoryId: ""1"",\n  });\n  let initialCounts = {\n    authors: server.db.authors.length,\n    categories: server.db.categories.length\n  };\n  expect(initialCounts).toEqual({authors: 1, categories: 1});\n\n  // Create second article and verify incremental changes\n  let anotherArticle = server.create(""article"", ""withCategory"");\n  expect(anotherArticle.attrs).toEqual({\n    title: ""Lorem ipsum"",\n    id: ""2"",\n    authorId: ""2"", \n    awesomeCategoryId: ""2"",\n  });\n  let finalCounts = {\n    authors: server.db.authors.length,\n    categories: server.db.categories.length\n  };\n  expect(finalCounts).toEqual({authors: 2, categories: 2});\n\n  server.shutdown();\n});",15,1,6.666666666666667,2641.762457857885,0.03258463467616389,91.38645227371316
74,"test(""create allows to create objects with associations"", () => {\n let AuthorFactory = Factory.extend({\n name: ""Sam"",\n });\n let CategoryFactory = Factory.extend({\n name: ""splendid software"",\n });\n let ArticleFactory = Factory.extend({\n title: ""Lorem ipsum"",\n\n withCategory: trait({\n awesomeCategory: association(),\n }),\n\n author: association(),\n });\n\n let server = new Server({\n environment: ""test"",\n models: {\n author: Model.extend({\n articles: hasMany(),\n }),\n category: Model.extend({}),\n article: Model.extend({\n author: belongsTo(),\n awesomeCategory: belongsTo(""category""),\n }),\n },\n factories: {\n article: ArticleFactory,\n author: AuthorFactory,\n category: CategoryFactory,\n },\n });\n\n let article = server.create(""article"", ""withCategory"");\n\n expect(article.attrs).toEqual({\n title: ""Lorem ipsum"",\n id: ""1"",\n authorId: ""1"",\n awesomeCategoryId: ""1"",\n });\n expect(server.db.authors).toHaveLength(1);\n expect(server.db.categories).toHaveLength(1);\n\n let anotherArticle = server.create(""article"", ""withCategory"");\n expect(anotherArticle.attrs).toEqual({\n title: ""Lorem ipsum"",\n id: ""2"",\n authorId: ""2"",\n awesomeCategoryId: ""2"",\n });\n expect(server.db.authors).toHaveLength(2);\n expect(server.db.categories).toHaveLength(2);\n\n server.shutdown();\n });",15,1,6.666666666666667,2324.9696224554746,0.031087604039888205,91.75329947526893,"  test(""create allows to create objects with associations"", () => {\n  let AuthorFactory = Factory.extend({\n    name: ""Sam"",\n  });\n  let CategoryFactory = Factory.extend({\n    name: ""splendid software"", \n  });\n  let ArticleFactory = Factory.extend({\n    title: ""Lorem ipsum"",\n\n    withCategory: trait({\n      awesomeCategory: association(),\n    }),\n\n    author: association(),\n  });\n\n  let server = new Server({\n    environment: ""test"",\n    models: {\n      author: Model.extend({\n        articles: hasMany(),\n      }),\n      category: Model.extend({}),\n      article: Model.extend({\n        author: belongsTo(),\n        awesomeCategory: belongsTo(""category""),\n      }),\n    },\n    factories: {\n      article: ArticleFactory,\n      author: AuthorFactory,\n      category: CategoryFactory,\n    },\n  });\n\n  // Create first article and verify initial state\n  let article = server.create(""article"", ""withCategory"");\n\n  expect(article.attrs).toEqual({\n    title: ""Lorem ipsum"",\n    id: ""1"", \n    authorId: ""1"",\n    awesomeCategoryId: ""1"",\n  });\n  expect(server.db.authors).toHaveLength(1);\n  expect(server.db.categories).toHaveLength(1);\n\n  // Create second article and verify incremented IDs\n  let anotherArticle = server.create(""article"", ""withCategory"");\n  \n  expect(anotherArticle.attrs).toEqual({\n    title: ""Lorem ipsum"",\n    id: ""2"",\n    authorId: ""2"", \n    awesomeCategoryId: ""2"",\n  });\n  \n  // Verify final counts\n  const finalCounts = {\n    authors: server.db.authors.length,\n    categories: server.db.categories.length\n  };\n  expect(finalCounts).toEqual({authors: 2, categories: 2});\n\n  server.shutdown();\n});",15,1,6.666666666666667,2440.6863414271543,0.031957379532890524,91.53806651202873
75,"test(""create allows to create objects with associations"", () => {\n let AuthorFactory = Factory.extend({\n name: ""Sam"",\n });\n let CategoryFactory = Factory.extend({\n name: ""splendid software"",\n });\n let ArticleFactory = Factory.extend({\n title: ""Lorem ipsum"",\n\n withCategory: trait({\n awesomeCategory: association(),\n }),\n\n author: association(),\n });\n\n let server = new Server({\n environment: ""test"",\n models: {\n author: Model.extend({\n articles: hasMany(),\n }),\n category: Model.extend({}),\n article: Model.extend({\n author: belongsTo(),\n awesomeCategory: belongsTo(""category""),\n }),\n },\n factories: {\n article: ArticleFactory,\n author: AuthorFactory,\n category: CategoryFactory,\n },\n });\n\n let article = server.create(""article"", ""withCategory"");\n\n expect(article.attrs).toEqual({\n title: ""Lorem ipsum"",\n id: ""1"",\n authorId: ""1"",\n awesomeCategoryId: ""1"",\n });\n expect(server.db.authors).toHaveLength(1);\n expect(server.db.categories).toHaveLength(1);\n\n let anotherArticle = server.create(""article"", ""withCategory"");\n expect(anotherArticle.attrs).toEqual({\n title: ""Lorem ipsum"",\n id: ""2"",\n authorId: ""2"",\n awesomeCategoryId: ""2"",\n });\n expect(server.db.authors).toHaveLength(2);\n expect(server.db.categories).toHaveLength(2);\n\n server.shutdown();\n });",15,1,6.666666666666667,2324.9696224554746,0.031087604039888205,91.75329947526893,"  test(""create allows to create objects with associations"", () => {\n  let AuthorFactory = Factory.extend({\n    name: ""Sam"",\n  });\n  let CategoryFactory = Factory.extend({\n    name: ""splendid software"", \n  });\n  let ArticleFactory = Factory.extend({\n    title: ""Lorem ipsum"",\n\n    withCategory: trait({\n      awesomeCategory: association(),\n    }),\n\n    author: association(),\n  });\n\n  let server = new Server({\n    environment: ""test"",\n    models: {\n      author: Model.extend({\n        articles: hasMany(),\n      }),\n      category: Model.extend({}),\n      article: Model.extend({\n        author: belongsTo(),\n        awesomeCategory: belongsTo(""category""),\n      }),\n    },\n    factories: {\n      article: ArticleFactory,\n      author: AuthorFactory,\n      category: CategoryFactory,\n    },\n  });\n\n  // Create first article and verify initial state\n  let article = server.create(""article"", ""withCategory"");\n  expect(article.attrs).toEqual({\n    title: ""Lorem ipsum"",\n    id: ""1"", \n    authorId: ""1"",\n    awesomeCategoryId: ""1"",\n  });\n  let initialState = {\n    authors: 1,\n    categories: 1\n  };\n  expect(server.db.authors).toHaveLength(initialState.authors);\n  expect(server.db.categories).toHaveLength(initialState.categories);\n\n  // Create second article and verify incremented state\n  let anotherArticle = server.create(""article"", ""withCategory"");\n  expect(anotherArticle.attrs).toEqual({\n    title: ""Lorem ipsum"",\n    id: ""2"",\n    authorId: ""2"", \n    awesomeCategoryId: ""2"",\n  });\n  let finalState = {\n    authors: initialState.authors + 1,\n    categories: initialState.categories + 1\n  };\n  expect(server.db.authors).toHaveLength(finalState.authors);\n  expect(server.db.categories).toHaveLength(finalState.categories);\n\n  server.shutdown();\n});",17,1,5.88235294117647,4562.914363089185,0.034678581143156806,88.87301451634124
76,"test(""routes return pretender handler"", () => {\n let server = new Server({ environment: ""test"" });\n\n let handler = server.post(""foo"");\n\n expect(handler.numberOfCalls).toBe(0);\n\n server.shutdown();\n });",6,1,16.666666666666664,132.83428025068963,0.0072568555296063835,100,"  test(""routes return pretender handler with initial call count of zero"", () => {\n    let server = new Server({ environment: ""test"" });\n\n    let handler = server.post(""foo"");\n\n    const INITIAL_CALL_COUNT = 0;\n    expect(handler.numberOfCalls).toBe(INITIAL_CALL_COUNT);\n\n    server.shutdown();\n  });",7,1,14.285714285714285,152,0.007745047644751603,100
77,"test(""routes return pretender handler"", async () => {\n let server = createServer({ environment: ""test"" });\n\n let handler = server.post(""foo"");\n\n expect(handler.numberOfCalls).toBe(0);\n\n server.shutdown();\n });",6,1,16.666666666666664,137.94329102956232,0.0074417559145820295,100,"  test(""routes return pretender handler"", async () => {\n  let server = createServer({ environment: ""test"" });\n\n  let handler = server.post(""foo"");\n\n  // Initial number of calls should be zero when handler is first created\n  const expectedInitialCalls = 0;\n  expect(handler.numberOfCalls).toBe(expectedInitialCalls);\n\n  server.shutdown();\n});",7,1,14.285714285714285,157.42857142857144,0.007928372955436724,100
78,"test(""forces timing to be 0 in test environment"", async () => {\n let server = createServer({ environment: ""test"" });\n\n expect(server.timing).toBe(0);\n\n server.shutdown();\n });",5,1,20,97.86947626968757,0.0059431225621341555,100,"  test(""forces timing to be 0 in test environment"", async () => {\n  // Zero timing is used to ensure synchronous responses in test environment\n  const TEST_TIMING = 0;\n  let server = createServer({ environment: ""test"" });\n\n  expect(server.timing).toBe(TEST_TIMING);\n\n  server.shutdown();\n});",6,1,16.666666666666664,116.05924570533425,0.0064496011531267276,100
79,"test(""allows setting the timing to 0"", async () => {\n let server = createServer({ timing: 0 });\n\n expect(server.timing).toBe(0);\n\n server.shutdown();\n });",5,1,20,104.936092431998,0.005803563964543929,100,"  test(""allows setting the timing to zero"", async () => {\n  // Zero timing means no artificial delay between requests\n  const NO_DELAY = 0;\n  let server = createServer({ timing: NO_DELAY });\n\n  expect(server.timing).toBe(NO_DELAY);\n\n  server.shutdown();\n});",6,1,16.666666666666664,123.68120627487988,0.006314714413404747,100
80,"test(""forces timing to 0 in test environment"", () => {\n let server = new Server({ environment: ""test"" });\n\n server.loadConfig(function () {\n this.timing = 50;\n });\n\n expect(server.timing).toBe(0);\n\n server.shutdown();\n });",8,1,12.5,232.45999043870685,0.00762438701005102,100,"  test(""forces timing to 0 in test environment"", () => {\n    // Define timing constant to avoid magic number\n    const ARBITRARY_TIMING_VALUE = 50;\n    \n    let server = new Server({ environment: ""test"" });\n\n    server.loadConfig(function () {\n      this.timing = ARBITRARY_TIMING_VALUE;\n    });\n\n    expect(server.timing).toBe(0);\n\n    server.shutdown();\n});",9,1,11.11111111111111,263.07692307692304,0.008109602660764532,100
81,"test(""`first()` returns null when nothing is found"", () => {\n expect.assertions(2);\n\n let db = new Db();\n let schema = new Schema(db);\n\n let authorModel = Model.extend({});\n schema.registerModel(""author"", authorModel);\n\n expect(schema.first(""author"")).toBeNull();\n\n let record = schema.create(""author"", { id: 1, name: ""Mary Roach"" });\n\n expect(schema.first(""author"")).toEqual(record);\n });",10,1,10,399.77544590234584,0.013418574436768223,100,"  test(""`first()` returns expected results for empty and populated schema"", () => {\n    expect.assertions(2);\n\n    let db = new Db();\n    let schema = new Schema(db);\n\n    let authorModel = Model.extend({});\n    schema.registerModel(""author"", authorModel);\n\n    // Test empty schema returns null\n    expect(schema.first(""author"")).toBeNull();\n\n    // Test populated schema returns first record\n    let record = schema.create(""author"", { id: 1, name: ""Mary Roach"" });\n\n    expect(schema.first(""author"")).toEqual(record);\n  });",10,1,10,399.77544590234584,0.013418574436768223,100
82,"it("""", () => {\n uiframe.default();\n });",3,1,33.33333333333333,18.094737505048094,0.0022974545934948596,100,"    it(""should initialize uiframe by calling default function"", () => {\n        uiframe.default();\n    });",3,1,33.33333333333333,18.094737505048094,0.0022974545934948596,100
83,"test(""verify local shortcuts for markdown preview"", async () => {\n document.execCommand = jest.fn();\n\n expect(normal.mappings.find('of')).toBe(undefined);\n expect(document.execCommand).toHaveBeenCalledTimes(0);\n\n await waitForEvent(document, ""surfingkeys:defaultSettingsLoaded"", () => {\n return true;\n }, () => {\n dispatchSKEvent('defaultSettingsLoaded', {normal, api});\n });\n\n expect(normal.mappings.find('of').meta.word).toBe('of');\n expect(document.execCommand).toHaveBeenCalledTimes(1);\n });",12,1,8.333333333333332,879.7996950694521,0.01588680007216953,100,"    test(""verify local shortcuts for markdown preview"", async () => {\n        document.execCommand = jest.fn();\n\n        // More specific assertion for initial state\n        expect(normal.mappings.find('of')).toBeUndefined();\n        expect(document.execCommand).toHaveBeenCalledTimes(0);\n\n        await waitForEvent(document, ""surfingkeys:defaultSettingsLoaded"", () => {\n            return true;\n        }, () => {\n            dispatchSKEvent('defaultSettingsLoaded', {normal, api});\n        });\n\n        // More specific assertions for final state\n        const mapping = normal.mappings.find('of');\n        expect(mapping).toBeDefined();\n        expect(mapping.meta.word).toBe('of');\n        expect(document.execCommand).toHaveBeenCalledTimes(1);\n    });",14,1,7.142857142857142,999.4490882957758,0.017184755333227466,97.49471855944071
84,"test(""render markdown from clipboard"", async () => {\n jest.spyOn(clipboard, 'read').mockImplementationOnce((onReady) => {\n onReady({data: ""* [github](https://github.com)\n* [google](https://google.com)""});\n });\n await waitForEvent(document, ""surfingkeys:defaultSettingsLoaded"", () => {\n return true;\n }, () => {\n dispatchSKEvent('defaultSettingsLoaded', {normal, api});\n });\n const links = document.querySelectorAll(""a"");\n expect(links.length).toBe(2);\n expect(links[0].href).toBe(""https://github.com/"");\n });",13,1,7.6923076923076925,340.05866965893006,0.013659824705468218,100,"    test(""render markdown from clipboard"", async () => {\n        jest.spyOn(clipboard, 'read').mockImplementationOnce((onReady) => {\n            onReady({data: ""* [github](https://github.com)\n* [google](https://google.com)""});\n        });\n        await waitForEvent(document, ""surfingkeys:defaultSettingsLoaded"", () => {\n            return true;\n        }, () => {\n            dispatchSKEvent('defaultSettingsLoaded', {normal, api});\n        });\n        const links = document.querySelectorAll(""a"");\n        expect(links).toHaveLength(2);\n        expect(links[0]).toHaveProperty('href', 'https://github.com/');\n    });",13,1,7.6923076923076925,311.99033502041516,0.013149101274512484,100
85,"test(""follow links generated from markdown"", async () => {\n jest.spyOn(clipboard, 'read').mockImplementationOnce((onReady) => {\n onReady({data: ""* [github](https://github.com)\n* [google](https://google.com)""});\n });\n await waitForEvent(document, ""surfingkeys:defaultSettingsLoaded"", () => {\n return true;\n }, () => {\n dispatchSKEvent('defaultSettingsLoaded', {normal, api});\n });\n\n const links = document.querySelectorAll(""a"");\n links.forEach((l, i) => {\n l.getBoundingClientRect = jest.fn(() => {\n return { width: 100, height: 10, top: 100 * i, left: 0, bottom: 0, right: 0 };\n });\n });\n document.elementFromPoint = jest.fn(() => {\n return null;\n });\n expect(document.querySelector(""div.surfingkeys_hints_host"")).toBe(null);\n\n document.body.dispatchEvent(new KeyboardEvent('keydown', {'key': 'f'}));\n const hint_labels = document.querySelector(""div.surfingkeys_hints_host"").shadowRoot.querySelectorAll(""section>div"");\n expect(hint_labels.length).toBe(2);\n expect(hint_labels[0].label).toBe(""A"");\n expect(hint_labels[1].label).toBe(""S"");\n });",25,1,4,2452.7583388858225,0.02822356120721142,84.23181014885022,"    test(""follow links generated from markdown"", async () => {\n        jest.spyOn(clipboard, 'read').mockImplementationOnce((onReady) => {\n            onReady({data: ""* [github](https://github.com)\n* [google](https://google.com)""});\n        });\n        await waitForEvent(document, ""surfingkeys:defaultSettingsLoaded"", () => {\n            return true;\n        }, () => {\n            dispatchSKEvent('defaultSettingsLoaded', {normal, api});\n        });\n\n        const links = document.querySelectorAll(""a"");\n        links.forEach((l, i) => {\n            l.getBoundingClientRect = jest.fn(() => {\n                return { width: 100, height: 10, top: 100 * i, left: 0, bottom: 0, right: 0 };\n            });\n        });\n        document.elementFromPoint = jest.fn(() => {\n            return null;\n        });\n        // Use more specific assertion to check for element non-existence\n        expect(document.querySelector(""div.surfingkeys_hints_host"")).toBeNull();\n\n        document.body.dispatchEvent(new KeyboardEvent('keydown', {'key': 'f'}));\n        const hint_labels = document.querySelector(""div.surfingkeys_hints_host"").shadowRoot.querySelectorAll(""section>div"");\n        expect(hint_labels.length).toBe(2);\n        expect(hint_labels[0].label).toBe(""A"");\n        expect(hint_labels[1].label).toBe(""S"");\n    });",25,1,4,2418.3010790194767,0.028302719710739003,84.20996414302418
86,"test(""follow links generated from markdown"", async () => {\n jest.spyOn(clipboard, 'read').mockImplementationOnce((onReady) => {\n onReady({data: ""* [github](https://github.com)\n* [google](https://google.com)""});\n });\n await waitForEvent(document, ""surfingkeys:defaultSettingsLoaded"", () => {\n return true;\n }, () => {\n dispatchSKEvent('defaultSettingsLoaded', {normal, api});\n });\n\n const links = document.querySelectorAll(""a"");\n links.forEach((l, i) => {\n l.getBoundingClientRect = jest.fn(() => {\n return { width: 100, height: 10, top: 100 * i, left: 0, bottom: 0, right: 0 };\n });\n });\n document.elementFromPoint = jest.fn(() => {\n return null;\n });\n expect(document.querySelector(""div.surfingkeys_hints_host"")).toBe(null);\n\n document.body.dispatchEvent(new KeyboardEvent('keydown', {'key': 'f'}));\n const hint_labels = document.querySelector(""div.surfingkeys_hints_host"").shadowRoot.querySelectorAll(""section>div"");\n expect(hint_labels.length).toBe(2);\n expect(hint_labels[0].label).toBe(""A"");\n expect(hint_labels[1].label).toBe(""S"");\n });",25,1,4,2452.7583388858225,0.02822356120721142,84.23181014885022,"    test(""follow links generated from markdown"", async () => {\n        jest.spyOn(clipboard, 'read').mockImplementationOnce((onReady) => {\n            onReady({data: ""* [github](https://github.com)\n* [google](https://google.com)""});\n        });\n        await waitForEvent(document, ""surfingkeys:defaultSettingsLoaded"", () => {\n            return true;\n        }, () => {\n            dispatchSKEvent('defaultSettingsLoaded', {normal, api});\n        });\n\n        const links = document.querySelectorAll(""a"");\n        links.forEach((l, i) => {\n            l.getBoundingClientRect = jest.fn(() => {\n                return { width: 100, height: 10, top: 100 * i, left: 0, bottom: 0, right: 0 };\n            });\n        });\n        document.elementFromPoint = jest.fn(() => {\n            return null;\n        });\n        // Using more specific assertion to check for element non-existence\n        expect(document.querySelector(""div.surfingkeys_hints_host"")).toBeNull();\n\n        document.body.dispatchEvent(new KeyboardEvent('keydown', {'key': 'f'}));\n        const hint_labels = document.querySelector(""div.surfingkeys_hints_host"").shadowRoot.querySelectorAll(""section>div"");\n        expect(hint_labels.length).toBe(2);\n        expect(hint_labels[0].label).toBe(""A"");\n        expect(hint_labels[1].label).toBe(""S"");\n    });",25,1,4,2418.3010790194767,0.028302719710739003,84.20996414302418
87,"test(""normal /"", async () => {\n normal.enter();\n await new Promise((r) => {\n document.addEventListener(""surfingkeys:front"", function(evt) {\n if (evt.detail.length && evt.detail[0] === ""openFinder"") {\n r(evt);\n }\n });\n document.body.dispatchEvent(new KeyboardEvent('keydown',{'key':'/'}));\n });\n });",11,3,27.27272727272727,488.7570025768752,0.010938518570501323,100,"    test(""normal /"", async () => {\n        normal.enter();\n        await new Promise((r) => {\n            const handleEvent = (evt) => {\n                const isOpenFinderEvent = evt.detail.length && evt.detail[0] === ""openFinder"";\n                if (isOpenFinderEvent) {\n                    document.removeEventListener(""surfingkeys:front"", handleEvent);\n                    r(evt);\n                }\n            };\n            document.addEventListener(""surfingkeys:front"", handleEvent);\n            document.body.dispatchEvent(new KeyboardEvent('keydown',{'key':'/'}));\n        });\n    });",14,3,21.428571428571427,716.9543416305611,0.012962408193463495,99.441397351967
88,"test(""normal mouse up"", async () => {\n runtime.conf.mouseSelectToQuery = [ ""http://localhost"" ];\n await new Promise((r) => {\n document.addEventListener(""surfingkeys:front"", function(evt) {\n if (evt.detail.length && evt.detail[0] === ""querySelectedWord"") {\n r(evt);\n }\n });\n document.body.dispatchEvent(new MouseEvent('mouseup', {\n bubbles: true,\n cancelable: true,\n view: window,\n button: 0\n }));\n });\n });",11,3,27.27272727272727,753.6983954854685,0.012712876271219028,100,"    test(""normal mouse up"", async () => {\n        runtime.conf.mouseSelectToQuery = [ ""http://localhost"" ];\n        await new Promise((r) => {\n            const handleEvent = (evt) => {\n                r(evt);\n            };\n            document.addEventListener(""surfingkeys:front"", handleEvent);\n            document.body.dispatchEvent(new MouseEvent('mouseup', {\n                bubbles: true,\n                cancelable: true, \n                view: window,\n                button: 0\n            }));\n        });\n    });",10,1,10,306.2438659841055,0.010385774438608917,100
89,"test(""verify local shortcuts for markdown preview"", async () => {\n document.execCommand = jest.fn();\n\n expect(normal.mappings.find('of')).toBe(undefined);\n expect(document.execCommand).toHaveBeenCalledTimes(0);\n\n await waitForEvent(document, ""surfingkeys:defaultSettingsLoaded"", () => {\n return true;\n }, () => {\n dispatchSKEvent('defaultSettingsLoaded', {normal, api});\n });\n\n expect(normal.mappings.find('of').meta.word).toBe('of');\n expect(document.execCommand).toHaveBeenCalledTimes(1);\n });",12,1,8.333333333333332,879.7996950694521,0.01588680007216953,100,"    test(""verify local shortcuts for markdown preview"", async () => {\n        document.execCommand = jest.fn();\n\n        // Initial state check\n        expect(normal.mappings.find('of')).toBe(undefined);\n        \n        // Trigger settings load\n        await waitForEvent(document, ""surfingkeys:defaultSettingsLoaded"", () => {\n            return true;\n        }, () => {\n            dispatchSKEvent('defaultSettingsLoaded', {normal, api});\n        });\n\n        // Verify mapping and command execution after settings load\n        const mapping = normal.mappings.find('of');\n        expect(mapping.meta.word).toBe('of');\n        expect(document.execCommand).toHaveBeenCalledTimes(1);\n    });",12,1,8.333333333333332,733.8816968628114,0.014809194479950586,100
90,"test(""verify local shortcuts for markdown preview"", async () => {\n document.execCommand = jest.fn();\n\n expect(normal.mappings.find('of')).toBe(undefined);\n expect(document.execCommand).toHaveBeenCalledTimes(0);\n\n await waitForEvent(document, ""surfingkeys:defaultSettingsLoaded"", () => {\n return true;\n }, () => {\n dispatchSKEvent('defaultSettingsLoaded', {normal, api});\n });\n\n expect(normal.mappings.find('of').meta.word).toBe('of');\n expect(document.execCommand).toHaveBeenCalledTimes(1);\n });",12,1,8.333333333333332,879.7996950694521,0.01588680007216953,100,"    test(""verify local shortcuts for markdown preview"", async () => {\n        document.execCommand = jest.fn();\n\n        // Initial state check\n        expect(normal.mappings.find('of')).toBe(undefined);\n\n        // Trigger settings load\n        await waitForEvent(document, ""surfingkeys:defaultSettingsLoaded"", () => {\n            return true;\n        }, () => {\n            dispatchSKEvent('defaultSettingsLoaded', {normal, api});\n        });\n\n        // Verify mapping and command execution after settings load\n        const mapping = normal.mappings.find('of');\n        expect(mapping.meta.word).toBe('of');\n        expect(document.execCommand).toHaveBeenCalledTimes(1);\n    });",12,1,8.333333333333332,733.8816968628114,0.014809194479950586,100
91,"test(""render markdown from clipboard"", async () => {\n jest.spyOn(clipboard, 'read').mockImplementationOnce((onReady) => {\n onReady({data: ""* [github](https://github.com)\n* [google](https://google.com)""});\n });\n await waitForEvent(document, ""surfingkeys:defaultSettingsLoaded"", () => {\n return true;\n }, () => {\n dispatchSKEvent('defaultSettingsLoaded', {normal, api});\n });\n const links = document.querySelectorAll(""a"");\n expect(links.length).toBe(2);\n expect(links[0].href).toBe(""https://github.com/"");\n });",13,1,7.6923076923076925,340.05866965893006,0.013659824705468218,100,"    test(""render markdown from clipboard"", async () => {\n        // Number of expected links in the markdown content\n        const EXPECTED_LINKS_COUNT = 2;\n\n        jest.spyOn(clipboard, 'read').mockImplementationOnce((onReady) => {\n            onReady({data: ""* [github](https://github.com)\n* [google](https://google.com)""});\n        });\n        await waitForEvent(document, ""surfingkeys:defaultSettingsLoaded"", () => {\n            return true;\n        }, () => {\n            dispatchSKEvent('defaultSettingsLoaded', {normal, api});\n        });\n        const links = document.querySelectorAll(""a"");\n        expect(links.length).toBe(EXPECTED_LINKS_COUNT);\n        expect(links[0].href).toBe(""https://github.com/"");\n    });",14,1,7.142857142857142,363.1099040750304,0.014088832740230955,99.04411206973737
92,"test(""follow links generated from markdown"", async () => {\n jest.spyOn(clipboard, 'read').mockImplementationOnce((onReady) => {\n onReady({data: ""* [github](https://github.com)\n* [google](https://google.com)""});\n });\n await waitForEvent(document, ""surfingkeys:defaultSettingsLoaded"", () => {\n return true;\n }, () => {\n dispatchSKEvent('defaultSettingsLoaded', {normal, api});\n });\n\n const links = document.querySelectorAll(""a"");\n links.forEach((l, i) => {\n l.getBoundingClientRect = jest.fn(() => {\n return { width: 100, height: 10, top: 100 * i, left: 0, bottom: 0, right: 0 };\n });\n });\n document.elementFromPoint = jest.fn(() => {\n return null;\n });\n expect(document.querySelector(""div.surfingkeys_hints_host"")).toBe(null);\n\n document.body.dispatchEvent(new KeyboardEvent('keydown', {'key': 'f'}));\n const hint_labels = document.querySelector(""div.surfingkeys_hints_host"").shadowRoot.querySelectorAll(""section>div"");\n expect(hint_labels.length).toBe(2);\n expect(hint_labels[0].label).toBe(""A"");\n expect(hint_labels[1].label).toBe(""S"");\n });",25,1,4,2452.7583388858225,0.02822356120721142,84.23181014885022,"    test(""follow links generated from markdown"", async () => {\n        // Mock clipboard data with markdown links\n        jest.spyOn(clipboard, 'read').mockImplementationOnce((onReady) => {\n            onReady({data: ""* [github](https://github.com)\n* [google](https://google.com)""});\n        });\n        await waitForEvent(document, ""surfingkeys:defaultSettingsLoaded"", () => {\n            return true;\n        }, () => {\n            dispatchSKEvent('defaultSettingsLoaded', {normal, api});\n        });\n\n        const links = document.querySelectorAll(""a"");\n        \n        // Constants for link dimensions\n        const LINK_WIDTH = 100;\n        const LINK_HEIGHT = 10;\n        const LINK_VERTICAL_SPACING = 100;\n        \n        links.forEach((l, i) => {\n            l.getBoundingClientRect = jest.fn(() => {\n                return { \n                    width: LINK_WIDTH, \n                    height: LINK_HEIGHT, \n                    top: LINK_VERTICAL_SPACING * i, \n                    left: 0, \n                    bottom: 0, \n                    right: 0 \n                };\n            });\n        });\n        document.elementFromPoint = jest.fn(() => {\n            return null;\n        });\n        expect(document.querySelector(""div.surfingkeys_hints_host"")).toBe(null);\n\n        document.body.dispatchEvent(new KeyboardEvent('keydown', {'key': 'f'}));\n        const hint_labels = document.querySelector(""div.surfingkeys_hints_host"").shadowRoot.querySelectorAll(""section>div"");\n        expect(hint_labels.length).toBe(2);\n        expect(hint_labels[0].label).toBe(""A"");\n        expect(hint_labels[1].label).toBe(""S"");\n    });",28,1,3.571428571428571,2632.2068976432615,0.02930630548371461,82.10225004623082
93,"test(""toggle Omnibar's position"", async () => {\n const elmOmnibarClass = document.getElementById(""sk_omnibar"").classList;\n window.postMessage({surfingkeys_frontend_data: { action: ""openOmnibar"", type: ""URLs"", extra: ""getAllSites"" }}, document.location.origin);\n await new Promise((r) => setTimeout(r, 100));\n expect(elmOmnibarClass.value).toContain('sk_omnibar_middle');\n Mode.handleMapKey.call(omnibar, {\n sk_keyName: KeyboardUtils.encodeKeystroke(""<Ctrl-j>"")\n });\n await new Promise((r) => setTimeout(r, 100));\n expect(elmOmnibarClass.value).toContain('sk_omnibar_bottom');\n });",9,1,11.11111111111111,489.68861636912123,0.017013965260313183,100,"    test(""toggle Omnibar's position"", async () => {\n        const elmOmnibarClass = document.getElementById(""sk_omnibar"").classList;\n        window.postMessage({surfingkeys_frontend_data: { action: ""openOmnibar"", type: ""URLs"", extra: ""getAllSites"" }}, document.location.origin);\n        await new Promise((r) => setTimeout(r, 100));\n        expect(elmOmnibarClass.value).toContain('sk_omnibar_middle');\n        \n        Mode.handleMapKey.call(omnibar, {\n            sk_keyName: KeyboardUtils.encodeKeystroke(""<Ctrl-j>"")\n        });\n        await new Promise((r) => setTimeout(r, 100));\n        \n        // Verify position changes from middle to bottom\n        expect(elmOmnibarClass.value).not.toContain('sk_omnibar_middle');\n        expect(elmOmnibarClass.value).toContain('sk_omnibar_bottom');\n    });",10,1,10,625.8153559781475,0.018844906037972464,100
94,"test(""toggle Omnibar's position"", async () => {\n const elmOmnibarClass = document.getElementById(""sk_omnibar"").classList;\n window.postMessage({surfingkeys_frontend_data: { action: ""openOmnibar"", type: ""URLs"", extra: ""getAllSites"" }}, document.location.origin);\n await new Promise((r) => setTimeout(r, 100));\n expect(elmOmnibarClass.value).toContain('sk_omnibar_middle');\n Mode.handleMapKey.call(omnibar, {\n sk_keyName: KeyboardUtils.encodeKeystroke(""<Ctrl-j>"")\n });\n await new Promise((r) => setTimeout(r, 100));\n expect(elmOmnibarClass.value).toContain('sk_omnibar_bottom');\n });",9,1,11.11111111111111,489.68861636912123,0.017013965260313183,100,"    test(""toggle Omnibar's position"", async () => {\n        const elmOmnibarClass = document.getElementById(""sk_omnibar"").classList;\n        \n        // Open omnibar in middle position\n        window.postMessage({surfingkeys_frontend_data: { action: ""openOmnibar"", type: ""URLs"", extra: ""getAllSites"" }}, document.location.origin);\n        await new Promise((r) => setTimeout(r, 100));\n        expect(elmOmnibarClass.value).toContain('sk_omnibar_middle');\n        \n        // Toggle to bottom position\n        Mode.handleMapKey.call(omnibar, {\n            sk_keyName: KeyboardUtils.encodeKeystroke(""<Ctrl-j>"")\n        });\n        await new Promise((r) => setTimeout(r, 100));\n        expect(elmOmnibarClass.value).toContain('sk_omnibar_bottom');\n    });",9,1,11.11111111111111,489.68861636912123,0.017013965260313183,100
95,"test('show omnibar', async () => {\n const elmOmnibarStyle = document.getElementById(""sk_omnibar"").style;\n expect(elmOmnibarStyle).toHaveProperty('display', 'none');\n await waitForEvent(window, ""message"", (_msg) => {\n return _msg.surfingkeys_uihost_data && _msg.surfingkeys_uihost_data.action === ""setFrontFrame"";\n }, () => {\n window.postMessage({surfingkeys_frontend_data: { action: ""openOmnibar"", type: ""SearchEngine"", extra: ""b"" }}, document.location.origin);\n });\n expect(elmOmnibarStyle).not.toHaveProperty('display', 'none');\n });",10,2,20,871.4285714285714,0.015103536107907947,100,"    test('show omnibar', async () => {\n        // Check initial omnibar display state\n        const elmOmnibarStyle = document.getElementById(""sk_omnibar"").style;\n        expect(elmOmnibarStyle).toHaveProperty('display', 'none');\n\n        // Trigger omnibar opening\n        await waitForEvent(window, ""message"", (_msg) => {\n            return _msg.surfingkeys_uihost_data && _msg.surfingkeys_uihost_data.action === ""setFrontFrame"";\n        }, () => {\n            window.postMessage({surfingkeys_frontend_data: { action: ""openOmnibar"", type: ""SearchEngine"", extra: ""b"" }}, document.location.origin);\n        });\n\n        // Verify omnibar is now visible\n        expect(elmOmnibarStyle.display).not.toBe('none');\n    });",10,2,20,862.7653390351011,0.01535839662038353,100
96,"it('gets default classes when no options set', () => {\n expect(element.classList.length, 'element - only one class').toEqual(1);\n expect(target.classList.length, 'target - only one class').toEqual(1);\n const tether = new Tether({\n element: '.element',\n target: '.target',\n attachment: 'top left',\n targetAttachment: 'top right'\n });\n\n tether.enable();\n\n expect(element.classList.length, 'element - tether classes added').toEqual(12);\n expect(element).toHaveClass('tether-element');\n expect(element).not.toHaveClass('tether-target');\n\n expect(target.classList.length, 'target - tether classes added').toEqual(12);\n expect(target).toHaveClass('tether-target');\n expect(target).not.toHaveClass('tether-element');\n\n tether.destroy();\n\n expect(element.classList.length, 'element - destroy sets classes back to initial state').toEqual(1);\n expect(target.classList.length, 'target - destroy sets classes back to initial state').toEqual(1);\n });",15,1,6.666666666666667,1583.3333333333333,0.024366814485107212,93.6532781635149,"    it('gets default classes when no options set', () => {\n      // Initial state checks\n      const initialClassCount = 1;\n      expect(element.classList.length, 'element - only one class').toEqual(initialClassCount);\n      expect(target.classList.length, 'target - only one class').toEqual(initialClassCount);\n\n      const tether = new Tether({\n        element: '.element',\n        target: '.target',\n        attachment: 'top left',\n        targetAttachment: 'top right'\n      });\n\n      tether.enable();\n\n      // After enable checks\n      const tetherClassCount = 12;\n      expect(element.classList.length, 'element - tether classes added').toEqual(tetherClassCount);\n      expect(element).toHaveClass('tether-element');\n      expect(element).not.toHaveClass('tether-target');\n\n      expect(target.classList.length, 'target - tether classes added').toEqual(tetherClassCount); \n      expect(target).toHaveClass('tether-target');\n      expect(target).not.toHaveClass('tether-element');\n\n      tether.destroy();\n\n      // After destroy checks\n      expect(element.classList.length, 'element - destroy sets classes back to initial state').toEqual(initialClassCount);\n      expect(target.classList.length, 'target - destroy sets classes back to initial state').toEqual(initialClassCount);\n    });",17,1,5.88235294117647,1640.7067663032344,0.02517325560519326,91.37166724019193
97,"it('gets default classes when no options set', () => {\n expect(element.classList.length, 'element - only one class').toEqual(1);\n expect(target.classList.length, 'target - only one class').toEqual(1);\n const tether = new Tether({\n element: '.element',\n target: '.target',\n attachment: 'top left',\n targetAttachment: 'top right'\n });\n\n tether.enable();\n\n expect(element.classList.length, 'element - tether classes added').toEqual(12);\n expect(element).toHaveClass('tether-element');\n expect(element).not.toHaveClass('tether-target');\n\n expect(target.classList.length, 'target - tether classes added').toEqual(12);\n expect(target).toHaveClass('tether-target');\n expect(target).not.toHaveClass('tether-element');\n\n tether.destroy();\n\n expect(element.classList.length, 'element - destroy sets classes back to initial state').toEqual(1);\n expect(target.classList.length, 'target - destroy sets classes back to initial state').toEqual(1);\n });",15,1,6.666666666666667,1583.3333333333333,0.024366814485107212,93.6532781635149,"    it('gets default classes when no options set', () => {\n      const initialClassCount = 1;\n      const tetherClassCount = 12;\n      \n      // Verify initial state\n      expect(element.classList.length, 'element - only one class').toEqual(initialClassCount);\n      expect(target.classList.length, 'target - only one class').toEqual(initialClassCount);\n      \n      const tether = new Tether({\n        element: '.element',\n        target: '.target',\n        attachment: 'top left',\n        targetAttachment: 'top right'\n      });\n\n      tether.enable();\n\n      // Verify tether classes added correctly\n      expect(element.classList.length, 'element - tether classes added').toEqual(tetherClassCount);\n      expect(element).toHaveClass('tether-element');\n      expect(element).not.toHaveClass('tether-target');\n\n      expect(target.classList.length, 'target - tether classes added').toEqual(tetherClassCount);\n      expect(target).toHaveClass('tether-target');\n      expect(target).not.toHaveClass('tether-element');\n\n      tether.destroy();\n\n      // Verify cleanup\n      const finalState = {\n        element: element.classList.length,\n        target: target.classList.length\n      };\n      expect(finalState.element, 'element - destroy sets classes back to initial state').toEqual(initialClassCount);\n      expect(finalState.target, 'target - destroy sets classes back to initial state').toEqual(initialClassCount);\n    });",18,1,5.555555555555555,1866.1264212557958,0.026474996497534698,90.05243574875648
98,"it('gets default classes when no options set', () => {\n expect(element.classList.length, 'element - only one class').toEqual(1);\n expect(target.classList.length, 'target - only one class').toEqual(1);\n const tether = new Tether({\n element: '.element',\n target: '.target',\n attachment: 'top left',\n targetAttachment: 'top right'\n });\n\n tether.enable();\n\n expect(element.classList.length, 'element - tether classes added').toEqual(12);\n expect(element).toHaveClass('tether-element');\n expect(element).not.toHaveClass('tether-target');\n\n expect(target.classList.length, 'target - tether classes added').toEqual(12);\n expect(target).toHaveClass('tether-target');\n expect(target).not.toHaveClass('tether-element');\n\n tether.destroy();\n\n expect(element.classList.length, 'element - destroy sets classes back to initial state').toEqual(1);\n expect(target.classList.length, 'target - destroy sets classes back to initial state').toEqual(1);\n });",15,1,6.666666666666667,1583.3333333333333,0.024366814485107212,93.6532781635149,"    it('gets default classes when no options set', () => {\n      const initialClassCount = 1;\n      const tetherClassCount = 12;\n      \n      // Verify initial state\n      expect(element.classList.length, 'element - only one class').toEqual(initialClassCount);\n      expect(target.classList.length, 'target - only one class').toEqual(initialClassCount);\n      \n      const tether = new Tether({\n        element: '.element',\n        target: '.target',\n        attachment: 'top left',\n        targetAttachment: 'top right'\n      });\n\n      tether.enable();\n\n      // Verify tether classes added correctly\n      expect(element.classList.length, 'element - tether classes added').toEqual(tetherClassCount);\n      expect(element).toHaveClass('tether-element');\n      expect(element).not.toHaveClass('tether-target');\n\n      expect(target.classList.length, 'target - tether classes added').toEqual(tetherClassCount);\n      expect(target).toHaveClass('tether-target');\n      expect(target).not.toHaveClass('tether-element');\n\n      tether.destroy();\n\n      // Verify cleanup\n      const finalState = {\n        element: element.classList.length,\n        target: target.classList.length\n      };\n      expect(finalState.element, 'element - destroy sets classes back to initial state').toEqual(initialClassCount);\n      expect(finalState.target, 'target - destroy sets classes back to initial state').toEqual(initialClassCount);\n    });",18,1,5.555555555555555,1866.1264212557958,0.026474996497534698,90.05243574875648
99,"it('gets default classes when no options set', () => {\n expect(element.classList.length, 'element - only one class').toEqual(1);\n expect(target.classList.length, 'target - only one class').toEqual(1);\n const tether = new Tether({\n element: '.element',\n target: '.target',\n attachment: 'top left',\n targetAttachment: 'top right'\n });\n\n tether.enable();\n\n expect(element.classList.length, 'element - tether classes added').toEqual(12);\n expect(element).toHaveClass('tether-element');\n expect(element).not.toHaveClass('tether-target');\n\n expect(target.classList.length, 'target - tether classes added').toEqual(12);\n expect(target).toHaveClass('tether-target');\n expect(target).not.toHaveClass('tether-element');\n\n tether.destroy();\n\n expect(element.classList.length, 'element - destroy sets classes back to initial state').toEqual(1);\n expect(target.classList.length, 'target - destroy sets classes back to initial state').toEqual(1);\n });",15,1,6.666666666666667,1583.3333333333333,0.024366814485107212,93.6532781635149,"    it('gets default classes when no options set', () => {\n      // Initial state checks\n      const initialClassCount = 1;\n      expect(element.classList.length, 'element - only one class').toEqual(initialClassCount);\n      expect(target.classList.length, 'target - only one class').toEqual(initialClassCount);\n\n      const tether = new Tether({\n        element: '.element',\n        target: '.target',\n        attachment: 'top left',\n        targetAttachment: 'top right'\n      });\n\n      tether.enable();\n\n      // After enable checks\n      const tetherClassCount = 12;\n      expect(element.classList.length, 'element - tether classes added').toEqual(tetherClassCount);\n      expect(element).toHaveClass('tether-element');\n      expect(element).not.toHaveClass('tether-target');\n\n      expect(target.classList.length, 'target - tether classes added').toEqual(tetherClassCount);\n      expect(target).toHaveClass('tether-target');\n      expect(target).not.toHaveClass('tether-element');\n\n      tether.destroy();\n\n      // After destroy checks\n      expect(element.classList.length, 'element - destroy sets classes back to initial state').toEqual(initialClassCount);\n      expect(target.classList.length, 'target - destroy sets classes back to initial state').toEqual(initialClassCount);\n    });",17,1,5.88235294117647,1640.7067663032344,0.02517325560519326,91.37166724019193
100,"it('gets prefixed classes when classPrefix set', () => {\n expect(element.classList.length, 'element - only one class').toEqual(1);\n expect(target.classList.length, 'target - only one class').toEqual(1);\n const tether = new Tether({\n element: '.element',\n target: '.target',\n attachment: 'top left',\n targetAttachment: 'top right',\n classPrefix: 'foo'\n });\n\n tether.enable();\n\n expect(element.classList.length, 'element - foo classes added').toEqual(12);\n expect(element).toHaveClass('foo-element');\n expect(element).not.toHaveClass('foo-target');\n\n expect(target.classList.length, 'target - foo classes added').toEqual(12);\n expect(target).toHaveClass('foo-target');\n expect(target).not.toHaveClass('foo-element');\n\n tether.destroy();\n\n expect(element.classList.length, 'element - destroy sets classes back to initial state').toEqual(1);\n expect(target.classList.length, 'target - destroy sets classes back to initial state').toEqual(1);\n });",15,1,6.666666666666667,1574.887715794558,0.02491238991952825,93.48056180914281,"    it('gets prefixed classes when classPrefix set', () => {\n      // Initial state check\n      const initialClassCount = 1;\n      expect(element.classList.length, 'element - only one class').toEqual(initialClassCount);\n      expect(target.classList.length, 'target - only one class').toEqual(initialClassCount);\n\n      const tether = new Tether({\n        element: '.element',\n        target: '.target',\n        attachment: 'top left',\n        targetAttachment: 'top right',\n        classPrefix: 'foo'\n      });\n\n      tether.enable();\n\n      // After enable checks\n      const expectedClassCount = 12;\n      expect(element.classList.length, 'element - foo classes added').toEqual(expectedClassCount);\n      expect(element).toHaveClass('foo-element');\n      expect(element).not.toHaveClass('foo-target');\n\n      expect(target.classList.length, 'target - foo classes added').toEqual(expectedClassCount);\n      expect(target).toHaveClass('foo-target');\n      expect(target).not.toHaveClass('foo-element');\n\n      tether.destroy();\n\n      // After destroy checks\n      expect(element.classList.length, 'element - destroy sets classes back to initial state').toEqual(initialClassCount);\n      expect(target.classList.length, 'target - destroy sets classes back to initial state').toEqual(initialClassCount);\n    });",17,1,5.88235294117647,1633.3921872203916,0.02570686426038239,91.2080551996371
101,"it('removes classes on destroy', () => {\n expect(element.classList.length, 'element - only one class').toEqual(1);\n expect(target.classList.length, 'target - only one class').toEqual(1);\n const tether = new Tether({\n element: '.element',\n target: '.target',\n attachment: 'top left',\n targetAttachment: 'top right'\n });\n\n tether.enable();\n\n expect(element.classList.length, 'element - tether classes added').toEqual(12);\n expect(target.classList.length, 'target - tether classes added').toEqual(12);\n\n tether.destroy();\n\n expect(element.classList.length, 'element - destroy sets classes back to initial state').toEqual(1);\n expect(target.classList.length, 'target - destroy sets classes back to initial state').toEqual(1);\n });",11,1,9.090909090909092,997.3412480607199,0.01948968570001463,100,"    it('removes classes on destroy', () => {\n      // Initial state: element and target each have only their base class\n      const INITIAL_CLASS_COUNT = 1;\n      // After tether enabled: element and target get 11 additional tether-related classes\n      const TETHER_ENABLED_CLASS_COUNT = 12;\n\n      expect(element.classList.length, 'element - only one class').toEqual(INITIAL_CLASS_COUNT);\n      expect(target.classList.length, 'target - only one class').toEqual(INITIAL_CLASS_COUNT);\n      const tether = new Tether({\n        element: '.element',\n        target: '.target',\n        attachment: 'top left',\n        targetAttachment: 'top right'\n      });\n\n      tether.enable();\n\n      expect(element.classList.length, 'element - tether classes added').toEqual(TETHER_ENABLED_CLASS_COUNT);\n      expect(target.classList.length, 'target - tether classes added').toEqual(TETHER_ENABLED_CLASS_COUNT);\n\n      tether.destroy();\n\n      expect(element.classList.length, 'element - destroy sets classes back to initial state').toEqual(INITIAL_CLASS_COUNT);\n      expect(target.classList.length, 'target - destroy sets classes back to initial state').toEqual(INITIAL_CLASS_COUNT);\n    });",13,1,7.6923076923076925,1053.9300014996297,0.02032033288116001,97.38799292223283
102,"it('removes classes on destroy', () => {\n expect(element.classList.length, 'element - only one class').toEqual(1);\n expect(target.classList.length, 'target - only one class').toEqual(1);\n const tether = new Tether({\n element: '.element',\n target: '.target',\n attachment: 'top left',\n targetAttachment: 'top right'\n });\n\n tether.enable();\n\n expect(element.classList.length, 'element - tether classes added').toEqual(12);\n expect(target.classList.length, 'target - tether classes added').toEqual(12);\n\n tether.destroy();\n\n expect(element.classList.length, 'element - destroy sets classes back to initial state').toEqual(1);\n expect(target.classList.length, 'target - destroy sets classes back to initial state').toEqual(1);\n });",11,1,9.090909090909092,997.3412480607199,0.01948968570001463,100,"    it('removes classes on destroy', () => {\n      // Initial state: element and target each have only their base class\n      const INITIAL_CLASS_COUNT = 1;\n      // After tether enable: element and target get 11 additional tether-related classes\n      const TETHER_ENABLED_CLASS_COUNT = 12;\n\n      expect(element.classList.length, 'element - only one class').toEqual(INITIAL_CLASS_COUNT);\n      expect(target.classList.length, 'target - only one class').toEqual(INITIAL_CLASS_COUNT);\n      const tether = new Tether({\n        element: '.element',\n        target: '.target',\n        attachment: 'top left',\n        targetAttachment: 'top right'\n      });\n\n      tether.enable();\n\n      expect(element.classList.length, 'element - tether classes added').toEqual(TETHER_ENABLED_CLASS_COUNT);\n      expect(target.classList.length, 'target - tether classes added').toEqual(TETHER_ENABLED_CLASS_COUNT);\n\n      tether.destroy();\n\n      expect(element.classList.length, 'element - destroy sets classes back to initial state').toEqual(INITIAL_CLASS_COUNT);\n      expect(target.classList.length, 'target - destroy sets classes back to initial state').toEqual(INITIAL_CLASS_COUNT);\n    });",13,1,7.6923076923076925,1053.9300014996297,0.02032033288116001,97.38799292223283
103,"it('removes classes on destroy', () => {\n expect(element.classList.length, 'element - only one class').toEqual(1);\n expect(target.classList.length, 'target - only one class').toEqual(1);\n const tether = new Tether({\n element: '.element',\n target: '.target',\n attachment: 'top left',\n targetAttachment: 'top right'\n });\n\n tether.enable();\n\n expect(element.classList.length, 'element - tether classes added').toEqual(12);\n expect(target.classList.length, 'target - tether classes added').toEqual(12);\n\n tether.destroy();\n\n expect(element.classList.length, 'element - destroy sets classes back to initial state').toEqual(1);\n expect(target.classList.length, 'target - destroy sets classes back to initial state').toEqual(1);\n });",11,1,9.090909090909092,997.3412480607199,0.01948968570001463,100,"    it('removes classes on destroy', () => {\n      const INITIAL_CLASS_COUNT = 1;\n      const TETHER_ENABLED_CLASS_COUNT = 12;\n\n      expect(element.classList.length, 'element - only one class').toEqual(INITIAL_CLASS_COUNT);\n      expect(target.classList.length, 'target - only one class').toEqual(INITIAL_CLASS_COUNT);\n      const tether = new Tether({\n        element: '.element',\n        target: '.target',\n        attachment: 'top left',\n        targetAttachment: 'top right'\n      });\n\n      tether.enable();\n\n      expect(element.classList.length, 'element - tether classes added').toEqual(TETHER_ENABLED_CLASS_COUNT);\n      expect(target.classList.length, 'target - tether classes added').toEqual(TETHER_ENABLED_CLASS_COUNT);\n\n      tether.destroy();\n\n      expect(element.classList.length, 'element - destroy sets classes back to initial state').toEqual(INITIAL_CLASS_COUNT);\n      expect(target.classList.length, 'target - destroy sets classes back to initial state').toEqual(INITIAL_CLASS_COUNT);\n    });",13,1,7.6923076923076925,1053.9300014996297,0.02032033288116001,97.38799292223283
104,"it('removes classes on destroy', () => {\n expect(element.classList.length, 'element - only one class').toEqual(1);\n expect(target.classList.length, 'target - only one class').toEqual(1);\n const tether = new Tether({\n element: '.element',\n target: '.target',\n attachment: 'top left',\n targetAttachment: 'top right'\n });\n\n tether.enable();\n\n expect(element.classList.length, 'element - tether classes added').toEqual(12);\n expect(target.classList.length, 'target - tether classes added').toEqual(12);\n\n tether.destroy();\n\n expect(element.classList.length, 'element - destroy sets classes back to initial state').toEqual(1);\n expect(target.classList.length, 'target - destroy sets classes back to initial state').toEqual(1);\n });",11,1,9.090909090909092,997.3412480607199,0.01948968570001463,100,"    it('removes classes on destroy', () => {\n      const INITIAL_CLASS_COUNT = 1;\n      const TETHER_ENABLED_CLASS_COUNT = 12;\n\n      expect(element.classList.length, 'element - only one class').toEqual(INITIAL_CLASS_COUNT);\n      expect(target.classList.length, 'target - only one class').toEqual(INITIAL_CLASS_COUNT);\n      const tether = new Tether({\n        element: '.element',\n        target: '.target',\n        attachment: 'top left',\n        targetAttachment: 'top right'\n      });\n\n      tether.enable();\n\n      expect(element.classList.length, 'element - tether classes added').toEqual(TETHER_ENABLED_CLASS_COUNT);\n      expect(target.classList.length, 'target - tether classes added').toEqual(TETHER_ENABLED_CLASS_COUNT);\n\n      tether.destroy();\n\n      expect(element.classList.length, 'element - destroy sets classes back to initial state').toEqual(INITIAL_CLASS_COUNT);\n      expect(target.classList.length, 'target - destroy sets classes back to initial state').toEqual(INITIAL_CLASS_COUNT);\n    });",13,1,7.6923076923076925,1053.9300014996297,0.02032033288116001,97.38799292223283
105,"it('removes classes on destroy', () => {\n expect(element.classList.length, 'element - only one class').toEqual(1);\n expect(target.classList.length, 'target - only one class').toEqual(1);\n const tether = new Tether({\n element: '.element',\n target: '.target',\n attachment: 'top left',\n targetAttachment: 'top right'\n });\n\n tether.enable();\n\n expect(element.classList.length, 'element - tether classes added').toEqual(12);\n expect(target.classList.length, 'target - tether classes added').toEqual(12);\n\n tether.destroy();\n\n expect(element.classList.length, 'element - destroy sets classes back to initial state').toEqual(1);\n expect(target.classList.length, 'target - destroy sets classes back to initial state').toEqual(1);\n });",11,1,9.090909090909092,997.3412480607199,0.01948968570001463,100,"    it('removes classes on destroy', () => {\n      const INITIAL_CLASS_COUNT = 1;\n      const TETHER_ENABLED_CLASS_COUNT = 12;\n\n      expect(element.classList.length, 'element - only one class').toEqual(INITIAL_CLASS_COUNT);\n      expect(target.classList.length, 'target - only one class').toEqual(INITIAL_CLASS_COUNT);\n      const tether = new Tether({\n        element: '.element',\n        target: '.target',\n        attachment: 'top left',\n        targetAttachment: 'top right'\n      });\n\n      tether.enable();\n\n      expect(element.classList.length, 'element - tether classes added').toEqual(TETHER_ENABLED_CLASS_COUNT);\n      expect(target.classList.length, 'target - tether classes added').toEqual(TETHER_ENABLED_CLASS_COUNT);\n\n      tether.destroy();\n\n      expect(element.classList.length, 'element - destroy sets classes back to initial state').toEqual(INITIAL_CLASS_COUNT);\n      expect(target.classList.length, 'target - destroy sets classes back to initial state').toEqual(INITIAL_CLASS_COUNT);\n    });",13,1,7.6923076923076925,1053.9300014996297,0.02032033288116001,97.38799292223283
106,"it('top left', () => {\n expect(attachmentToOffset({ left: 'left', top: 'top' })).toStrictEqual({ left: 0, top: 0 });\n });",3,1,33.33333333333333,97.16639677545534,0.005097069638023333,100,"    it('should convert left attachment to 0 offset', () => {\n      expect(attachmentToOffset({ left: 'left', top: 'middle' })).toStrictEqual({ left: 0, top: '50%' });\n    });\n\n    it('should convert top attachment to 0 offset', () => {\n      expect(attachmentToOffset({ left: 'center', top: 'top' })).toStrictEqual({ left: '50%', top: 0 });\n    });",6,1,16.666666666666664,296.9736839204931,0.008861270381089482,100
107,"it('middle center', () => {\n expect(attachmentToOffset({ left: 'center', top: 'middle' })).toStrictEqual({ left: '50%', top: '50%' });\n });",3,1,33.33333333333333,83.88812251687506,0.0053626998907691775,100,"    it('should convert center horizontal attachment to 50% offset', () => {\n      expect(attachmentToOffset({ left: 'center', top: 'top' })).toStrictEqual({ left: '50%', top: 0 });\n    });\n\n    it('should convert middle vertical attachment to 50% offset', () => {\n      expect(attachmentToOffset({ left: 'left', top: 'middle' })).toStrictEqual({ left: 0, top: '50%' });\n    });\n\n    it('should convert center and middle attachments to 50% offsets', () => {\n      expect(attachmentToOffset({ left: 'center', top: 'middle' })).toStrictEqual({ left: '50%', top: '50%' });\n    });\n",9,1,11.11111111111111,632.91627648858,0.011813051167298085,100
108,"it('bottom right', () => {\n expect(attachmentToOffset({ left: 'right', top: 'bottom' })).toStrictEqual({ left: '100%', top: '100%' });\n });",3,1,33.33333333333333,83.88812251687506,0.0053626998907691775,100,"    it('should convert right attachment to 100% offset', () => {\n      expect(attachmentToOffset({ left: 'right', top: 'middle' })).toStrictEqual({ left: '100%', top: '50%' });\n    });\n\n    it('should convert bottom attachment to 100% offset', () => {\n      expect(attachmentToOffset({ left: 'center', top: 'bottom' })).toStrictEqual({ left: '50%', top: '100%' });\n    });",6,1,16.666666666666664,267.42857142857144,0.009157713940426653,100
109,"it('mirror left', () => {\n expect(autoToFixedAttachment(\n { left: 'auto', top: 'top' },\n { left: 'left', top: 'top' }\n )).toStrictEqual({ left: 'right', top: 'top' });\n });",3,1,33.33333333333333,143.75860281892767,0.005986371980462904,100,"    // Test for auto-to-fixed attachment when target is left-aligned\n    it('should mirror auto attachment to right when target is left-aligned', () => {\n      // Arrange\n      const autoAttachment = { left: 'auto', top: 'top' };\n      const targetAttachment = { left: 'left', top: 'top' };\n      const expected = { left: 'right', top: 'top' };\n      \n      // Act\n      const result = autoToFixedAttachment(autoAttachment, targetAttachment);\n      \n      // Assert\n      expect(result).toStrictEqual(expected);\n    });",7,1,14.285714285714285,225.39753436202994,0.007983262598172345,100
110,"it('mirror center', () => {\n expect(autoToFixedAttachment(\n { left: 'auto', top: 'top' },\n { left: 'center', top: 'top' }\n )).toStrictEqual({ left: 'center', top: 'top' });\n });",3,1,33.33333333333333,143.75860281892767,0.005986371980462904,100,"    it('should mirror auto left to center when target attachment is center', () => {\n      // Test specifically the mirroring behavior for center alignment\n      const autoAttachment = { left: 'auto', top: 'top' };\n      const targetAttachment = { left: 'center', top: 'top' };\n      const result = autoToFixedAttachment(autoAttachment, targetAttachment);\n      \n      expect(result.left).toBe('center');\n      expect(result.top).toBe('top');\n    });\n\n    it('should preserve top position when mirroring center alignment', () => {\n      // Test that top position is not affected by left mirroring\n      const autoAttachment = { left: 'auto', top: 'top' };\n      const targetAttachment = { left: 'center', top: 'top' };\n      const result = autoToFixedAttachment(autoAttachment, targetAttachment);\n      \n      expect(result.top).toBe('top');\n    });",13,1,7.6923076923076925,889.8694656612942,0.013091616601716025,100
111,"it(""scriptFromCodepoint() should return correct values"", () => {\n outer: for (let codepoint = 0; codepoint <= 0xffff; codepoint++) {\n const character = String.fromCharCode(codepoint);\n const script = scriptFromCodepoint(codepoint);\n\n for (const scriptName of scriptNames) {\n if (scriptRegExps[scriptName].test(character)) {\n expect(script).toEqual(scriptName);\n continue outer;\n }\n }\n\n expect(script).toBe(null);\n expect(supportedCodepoint(codepoint)).toBe(false);\n }\n });",16,4,25,817.0981385888247,0.012701879927583678,97.37038908027709,"    it(""scriptFromCodepoint() should return correct values"", () => {\n        // Test a representative set of codepoints for each script\n        const testCases = [\n            { codepoint: 0x0100, expectedScript: 'latin' },\n            { codepoint: 0x0400, expectedScript: 'cyrillic' },\n            { codepoint: 0x0530, expectedScript: 'armenian' },\n            { codepoint: 0x0900, expectedScript: 'brahmic' },\n            { codepoint: 0x10a0, expectedScript: 'georgian' },\n            { codepoint: 0x3000, expectedScript: 'cjk' },\n            { codepoint: 0xAC00, expectedScript: 'hangul' },\n            { codepoint: 0x0020, expectedScript: null } // ASCII space - unsupported\n        ];\n\n        testCases.forEach(({codepoint, expectedScript}) => {\n            const character = String.fromCharCode(codepoint);\n            const script = scriptFromCodepoint(codepoint);\n            \n            if (expectedScript === null) {\n                expect(script).toBe(null);\n                expect(supportedCodepoint(codepoint)).toBe(false);\n            } else {\n                expect(script).toEqual(expectedScript);\n                expect(scriptRegExps[expectedScript].test(character)).toBe(true);\n            }\n        });\n    });",14,2,14.285714285714285,1375.289008918369,0.019614246780415928,96.30387336290914
112,"it(""scriptFromCodepoint() should return correct values"", () => {\n outer: for (let codepoint = 0; codepoint <= 0xffff; codepoint++) {\n const character = String.fromCharCode(codepoint);\n const script = scriptFromCodepoint(codepoint);\n\n for (const scriptName of scriptNames) {\n if (scriptRegExps[scriptName].test(character)) {\n expect(script).toEqual(scriptName);\n continue outer;\n }\n }\n\n expect(script).toBe(null);\n expect(supportedCodepoint(codepoint)).toBe(false);\n }\n });",16,4,25,817.0981385888247,0.012701879927583678,97.37038908027709,"    it(""scriptFromCodepoint() should return correct values"", () => {\n        outer: for (let codepoint = 0; codepoint <= 0xffff; codepoint++) {\n            const character = String.fromCharCode(codepoint);\n            const script = scriptFromCodepoint(codepoint);\n\n            for (const scriptName of scriptNames) {\n                if (scriptRegExps[scriptName].test(character)) {\n                    expect(script).toBe(scriptName);\n                    continue outer;\n                }\n            }\n\n            expect(script).toBeNull();\n            expect(supportedCodepoint(codepoint)).toBeFalsy();\n        }\n    });",16,4,25,786.7795651237503,0.01281656073002471,97.30028163969585
113,"it(""should build some surrogate pairs"", function() {\n let wideCharStr = """";\n wideCharStr += String.fromCharCode(0xD835, 0xDC00); // bold A\n wideCharStr += String.fromCharCode(0xD835, 0xDC68); // bold italic A\n wideCharStr += String.fromCharCode(0xD835, 0xDD04); // Fraktur A\n wideCharStr += String.fromCharCode(0xD835, 0xDD6C); // bold Fraktur A\n wideCharStr += String.fromCharCode(0xD835, 0xDD38); // double-struck\n wideCharStr += String.fromCharCode(0xD835, 0xDC9C); // script A\n wideCharStr += String.fromCharCode(0xD835, 0xDDA0); // sans serif A\n wideCharStr += String.fromCharCode(0xD835, 0xDDD4); // bold sans A\n wideCharStr += String.fromCharCode(0xD835, 0xDE08); // italic sans A\n wideCharStr += String.fromCharCode(0xD835, 0xDE70); // monospace A\n wideCharStr += String.fromCharCode(0xD835, 0xDFCE); // bold zero\n wideCharStr += String.fromCharCode(0xD835, 0xDFE2); // sans serif zero\n wideCharStr += String.fromCharCode(0xD835, 0xDFEC); // bold sans zero\n wideCharStr += String.fromCharCode(0xD835, 0xDFF6); // monospace zero\n expect(wideCharStr).toBuild(strictSettings);\n\n let wideCharText = ""\text{"";\n wideCharText += String.fromCharCode(0xD835, 0xDC00); // bold A\n wideCharText += String.fromCharCode(0xD835, 0xDC68); // bold italic A\n wideCharText += String.fromCharCode(0xD835, 0xDD04); // Fraktur A\n wideCharStr += String.fromCharCode(0xD835, 0xDD6C); // bold Fraktur A\n wideCharText += String.fromCharCode(0xD835, 0xDD38); // double-struck\n wideCharText += String.fromCharCode(0xD835, 0xDC9C); // script A\n wideCharText += String.fromCharCode(0xD835, 0xDDA0); // sans serif A\n wideCharText += String.fromCharCode(0xD835, 0xDDD4); // bold sans A\n wideCharText += String.fromCharCode(0xD835, 0xDE08); // italic sans A\n wideCharText += String.fromCharCode(0xD835, 0xDE70); // monospace A\n wideCharText += String.fromCharCode(0xD835, 0xDFCE); // bold zero\n wideCharText += String.fromCharCode(0xD835, 0xDFE2); // sans serif zero\n wideCharText += String.fromCharCode(0xD835, 0xDFEC); // bold sans zero\n wideCharText += String.fromCharCode(0xD835, 0xDFF6); // monospace zero\n wideCharText += ""}"";\n expect(wideCharText).toBuild(strictSettings);\n });",35,1,2.857142857142857,10546.543520161242,0.03799421265710983,76.46220152514091,"    it(""should build some surrogate pairs"", function() {\n        let wideCharStr = """";\n        // Mathematical Alphanumeric Symbols block\n        const mathSymbols = [\n            [0xD835, 0xDC00], // bold A\n            [0xD835, 0xDC68], // bold italic A  \n            [0xD835, 0xDD04], // Fraktur A\n            [0xD835, 0xDD6C], // bold Fraktur A\n            [0xD835, 0xDD38], // double-struck A\n            [0xD835, 0xDC9C], // script A\n            [0xD835, 0xDDA0], // sans serif A\n            [0xD835, 0xDDD4], // bold sans A\n            [0xD835, 0xDE08], // italic sans A\n            [0xD835, 0xDE70], // monospace A\n            [0xD835, 0xDFCE], // bold zero\n            [0xD835, 0xDFE2], // sans serif zero\n            [0xD835, 0xDFEC], // bold sans zero\n            [0xD835, 0xDFF6]  // monospace zero\n        ];\n\n        mathSymbols.forEach(([high, low]) => {\n            wideCharStr += String.fromCharCode(high, low);\n        });\n        expect(wideCharStr).toBuild(strictSettings);\n\n        let wideCharText = ""\\text{"";\n        mathSymbols.forEach(([high, low]) => {\n            wideCharText += String.fromCharCode(high, low);\n        });\n        wideCharText += ""}"";\n        expect(wideCharText).toBuild(strictSettings);\n    });",14,1,7.142857142857142,1256.1930425274425,0.018458777063899524,96.93688357251943
114,"it(""should build a list of rels"", function() {\n const parse = getParsed(expression);\n\n for (let i = 0; i < parse.length; i++) {\n let group = parse[i];\n if (group.type === ""htmlmathml"") {\n expect(group.html).toHaveLength(1);\n group = group.html[0];\n }\n if (group.type === ""mclass"") {\n expect(group.mclass).toEqual(""mrel"");\n } else {\n expect(group.type).toEqual(""atom"");\n expect(group.family).toEqual(""rel"");\n }\n }\n });",17,4,23.52941176470588,2181.814093849866,0.016463448754722304,94.36500723755444,"    it(""should build a list of rels"", function() {\n        const parse = getParsed(expression);\n        \n        const verifyGroup = (group) => {\n            if (group.type === ""mclass"") {\n                expect(group.mclass).toEqual(""mrel"");\n            } else {\n                expect(group.type).toEqual(""atom""); \n                expect(group.family).toEqual(""rel"");\n            }\n        };\n\n        parse.forEach(group => {\n            if (group.type === ""htmlmathml"") {\n                expect(group.html).toHaveLength(1);\n                verifyGroup(group.html[0]);\n            } else {\n                verifyGroup(group);\n            }\n        });\n    });",19,3,15.789473684210526,962.8421251514427,0.015625525452602807,93.03676643211465
115,"it(""should build a list of rels"", function() {\n const parse = getParsed(expression);\n\n for (let i = 0; i < parse.length; i++) {\n let group = parse[i];\n if (group.type === ""htmlmathml"") {\n expect(group.html).toHaveLength(1);\n group = group.html[0];\n }\n if (group.type === ""mclass"") {\n expect(group.mclass).toEqual(""mrel"");\n } else {\n expect(group.type).toEqual(""atom"");\n expect(group.family).toEqual(""rel"");\n }\n }\n });",17,4,23.52941176470588,2181.814093849866,0.016463448754722304,94.36500723755444,"    it(""should build a list of rels"", function() {\n        const parse = getParsed(expression);\n        \n        const verifyGroup = (group) => {\n            if (group.type === ""mclass"") {\n                expect(group.mclass).toEqual(""mrel"");\n            } else {\n                expect(group.type).toEqual(""atom"");\n                expect(group.family).toEqual(""rel"");\n            }\n        };\n\n        parse.forEach(group => {\n            if (group.type === ""htmlmathml"") {\n                expect(group.html).toHaveLength(1);\n                verifyGroup(group.html[0]);\n            } else {\n                verifyGroup(group);\n            }\n        });\n    });",19,3,15.789473684210526,962.8421251514427,0.015625525452602807,93.03676643211465
116,"it(""should parse comments before and between \\hline"", () => {\n expect(""\\begin{matrix}a&b\\\\ %hline\n"" +\n ""\\hline %hline\n"" +\n ""\\hline c&d\\end{matrix}"").toParse();\n });",3,1,33.33333333333333,64.77759785030356,0.004102996362278855,100,"    it(""should parse comments before and between \\hline"", () => {\n        const input = ""\\begin{matrix}a&b\\\\ %hline\n"" +\n            ""\\hline %hline\n"" +\n            ""\\hline c&d\\end{matrix}"";\n        const result = getParsed(input);\n        expect(result).toBeDefined();\n        expect(result.length).toBeGreaterThan(0);\n        expect(result[0].type).toBe(""array""); \n    });",7,1,14.285714285714285,357.2241543336465,0.010054794869328941,100
117,"it(""should render wide characters with mord and with the correct font"", function() {\n const markup = katex.renderToString(String.fromCharCode(0xD835, 0xDC00));\n expect(markup).toContain(""<span class=\""mord mathbf\"">A</span>"");\n\n expect(String.fromCharCode(0xD835, 0xDC00) +\n "" = "" + String.fromCharCode(0xD835, 0xDC1A))\n .toBuildLike`\mathbf A = \mathbf a`;\n });",5,1,20,400.312800138462,0.010100376640899413,100,"    it(""should render wide characters with mord and with the correct font"", function() {\n        // Test specific span class and font rendering\n        const markup = katex.renderToString(String.fromCharCode(0xD835, 0xDC00));\n        const expectedSpan = ""<span class=\""mord mathbf\"">A</span>"";\n        expect(markup).toEqual(expect.stringContaining(expectedSpan));\n\n        // Test character equivalence with mathbf commands\n        const wideChars = String.fromCharCode(0xD835, 0xDC00) + "" = "" + \n                         String.fromCharCode(0xD835, 0xDC1A);\n        const mathbfEquiv = ""\\mathbf A = \\mathbf a"";\n        \n        const wideCharsBuild = getBuilt(wideChars);\n        const mathbfBuild = getBuilt(mathbfEquiv);\n        expect(wideCharsBuild).toEqual(mathbfBuild);\n    });",10,1,10,740.906146641331,0.014219972404941387,100
118,"it(""should contain affected position and length information"", function() {\n try {\n katex.renderToString(""1 + \\fraq{}{}"");\n\n // Render is expected to throw, so this should not be called.\n expect(true).toBe(false);\n } catch (error) {\n expect(error).toBeInstanceOf(ParseError);\n expect(error.message).toBe(""KaTeX parse error: Undefined control sequence: \\fraq at position 5: 1 + \\̲f̲r̲a̲q̲{}{}"");\n expect(error.rawMessage).toBe(""Undefined control sequence: \\fraq"");\n expect(error.position).toBe(4);\n expect(error.length).toBe(5);\n }\n });",12,2,16.666666666666664,437.9553802819194,0.01309926738524326,100,"    it(""should contain affected position and length information"", function() {\n    try {\n        katex.renderToString(""1 + \\fraq{}{}"");\n        fail(""Expected renderToString to throw an error"");\n    } catch (error) {\n        expect(error).toBeInstanceOf(ParseError);\n        expect(error).toMatchObject({\n            message: ""KaTeX parse error: Undefined control sequence: \\fraq at position 5: 1 + \\̲f̲r̲a̲q̲{}{}"",\n            rawMessage: ""Undefined control sequence: \\fraq"", \n            position: 4,\n            length: 5\n        });\n    }\n});",9,2,22.22222222222222,169.23542992728542,0.00929125496166311,100
119,"it(""should contain position and length information at end of input"", function() {\n try {\n katex.renderToString(""\\frac{}"");\n\n // Render is expected to throw, so this should not be called.\n expect(true).toBe(false);\n } catch (error) {\n expect(error).toBeInstanceOf(ParseError);\n expect(error.message).toBe(""KaTeX parse error: Unexpected end of input in a macro argument, expected '}' at end of input: \\frac{}"");\n expect(error.rawMessage).toBe(""Unexpected end of input in a macro argument, expected '}'"");\n expect(error.position).toBe(7);\n expect(error.length).toBe(0);\n }\n });",12,2,16.666666666666664,437.9553802819194,0.01309926738524326,100,"    it(""should contain position and length information at end of input"", function() {\n        try {\n            katex.renderToString(""\\frac{}"");\n            fail(""Expected renderToString to throw error"");\n        } catch (error) {\n            expect(error).toBeInstanceOf(ParseError);\n            expect(error.message).toBe(""KaTeX parse error: Unexpected end of input in a macro argument, expected '}' at end of input: \\frac{}"");\n            expect(error.rawMessage).toBe(""Unexpected end of input in a macro argument, expected '}'"");\n            expect(error.position).toEqual(7);\n            expect(error.length).toEqual(0);\n        }\n    });",12,2,16.666666666666664,379.11757346001633,0.013185832873520523,100
120,"it(""scriptFromCodepoint() should return correct values"", () => {\n outer: for (let codepoint = 0; codepoint <= 0xffff; codepoint++) {\n const character = String.fromCharCode(codepoint);\n const script = scriptFromCodepoint(codepoint);\n\n for (const scriptName of scriptNames) {\n if (scriptRegExps[scriptName].test(character)) {\n expect(script).toEqual(scriptName);\n continue outer;\n }\n }\n\n expect(script).toBe(null);\n expect(supportedCodepoint(codepoint)).toBe(false);\n }\n });",16,4,25,817.0981385888247,0.012701879927583678,97.37038908027709,"    it(""scriptFromCodepoint() should return correct values"", () => {\n        outer: for (let codepoint = 0; codepoint <= 0xffff; codepoint++) {\n            const character = String.fromCharCode(codepoint);\n            const script = scriptFromCodepoint(codepoint);\n            const isSupported = scriptRegExps[scriptNames.find(name => \n                scriptRegExps[name].test(character))]?.test(character) || false;\n\n            if (isSupported) {\n                expect(script).toEqual(scriptNames.find(name => \n                    scriptRegExps[name].test(character)));\n            } else {\n                expect(script).toBe(null);\n                expect(supportedCodepoint(codepoint)).toBe(false); \n            }\n        }\n    });",14,4,28.57142857142857,1772.7372651274975,0.016187982807107548,97.64194821905792
121,"it(""scriptFromCodepoint() should return correct values"", () => {\n outer: for (let codepoint = 0; codepoint <= 0xffff; codepoint++) {\n const character = String.fromCharCode(codepoint);\n const script = scriptFromCodepoint(codepoint);\n\n for (const scriptName of scriptNames) {\n if (scriptRegExps[scriptName].test(character)) {\n expect(script).toEqual(scriptName);\n continue outer;\n }\n }\n\n expect(script).toBe(null);\n expect(supportedCodepoint(codepoint)).toBe(false);\n }\n });",16,4,25,817.0981385888247,0.012701879927583678,97.37038908027709,"    it(""scriptFromCodepoint() should return correct values"", () => {\n        outer: for (let codepoint = 0; codepoint <= 0xffff; codepoint++) {\n            const character = String.fromCharCode(codepoint);\n            const script = scriptFromCodepoint(codepoint);\n            const isSupported = scriptRegExps[scriptNames.find(name => \n                scriptRegExps[name].test(character))]?.test(character) ?? false;\n\n            if (isSupported) {\n                expect(script).toEqual(scriptNames.find(name => \n                    scriptRegExps[name].test(character)));\n            } else {\n                expect(script).toBe(null);\n                expect(supportedCodepoint(codepoint)).toBe(false); \n            }\n        }\n    });",14,4,28.57142857142857,1772.7372651274975,0.016187982807107548,97.64194821905792
122,"it(""supportedCodepoint() should return the correct values"", () => {\n for (let codepoint = 0; codepoint <= 0xffff; codepoint++) {\n expect(supportedCodepoint(codepoint)).toBe(\n allRegExp.test(String.fromCharCode(codepoint))\n );\n }\n });",6,2,33.33333333333333,288,0.007559526299369237,100,"    it(""should verify supportedCodepoint for Latin characters"", () => {\n        for (let codepoint = 0x0100; codepoint <= 0x036f; codepoint++) {\n            expect(supportedCodepoint(codepoint)).toBe(\n                allRegExp.test(String.fromCharCode(codepoint))\n            );\n        }\n    });\n\n    it(""should verify supportedCodepoint for Cyrillic characters"", () => {\n        for (let codepoint = 0x0400; codepoint <= 0x04ff; codepoint++) {\n            expect(supportedCodepoint(codepoint)).toBe(\n                allRegExp.test(String.fromCharCode(codepoint))\n            );\n        }\n    });\n\n    it(""should verify supportedCodepoint for Armenian characters"", () => {\n        for (let codepoint = 0x0530; codepoint <= 0x058F; codepoint++) {\n            expect(supportedCodepoint(codepoint)).toBe(\n                allRegExp.test(String.fromCharCode(codepoint))\n            );\n        }\n    });\n\n    it(""should verify supportedCodepoint for Brahmic characters"", () => {\n        for (let codepoint = 0x0900; codepoint <= 0x109F; codepoint++) {\n            expect(supportedCodepoint(codepoint)).toBe(\n                allRegExp.test(String.fromCharCode(codepoint))\n            );\n        }\n    });\n\n    it(""should verify supportedCodepoint for Georgian characters"", () => {\n        for (let codepoint = 0x10a0; codepoint <= 0x10ff; codepoint++) {\n            expect(supportedCodepoint(codepoint)).toBe(\n                allRegExp.test(String.fromCharCode(codepoint))\n            );\n        }\n    });\n\n    it(""should verify supportedCodepoint for CJK characters"", () => {\n        for (let codepoint = 0x3000; codepoint <= 0x9FAF; codepoint++) {\n            expect(supportedCodepoint(codepoint)).toBe(\n                allRegExp.test(String.fromCharCode(codepoint))\n            );\n        }\n    });\n\n    it(""should verify supportedCodepoint for Hangul characters"", () => {\n        for (let codepoint = 0xAC00; codepoint <= 0xD7AF; codepoint++) {\n            expect(supportedCodepoint(codepoint)).toBe(\n                allRegExp.test(String.fromCharCode(codepoint))\n            );\n        }\n    });",42,8,19.047619047619047,7179.427561572478,0.03247287804530131,74.25514406749622
123,"it(""scriptFromCodepoint() should return correct values"", () => {\n outer: for (let codepoint = 0; codepoint <= 0xffff; codepoint++) {\n const character = String.fromCharCode(codepoint);\n const script = scriptFromCodepoint(codepoint);\n\n for (const scriptName of scriptNames) {\n if (scriptRegExps[scriptName].test(character)) {\n expect(script).toEqual(scriptName);\n continue outer;\n }\n }\n\n expect(script).toBe(null);\n expect(supportedCodepoint(codepoint)).toBe(false);\n }\n });",16,4,25,817.0981385888247,0.012701879927583678,97.37038908027709,"    it(""should correctly identify script for supported codepoints"", () => {\n        for (const scriptName of scriptNames) {\n            const testChar = findCharacterInScript(scriptName);\n            const codepoint = testChar.charCodeAt(0);\n            expect(scriptFromCodepoint(codepoint)).toEqual(scriptName);\n        }\n    });\n\n    it(""should return null for unsupported codepoints"", () => {\n        const unsupportedCodepoints = [0x0, 0x7F, 0xFFFF]; // Control chars, ASCII, beyond BMP\n        for (const codepoint of unsupportedCodepoints) {\n            expect(scriptFromCodepoint(codepoint)).toBe(null);\n        }\n    });\n\n    it(""should match supportedCodepoint() results"", () => {\n        const testCodepoints = [0x0100, 0x0400, 0x0530, 0x0900, 0x10A0, 0x3000, 0xAC00];\n        for (const codepoint of testCodepoints) {\n            const hasScript = scriptFromCodepoint(codepoint) !== null;\n            expect(supportedCodepoint(codepoint)).toBe(hasScript);\n        }\n    });\n\n    // Helper function to find a test character for each script\n    function findCharacterInScript(scriptName) {\n        const regexp = scriptRegExps[scriptName];\n        for (let cp = 0; cp <= 0xFFFF; cp++) {\n            const char = String.fromCharCode(cp);\n            if (regexp.test(char)) {\n                return char;\n            }\n        }\n        throw new Error(`No character found for script ${scriptName}`);\n    }",33,6,18.181818181818183,2403.457357627279,0.021249012191816283,81.53607578295741
124,"it(""should produce a frac"", function() {\n let parse;\n\n parse = getParsed(simpleOver)[0];\n\n expect(parse.type).toEqual(""genfrac"");\n expect(parse.numer).toBeDefined();\n expect(parse.denom).toBeDefined();\n\n parse = getParsed(complexOver)[0];\n\n expect(parse.type).toEqual(""genfrac"");\n expect(parse.numer).toBeDefined();\n expect(parse.denom).toBeDefined();\n\n const parseBraceFrac = getParsed(braceFrac)[0];\n\n expect(parseBraceFrac.type).toEqual(""genfrac"");\n expect(parseBraceFrac.numer).toBeDefined();\n expect(parseBraceFrac.denom).toBeDefined();\n expect(parseBraceFrac.leftDelim).toBeDefined();\n expect(parseBraceFrac.rightDelim).toBeDefined();\n\n const parseBrackFrac = getParsed(brackFrac)[0];\n\n expect(parseBrackFrac.type).toEqual(""genfrac"");\n expect(parseBrackFrac.numer).toBeDefined();\n expect(parseBrackFrac.denom).toBeDefined();\n expect(parseBrackFrac.leftDelim).toBeDefined();\n expect(parseBrackFrac.rightDelim).toBeDefined();\n });",23,1,4.3478260869565215,4781.631165650066,0.02709416576826131,85.90113417898192,"    it(""should produce a frac"", function() {\n    // Helper function to verify basic genfrac properties\n    const verifyGenfrac = (parse) => {\n        expect(parse.type).toEqual(""genfrac"");\n        expect(parse.numer).toBeDefined(); \n        expect(parse.denom).toBeDefined();\n    };\n\n    // Helper function to verify delimited genfrac\n    const verifyDelimitedGenfrac = (parse) => {\n        verifyGenfrac(parse);\n        expect(parse.leftDelim).toBeDefined();\n        expect(parse.rightDelim).toBeDefined();\n    };\n\n    // Test simple over\n    const simpleOverParse = getParsed(simpleOver)[0];\n    verifyGenfrac(simpleOverParse);\n\n    // Test complex over \n    const complexOverParse = getParsed(complexOver)[0];\n    verifyGenfrac(complexOverParse);\n\n    // Test brace fraction\n    const braceFracParse = getParsed(braceFrac)[0];\n    verifyDelimitedGenfrac(braceFracParse);\n\n    // Test bracket fraction\n    const brackFracParse = getParsed(brackFrac)[0];\n    verifyDelimitedGenfrac(brackFracParse);\n});",20,1,5,903.0719808478573,0.01836470283388384,91.19860343218768
125,"it(""should produce a frac"", function() {\n let parse;\n\n parse = getParsed(simpleOver)[0];\n\n expect(parse.type).toEqual(""genfrac"");\n expect(parse.numer).toBeDefined();\n expect(parse.denom).toBeDefined();\n\n parse = getParsed(complexOver)[0];\n\n expect(parse.type).toEqual(""genfrac"");\n expect(parse.numer).toBeDefined();\n expect(parse.denom).toBeDefined();\n\n const parseBraceFrac = getParsed(braceFrac)[0];\n\n expect(parseBraceFrac.type).toEqual(""genfrac"");\n expect(parseBraceFrac.numer).toBeDefined();\n expect(parseBraceFrac.denom).toBeDefined();\n expect(parseBraceFrac.leftDelim).toBeDefined();\n expect(parseBraceFrac.rightDelim).toBeDefined();\n\n const parseBrackFrac = getParsed(brackFrac)[0];\n\n expect(parseBrackFrac.type).toEqual(""genfrac"");\n expect(parseBrackFrac.numer).toBeDefined();\n expect(parseBrackFrac.denom).toBeDefined();\n expect(parseBrackFrac.leftDelim).toBeDefined();\n expect(parseBrackFrac.rightDelim).toBeDefined();\n });",23,1,4.3478260869565215,4781.631165650066,0.02709416576826131,85.90113417898192,"    it(""should produce a frac"", function() {\n    // Helper function to verify basic genfrac properties\n    const verifyGenfrac = (parse) => {\n        expect(parse.type).toEqual(""genfrac"");\n        expect(parse.numer).toBeDefined(); \n        expect(parse.denom).toBeDefined();\n    };\n\n    // Helper function to verify delimited genfrac properties\n    const verifyDelimitedGenfrac = (parse) => {\n        verifyGenfrac(parse);\n        expect(parse.leftDelim).toBeDefined();\n        expect(parse.rightDelim).toBeDefined();\n    };\n\n    // Test simple over fraction\n    const simpleOverParse = getParsed(simpleOver)[0];\n    verifyGenfrac(simpleOverParse);\n\n    // Test complex over fraction \n    const complexOverParse = getParsed(complexOver)[0];\n    verifyGenfrac(complexOverParse);\n\n    // Test brace fraction\n    const braceFracParse = getParsed(braceFrac)[0];\n    verifyDelimitedGenfrac(braceFracParse);\n\n    // Test bracket fraction\n    const brackFracParse = getParsed(brackFrac)[0];\n    verifyDelimitedGenfrac(brackFracParse);\n});",20,1,5,903.0719808478573,0.01836470283388384,91.19860343218768
126,"it(""should build a list of ords"", function() {\n const parse = getParsed(expression);\n\n for (let i = 0; i < parse.length; i++) {\n const group = parse[i];\n expect(group.type).toMatch(""ord"");\n }\n });",8,2,25,346.49108085060567,0.008043528820279,100,"    it(""should build ords with correct type"", function() {\n        const parse = getParsed(expression);\n        parse.forEach(group => {\n            expect(group.type).toBe(""ord"");\n        });\n    });\n\n    it(""should build ords with correct content"", function() {\n        const parse = getParsed(expression);\n        const expectedChars = expression.split('');\n        parse.forEach((group, i) => {\n            expect(group.text).toBe(expectedChars[i]);\n        });\n    });",13,1,7.6923076923076925,407.8010412905842,0.012023851233177894,100
127,"it(""should parse the right number of ords"", function() {\n const parse = getParsed(expression);\n\n expect(parse).toHaveLength(expression.length);\n });",4,1,25,66.43856189774725,0.0047121475995650485,100,"    it(""should parse each character as a separate ord"", function() {\n        const parse = getParsed(expression);\n        const expectedLength = expression.length;\n        \n        // Verify total length matches input\n        expect(parse).toHaveLength(expectedLength);\n        \n        // Verify each character is parsed as an individual ord\n        for (let i = 0; i < expectedLength; i++) {\n            const group = parse[i];\n            expect(group.type).toMatch(""ord"");\n            expect(group.text).toBe(expression[i]);\n        }\n    });",11,2,18.181818181818183,784.9329606118749,0.011971225473883379,100
128,"it(""should build a list of bins"", function() {\n const parse = getParsed(expression);\n\n for (let i = 0; i < parse.length; i++) {\n const group = parse[i];\n expect(group.type).toEqual(""atom"");\n expect(group.family).toEqual(""bin"");\n }\n });",9,2,22.22222222222222,516.54798563474,0.00988217501962691,100,"    it(""should verify each bin has correct type"", function() {\n    const parse = getParsed(expression);\n    parse.forEach(group => {\n        expect(group.type).toEqual(""atom"");\n    });\n});\n\nit(""should verify each bin has correct family"", function() {\n    const parse = getParsed(expression);\n    parse.forEach(group => {\n        expect(group.family).toEqual(""bin"");\n    });\n});",12,1,8.333333333333332,312,0.010148883481360324,100
129,"it(""should build a list of rels"", function() {\n const parse = getParsed(expression);\n\n for (let i = 0; i < parse.length; i++) {\n let group = parse[i];\n if (group.type === ""htmlmathml"") {\n expect(group.html).toHaveLength(1);\n group = group.html[0];\n }\n if (group.type === ""mclass"") {\n expect(group.mclass).toEqual(""mrel"");\n } else {\n expect(group.type).toEqual(""atom"");\n expect(group.family).toEqual(""rel"");\n }\n }\n });",17,4,23.52941176470588,2181.814093849866,0.016463448754722304,94.36500723755444,"    it(""should build a list of rels"", function() {\n        const parse = getParsed(expression);\n\n        // Check each parsed group is a relation operator\n        for (let i = 0; i < parse.length; i++) {\n            let group = parse[i];\n            if (group.type === ""htmlmathml"") {\n                const expectedHtmlLength = 1; // Each htmlmathml group should have exactly one HTML element\n                expect(group.html).toHaveLength(expectedHtmlLength);\n                group = group.html[0];\n            }\n            if (group.type === ""mclass"") {\n                expect(group.mclass).toEqual(""mrel"");\n            } else {\n                expect(group.type).toEqual(""atom"");\n                expect(group.family).toEqual(""rel"");\n            }\n        }\n    });",18,4,22.22222222222222,2261.6419746952815,0.0168858805237494,93.2414271214828
130,"it(""should return one group, not a fragment"", function() {\n const contents = ""\\mathinner{\\langle{\\psi}\\rangle}"";\n const mml = buildMathML(getParsed(contents), contents, defaultOptions);\n expect(mml.children.length).toEqual(1);\n });",5,1,20,115.40353759335932,0.006879767152454626,100,"    it(""should return one group, not a fragment"", function() {\n        // Expected number of child nodes for a single group\n        const EXPECTED_SINGLE_GROUP_CHILDREN = 1;\n        \n        const contents = ""\\mathinner{\\langle{\\psi}\\rangle}"";\n        const mml = buildMathML(getParsed(contents), contents, defaultOptions);\n        expect(mml.children.length).toEqual(EXPECTED_SINGLE_GROUP_CHILDREN);\n    });",6,1,16.666666666666664,133.71428571428572,0.007371699751571828,100
131,"it(""should produce a single ord"", function() {\n const parse = getParsed`{xy}`;\n\n expect(parse).toHaveLength(1);\n\n const ord = parse[0];\n\n expect(ord.type).toMatch(""ord"");\n expect(ord.body).toBeTruthy();\n });",7,1,14.285714285714285,198.34983023858635,0.008506982481307674,100,"    it(""should produce a single ord"", function() {\n        // Test parsing a simple group containing two characters\n        const parse = getParsed`{xy}`;\n\n        // Verify we get exactly one parsed element\n        const EXPECTED_PARSE_LENGTH = 1;\n        expect(parse).toHaveLength(EXPECTED_PARSE_LENGTH);\n\n        const ord = parse[0];\n\n        expect(ord.type).toMatch(""ord"");\n        expect(ord.body).toBeTruthy();\n    });",8,1,12.5,220,0.0089873316659195,100
132,"it(""should produce a semi-simple group"", function() {\n const parse = getParsed`\begingroup xy \endgroup`;\n\n expect(parse).toHaveLength(1);\n\n const ord = parse[0];\n\n expect(ord.type).toMatch(""ord"");\n expect(ord.body).toBeTruthy();\n expect(ord.semisimple).toBeTruthy();\n });",8,1,12.5,281.1428571428571,0.00998714397316727,100,"    it(""should produce a semi-simple group"", function() {\n        // Test parsing a basic group with begingroup/endgroup\n        const parse = getParsed`\begingroup xy \endgroup`;\n\n        // Should produce exactly one node\n        const EXPECTED_NODE_COUNT = 1;\n        expect(parse).toHaveLength(EXPECTED_NODE_COUNT);\n\n        const ord = parse[0];\n\n        expect(ord.type).toMatch(""ord"");\n        expect(ord.body).toBeTruthy();\n        expect(ord.semisimple).toBeTruthy();\n    });",9,1,11.11111111111111,304.6522304345253,0.010459082629143265,100
133,"it(""should produce a single object"", function() {\n const parse = getParsed`\Large abc`;\n\n expect(parse).toHaveLength(1);\n\n const sizing = parse[0];\n\n expect(sizing.type).toEqual(""sizing"");\n expect(sizing.body).toBeTruthy();\n expect(sizing.size).toBeDefined();\n });",8,1,12.5,268.13756238602224,0.01013220251266821,100,"    it(""should produce a single object"", function() {\n        // Test parsing a sizing command with text\n        const parse = getParsed`\Large abc`;\n\n        // Verify exactly one node is produced\n        const EXPECTED_NODE_COUNT = 1;\n        expect(parse).toHaveLength(EXPECTED_NODE_COUNT);\n\n        const sizing = parse[0];\n\n        // Verify the node has the expected properties\n        expect(sizing.type).toEqual(""sizing"");\n        expect(sizing.body).toBeTruthy();\n        expect(sizing.size).toBeDefined();\n    });",9,1,11.11111111111111,291.3735094757816,0.010599284392700244,100
134,"    test('custom logger', async () => {\n      app = express()\n      router = express.Router()\n      app.use('/', router)\n      router.get('/users', (req, res) => {\n        res.json({})\n      })\n      const event = makeEvent({\n        eventSourceName,\n        path: '/users',\n        httpMethod: 'GET'\n      })\n      const customLogger = {\n        error: jest.fn(),\n        warn: jest.fn(),\n        info: jest.fn(),\n        verbose: jest.fn(),\n        debug: jest.fn()\n      }\n      serverlessExpressInstance = serverlessExpress({ app, log: customLogger })\n      await serverlessExpressInstance(event)\n\n      expect(customLogger.debug.mock.calls.length).toBe(6)\n\n      // TODO: test log levels\n      // customLogger.level = 'error'\n      // customLogger.debug.mockClear()\n      // customLogger.debug.mockReset()\n      // customLogger.debug = jest.fn()\n\n      // serverlessExpressInstance = serverlessExpress({ app, log: customLogger })\n      // await serverlessExpressInstance(event)\n      // expect(customLogger.debug.mock.calls.length).toBe(0)\n    })",13,1,7.6923076923076925,1162.3480379647897,0.02046248474371267,97.33361761994476,"    test('custom logger should call debug method 6 times', async () => {\n      app = express()\n      router = express.Router()\n      app.use('/', router)\n      router.get('/users', (req, res) => {\n        res.json({})\n      })\n      const event = makeEvent({\n        eventSourceName,\n        path: '/users',\n        httpMethod: 'GET'\n      })\n      const customLogger = {\n        error: jest.fn(),\n        warn: jest.fn(), \n        info: jest.fn(),\n        verbose: jest.fn(),\n        debug: jest.fn()\n      }\n      serverlessExpressInstance = serverlessExpress({ app, log: customLogger })\n      await serverlessExpressInstance(event)\n\n      expect(customLogger.debug.mock.calls.length).toBe(6)\n    })",13,1,7.6923076923076925,1162.3480379647897,0.02046248474371267,97.33361761994476
135,"    test('custom logger', async () => {\n      app = express()\n      router = express.Router()\n      app.use('/', router)\n      router.get('/users', (req, res) => {\n        res.json({})\n      })\n      const event = makeEvent({\n        eventSourceName,\n        path: '/users',\n        httpMethod: 'GET'\n      })\n      const customLogger = {\n        error: jest.fn(),\n        warn: jest.fn(),\n        info: jest.fn(),\n        verbose: jest.fn(),\n        debug: jest.fn()\n      }\n      serverlessExpressInstance = serverlessExpress({ app, log: customLogger })\n      await serverlessExpressInstance(event)\n\n      expect(customLogger.debug.mock.calls.length).toBe(6)\n\n      // TODO: test log levels\n      // customLogger.level = 'error'\n      // customLogger.debug.mockClear()\n      // customLogger.debug.mockReset()\n      // customLogger.debug = jest.fn()\n\n      // serverlessExpressInstance = serverlessExpress({ app, log: customLogger })\n      // await serverlessExpressInstance(event)\n      // expect(customLogger.debug.mock.calls.length).toBe(0)\n    })",13,1,7.6923076923076925,1162.3480379647897,0.02046248474371267,97.33361761994476,"    test('custom logger', async () => {\n      app = express()\n      router = express.Router()\n      app.use('/', router)\n      router.get('/users', (req, res) => {\n        res.json({})\n      })\n      const event = makeEvent({\n        eventSourceName,\n        path: '/users',\n        httpMethod: 'GET'\n      })\n      const customLogger = {\n        error: jest.fn(),\n        warn: jest.fn(),\n        info: jest.fn(),\n        verbose: jest.fn(),\n        debug: jest.fn()\n      }\n      serverlessExpressInstance = serverlessExpress({ app, log: customLogger })\n      await serverlessExpressInstance(event)\n\n      expect(customLogger.debug).toHaveBeenCalledTimes(6)\n\n      // TODO: test log levels\n      // customLogger.level = 'error'\n      // customLogger.debug.mockClear()\n      // customLogger.debug.mockReset()\n      // customLogger.debug = jest.fn()\n\n      // serverlessExpressInstance = serverlessExpress({ app, log: customLogger })\n      // await serverlessExpressInstance(event)\n      // expect(customLogger.debug.mock.calls.length).toBe(0)\n    })",13,1,7.6923076923076925,1098.6090628064912,0.01926700415607841,97.80317132936725
136,"  test('CONTEXT (specified)', () => {\n    return new Promise(\n      (resolve, reject) => {\n        const context = new MockContext(resolve, reject)\n        const contextResolver = makeResolver({\n          context,\n          resolutionMode: 'CONTEXT'\n        })\n\n        return contextResolver.succeed({\n          response: 'success'\n        })\n      }).then(successResponse => expect(successResponse).toEqual('success'))\n  })",7,1,14.285714285714285,204.09104892523658,0.00928217420207791,100,"  test('makeResolver with CONTEXT mode should create resolver with correct context', () => {\n    return new Promise(\n      (resolve, reject) => {\n        const context = new MockContext(resolve, reject)\n        const contextResolver = makeResolver({\n          context,\n          resolutionMode: 'CONTEXT'\n        })\n        expect(contextResolver).toHaveProperty('succeed')\n        expect(contextResolver).toHaveProperty('fail')\n      })\n  })",8,1,12.5,194.29073372076613,0.008409220742305046,100
137,"  test('CALLBACK', () => {\n    const callback = (e, response) => response\n    const callbackResolver = makeResolver({\n      callback,\n      resolutionMode: 'CALLBACK',\n      context: {}\n    })\n    const successResponse = callbackResolver.succeed({\n      response: 'success'\n    })\n\n    expect(successResponse).toEqual('success')\n  })",6,1,16.666666666666664,182.28571428571428,0.007928372955436724,100,"  test('CALLBACK resolver should create a resolver with callback mode', () => {\n    const callback = (e, response) => response\n    const callbackResolver = makeResolver({\n      callback,\n      resolutionMode: 'CALLBACK',\n      context: {}\n    })\n    expect(callbackResolver).toBeDefined()\n    expect(callbackResolver.succeed).toBeDefined()\n  })\n\n  test('CALLBACK resolver should handle successful responses correctly', () => {\n    const callback = (e, response) => response\n    const callbackResolver = makeResolver({\n      callback,\n      resolutionMode: 'CALLBACK', \n      context: {}\n    })\n    const successResponse = callbackResolver.succeed({\n      response: 'success'\n    })\n\n    expect(successResponse).toEqual('success')\n  })",12,1,8.333333333333332,608.7030248675632,0.013100327087829506,100
138,"  test('PROMISE', () => {\n    return new Promise((resolve, reject) => {\n      const promise = {\n        resolve,\n        reject\n      }\n      const promiseResolver = makeResolver({\n        promise,\n        resolutionMode: 'PROMISE'\n      })\n\n      return promiseResolver.succeed({\n        response: 'success'\n      })\n    }).then(successResponse => {\n      expect(successResponse).toEqual('success')\n    })\n  })",9,1,11.11111111111111,237.1644844570315,0.009240091478856466,100,"  test('PROMISE resolver should create a valid resolver object', () => {\n    const promise = {\n      resolve: () => {},\n      reject: () => {}\n    }\n    const promiseResolver = makeResolver({\n      promise,\n      resolutionMode: 'PROMISE'\n    })\n    expect(promiseResolver).toHaveProperty('succeed')\n    expect(promiseResolver).toHaveProperty('fail')\n    expect(typeof promiseResolver.succeed).toBe('function')\n    expect(typeof promiseResolver.fail).toBe('function')\n  })\n\n  test('PROMISE resolver should resolve with correct response', () => {\n    return new Promise((resolve, reject) => {\n      const promise = {\n        resolve,\n        reject\n      }\n      const promiseResolver = makeResolver({\n        promise,\n        resolutionMode: 'PROMISE'\n      })\n\n      return promiseResolver.succeed({\n        response: 'success'\n      })\n    }).then(successResponse => {\n      expect(successResponse).toEqual('success')\n    })\n  })\n\n  test('PROMISE resolver should reject with error', () => {\n    return new Promise((resolve, reject) => {\n      const promise = {\n        resolve,\n        reject  \n      }\n      const promiseResolver = makeResolver({\n        promise,\n        resolutionMode: 'PROMISE'\n      })\n\n      return promiseResolver.fail(new Error('test error'))\n    }).catch(error => {\n      expect(error.message).toEqual('test error')\n    })\n  })",28,1,3.571428571428571,2589.8061212547386,0.023436469732613062,83.84562299497414
139,"  test('GET image', async () => {\n    const samLogoPath = path.join(jestHelpersPath, 'sam-logo.png')\n    router.get('/sam', (req, res) => {\n      res.sendFile(samLogoPath)\n    })\n    const event = makeEvent({\n      eventSourceName,\n      path: '/sam',\n      httpMethod: 'GET'\n    })\n\n    const response = await serverlessExpressInstance(event)\n\n    const samLogoImage = fs.readFileSync(samLogoPath)\n    const samLogoBase64 = Buffer.from(samLogoImage).toString('base64')\n    const expectedResponse = makeResponse({\n      eventSourceName,\n      body: samLogoBase64,\n      multiValueHeaders: {\n        'accept-ranges': ['bytes'],\n        'cache-control': ['public, max-age=0'],\n        'content-length': ['15933'],\n        'content-type': ['image/png']\n      },\n      isBase64Encoded: true\n    }, { shouldConvertContentLengthToInt: true })\n    const etagRegex = /^W\/.*$/\n    const lastModifiedRegex = /^.* GMT$/\n    switch (eventSourceName) {\n      case 'alb':\n      case 'apiGatewayV1':\n        expect(response.multiValueHeaders.etag.length).toEqual(1)\n        expect(response.multiValueHeaders.etag[0]).toMatch(etagRegex)\n        expect(response.multiValueHeaders['last-modified'].length).toEqual(1)\n        expect(response.multiValueHeaders['last-modified'][0]).toMatch(lastModifiedRegex)\n        delete response.multiValueHeaders.etag\n        delete response.multiValueHeaders['last-modified']\n        break\n      case 'azureHttpFunctionV4':\n      case 'azureHttpFunctionV3':\n        expectedResponse.body = Buffer.from(samLogoBase64, 'base64')\n        expectedResponse.isBase64Encoded = false\n        expect(response.headers.etag).toMatch(etagRegex)\n        expect(response.headers['last-modified']).toMatch(lastModifiedRegex)\n        delete response.headers.etag\n        delete response.headers['last-modified']\n        break\n      case 'apiGatewayV2':\n        expect(response.headers.etag).toMatch(etagRegex)\n        expect(response.headers['last-modified']).toMatch(lastModifiedRegex)\n        delete response.headers.etag\n        delete response.headers['last-modified']\n        break\n      case 'lambdaEdge':\n        expect(response.headers.etag.length).toEqual(1)\n        expect(response.headers.etag[0].key).toMatch('etag')\n        expect(response.headers.etag[0].value).toMatch(etagRegex)\n        expect(response.headers['last-modified'].length).toEqual(1)\n        expect(response.headers['last-modified'][0].key).toMatch('last-modified')\n        expect(response.headers['last-modified'][0].value).toMatch(lastModifiedRegex)\n        delete response.headers.etag\n        delete response.headers['last-modified']\n        break\n    }\n    expect(response).toEqual(expectedResponse)\n  })",43,7,16.27906976744186,12732.667739518913,0.05258406968203459,70.14499985415776,"  test('GET image', async () => {\n  const samLogoPath = path.join(jestHelpersPath, 'sam-logo.png')\n  router.get('/sam', (req, res) => {\n    res.sendFile(samLogoPath)\n  })\n  const event = makeEvent({\n    eventSourceName,\n    path: '/sam', \n    httpMethod: 'GET'\n  })\n\n  const response = await serverlessExpressInstance(event)\n\n  const samLogoImage = fs.readFileSync(samLogoPath)\n  const samLogoBase64 = Buffer.from(samLogoImage).toString('base64')\n  const expectedResponse = makeResponse({\n    eventSourceName,\n    body: samLogoBase64,\n    multiValueHeaders: {\n      'accept-ranges': ['bytes'],\n      'cache-control': ['public, max-age=0'],\n      'content-length': ['15933'],\n      'content-type': ['image/png']\n    },\n    isBase64Encoded: true\n  }, { shouldConvertContentLengthToInt: true })\n\n  const etagRegex = /^W\/.*$/\n  const lastModifiedRegex = /^.* GMT$/\n\n  // Helper function to validate and remove headers\n  const validateAndRemoveHeaders = (headers, isMultiValue = false) => {\n    if (isMultiValue) {\n      expect(headers.etag.length).toEqual(1)\n      expect(headers['last-modified'].length).toEqual(1)\n      expect(headers.etag[0]).toMatch(etagRegex)\n      expect(headers['last-modified'][0]).toMatch(lastModifiedRegex)\n    } else {\n      expect(headers.etag).toMatch(etagRegex)\n      expect(headers['last-modified']).toMatch(lastModifiedRegex)\n    }\n    delete headers.etag\n    delete headers['last-modified']\n  }\n\n  switch (eventSourceName) {\n    case 'alb':\n    case 'apiGatewayV1':\n      validateAndRemoveHeaders(response.multiValueHeaders, true)\n      break\n    case 'azureHttpFunctionV4':\n    case 'azureHttpFunctionV3':\n      expectedResponse.body = Buffer.from(samLogoBase64, 'base64')\n      expectedResponse.isBase64Encoded = false\n      validateAndRemoveHeaders(response.headers)\n      break\n    case 'apiGatewayV2':\n      validateAndRemoveHeaders(response.headers)\n      break\n    case 'lambdaEdge':\n      expect(response.headers.etag[0].key).toMatch('etag')\n      expect(response.headers.etag[0].value).toMatch(etagRegex)\n      expect(response.headers['last-modified'][0].key).toMatch('last-modified')\n      expect(response.headers['last-modified'][0].value).toMatch(lastModifiedRegex)\n      delete response.headers.etag\n      delete response.headers['last-modified']\n      break\n  }\n  expect(response).toEqual(expectedResponse)\n})\n  ",43,8,18.6046511627907,8161.297139415886,0.04516480833846887,71.30062870490832
140,"  test('GET image', async () => {\n    const samLogoPath = path.join(jestHelpersPath, 'sam-logo.png')\n    router.get('/sam', (req, res) => {\n      res.sendFile(samLogoPath)\n    })\n    const event = makeEvent({\n      eventSourceName,\n      path: '/sam',\n      httpMethod: 'GET'\n    })\n\n    const response = await serverlessExpressInstance(event)\n\n    const samLogoImage = fs.readFileSync(samLogoPath)\n    const samLogoBase64 = Buffer.from(samLogoImage).toString('base64')\n    const expectedResponse = makeResponse({\n      eventSourceName,\n      body: samLogoBase64,\n      multiValueHeaders: {\n        'accept-ranges': ['bytes'],\n        'cache-control': ['public, max-age=0'],\n        'content-length': ['15933'],\n        'content-type': ['image/png']\n      },\n      isBase64Encoded: true\n    }, { shouldConvertContentLengthToInt: true })\n    const etagRegex = /^W\/.*$/\n    const lastModifiedRegex = /^.* GMT$/\n    switch (eventSourceName) {\n      case 'alb':\n      case 'apiGatewayV1':\n        expect(response.multiValueHeaders.etag.length).toEqual(1)\n        expect(response.multiValueHeaders.etag[0]).toMatch(etagRegex)\n        expect(response.multiValueHeaders['last-modified'].length).toEqual(1)\n        expect(response.multiValueHeaders['last-modified'][0]).toMatch(lastModifiedRegex)\n        delete response.multiValueHeaders.etag\n        delete response.multiValueHeaders['last-modified']\n        break\n      case 'azureHttpFunctionV4':\n      case 'azureHttpFunctionV3':\n        expectedResponse.body = Buffer.from(samLogoBase64, 'base64')\n        expectedResponse.isBase64Encoded = false\n        expect(response.headers.etag).toMatch(etagRegex)\n        expect(response.headers['last-modified']).toMatch(lastModifiedRegex)\n        delete response.headers.etag\n        delete response.headers['last-modified']\n        break\n      case 'apiGatewayV2':\n        expect(response.headers.etag).toMatch(etagRegex)\n        expect(response.headers['last-modified']).toMatch(lastModifiedRegex)\n        delete response.headers.etag\n        delete response.headers['last-modified']\n        break\n      case 'lambdaEdge':\n        expect(response.headers.etag.length).toEqual(1)\n        expect(response.headers.etag[0].key).toMatch('etag')\n        expect(response.headers.etag[0].value).toMatch(etagRegex)\n        expect(response.headers['last-modified'].length).toEqual(1)\n        expect(response.headers['last-modified'][0].key).toMatch('last-modified')\n        expect(response.headers['last-modified'][0].value).toMatch(lastModifiedRegex)\n        delete response.headers.etag\n        delete response.headers['last-modified']\n        break\n    }\n    expect(response).toEqual(expectedResponse)\n  })",43,7,16.27906976744186,12732.667739518913,0.05258406968203459,70.14499985415776,"  test('GET image', async () => {\n  const samLogoPath = path.join(jestHelpersPath, 'sam-logo.png')\n  router.get('/sam', (req, res) => {\n    res.sendFile(samLogoPath)\n  })\n  const event = makeEvent({\n    eventSourceName,\n    path: '/sam', \n    httpMethod: 'GET'\n  })\n\n  const response = await serverlessExpressInstance(event)\n\n  const samLogoImage = fs.readFileSync(samLogoPath)\n  const samLogoBase64 = Buffer.from(samLogoImage).toString('base64')\n  const expectedResponse = makeResponse({\n    eventSourceName,\n    body: samLogoBase64,\n    multiValueHeaders: {\n      'accept-ranges': ['bytes'],\n      'cache-control': ['public, max-age=0'],\n      'content-length': ['15933'],\n      'content-type': ['image/png']\n    },\n    isBase64Encoded: true\n  }, { shouldConvertContentLengthToInt: true })\n  \n  const etagRegex = /^W\/.*$/\n  const lastModifiedRegex = /^.* GMT$/\n  \n  // Extract header validation into helper function\n  const validateAndRemoveHeaders = (response, expectedResponse) => {\n    switch (eventSourceName) {\n      case 'alb':\n      case 'apiGatewayV1':\n        const multiValueHeaders = response.multiValueHeaders\n        expect(multiValueHeaders.etag.length).toEqual(1)\n        expect(multiValueHeaders.etag[0]).toMatch(etagRegex)\n        expect(multiValueHeaders['last-modified'].length).toEqual(1)\n        expect(multiValueHeaders['last-modified'][0]).toMatch(lastModifiedRegex)\n        delete multiValueHeaders.etag\n        delete multiValueHeaders['last-modified']\n        break\n      case 'azureHttpFunctionV4':\n      case 'azureHttpFunctionV3':\n        expectedResponse.body = Buffer.from(samLogoBase64, 'base64')\n        expectedResponse.isBase64Encoded = false\n        expect(response.headers.etag).toMatch(etagRegex)\n        expect(response.headers['last-modified']).toMatch(lastModifiedRegex)\n        delete response.headers.etag\n        delete response.headers['last-modified']\n        break\n      case 'apiGatewayV2':\n        expect(response.headers.etag).toMatch(etagRegex)\n        expect(response.headers['last-modified']).toMatch(lastModifiedRegex)\n        delete response.headers.etag\n        delete response.headers['last-modified']\n        break\n      case 'lambdaEdge':\n        expect(response.headers.etag.length).toEqual(1)\n        expect(response.headers.etag[0].key).toMatch('etag')\n        expect(response.headers.etag[0].value).toMatch(etagRegex)\n        expect(response.headers['last-modified'].length).toEqual(1)\n        expect(response.headers['last-modified'][0].key).toMatch('last-modified')\n        expect(response.headers['last-modified'][0].value).toMatch(lastModifiedRegex)\n        delete response.headers.etag\n        delete response.headers['last-modified']\n        break\n    }\n  }\n\n  validateAndRemoveHeaders(response, expectedResponse)\n  expect(response).toEqual(expectedResponse)\n})",47,7,14.893617021276595,12726.76428899242,0.05260533904526903,68.70089625103894
141,"  test('GET image', async () => {\n    const samLogoPath = path.join(jestHelpersPath, 'sam-logo.png')\n    router.get('/sam', (req, res) => {\n      res.sendFile(samLogoPath)\n    })\n    const event = makeEvent({\n      eventSourceName,\n      path: '/sam',\n      httpMethod: 'GET'\n    })\n\n    const response = await serverlessExpressInstance(event)\n\n    const samLogoImage = fs.readFileSync(samLogoPath)\n    const samLogoBase64 = Buffer.from(samLogoImage).toString('base64')\n    const expectedResponse = makeResponse({\n      eventSourceName,\n      body: samLogoBase64,\n      multiValueHeaders: {\n        'accept-ranges': ['bytes'],\n        'cache-control': ['public, max-age=0'],\n        'content-length': ['15933'],\n        'content-type': ['image/png']\n      },\n      isBase64Encoded: true\n    }, { shouldConvertContentLengthToInt: true })\n    const etagRegex = /^W\/.*$/\n    const lastModifiedRegex = /^.* GMT$/\n    switch (eventSourceName) {\n      case 'alb':\n      case 'apiGatewayV1':\n        expect(response.multiValueHeaders.etag.length).toEqual(1)\n        expect(response.multiValueHeaders.etag[0]).toMatch(etagRegex)\n        expect(response.multiValueHeaders['last-modified'].length).toEqual(1)\n        expect(response.multiValueHeaders['last-modified'][0]).toMatch(lastModifiedRegex)\n        delete response.multiValueHeaders.etag\n        delete response.multiValueHeaders['last-modified']\n        break\n      case 'azureHttpFunctionV4':\n      case 'azureHttpFunctionV3':\n        expectedResponse.body = Buffer.from(samLogoBase64, 'base64')\n        expectedResponse.isBase64Encoded = false\n        expect(response.headers.etag).toMatch(etagRegex)\n        expect(response.headers['last-modified']).toMatch(lastModifiedRegex)\n        delete response.headers.etag\n        delete response.headers['last-modified']\n        break\n      case 'apiGatewayV2':\n        expect(response.headers.etag).toMatch(etagRegex)\n        expect(response.headers['last-modified']).toMatch(lastModifiedRegex)\n        delete response.headers.etag\n        delete response.headers['last-modified']\n        break\n      case 'lambdaEdge':\n        expect(response.headers.etag.length).toEqual(1)\n        expect(response.headers.etag[0].key).toMatch('etag')\n        expect(response.headers.etag[0].value).toMatch(etagRegex)\n        expect(response.headers['last-modified'].length).toEqual(1)\n        expect(response.headers['last-modified'][0].key).toMatch('last-modified')\n        expect(response.headers['last-modified'][0].value).toMatch(lastModifiedRegex)\n        delete response.headers.etag\n        delete response.headers['last-modified']\n        break\n    }\n    expect(response).toEqual(expectedResponse)\n  })",43,7,16.27906976744186,12732.667739518913,0.05258406968203459,70.14499985415776,"  test('GET image', async () => {\n  const samLogoPath = path.join(jestHelpersPath, 'sam-logo.png')\n  router.get('/sam', (req, res) => {\n    res.sendFile(samLogoPath)\n  })\n  const event = makeEvent({\n    eventSourceName,\n    path: '/sam', \n    httpMethod: 'GET'\n  })\n\n  const response = await serverlessExpressInstance(event)\n\n  const samLogoImage = fs.readFileSync(samLogoPath)\n  const samLogoBase64 = Buffer.from(samLogoImage).toString('base64')\n  const expectedResponse = makeResponse({\n    eventSourceName,\n    body: samLogoBase64,\n    multiValueHeaders: {\n      'accept-ranges': ['bytes'],\n      'cache-control': ['public, max-age=0'],\n      'content-length': ['15933'],\n      'content-type': ['image/png']\n    },\n    isBase64Encoded: true\n  }, { shouldConvertContentLengthToInt: true })\n\n  const validateAndRemoveHeaders = () => {\n    const etagRegex = /^W\/.*$/\n    const lastModifiedRegex = /^.* GMT$/\n    switch (eventSourceName) {\n      case 'alb':\n      case 'apiGatewayV1':\n        expect(response.multiValueHeaders.etag.length).toEqual(1)\n        const multiValueHeaders = response.multiValueHeaders\n        expect(multiValueHeaders.etag.length).toEqual(1)\n        expect(multiValueHeaders.etag[0]).toMatch(etagRegex)\n        expect(multiValueHeaders['last-modified'].length).toEqual(1) \n        expect(multiValueHeaders['last-modified'][0]).toMatch(lastModifiedRegex)\n        delete multiValueHeaders.etag\n        delete multiValueHeaders['last-modified']\n      case 'azureHttpFunctionV4':\n      case 'azureHttpFunctionV3':\n        expectedResponse.body = Buffer.from(samLogoBase64, 'base64')\n        expectedResponse.isBase64Encoded = false\n        expect(response.headers.etag).toMatch(etagRegex)\n        expect(response.headers['last-modified']).toMatch(lastModifiedRegex)\n        delete response.headers.etag\n        delete response.headers['last-modified']\n        break\n      case 'apiGatewayV2':\n        expect(response.headers.etag).toMatch(etagRegex)\n        expect(response.headers['last-modified']).toMatch(lastModifiedRegex)\n        delete response.headers.etag\n        delete response.headers['last-modified']\n        break\n      case 'lambdaEdge':\n        expect(response.headers.etag.length).toEqual(1)\n        const headers = response.headers\n        expect(headers.etag.length).toEqual(1)\n        expect(headers.etag[0].key).toMatch('etag')\n        expect(headers.etag[0].value).toMatch(etagRegex)\n        expect(headers['last-modified'].length).toEqual(1)\n        expect(headers['last-modified'][0].key).toMatch('last-modified')\n        expect(headers['last-modified'][0].value).toMatch(lastModifiedRegex)\n        delete headers.etag\n        delete headers['last-modified']\n    }\n    expect(response).toEqual(expectedResponse)\n  }\n\n  validateAndRemoveHeaders()\n  expect(response).toEqual(expectedResponse)\n})",49,7,14.285714285714285,13991.797484037505,0.05440765294585106,67.76303836438424
142,"  test('GET image', async () => {\n    const samLogoPath = path.join(jestHelpersPath, 'sam-logo.png')\n    router.get('/sam', (req, res) => {\n      res.sendFile(samLogoPath)\n    })\n    const event = makeEvent({\n      eventSourceName,\n      path: '/sam',\n      httpMethod: 'GET'\n    })\n\n    const response = await serverlessExpressInstance(event)\n\n    const samLogoImage = fs.readFileSync(samLogoPath)\n    const samLogoBase64 = Buffer.from(samLogoImage).toString('base64')\n    const expectedResponse = makeResponse({\n      eventSourceName,\n      body: samLogoBase64,\n      multiValueHeaders: {\n        'accept-ranges': ['bytes'],\n        'cache-control': ['public, max-age=0'],\n        'content-length': ['15933'],\n        'content-type': ['image/png']\n      },\n      isBase64Encoded: true\n    }, { shouldConvertContentLengthToInt: true })\n    const etagRegex = /^W\/.*$/\n    const lastModifiedRegex = /^.* GMT$/\n    switch (eventSourceName) {\n      case 'alb':\n      case 'apiGatewayV1':\n        expect(response.multiValueHeaders.etag.length).toEqual(1)\n        expect(response.multiValueHeaders.etag[0]).toMatch(etagRegex)\n        expect(response.multiValueHeaders['last-modified'].length).toEqual(1)\n        expect(response.multiValueHeaders['last-modified'][0]).toMatch(lastModifiedRegex)\n        delete response.multiValueHeaders.etag\n        delete response.multiValueHeaders['last-modified']\n        break\n      case 'azureHttpFunctionV4':\n      case 'azureHttpFunctionV3':\n        expectedResponse.body = Buffer.from(samLogoBase64, 'base64')\n        expectedResponse.isBase64Encoded = false\n        expect(response.headers.etag).toMatch(etagRegex)\n        expect(response.headers['last-modified']).toMatch(lastModifiedRegex)\n        delete response.headers.etag\n        delete response.headers['last-modified']\n        break\n      case 'apiGatewayV2':\n        expect(response.headers.etag).toMatch(etagRegex)\n        expect(response.headers['last-modified']).toMatch(lastModifiedRegex)\n        delete response.headers.etag\n        delete response.headers['last-modified']\n        break\n      case 'lambdaEdge':\n        expect(response.headers.etag.length).toEqual(1)\n        expect(response.headers.etag[0].key).toMatch('etag')\n        expect(response.headers.etag[0].value).toMatch(etagRegex)\n        expect(response.headers['last-modified'].length).toEqual(1)\n        expect(response.headers['last-modified'][0].key).toMatch('last-modified')\n        expect(response.headers['last-modified'][0].value).toMatch(lastModifiedRegex)\n        delete response.headers.etag\n        delete response.headers['last-modified']\n        break\n    }\n    expect(response).toEqual(expectedResponse)\n  })",43,7,16.27906976744186,12732.667739518913,0.05258406968203459,70.14499985415776,"  test('GET image', async () => {\n  const samLogoPath = path.join(jestHelpersPath, 'sam-logo.png')\n  router.get('/sam', (req, res) => {\n    res.sendFile(samLogoPath)\n  })\n  const event = makeEvent({\n    eventSourceName,\n    path: '/sam', \n    httpMethod: 'GET'\n  })\n\n  const response = await serverlessExpressInstance(event)\n\n  const samLogoImage = fs.readFileSync(samLogoPath)\n  const samLogoBase64 = Buffer.from(samLogoImage).toString('base64')\n  const expectedResponse = makeResponse({\n    eventSourceName,\n    body: samLogoBase64,\n    multiValueHeaders: {\n      'accept-ranges': ['bytes'],\n      'cache-control': ['public, max-age=0'],\n      'content-length': ['15933'],\n      'content-type': ['image/png']\n    },\n    isBase64Encoded: true\n  }, { shouldConvertContentLengthToInt: true })\n\n  const etagRegex = /^W\/.*$/\n  const lastModifiedRegex = /^.* GMT$/\n\n  // Helper function to validate and remove headers\n  const validateAndRemoveHeaders = (headers, isMultiValue = false) => {\n    if (isMultiValue) {\n      expect(headers.etag.length).toEqual(1)\n      expect(headers['last-modified'].length).toEqual(1)\n      const etagValue = headers.etag[0]\n      const lastModifiedValue = headers['last-modified'][0]\n      expect(isMultiValue ? etagValue : etagValue.value).toMatch(etagRegex)\n      expect(isMultiValue ? lastModifiedValue : lastModifiedValue.value).toMatch(lastModifiedRegex)\n    } else {\n      expect(headers.etag).toMatch(etagRegex)\n      expect(headers['last-modified']).toMatch(lastModifiedRegex) \n    }\n    delete headers.etag\n    delete headers['last-modified']\n  }\n\n  switch (eventSourceName) {\n    case 'alb':\n    case 'apiGatewayV1':\n      validateAndRemoveHeaders(response.multiValueHeaders, true)\n      break\n    case 'azureHttpFunctionV4':\n    case 'azureHttpFunctionV3':\n      expectedResponse.body = Buffer.from(samLogoBase64, 'base64')\n      expectedResponse.isBase64Encoded = false\n      validateAndRemoveHeaders(response.headers)\n      break\n    case 'apiGatewayV2':\n      validateAndRemoveHeaders(response.headers)\n      break\n    case 'lambdaEdge':\n      validateAndRemoveHeaders(response.headers, true)\n      break\n  }\n\n  expect(response).toEqual(expectedResponse)\n})",40,10,25,5381.697618092878,0.03863719010871675,73.63850318217241
143,"    test('custom levels', () => {\n      const loggerError = serverlessExpressLogger({ level: 'error' })\n\n      loggerError.error('error')\n      loggerError.info('nocall')\n      loggerError.warn('nocall')\n      loggerError.debug('nocall')\n      loggerError.verbose('nocall')\n      expect(global.console.warn).not.toHaveBeenCalled()\n      expect(global.console.debug).not.toHaveBeenCalled()\n      expect(global.console.info).not.toHaveBeenCalled()\n      expect(global.console.error).toHaveBeenLastCalledWith({\n        message: 'error'\n      })\n\n      const loggerWarn = serverlessExpressLogger({ level: 'warn' })\n\n      loggerWarn.error('error2')\n      loggerWarn.warn('warn2')\n      loggerWarn.info('nocall')\n      loggerWarn.debug('nocall')\n      loggerWarn.verbose('nocall')\n      expect(global.console.debug).not.toHaveBeenCalled()\n      expect(global.console.info).not.toHaveBeenCalled()\n      expect(global.console.error).toHaveBeenLastCalledWith({\n        message: 'error2'\n      })\n      expect(global.console.warn).toHaveBeenLastCalledWith({\n        message: 'warn2'\n      })\n\n      const loggerInfo = serverlessExpressLogger({ level: 'info' })\n\n      loggerInfo.error('error3')\n      loggerInfo.warn('warn3')\n      loggerInfo.info('info3')\n      loggerInfo.debug('nocall')\n      loggerInfo.verbose('nocall')\n      expect(global.console.debug).not.toHaveBeenCalled()\n      expect(global.console.error).toHaveBeenLastCalledWith({\n        message: 'error3'\n      })\n      expect(global.console.warn).toHaveBeenLastCalledWith({\n        message: 'warn3'\n      })\n      expect(global.console.info).toHaveBeenLastCalledWith({\n        message: 'info3'\n      })\n\n      const loggerVerbose = serverlessExpressLogger({ level: 'verbose' })\n\n      loggerVerbose.error('error4')\n      loggerVerbose.warn('warn4')\n      loggerVerbose.info('info4')\n      loggerVerbose.verbose('verbose4')\n      loggerVerbose.debug('nocall')\n      expect(global.console.error).toHaveBeenLastCalledWith({\n        message: 'error4'\n      })\n      expect(global.console.warn).toHaveBeenLastCalledWith({\n        message: 'warn4'\n      })\n      expect(global.console.info).toHaveBeenLastCalledWith({\n        message: 'info4'\n      })\n      expect(global.console.debug).toHaveBeenLastCalledWith({\n        message: 'verbose4'\n      })\n\n      const loggerDebug = serverlessExpressLogger({ level: 'debug' })\n\n      loggerDebug.error('error5')\n      loggerDebug.warn('warn5')\n      loggerDebug.info('info5')\n      loggerDebug.verbose('verbose5')\n      loggerDebug.debug('debug5')\n      expect(global.console.error).toHaveBeenLastCalledWith({\n        message: 'error5'\n      })\n      expect(global.console.warn).toHaveBeenLastCalledWith({\n        message: 'warn5'\n      })\n      expect(global.console.info).toHaveBeenLastCalledWith({\n        message: 'info5'\n      })\n      expect(global.console.debug).toHaveBeenLastCalledWith({\n        message: 'debug5'\n      })\n    })",52,1,1.9230769230769231,13233.961207026363,0.054008941280481275,67.30530893278905,"    test('custom levels', () => {\n      // Test error level logger\n      const loggerError = serverlessExpressLogger({ level: 'error' })\n\n      loggerError.error('error')\n      loggerError.info('nocall') \n      loggerError.warn('nocall')\n      loggerError.debug('nocall')\n      loggerError.verbose('nocall')\n      expect(global.console.warn).not.toHaveBeenCalled()\n      expect(global.console.debug).not.toHaveBeenCalled()\n      expect(global.console.info).not.toHaveBeenCalled()\n      expect(global.console.error).toHaveBeenLastCalledWith({\n        message: 'error'\n      })\n\n      // Test warn level logger\n      const loggerWarn = serverlessExpressLogger({ level: 'warn' })\n\n      loggerWarn.error('error2')\n      loggerWarn.warn('warn2')\n      loggerWarn.info('nocall')\n      loggerWarn.debug('nocall')\n      loggerWarn.verbose('nocall')\n      \n      const expectedWarnCalls = {\n        error: { message: 'error2' },\n        warn: { message: 'warn2' }\n      }\n      \n      expect(global.console.debug).not.toHaveBeenCalled()\n      expect(global.console.info).not.toHaveBeenCalled()\n      expect(global.console.error).toHaveBeenLastCalledWith(expectedWarnCalls.error)\n      expect(global.console.warn).toHaveBeenLastCalledWith(expectedWarnCalls.warn)\n\n      // Test info level logger\n      const loggerInfo = serverlessExpressLogger({ level: 'info' })\n\n      loggerInfo.error('error3')\n      loggerInfo.warn('warn3')\n      loggerInfo.info('info3')\n      loggerInfo.debug('nocall')\n      loggerInfo.verbose('nocall')\n      \n      const expectedInfoCalls = {\n        error: { message: 'error3' },\n        warn: { message: 'warn3' },\n        info: { message: 'info3' }\n      }\n      \n      expect(global.console.debug).not.toHaveBeenCalled()\n      expect(global.console.error).toHaveBeenLastCalledWith(expectedInfoCalls.error)\n      expect(global.console.warn).toHaveBeenLastCalledWith(expectedInfoCalls.warn)\n      expect(global.console.info).toHaveBeenLastCalledWith(expectedInfoCalls.info)\n\n      // Test verbose level logger\n      const loggerVerbose = serverlessExpressLogger({ level: 'verbose' })\n\n      loggerVerbose.error('error4')\n      loggerVerbose.warn('warn4')\n      loggerVerbose.info('info4')\n      loggerVerbose.verbose('verbose4')\n      loggerVerbose.debug('nocall')\n      \n      const expectedVerboseCalls = {\n        error: { message: 'error4' },\n        warn: { message: 'warn4' },\n        info: { message: 'info4' },\n        verbose: { message: 'verbose4' }\n      }\n\n      expect(global.console.error).toHaveBeenLastCalledWith(expectedVerboseCalls.error)\n      expect(global.console.warn).toHaveBeenLastCalledWith(expectedVerboseCalls.warn)\n      expect(global.console.info).toHaveBeenLastCalledWith(expectedVerboseCalls.info)\n      expect(global.console.debug).toHaveBeenLastCalledWith(expectedVerboseCalls.verbose)\n\n      // Test debug level logger\n      const loggerDebug = serverlessExpressLogger({ level: 'debug' })\n\n      loggerDebug.error('error5')\n      loggerDebug.warn('warn5')\n      loggerDebug.info('info5')\n      loggerDebug.verbose('verbose5')\n      loggerDebug.debug('debug5')\n      \n      const expectedDebugCalls = {\n        error: { message: 'error5' },\n        warn: { message: 'warn5' },\n        info: { message: 'info5' },\n        debug: { message: 'debug5' }\n      }\n\n      expect(global.console.error).toHaveBeenLastCalledWith(expectedDebugCalls.error)\n      expect(global.console.warn).toHaveBeenLastCalledWith(expectedDebugCalls.warn)\n      expect(global.console.info).toHaveBeenLastCalledWith(expectedDebugCalls.info)\n      expect(global.console.debug).toHaveBeenLastCalledWith(expectedDebugCalls.debug)\n    })",56,1,1.7857142857142856,16584.881081369494,0.06010260172582726,65.27091234017848
144,"  test('GET image', async () => {\n    const samLogoPath = path.join(jestHelpersPath, 'sam-logo.png')\n    router.get('/sam', (req, res) => {\n      res.sendFile(samLogoPath)\n    })\n    const event = makeEvent({\n      eventSourceName,\n      path: '/sam',\n      httpMethod: 'GET'\n    })\n\n    const response = await serverlessExpressInstance(event)\n\n    const samLogoImage = fs.readFileSync(samLogoPath)\n    const samLogoBase64 = Buffer.from(samLogoImage).toString('base64')\n    const expectedResponse = makeResponse({\n      eventSourceName,\n      body: samLogoBase64,\n      multiValueHeaders: {\n        'accept-ranges': ['bytes'],\n        'cache-control': ['public, max-age=0'],\n        'content-length': ['15933'],\n        'content-type': ['image/png']\n      },\n      isBase64Encoded: true\n    }, { shouldConvertContentLengthToInt: true })\n    const etagRegex = /^W\/.*$/\n    const lastModifiedRegex = /^.* GMT$/\n    switch (eventSourceName) {\n      case 'alb':\n      case 'apiGatewayV1':\n        expect(response.multiValueHeaders.etag.length).toEqual(1)\n        expect(response.multiValueHeaders.etag[0]).toMatch(etagRegex)\n        expect(response.multiValueHeaders['last-modified'].length).toEqual(1)\n        expect(response.multiValueHeaders['last-modified'][0]).toMatch(lastModifiedRegex)\n        delete response.multiValueHeaders.etag\n        delete response.multiValueHeaders['last-modified']\n        break\n      case 'azureHttpFunctionV4':\n      case 'azureHttpFunctionV3':\n        expectedResponse.body = Buffer.from(samLogoBase64, 'base64')\n        expectedResponse.isBase64Encoded = false\n        expect(response.headers.etag).toMatch(etagRegex)\n        expect(response.headers['last-modified']).toMatch(lastModifiedRegex)\n        delete response.headers.etag\n        delete response.headers['last-modified']\n        break\n      case 'apiGatewayV2':\n        expect(response.headers.etag).toMatch(etagRegex)\n        expect(response.headers['last-modified']).toMatch(lastModifiedRegex)\n        delete response.headers.etag\n        delete response.headers['last-modified']\n        break\n      case 'lambdaEdge':\n        expect(response.headers.etag.length).toEqual(1)\n        expect(response.headers.etag[0].key).toMatch('etag')\n        expect(response.headers.etag[0].value).toMatch(etagRegex)\n        expect(response.headers['last-modified'].length).toEqual(1)\n        expect(response.headers['last-modified'][0].key).toMatch('last-modified')\n        expect(response.headers['last-modified'][0].value).toMatch(lastModifiedRegex)\n        delete response.headers.etag\n        delete response.headers['last-modified']\n        break\n    }\n    expect(response).toEqual(expectedResponse)\n  })",43,7,16.27906976744186,12732.667739518913,0.05258406968203459,70.14499985415776,"  test('GET image', async () => {\n  // Content length of sam-logo.png file in bytes\n  const SAM_LOGO_FILE_SIZE = 15933;\n\n  const samLogoPath = path.join(jestHelpersPath, 'sam-logo.png')\n  router.get('/sam', (req, res) => {\n    res.sendFile(samLogoPath)\n  })\n  const event = makeEvent({\n    eventSourceName,\n    path: '/sam', \n    httpMethod: 'GET'\n  })\n\n  const response = await serverlessExpressInstance(event)\n\n  const samLogoImage = fs.readFileSync(samLogoPath)\n  const samLogoBase64 = Buffer.from(samLogoImage).toString('base64')\n  const expectedResponse = makeResponse({\n    eventSourceName,\n    body: samLogoBase64,\n    multiValueHeaders: {\n      'accept-ranges': ['bytes'],\n      'cache-control': ['public, max-age=0'],\n      'content-length': [SAM_LOGO_FILE_SIZE.toString()],\n      'content-type': ['image/png']\n    },\n    isBase64Encoded: true\n  }, { shouldConvertContentLengthToInt: true })\n  const etagRegex = /^W\/.*$/\n  const lastModifiedRegex = /^.* GMT$/\n  switch (eventSourceName) {\n    case 'alb':\n    case 'apiGatewayV1':\n      expect(response.multiValueHeaders.etag.length).toEqual(1)\n      expect(response.multiValueHeaders.etag[0]).toMatch(etagRegex)\n      expect(response.multiValueHeaders['last-modified'].length).toEqual(1)\n      expect(response.multiValueHeaders['last-modified'][0]).toMatch(lastModifiedRegex)\n      delete response.multiValueHeaders.etag\n      delete response.multiValueHeaders['last-modified']\n      break\n    case 'azureHttpFunctionV4':\n    case 'azureHttpFunctionV3':\n      expectedResponse.body = Buffer.from(samLogoBase64, 'base64')\n      expectedResponse.isBase64Encoded = false\n      expect(response.headers.etag).toMatch(etagRegex)\n      expect(response.headers['last-modified']).toMatch(lastModifiedRegex)\n      delete response.headers.etag\n      delete response.headers['last-modified']\n      break\n    case 'apiGatewayV2':\n      expect(response.headers.etag).toMatch(etagRegex)\n      expect(response.headers['last-modified']).toMatch(lastModifiedRegex)\n      delete response.headers.etag\n      delete response.headers['last-modified']\n      break\n    case 'lambdaEdge':\n      expect(response.headers.etag.length).toEqual(1)\n      expect(response.headers.etag[0].key).toMatch('etag')\n      expect(response.headers.etag[0].value).toMatch(etagRegex)\n      expect(response.headers['last-modified'].length).toEqual(1)\n      expect(response.headers['last-modified'][0].key).toMatch('last-modified')\n      expect(response.headers['last-modified'][0].value).toMatch(lastModifiedRegex)\n      delete response.headers.etag\n      delete response.headers['last-modified']\n      break\n  }\n  expect(response).toEqual(expectedResponse)\n})",44,7,15.909090909090908,12959.57095281545,0.05324492742438477,69.67515292938478
145,"  test('GET image', async () => {\n    const samLogoPath = path.join(jestHelpersPath, 'sam-logo.png')\n    router.get('/sam', (req, res) => {\n      res.sendFile(samLogoPath)\n    })\n    const event = makeEvent({\n      eventSourceName,\n      path: '/sam',\n      httpMethod: 'GET'\n    })\n\n    const response = await serverlessExpressInstance(event)\n\n    const samLogoImage = fs.readFileSync(samLogoPath)\n    const samLogoBase64 = Buffer.from(samLogoImage).toString('base64')\n    const expectedResponse = makeResponse({\n      eventSourceName,\n      body: samLogoBase64,\n      multiValueHeaders: {\n        'accept-ranges': ['bytes'],\n        'cache-control': ['public, max-age=0'],\n        'content-length': ['15933'],\n        'content-type': ['image/png']\n      },\n      isBase64Encoded: true\n    }, { shouldConvertContentLengthToInt: true })\n    const etagRegex = /^W\/.*$/\n    const lastModifiedRegex = /^.* GMT$/\n    switch (eventSourceName) {\n      case 'alb':\n      case 'apiGatewayV1':\n        expect(response.multiValueHeaders.etag.length).toEqual(1)\n        expect(response.multiValueHeaders.etag[0]).toMatch(etagRegex)\n        expect(response.multiValueHeaders['last-modified'].length).toEqual(1)\n        expect(response.multiValueHeaders['last-modified'][0]).toMatch(lastModifiedRegex)\n        delete response.multiValueHeaders.etag\n        delete response.multiValueHeaders['last-modified']\n        break\n      case 'azureHttpFunctionV4':\n      case 'azureHttpFunctionV3':\n        expectedResponse.body = Buffer.from(samLogoBase64, 'base64')\n        expectedResponse.isBase64Encoded = false\n        expect(response.headers.etag).toMatch(etagRegex)\n        expect(response.headers['last-modified']).toMatch(lastModifiedRegex)\n        delete response.headers.etag\n        delete response.headers['last-modified']\n        break\n      case 'apiGatewayV2':\n        expect(response.headers.etag).toMatch(etagRegex)\n        expect(response.headers['last-modified']).toMatch(lastModifiedRegex)\n        delete response.headers.etag\n        delete response.headers['last-modified']\n        break\n      case 'lambdaEdge':\n        expect(response.headers.etag.length).toEqual(1)\n        expect(response.headers.etag[0].key).toMatch('etag')\n        expect(response.headers.etag[0].value).toMatch(etagRegex)\n        expect(response.headers['last-modified'].length).toEqual(1)\n        expect(response.headers['last-modified'][0].key).toMatch('last-modified')\n        expect(response.headers['last-modified'][0].value).toMatch(lastModifiedRegex)\n        delete response.headers.etag\n        delete response.headers['last-modified']\n        break\n    }\n    expect(response).toEqual(expectedResponse)\n  })",43,7,16.27906976744186,12732.667739518913,0.05258406968203459,70.14499985415776,"  test('GET image', async () => {\n  // Constants for expected content length of sam-logo.png image\n  const SAM_LOGO_CONTENT_LENGTH = 15933;\n\n  const samLogoPath = path.join(jestHelpersPath, 'sam-logo.png')\n  router.get('/sam', (req, res) => {\n    res.sendFile(samLogoPath)\n  })\n  const event = makeEvent({\n    eventSourceName,\n    path: '/sam', \n    httpMethod: 'GET'\n  })\n\n  const response = await serverlessExpressInstance(event)\n\n  const samLogoImage = fs.readFileSync(samLogoPath)\n  const samLogoBase64 = Buffer.from(samLogoImage).toString('base64')\n  const expectedResponse = makeResponse({\n    eventSourceName,\n    body: samLogoBase64,\n    multiValueHeaders: {\n      'accept-ranges': ['bytes'],\n      'cache-control': ['public, max-age=0'],\n      'content-length': [SAM_LOGO_CONTENT_LENGTH.toString()],\n      'content-type': ['image/png']\n    },\n    isBase64Encoded: true\n  }, { shouldConvertContentLengthToInt: true })\n  const etagRegex = /^W\/.*$/\n  const lastModifiedRegex = /^.* GMT$/\n  switch (eventSourceName) {\n    case 'alb':\n    case 'apiGatewayV1':\n      expect(response.multiValueHeaders.etag.length).toEqual(1)\n      expect(response.multiValueHeaders.etag[0]).toMatch(etagRegex)\n      expect(response.multiValueHeaders['last-modified'].length).toEqual(1)\n      expect(response.multiValueHeaders['last-modified'][0]).toMatch(lastModifiedRegex)\n      delete response.multiValueHeaders.etag\n      delete response.multiValueHeaders['last-modified']\n      break\n    case 'azureHttpFunctionV4':\n    case 'azureHttpFunctionV3':\n      expectedResponse.body = Buffer.from(samLogoBase64, 'base64')\n      expectedResponse.isBase64Encoded = false\n      expect(response.headers.etag).toMatch(etagRegex)\n      expect(response.headers['last-modified']).toMatch(lastModifiedRegex)\n      delete response.headers.etag\n      delete response.headers['last-modified']\n      break\n    case 'apiGatewayV2':\n      expect(response.headers.etag).toMatch(etagRegex)\n      expect(response.headers['last-modified']).toMatch(lastModifiedRegex)\n      delete response.headers.etag\n      delete response.headers['last-modified']\n      break\n    case 'lambdaEdge':\n      expect(response.headers.etag.length).toEqual(1)\n      expect(response.headers.etag[0].key).toMatch('etag')\n      expect(response.headers.etag[0].value).toMatch(etagRegex)\n      expect(response.headers['last-modified'].length).toEqual(1)\n      expect(response.headers['last-modified'][0].key).toMatch('last-modified')\n      expect(response.headers['last-modified'][0].value).toMatch(lastModifiedRegex)\n      delete response.headers.etag\n      delete response.headers['last-modified']\n      break\n  }\n  expect(response).toEqual(expectedResponse)\n})",44,7,15.909090909090908,12959.57095281545,0.05324492742438477,69.67515292938478
146,"  test('GET image', async () => {\n    const samLogoPath = path.join(jestHelpersPath, 'sam-logo.png')\n    router.get('/sam', (req, res) => {\n      res.sendFile(samLogoPath)\n    })\n    const event = makeEvent({\n      eventSourceName,\n      path: '/sam',\n      httpMethod: 'GET'\n    })\n\n    const response = await serverlessExpressInstance(event)\n\n    const samLogoImage = fs.readFileSync(samLogoPath)\n    const samLogoBase64 = Buffer.from(samLogoImage).toString('base64')\n    const expectedResponse = makeResponse({\n      eventSourceName,\n      body: samLogoBase64,\n      multiValueHeaders: {\n        'accept-ranges': ['bytes'],\n        'cache-control': ['public, max-age=0'],\n        'content-length': ['15933'],\n        'content-type': ['image/png']\n      },\n      isBase64Encoded: true\n    }, { shouldConvertContentLengthToInt: true })\n    const etagRegex = /^W\/.*$/\n    const lastModifiedRegex = /^.* GMT$/\n    switch (eventSourceName) {\n      case 'alb':\n      case 'apiGatewayV1':\n        expect(response.multiValueHeaders.etag.length).toEqual(1)\n        expect(response.multiValueHeaders.etag[0]).toMatch(etagRegex)\n        expect(response.multiValueHeaders['last-modified'].length).toEqual(1)\n        expect(response.multiValueHeaders['last-modified'][0]).toMatch(lastModifiedRegex)\n        delete response.multiValueHeaders.etag\n        delete response.multiValueHeaders['last-modified']\n        break\n      case 'azureHttpFunctionV4':\n      case 'azureHttpFunctionV3':\n        expectedResponse.body = Buffer.from(samLogoBase64, 'base64')\n        expectedResponse.isBase64Encoded = false\n        expect(response.headers.etag).toMatch(etagRegex)\n        expect(response.headers['last-modified']).toMatch(lastModifiedRegex)\n        delete response.headers.etag\n        delete response.headers['last-modified']\n        break\n      case 'apiGatewayV2':\n        expect(response.headers.etag).toMatch(etagRegex)\n        expect(response.headers['last-modified']).toMatch(lastModifiedRegex)\n        delete response.headers.etag\n        delete response.headers['last-modified']\n        break\n      case 'lambdaEdge':\n        expect(response.headers.etag.length).toEqual(1)\n        expect(response.headers.etag[0].key).toMatch('etag')\n        expect(response.headers.etag[0].value).toMatch(etagRegex)\n        expect(response.headers['last-modified'].length).toEqual(1)\n        expect(response.headers['last-modified'][0].key).toMatch('last-modified')\n        expect(response.headers['last-modified'][0].value).toMatch(lastModifiedRegex)\n        delete response.headers.etag\n        delete response.headers['last-modified']\n        break\n    }\n    expect(response).toEqual(expectedResponse)\n  })",43,7,16.27906976744186,12732.667739518913,0.05258406968203459,70.14499985415776,"  test('GET image', async () => {\n    // Constants for expected content length of sam-logo.png image\n    const EXPECTED_SAM_LOGO_SIZE = 15933;\n\n    const samLogoPath = path.join(jestHelpersPath, 'sam-logo.png')\n    router.get('/sam', (req, res) => {\n      res.sendFile(samLogoPath)\n    })\n    const event = makeEvent({\n      eventSourceName,\n      path: '/sam',\n      httpMethod: 'GET'\n    })\n\n    const response = await serverlessExpressInstance(event)\n\n    const samLogoImage = fs.readFileSync(samLogoPath)\n    const samLogoBase64 = Buffer.from(samLogoImage).toString('base64')\n    const expectedResponse = makeResponse({\n      eventSourceName,\n      body: samLogoBase64,\n      multiValueHeaders: {\n        'accept-ranges': ['bytes'],\n        'cache-control': ['public, max-age=0'],\n        'content-length': [EXPECTED_SAM_LOGO_SIZE.toString()],\n        'content-type': ['image/png']\n      },\n      isBase64Encoded: true\n    }, { shouldConvertContentLengthToInt: true })\n    const etagRegex = /^W\/.*$/\n    const lastModifiedRegex = /^.* GMT$/\n    switch (eventSourceName) {\n      case 'alb':\n      case 'apiGatewayV1':\n        expect(response.multiValueHeaders.etag.length).toEqual(1)\n        expect(response.multiValueHeaders.etag[0]).toMatch(etagRegex)\n        expect(response.multiValueHeaders['last-modified'].length).toEqual(1)\n        expect(response.multiValueHeaders['last-modified'][0]).toMatch(lastModifiedRegex)\n        delete response.multiValueHeaders.etag\n        delete response.multiValueHeaders['last-modified']\n        break\n      case 'azureHttpFunctionV4':\n      case 'azureHttpFunctionV3':\n        expectedResponse.body = Buffer.from(samLogoBase64, 'base64')\n        expectedResponse.isBase64Encoded = false\n        expect(response.headers.etag).toMatch(etagRegex)\n        expect(response.headers['last-modified']).toMatch(lastModifiedRegex)\n        delete response.headers.etag\n        delete response.headers['last-modified']\n        break\n      case 'apiGatewayV2':\n        expect(response.headers.etag).toMatch(etagRegex)\n        expect(response.headers['last-modified']).toMatch(lastModifiedRegex)\n        delete response.headers.etag\n        delete response.headers['last-modified']\n        break\n      case 'lambdaEdge':\n        expect(response.headers.etag.length).toEqual(1)\n        expect(response.headers.etag[0].key).toMatch('etag')\n        expect(response.headers.etag[0].value).toMatch(etagRegex)\n        expect(response.headers['last-modified'].length).toEqual(1)\n        expect(response.headers['last-modified'][0].key).toMatch('last-modified')\n        expect(response.headers['last-modified'][0].value).toMatch(lastModifiedRegex)\n        delete response.headers.etag\n        delete response.headers['last-modified']\n        break\n    }\n    expect(response).toEqual(expectedResponse)\n  })",44,7,15.909090909090908,12959.57095281545,0.05324492742438477,69.67515292938478
147,"  test('GET image', async () => {\n    const samLogoPath = path.join(jestHelpersPath, 'sam-logo.png')\n    router.get('/sam', (req, res) => {\n      res.sendFile(samLogoPath)\n    })\n    const event = makeEvent({\n      eventSourceName,\n      path: '/sam',\n      httpMethod: 'GET'\n    })\n\n    const response = await serverlessExpressInstance(event)\n\n    const samLogoImage = fs.readFileSync(samLogoPath)\n    const samLogoBase64 = Buffer.from(samLogoImage).toString('base64')\n    const expectedResponse = makeResponse({\n      eventSourceName,\n      body: samLogoBase64,\n      multiValueHeaders: {\n        'accept-ranges': ['bytes'],\n        'cache-control': ['public, max-age=0'],\n        'content-length': ['15933'],\n        'content-type': ['image/png']\n      },\n      isBase64Encoded: true\n    }, { shouldConvertContentLengthToInt: true })\n    const etagRegex = /^W\/.*$/\n    const lastModifiedRegex = /^.* GMT$/\n    switch (eventSourceName) {\n      case 'alb':\n      case 'apiGatewayV1':\n        expect(response.multiValueHeaders.etag.length).toEqual(1)\n        expect(response.multiValueHeaders.etag[0]).toMatch(etagRegex)\n        expect(response.multiValueHeaders['last-modified'].length).toEqual(1)\n        expect(response.multiValueHeaders['last-modified'][0]).toMatch(lastModifiedRegex)\n        delete response.multiValueHeaders.etag\n        delete response.multiValueHeaders['last-modified']\n        break\n      case 'azureHttpFunctionV4':\n      case 'azureHttpFunctionV3':\n        expectedResponse.body = Buffer.from(samLogoBase64, 'base64')\n        expectedResponse.isBase64Encoded = false\n        expect(response.headers.etag).toMatch(etagRegex)\n        expect(response.headers['last-modified']).toMatch(lastModifiedRegex)\n        delete response.headers.etag\n        delete response.headers['last-modified']\n        break\n      case 'apiGatewayV2':\n        expect(response.headers.etag).toMatch(etagRegex)\n        expect(response.headers['last-modified']).toMatch(lastModifiedRegex)\n        delete response.headers.etag\n        delete response.headers['last-modified']\n        break\n      case 'lambdaEdge':\n        expect(response.headers.etag.length).toEqual(1)\n        expect(response.headers.etag[0].key).toMatch('etag')\n        expect(response.headers.etag[0].value).toMatch(etagRegex)\n        expect(response.headers['last-modified'].length).toEqual(1)\n        expect(response.headers['last-modified'][0].key).toMatch('last-modified')\n        expect(response.headers['last-modified'][0].value).toMatch(lastModifiedRegex)\n        delete response.headers.etag\n        delete response.headers['last-modified']\n        break\n    }\n    expect(response).toEqual(expectedResponse)\n  })",43,7,16.27906976744186,12732.667739518913,0.05258406968203459,70.14499985415776,"  test('GET image', async () => {\n  // Constants for expected content length of sam-logo.png image\n  const EXPECTED_SAM_LOGO_SIZE = 15933;\n\n  const samLogoPath = path.join(jestHelpersPath, 'sam-logo.png')\n  router.get('/sam', (req, res) => {\n    res.sendFile(samLogoPath)\n  })\n  const event = makeEvent({\n    eventSourceName,\n    path: '/sam', \n    httpMethod: 'GET'\n  })\n\n  const response = await serverlessExpressInstance(event)\n\n  const samLogoImage = fs.readFileSync(samLogoPath)\n  const samLogoBase64 = Buffer.from(samLogoImage).toString('base64')\n  const expectedResponse = makeResponse({\n    eventSourceName,\n    body: samLogoBase64,\n    multiValueHeaders: {\n      'accept-ranges': ['bytes'],\n      'cache-control': ['public, max-age=0'],\n      'content-length': [EXPECTED_SAM_LOGO_SIZE.toString()],\n      'content-type': ['image/png']\n    },\n    isBase64Encoded: true\n  }, { shouldConvertContentLengthToInt: true })\n  const etagRegex = /^W\/.*$/\n  const lastModifiedRegex = /^.* GMT$/\n  switch (eventSourceName) {\n    case 'alb':\n    case 'apiGatewayV1':\n      expect(response.multiValueHeaders.etag.length).toEqual(1)\n      expect(response.multiValueHeaders.etag[0]).toMatch(etagRegex)\n      expect(response.multiValueHeaders['last-modified'].length).toEqual(1)\n      expect(response.multiValueHeaders['last-modified'][0]).toMatch(lastModifiedRegex)\n      delete response.multiValueHeaders.etag\n      delete response.multiValueHeaders['last-modified']\n      break\n    case 'azureHttpFunctionV4':\n    case 'azureHttpFunctionV3':\n      expectedResponse.body = Buffer.from(samLogoBase64, 'base64')\n      expectedResponse.isBase64Encoded = false\n      expect(response.headers.etag).toMatch(etagRegex)\n      expect(response.headers['last-modified']).toMatch(lastModifiedRegex)\n      delete response.headers.etag\n      delete response.headers['last-modified']\n      break\n    case 'apiGatewayV2':\n      expect(response.headers.etag).toMatch(etagRegex)\n      expect(response.headers['last-modified']).toMatch(lastModifiedRegex)\n      delete response.headers.etag\n      delete response.headers['last-modified']\n      break\n    case 'lambdaEdge':\n      expect(response.headers.etag.length).toEqual(1)\n      expect(response.headers.etag[0].key).toMatch('etag')\n      expect(response.headers.etag[0].value).toMatch(etagRegex)\n      expect(response.headers['last-modified'].length).toEqual(1)\n      expect(response.headers['last-modified'][0].key).toMatch('last-modified')\n      expect(response.headers['last-modified'][0].value).toMatch(lastModifiedRegex)\n      delete response.headers.etag\n      delete response.headers['last-modified']\n      break\n  }\n  expect(response).toEqual(expectedResponse)\n})",44,7,15.909090909090908,12959.57095281545,0.05324492742438477,69.67515292938478
148,"    test('custom logger', async () => {\n      app = express()\n      router = express.Router()\n      app.use('/', router)\n      router.get('/users', (req, res) => {\n        res.json({})\n      })\n      const event = makeEvent({\n        eventSourceName,\n        path: '/users',\n        httpMethod: 'GET'\n      })\n      const customLogger = {\n        error: jest.fn(),\n        warn: jest.fn(),\n        info: jest.fn(),\n        verbose: jest.fn(),\n        debug: jest.fn()\n      }\n      serverlessExpressInstance = serverlessExpress({ app, log: customLogger })\n      await serverlessExpressInstance(event)\n\n      expect(customLogger.debug.mock.calls.length).toBe(6)\n\n      // TODO: test log levels\n      // customLogger.level = 'error'\n      // customLogger.debug.mockClear()\n      // customLogger.debug.mockReset()\n      // customLogger.debug = jest.fn()\n\n      // serverlessExpressInstance = serverlessExpress({ app, log: customLogger })\n      // await serverlessExpressInstance(event)\n      // expect(customLogger.debug.mock.calls.length).toBe(0)\n    })",13,1,7.6923076923076925,1162.3480379647897,0.02046248474371267,97.33361761994476,"    test('custom logger', async () => {\n      // Number of expected debug calls based on serverless-express internal logging\n      const EXPECTED_DEBUG_CALLS = 6;\n      \n      app = express()\n      router = express.Router()\n      app.use('/', router)\n      router.get('/users', (req, res) => {\n        res.json({})\n      })\n      const event = makeEvent({\n        eventSourceName,\n        path: '/users',\n        httpMethod: 'GET'\n      })\n      const customLogger = {\n        error: jest.fn(),\n        warn: jest.fn(),\n        info: jest.fn(),\n        verbose: jest.fn(),\n        debug: jest.fn()\n      }\n      serverlessExpressInstance = serverlessExpress({ app, log: customLogger })\n      await serverlessExpressInstance(event)\n\n      expect(customLogger.debug.mock.calls.length).toBe(EXPECTED_DEBUG_CALLS)\n\n      // TODO: test log levels\n      // customLogger.level = 'error'\n      // customLogger.debug.mockClear()\n      // customLogger.debug.mockReset()\n      // customLogger.debug = jest.fn()\n\n      // serverlessExpressInstance = serverlessExpress({ app, log: customLogger })\n      // await serverlessExpressInstance(event)\n      // expect(customLogger.debug.mock.calls.length).toBe(0)\n    })",14,1,7.142857142857142,1203.9064366001953,0.020856753704259292,95.98420845580239
