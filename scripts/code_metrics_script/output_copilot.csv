number,original_method,SLOC_Logical,Cyclomatic,CyclomaticDensity,Halstead_Effort,Halstead_Bugs,Maintainability,refactored_method,SLOC_Logical,Cyclomatic,CyclomaticDensity,Halstead_Effort,Halstead_Bugs,Maintainability
1,"test(""Resets internal status"", () => {\n img.setAttribute(""src"", url200);\n setSources(img, settings, instance);\n cancelLoading(img, entry, settings, instance);\n expect(getStatus(img)).toBe(null);\n });",6,1,16.666666666666664,152,0.007745047644751603,100,"  test(""Resets internal status"", () => {\n    img.setAttribute(""src"", url200);\n    setSources(img, settings, instance);\n    cancelLoading(img, entry, settings, instance);\n    expect(getStatus(img)).toBeNull();\n  });",6,1,16.666666666666664,152,0.007745047644751603,100
2,"test(""Restores original attributes"", () => {\n img.setAttribute(""src"", url1);\n img.setAttribute(""data-src"", url100);\n img.setAttribute(""data-srcset"", url200);\n img.setAttribute(""data-sizes"", sizes100);\n setSources(img, settings, instance);\n cancelLoading(img, entry, settings, instance);\n expect(img).toHaveAttribute(""src"", url1);\n expect(img).not.toHaveAttribute(""srcset"");\n expect(img).not.toHaveAttribute(""sizes"");\n });",11,1,9.090909090909092,560.1990546335667,0.014719371051336319,100,"  test(""Restores original attributes"", () => {\n    img.setAttribute(""src"", url1);\n    img.setAttribute(""data-src"", url100);\n    img.setAttribute(""data-srcset"", url200);\n    img.setAttribute(""data-sizes"", sizes100);\n    setSources(img, settings, instance);\n    cancelLoading(img, entry, settings, instance);\n    expect(img).toMatchObject({\n      src: url1,\n      srcset: undefined,\n      sizes: undefined,\n    });\n  });",9,1,11.11111111111111,375.13329551354917,0.012485787527170125,100
3,"test(""Restores original attributes"", () => {\n img.setAttribute(""src"", url1);\n img.setAttribute(""data-src"", url100);\n img.setAttribute(""data-srcset"", url200);\n img.setAttribute(""data-sizes"", sizes100);\n setSources(img, settings, instance);\n cancelLoading(img, entry, settings, instance);\n expect(img).toHaveAttribute(""src"", url1);\n expect(img).not.toHaveAttribute(""srcset"");\n expect(img).not.toHaveAttribute(""sizes"");\n });",11,1,9.090909090909092,560.1990546335667,0.014719371051336319,100,"  test(""Restores original attributes"", () => {\n    img.setAttribute(""src"", url1);\n    img.setAttribute(""data-src"", url100);\n    img.setAttribute(""data-srcset"", url200);\n    img.setAttribute(""data-sizes"", sizes100);\n    setSources(img, settings, instance);\n    cancelLoading(img, entry, settings, instance);\n    expect(img).toMatchObject({\n      src: url1,\n      srcset: undefined,\n      sizes: undefined,\n    });\n  });",9,1,11.11111111111111,375.13329551354917,0.012485787527170125,100
4,"test(""Restores original attributes"", () => {\n img.setAttribute(""src"", url1);\n img.setAttribute(""data-src"", url100);\n img.setAttribute(""data-srcset"", url200);\n img.setAttribute(""data-sizes"", sizes100);\n setSources(img, settings, instance);\n cancelLoading(img, entry, settings, instance);\n expect(img).toHaveAttribute(""src"", url1);\n expect(img).not.toHaveAttribute(""srcset"");\n expect(img).not.toHaveAttribute(""sizes"");\n });",11,1,9.090909090909092,560.1990546335667,0.014719371051336319,100,"  test(""Restores original attributes"", () => {\n    img.setAttribute(""src"", url1);\n    img.setAttribute(""data-src"", url100);\n    img.setAttribute(""data-srcset"", url200);\n    img.setAttribute(""data-sizes"", sizes100);\n    setSources(img, settings, instance);\n    cancelLoading(img, entry, settings, instance);\n    expect(img).toMatchObject({\n      src: url1,\n      srcset: undefined,\n      sizes: undefined,\n    });\n  });",9,1,11.11111111111111,375.13329551354917,0.012485787527170125,100
5,"test(""Callbacks are called"", () => {\n const cancelCb = jest.fn();\n settings.callback_cancel = cancelCb;\n setSources(img, settings, instance);\n cancelLoading(img, entry, settings, instance);\n expect(cancelCb).toHaveBeenCalledTimes(1);\n expect(cancelCb).toHaveBeenCalledWith(img, entry, instance);\n });",8,1,12.5,430.102660736163,0.010225945435769426,100,"  test(""Callbacks are called"", () => {\n    const cancelCb = jest.fn();\n    settings.callback_cancel = cancelCb;\n    setSources(img, settings, instance);\n    cancelLoading(img, entry, settings, instance);\n    expect(cancelCb).toHaveBeenCalledWith(img, entry, instance);\n  });",7,1,14.285714285714285,332.3983174831079,0.008767126040623019,100
6,"test(""Callbacks are called"", () => {\n const cancelCb = jest.fn();\n settings.callback_cancel = cancelCb;\n setSources(img, settings, instance);\n cancelLoading(img, entry, settings, instance);\n expect(cancelCb).toHaveBeenCalledTimes(1);\n expect(cancelCb).toHaveBeenCalledWith(img, entry, instance);\n });",8,1,12.5,430.102660736163,0.010225945435769426,100,"  test(""Callbacks are called"", () => {\n    const cancelCb = jest.fn();\n    settings.callback_cancel = cancelCb;\n    setSources(img, settings, instance);\n    cancelLoading(img, entry, settings, instance);\n    expect(cancelCb).toHaveBeenCalledWith(img, entry, instance);\n  });",7,1,14.285714285714285,332.3983174831079,0.008767126040623019,100
7,"test(""Decreases loading count"", () => {\n img.setAttribute(""src"", url200);\n setSources(img, settings, instance);\n cancelLoading(img, entry, settings, instance);\n expect(instance.loadingCount).toBe(0);\n });",6,1,16.666666666666664,158.04856319501312,0.008043528820279,100,"  test(""Decreases loading count"", () => {\n    const expectedLoadingCount = 0; // Refactored to eliminate magic number\n    img.setAttribute(""src"", url200);\n    setSources(img, settings, instance);\n    cancelLoading(img, entry, settings, instance);\n    expect(instance.loadingCount).toBe(expectedLoadingCount);\n  });",7,1,14.285714285714285,177.74305318647853,0.008521944546104623,100
8,"test('decreaseToLoadCount decreases toLoadCount by 1', () => {\n const mockInstance = { toLoadCount: 5 };\n decreaseToLoadCount(mockInstance);\n expect(mockInstance.toLoadCount).toBe(4);\n });",5,1,20,83.02635884729513,0.005236770992579965,100,"  test('decreaseToLoadCount decreases toLoadCount by 1', () => {\n    const initialToLoadCount = 5;\n    const expectedToLoadCount = 4;\n    const mockInstance = { toLoadCount: initialToLoadCount };\n    decreaseToLoadCount(mockInstance);\n    expect(mockInstance.toLoadCount).toBe(expectedToLoadCount);\n  });",7,1,14.285714285714285,118.41407098051495,0.006261274657482988,100
9,"test('setToLoadCount sets toLoadCount to the given value', () => {\n const mockInstance = {};\n setToLoadCount(mockInstance, 10);\n expect(mockInstance.toLoadCount).toBe(10);\n });",5,1,20,77.6500692179921,0.004906496702463663,100,"  test('setToLoadCount sets toLoadCount to the given value', () => {\n    const mockInstance = {};\n    const toLoadCountValue = 10; // Define a constant for better readability\n    setToLoadCount(mockInstance, toLoadCountValue);\n    expect(mockInstance.toLoadCount).toBe(toLoadCountValue);\n  });",6,1,16.666666666666664,94.94217886704583,0.0054289725556949725,100
10,"    describe(`when unhandledRejection received`, () => {\n      it('throws an error', async () => {\n        expect(() => {\n          process.on = jest.fn().mockImplementation((event, error) => {\n            if (event === 'unhandledRejection') {\n              error({\n                message: `something-unhandled`,\n                code: 2000\n              });\n            }\n          });\n\n          const { runErrorHandler } = require('../error-handler');\n          runErrorHandler(mockLogger);\n        }).toThrow(`something-unhandled`);\n      });\n    });",13,2,15.384615384615385,429.1524900675002,0.010579837777895349,100,"    describe(`when unhandledRejection received`, () => {\n      beforeEach(() => {\n      process.on = jest.fn().mockImplementation((event, error) => {\n        if (event === 'unhandledRejection') {\n        error({\n          message: `something-unhandled`,\n          code: 2000\n        });\n        }\n      });\n\n      const { runErrorHandler } = require('../error-handler');\n      runErrorHandler(mockLogger);\n      });\n\n      it('throws an error with message ""something-unhandled""', () => {\n      expect(() => {\n        process.on.mock.calls.forEach(([event, handler]) => {\n        if (event === 'unhandledRejection') {\n          handler({\n          message: `something-unhandled`,\n          code: 2000\n          });\n        }\n        });\n      }).toThrow(`something-unhandled`);\n      });\n    });",20,3,15,900.863995736457,0.014816166264210708,92.62067307215729
11,"it('does not throws an error', async () => {\n expect(() => {\n process.on = jest.fn().mockImplementation((event, error) => {\n if (event === 'uncaughtException') {\n error({\n message: `redlock:lock-XRPBUSD`,\n code: 500\n });\n }\n });\n\n const { runErrorHandler } = require('../error-handler');\n runErrorHandler(mockLogger);\n }).not.toThrow();\n });",11,2,18.181818181818183,429.1524900675002,0.010579837777895349,100,"      describe('when uncaughtException is a redlock error', () => {\n        beforeEach(() => {\n          process.on = jest.fn().mockImplementation((event, error) => {\n        if (event === 'uncaughtException') {\n          error({\n            message: `redlock:lock-XRPBUSD`,\n            code: 500\n          });\n        }\n          });\n\n          const { runErrorHandler } = require('../error-handler');\n          runErrorHandler(mockLogger);\n        });\n\n        it('does not throw an error', () => {\n          expect(() => {}).not.toThrow();\n        });\n      });",15,2,13.333333333333334,491.2005523974087,0.011747371246463426,99.18467700253478
12,"it('keeps 10 logs in the folder', () => {\n const files = fs.readdirSync(fileFolder);\n expect(files.length).toBe(10);\n });",4,1,25,70.9822575142789,0.0053626998907691775,100,"      it('keeps 10 logs in the folder', () => {\n        const files = fs.readdirSync(fileFolder);\n        expect(files).toHaveLength(10);\n        files.forEach(file => {\n          expect(file).toMatch(/^file\d+\.json$/);\n        });\n      });",7,1,14.285714285714285,137.06477719407374,0.007314817532785559,100
13,"it('triggers refreshCandles', () => {\n expect(mockMongo.deleteAll).toHaveBeenCalledWith(\n logger,\n 'trailing-trade-candles',\n {}\n );\n expect(mockMongo.deleteAll).toHaveBeenCalledWith(\n logger,\n 'trailing-trade-ath-candles',\n {}\n );\n });",4,1,25,123.7707756890233,0.006166429958809705,100,"      it('triggers refreshCandles', () => {\n        expect(mockMongo.deleteAll).toHaveBeenCalledWith(\n          logger,\n          expect.stringMatching(/trailing-trade-(candles|ath-candles)/),\n          {}\n        );\n      });",3,1,33.33333333333333,59.79470570797252,0.0047121475995650485,100
14,"it('triggers refreshCandles', () => {\n expect(mockMongo.deleteAll).toHaveBeenCalledWith(\n logger,\n 'trailing-trade-candles',\n {}\n );\n expect(mockMongo.deleteAll).toHaveBeenCalledWith(\n logger,\n 'trailing-trade-ath-candles',\n {}\n );\n });",4,1,25,123.7707756890233,0.006166429958809705,100,"      it('triggers refreshCandles', () => {\n        const expectedCalls = [\n          [logger, 'trailing-trade-candles', {}],\n          [logger, 'trailing-trade-ath-candles', {}]\n        ];\n\n        expectedCalls.forEach(call => {\n          expect(mockMongo.deleteAll).toHaveBeenCalledWith(...call);\n        });\n      });",6,1,16.666666666666664,104.70226035658412,0.0063813041039506935,100
15,"it('triggers refreshCandles', () => {\n expect(mockMongo.deleteAll).toHaveBeenCalledWith(\n logger,\n 'trailing-trade-candles',\n {}\n );\n expect(mockMongo.deleteAll).toHaveBeenCalledWith(\n logger,\n 'trailing-trade-ath-candles',\n {}\n );\n });",4,1,25,123.7707756890233,0.006166429958809705,100,"    it('triggers refreshCandles', () => {\n      expect(mockMongo.deleteAll).toHaveBeenCalledWith(\n      logger,\n      expect.stringMatching(/^trailing-trade-(candles|ath-candles)$/),\n      {}\n      );\n    });",3,1,33.33333333333333,59.79470570797252,0.0047121475995650485,100
16,"it('triggers refreshCandles', () => {\n expect(mockMongo.deleteAll).toHaveBeenCalledWith(\n logger,\n 'trailing-trade-candles',\n {}\n );\n expect(mockMongo.deleteAll).toHaveBeenCalledWith(\n logger,\n 'trailing-trade-ath-candles',\n {}\n );\n });",4,1,25,123.7707756890233,0.006166429958809705,100,"    it('triggers refreshCandles', () => {\n      expect(mockMongo.deleteAll).toHaveBeenCalledWith(\n      logger,\n      expect.stringMatching(/^trailing-trade-(candles|ath-candles)$/),\n      {}\n      );\n    });",3,1,33.33333333333333,59.79470570797252,0.0047121475995650485,100
17,"it('triggers cache.hset', () => {\n expect(mockCache.hset).toHaveBeenCalledWith(\n 'trailing-trade-streams',\n `count`,\n 1\n );\n });",3,1,33.33333333333333,43.18506523353571,0.004102996362278855,100,"      it('triggers cache.hset', () => {\n        const expectedStreamCount = 1; // Number of streams expected\n        expect(mockCache.hset).toHaveBeenCalledWith(\n          'trailing-trade-streams',\n          `count`,\n          expectedStreamCount\n        );\n      });",4,1,25,57.65719364395496,0.0046374163084266905,100
18,"it('triggers cache.hset', () => {\n expect(mockCache.hset).toHaveBeenCalledWith(\n 'trailing-trade-streams',\n `count`,\n 1\n );\n });",3,1,33.33333333333333,43.18506523353571,0.004102996362278855,100,"    it('triggers cache.hset', () => {\n      const expectedStreamCount = 1; // Represents the initial stream count\n      expect(mockCache.hset).toHaveBeenCalledWith(\n      'trailing-trade-streams',\n      `count`,\n      expectedStreamCount\n      );\n    });",4,1,25,57.65719364395496,0.0046374163084266905,100
19,"it('triggers status', () => {\n expect(mockRateLimiterMiddlewareResStatus).toHaveBeenCalledWith(403);\n });",3,1,33.33333333333333,30,0.003218297948685432,100,"        const FORBIDDEN_STATUS_CODE = 403;\n\n        it('triggers status', () => {\n          expect(mockRateLimiterMiddlewareResStatus).toHaveBeenCalledWith(FORBIDDEN_STATUS_CODE);\n        });",4,1,25,43.473257162637424,0.0037702102294917654,100
20,"it('triggers clearInterval', () => {\n expect(spyOnClearInterval).toHaveBeenCalledWith(33);\n });",3,1,33.33333333333333,30,0.003218297948685432,100,"      const intervalId = 33; // Assigning a meaningful variable name for the magic number\n      it('triggers clearInterval', () => {\n        expect(spyOnClearInterval).toHaveBeenCalledWith(intervalId);\n      });",4,1,25,43.473257162637424,0.0037702102294917654,100
21,"it('triggers updateAccountInfo', () => {\n expect(mockUpdateAccountInfo).toHaveBeenCalledWith(\n loggerMock,\n [{ asset: 'ADA', free: '0.00000000', locked: '13.82000000' }],\n 1625585531721\n );\n });",3,1,33.33333333333333,66.41714012534482,0.005466787500811506,100,"      const mockBalances = [{ asset: 'ADA', free: '0.00000000', locked: '13.82000000' }];\n      const mockLastAccountUpdate = 1625585531721;\n\n      it('triggers updateAccountInfo', () => {\n        expect(mockUpdateAccountInfo).toHaveBeenCalledWith(\n          loggerMock,\n          mockBalances,\n          mockLastAccountUpdate\n        );\n      });",5,1,20,97.28161562175808,0.006486257016085221,100
22,"it('triggers slack.sendMessage', () => {\n expect(slackMock.sendMessage).toHaveBeenCalledWith(\n expect.stringContaining('BTCUSDT'),\n {\n apiLimit: 0,\n symbol: 'BTCUSDT'\n }\n );\n\n expect(slackMock.sendMessage).toHaveBeenCalledWith(\n expect.stringContaining(\n 'The bot queued to trigger the grid trade for buying'\n ),\n {\n apiLimit: 0,\n symbol: 'BTCUSDT'\n }\n );\n });",4,1,25,281.7442642322627,0.009024617499561433,100," it('triggers slack.sendMessage', () => {\n        expect(slackMock.sendMessage).toHaveBeenCalledWith(\n          expect.stringContaining(\n        'The bot queued to trigger the grid trade for buying'\n          ),\n          {\n        apiLimit: 0,\n        symbol: 'BTCUSDT'\n          }\n        );\n      });",3,1,33.33333333333333,82.49268997791475,0.005988448488353101,100
23,"it(""returns URL for patch releasing"", () => {\n const result = getReleaseUrl(""2.3.1"", ""2.3.0"");\n assert.equal(\n result,\n getExpectedReleaseUrl({\n tag: ""2.3.1"",\n title: ""2.3.1"",\n body: ""ðŸ”— [Changelog](https://github.com/prettier/prettier/blob/main/CHANGELOG.md#231)"",\n }),\n );\n });",4,1,25,100.97809539418941,0.006293792806151423,100,"    describe(""getReleaseUrl for patch releasing"", () => {\n      it(""returns the correct tag and title"", () => {\n      const result = getReleaseUrl(""2.3.1"", ""2.3.0"");\n      const expectedTag = ""2.3.1"";\n      const expectedTitle = ""2.3.1"";\n      assert.equal(new URLSearchParams(result).get(""tag""), expectedTag);\n      assert.equal(new URLSearchParams(result).get(""title""), expectedTitle);\n      });\n\n      it(""returns the correct body"", () => {\n      const result = getReleaseUrl(""2.3.1"", ""2.3.0"");\n      const expectedBody = ""ðŸ”— [Changelog](https://github.com/prettier/prettier/blob/main/CHANGELOG.md#231)"";\n      assert.equal(new URLSearchParams(result).get(""body""), expectedBody);\n      });\n    });",14,1,7.142857142857142,530.2264194559746,0.013531639325675077,99.35885675104569
24,"it(""returns URL for minor releasing"", () => {\n const result = getReleaseUrl(""2.4.0"", ""2.3.0"");\n assert.equal(\n result,\n getExpectedReleaseUrl({\n tag: ""2.4.0"",\n title: ""2.4.0"",\n body: [\n ""[diff](https://github.com/prettier/prettier/compare/2.3.0...2.4.0)"",\n `ðŸ”— [Release note](https://prettier.io/blog/${getDateParts().join(\n ""/"",\n )}/2.4.0)`,\n ].join(""\n\n""),\n }),\n );\n });",4,1,25,162.6706359559867,0.008627890130576228,100,"    describe(""minor release URL generation"", () => {\n      it(""includes the correct tag and title"", () => {\n      const result = getReleaseUrl(""2.4.0"", ""2.3.0"");\n      const expectedUrl = getExpectedReleaseUrl({\n        tag: ""2.4.0"",\n        title: ""2.4.0"",\n        body: [\n        ""[diff](https://github.com/prettier/prettier/compare/2.3.0...2.4.0)"",\n        `ðŸ”— [Release note](https://prettier.io/blog/${getDateParts().join(\n          ""/"",\n        )}/2.4.0)`,\n        ].join(""\n\n""),\n      });\n      assert.equal(result, expectedUrl);\n      });\n\n      it(""includes the correct diff link in the body"", () => {\n      const result = getReleaseUrl(""2.4.0"", ""2.3.0"");\n      const expectedBody = [\n        ""[diff](https://github.com/prettier/prettier/compare/2.3.0...2.4.0)"",\n        `ðŸ”— [Release note](https://prettier.io/blog/${getDateParts().join(\n        ""/"",\n        )}/2.4.0)`,\n      ].join(""\n\n"");\n      const parameters = new URLSearchParams(new URL(result).search);\n      assert.equal(parameters.get(""body""), expectedBody);\n      });\n\n      it(""includes the correct release note link in the body"", () => {\n      const result = getReleaseUrl(""2.4.0"", ""2.3.0"");\n      const expectedReleaseNoteLink = `ðŸ”— [Release note](https://prettier.io/blog/${getDateParts().join(\n        ""/"",\n      )}/2.4.0)`;\n      const parameters = new URLSearchParams(new URL(result).search);\n      assert.ok(parameters.get(""body"").includes(expectedReleaseNoteLink));\n      });\n    });",19,1,5.263157894736842,1224.648714267475,0.02195947717479332,90.63516198124294
25,"it(""returns URL for major releasing"", () => {\n const result = getReleaseUrl(""2.3.0"", ""2.2.0"");\n assert.equal(\n result,\n getExpectedReleaseUrl({\n tag: ""2.3.0"",\n title: ""2.3.0"",\n body: [\n ""[diff](https://github.com/prettier/prettier/compare/2.2.0...2.3.0)"",\n `ðŸ”— [Release note](https://prettier.io/blog/${getDateParts().join(\n ""/"",\n )}/2.3.0)`,\n ].join(""\n\n""),\n }),\n );\n });",4,1,25,162.6706359559867,0.008627890130576228,100,"    describe(""major release URL generation"", () => {\n      it(""includes the correct tag and title"", () => {\n      const result = getReleaseUrl(""2.3.0"", ""2.2.0"");\n      const expectedParameters = {\n        tag: ""2.3.0"",\n        title: ""2.3.0"",\n      };\n      assert.equal(\n        result.startsWith(getExpectedReleaseUrl(expectedParameters)),\n        true,\n      );\n      });\n\n      it(""includes the correct diff link in the body"", () => {\n      const result = getReleaseUrl(""2.3.0"", ""2.2.0"");\n      const diffLink = ""[diff](https://github.com/prettier/prettier/compare/2.2.0...2.3.0)"";\n      assert.equal(result.includes(diffLink), true);\n      });\n\n      it(""includes the correct release note link in the body"", () => {\n      const result = getReleaseUrl(""2.3.0"", ""2.2.0"");\n      const releaseNoteLink = `ðŸ”— [Release note](https://prettier.io/blog/${getDateParts().join(""/"")}/2.3.0)`;\n      assert.equal(result.includes(releaseNoteLink), true);\n      });\n    });",17,1,5.88235294117647,644.3519446951746,0.01588680007216953,94.9619570483988
26,"it(""returns true for existing version"", async () => {\n assert.ok(await isVersionReleased(""1.0.0""));\n });",3,1,33.33333333333333,30,0.003218297948685432,100,"  describe(""when the version exists"", () => {\n    it(""returns true"", async () => {\n      assert.ok(await isVersionReleased(""1.0.0""));\n    });\n  });",5,1,20,43.18506523353571,0.004102996362278855,100
27,"it(""rejects for non-existing version"", async () => {\n await assert.rejects(() => isVersionReleased(""999.0.0""), {\n message: ""prettier@999.0.0 doesn't exit."",\n });\n });",3,1,33.33333333333333,39.86313713864835,0.0038897921399543107,100,"  describe(""when the version exists"", () => {\n    it(""returns true"", async () => {\n      assert.ok(await isVersionReleased(""1.0.0""));\n    });\n  });\n\n  describe(""when the version does not exist"", () => {\n    it(""rejects with an appropriate error message"", async () => {\n      await assert.rejects(() => isVersionReleased(""999.0.0""), {\n        message: ""prettier@999.0.0 doesn't exit."",\n      });\n    });\n  });",10,1,10,144,0.007745047644751603,100
28,"it('should not fire a scroll if the value has not changed since the previous call', () => {\n // this can happen if you scroll backward and forward super quick\n const marshal: DimensionMarshal = getMarshalStub();\n const registry: Registry = createRegistry();\n const registerSpy = jest.spyOn(registry.droppable, 'register');\n const wrapper = mount(\n <WithAppContext marshal={marshal} registry={registry}>\n <ScrollableItem />\n </WithAppContext>,\n );\n const container: ?HTMLElement = wrapper\n .find('.scroll-container')\n .getDOMNode();\n invariant(container);\n // tell the droppable to watch for scrolling\n const callbacks: DroppableCallbacks =\n registerSpy.mock.calls[0][0].callbacks;\n\n // watch scroll will only be called after the dimension is requested\n callbacks.getDimensionAndWatchScroll(preset.windowScroll, immediate);\n\n // first event\n scroll(container, { x: 500, y: 1000 });\n expect(marshal.updateDroppableScroll).toHaveBeenCalledTimes(1);\n expect(marshal.updateDroppableScroll).toHaveBeenCalledWith(\n preset.home.descriptor.id,\n { x: 500, y: 1000 },\n );\n // $ExpectError\n marshal.updateDroppableScroll.mockReset();\n\n // second event - scroll to same spot\n scroll(container, { x: 500, y: 1000 });\n expect(marshal.updateDroppableScroll).not.toHaveBeenCalled();\n\n // third event - new value\n scroll(container, { x: 500, y: 1001 });\n expect(marshal.updateDroppableScroll).toHaveBeenCalledWith(\n preset.home.descriptor.id,\n { x: 500, y: 1001 },\n );\n });",18,1,5.555555555555555,1605.8070154169495,0.028795258533030558,89.3971579037872,"  it('should not fire a scroll if the value has not changed since the previous call', () => {\n    const marshal: DimensionMarshal = getMarshalStub();\n    const registry: Registry = createRegistry();\n    const registerSpy = jest.spyOn(registry.droppable, 'register');\n    const wrapper = mount(\n      <WithAppContext marshal={marshal} registry={registry}>\n        <ScrollableItem />\n      </WithAppContext>,\n    );\n    const container: ?HTMLElement = wrapper\n      .find('.scroll-container')\n      .getDOMNode();\n    invariant(container);\n\n    const callbacks: DroppableCallbacks =\n      registerSpy.mock.calls[0][0].callbacks;\n\n    callbacks.getDimensionAndWatchScroll(preset.windowScroll, immediate);\n\n    scroll(container, { x: 500, y: 1000 });\n    expect(marshal.updateDroppableScroll).toHaveBeenCalledTimes(1);\n    expect(marshal.updateDroppableScroll).toHaveBeenCalledWith(\n      preset.home.descriptor.id,\n      { x: 500, y: 1000 },\n    );\n\n    marshal.updateDroppableScroll.mockReset();\n\n    scroll(container, { x: 500, y: 1000 });\n    expect(marshal.updateDroppableScroll).not.toHaveBeenCalled();\n\n    scroll(container, { x: 500, y: 1001 });\n    expect(marshal.updateDroppableScroll).toHaveBeenCalledWith(\n      preset.home.descriptor.id,\n      { x: 500, y: 1001 },\n    );\n  });",18,1,5.555555555555555,1605.8070154169495,0.028795258533030558,89.3971579037872
29,"it('should throttle multiple scrolls into a animation frame', () => {\n const marshal: DimensionMarshal = getMarshalStub();\n const registry: Registry = createRegistry();\n const registerSpy = jest.spyOn(registry.droppable, 'register');\n const wrapper = mount(\n <WithAppContext marshal={marshal} registry={registry}>\n <ScrollableItem />\n </WithAppContext>,\n );\n const container: ?HTMLElement = wrapper\n .find('.scroll-container')\n .getDOMNode();\n invariant(container);\n // tell the droppable to watch for scrolling\n const callbacks: DroppableCallbacks =\n registerSpy.mock.calls[0][0].callbacks;\n\n // watch scroll will only be called after the dimension is requested\n callbacks.getDimensionAndWatchScroll(preset.windowScroll, scheduled);\n\n // first event\n scroll(container, { x: 500, y: 1000 });\n // second event in same frame\n scroll(container, { x: 200, y: 800 });\n\n // release the update animation frame\n requestAnimationFrame.step();\n\n expect(marshal.updateDroppableScroll).toHaveBeenCalledTimes(1);\n expect(marshal.updateDroppableScroll).toHaveBeenCalledWith(\n preset.home.descriptor.id,\n { x: 200, y: 800 },\n );\n\n // also checking that no loose frames are stored up\n requestAnimationFrame.flush();\n expect(marshal.updateDroppableScroll).toHaveBeenCalledTimes(1);\n });",17,1,5.88235294117647,1068.3349445894405,0.02542049732668734,91.29543250102327,"  it('should throttle multiple scrolls into a single animation frame', () => {\n    const marshal: DimensionMarshal = getMarshalStub();\n    const registry: Registry = createRegistry();\n    const registerSpy = jest.spyOn(registry.droppable, 'register');\n    const wrapper = mount(\n      <WithAppContext marshal={marshal} registry={registry}>\n        <ScrollableItem />\n      </WithAppContext>,\n    );\n    const container: ?HTMLElement = wrapper\n      .find('.scroll-container')\n      .getDOMNode();\n    invariant(container);\n\n    const callbacks: DroppableCallbacks =\n      registerSpy.mock.calls[0][0].callbacks;\n\n    callbacks.getDimensionAndWatchScroll(preset.windowScroll, scheduled);\n\n    scroll(container, { x: 500, y: 1000 });\n    scroll(container, { x: 200, y: 800 });\n\n    requestAnimationFrame.step();\n\n    expect(marshal.updateDroppableScroll).toHaveBeenCalledTimes(1);\n    expect(marshal.updateDroppableScroll).toHaveBeenCalledWith(\n      preset.home.descriptor.id,\n      { x: 200, y: 800 },\n    );\n\n    requestAnimationFrame.flush();\n    expect(marshal.updateDroppableScroll).toHaveBeenCalledTimes(1);\n  });",17,1,5.88235294117647,1068.3349445894405,0.02542049732668734,91.29543250102327
30,"it('should not fire a scroll if the value has not changed since the previous frame', () => {\n // this can happen if you scroll backward and forward super quick\n const marshal: DimensionMarshal = getMarshalStub();\n const registry: Registry = createRegistry();\n const registerSpy = jest.spyOn(registry.droppable, 'register');\n const wrapper = mount(\n <WithAppContext marshal={marshal} registry={registry}>\n <ScrollableItem />\n </WithAppContext>,\n );\n const container: ?HTMLElement = wrapper\n .find('.scroll-container')\n .getDOMNode();\n invariant(container);\n // tell the droppable to watch for scrolling\n const callbacks: DroppableCallbacks =\n registerSpy.mock.calls[0][0].callbacks;\n\n // watch scroll will only be called after the dimension is requested\n callbacks.getDimensionAndWatchScroll(preset.windowScroll, scheduled);\n\n // first event\n scroll(container, { x: 500, y: 1000 });\n // release the frame\n requestAnimationFrame.step();\n expect(marshal.updateDroppableScroll).toHaveBeenCalledTimes(1);\n expect(marshal.updateDroppableScroll).toHaveBeenCalledWith(\n preset.home.descriptor.id,\n { x: 500, y: 1000 },\n );\n // $ExpectError\n marshal.updateDroppableScroll.mockReset();\n\n // second event\n scroll(container, { x: 501, y: 1001 });\n // no frame to release change yet\n\n // third event - back to original value\n scroll(container, { x: 500, y: 1000 });\n // release the frame\n requestAnimationFrame.step();\n expect(marshal.updateDroppableScroll).not.toHaveBeenCalled();\n });",19,1,5.263157894736842,1294.2278336067534,0.027576148196781666,88.85869329998171,"  it('should not fire a scroll if the value has not changed since the previous frame', () => {\n    const marshal: DimensionMarshal = getMarshalStub();\n    const registry: Registry = createRegistry();\n    const registerSpy = jest.spyOn(registry.droppable, 'register');\n    const wrapper = mount(\n      <WithAppContext marshal={marshal} registry={registry}>\n        <ScrollableItem />\n      </WithAppContext>,\n    );\n    const container: ?HTMLElement = wrapper\n      .find('.scroll-container')\n      .getDOMNode();\n    invariant(container);\n\n    const callbacks: DroppableCallbacks =\n      registerSpy.mock.calls[0][0].callbacks;\n\n    callbacks.getDimensionAndWatchScroll(preset.windowScroll, scheduled);\n\n    scroll(container, { x: 500, y: 1000 });\n    requestAnimationFrame.step();\n    expect(marshal.updateDroppableScroll).toHaveBeenCalledTimes(1);\n    expect(marshal.updateDroppableScroll).toHaveBeenCalledWith(\n      preset.home.descriptor.id,\n      { x: 500, y: 1000 },\n    );\n    marshal.updateDroppableScroll.mockReset();\n\n    scroll(container, { x: 501, y: 1001 });\n    scroll(container, { x: 500, y: 1000 });\n    requestAnimationFrame.step();\n    expect(marshal.updateDroppableScroll).not.toHaveBeenCalled();\n  });",19,1,5.263157894736842,1294.2278336067534,0.027576148196781666,88.85869329998171
31,"it('should not publish a scroll update after requested not to update while an animation frame is occurring', () => {\n const marshal: DimensionMarshal = getMarshalStub();\n const registry: Registry = createRegistry();\n const registerSpy = jest.spyOn(registry.droppable, 'register');\n const wrapper = mount(\n <WithAppContext marshal={marshal} registry={registry}>\n <ScrollableItem />\n </WithAppContext>,\n );\n const container: ?HTMLElement = wrapper\n .find('.scroll-container')\n .getDOMNode();\n invariant(container);\n // tell the droppable to watch for scrolling\n const callbacks: DroppableCallbacks =\n registerSpy.mock.calls[0][0].callbacks;\n\n // watch scroll will only be called after the dimension is requested\n callbacks.getDimensionAndWatchScroll(preset.windowScroll, scheduled);\n\n // first event\n scroll(container, { x: 500, y: 1000 });\n requestAnimationFrame.step();\n expect(marshal.updateDroppableScroll).toHaveBeenCalledTimes(1);\n // $ExpectError\n marshal.updateDroppableScroll.mockReset();\n\n // second event\n scroll(container, { x: 400, y: 100 });\n // no animation frame to release event fired yet\n\n // unwatching before frame fired\n callbacks.dragStopped();\n\n // flushing any frames\n requestAnimationFrame.flush();\n expect(marshal.updateDroppableScroll).not.toHaveBeenCalled();\n });",18,1,5.555555555555555,905.3685971096953,0.024258158428388608,90.734528341917,"  it('should not publish a scroll update after being stopped during an animation frame', () => {\n    const marshal: DimensionMarshal = getMarshalStub();\n    const registry: Registry = createRegistry();\n    const registerSpy = jest.spyOn(registry.droppable, 'register');\n    const wrapper = mount(\n      <WithAppContext marshal={marshal} registry={registry}>\n        <ScrollableItem />\n      </WithAppContext>,\n    );\n    const container: ?HTMLElement = wrapper\n      .find('.scroll-container')\n      .getDOMNode();\n    invariant(container);\n\n    const callbacks: DroppableCallbacks =\n      registerSpy.mock.calls[0][0].callbacks;\n\n    callbacks.getDimensionAndWatchScroll(preset.windowScroll, scheduled);\n\n    scroll(container, { x: 500, y: 1000 });\n    requestAnimationFrame.step();\n    expect(marshal.updateDroppableScroll).toHaveBeenCalledTimes(1);\n    marshal.updateDroppableScroll.mockReset();\n\n    scroll(container, { x: 400, y: 100 });\n    callbacks.dragStopped();\n\n    requestAnimationFrame.flush();\n    expect(marshal.updateDroppableScroll).not.toHaveBeenCalled();\n  });\n",18,1,5.555555555555555,905.3685971096953,0.024258158428388608,90.734528341917
32,"it('should stop watching scroll when no longer required to publish', () => {\n // this can happen if you scroll backward and forward super quick\n const marshal: DimensionMarshal = getMarshalStub();\n const registry: Registry = createRegistry();\n const registerSpy = jest.spyOn(registry.droppable, 'register');\n const wrapper = mount(\n <WithAppContext marshal={marshal} registry={registry}>\n <ScrollableItem />\n </WithAppContext>,\n );\n const container: ?HTMLElement = wrapper\n .find('.scroll-container')\n .getDOMNode();\n invariant(container);\n // tell the droppable to watch for scrolling\n const callbacks: DroppableCallbacks = registerSpy.mock.calls[0][0].callbacks;\n\n // watch scroll will only be called after the dimension is requested\n callbacks.getDimensionAndWatchScroll(preset.windowScroll, immediate);\n\n // first event\n scroll(container, { x: 500, y: 1000 });\n expect(marshal.updateDroppableScroll).toHaveBeenCalledTimes(1);\n // $ExpectError\n marshal.updateDroppableScroll.mockReset();\n\n callbacks.dragStopped();\n\n // scroll event after no longer watching\n scroll(container, { x: 190, y: 400 });\n expect(marshal.updateDroppableScroll).not.toHaveBeenCalled();\n});",16,1,6.25,830.9664922109746,0.02282338932417839,93.11815715812183,"it('should stop watching scroll when no longer required to publish', () => {\n  const marshal: DimensionMarshal = getMarshalStub();\n  const registry: Registry = createRegistry();\n  const registerSpy = jest.spyOn(registry.droppable, 'register');\n  const wrapper = mount(\n    <WithAppContext marshal={marshal} registry={registry}>\n      <ScrollableItem />\n    </WithAppContext>,\n  );\n  const container: ?HTMLElement = wrapper\n    .find('.scroll-container')\n    .getDOMNode();\n  invariant(container);\n\n  const callbacks: DroppableCallbacks = registerSpy.mock.calls[0][0].callbacks;\n  callbacks.getDimensionAndWatchScroll(preset.windowScroll, immediate);\n\n  scroll(container, { x: 500, y: 1000 });\n  expect(marshal.updateDroppableScroll).toHaveBeenCalledTimes(1);\n  marshal.updateDroppableScroll.mockReset();\n\n  callbacks.dragStopped();\n  scroll(container, { x: 190, y: 400 });\n  expect(marshal.updateDroppableScroll).not.toHaveBeenCalled();\n});",16,1,6.25,830.9664922109746,0.02282338932417839,93.11815715812183
33,"it('should have every prettier target following the file name convention', async () => {\n const targets: string[] = pkg.config.prettier_target.split(' ');\n const paths: string[] = await globby(targets);\n\n invariant(\n paths.length,\n 'Could not find files to test against file name convention',\n );\n\n paths.forEach((filePath: string) => {\n if (exceptions.includes(filePath)) {\n return;\n }\n\n const isMatching: boolean = isSnakeCase(filePath);\n\n invariant(\n isMatching,\n `${filePath} does not follow the file path convention (snake-case.js) ${convention.toString()}`,\n );\n\n expect(isMatching).toBe(true);\n });\n});",13,2,15.384615384615385,329.51188268314564,0.012759824587919761,100,"it('should have every prettier target following the file name convention', async () => {\n  const targets: string[] = pkg.config.prettier_target.split(' ');\n  const paths: string[] = await globby(targets);\n\n  invariant(\n    paths.length,\n    'Could not find files to test against file name convention',\n  );\n\n  const nonCompliantFiles = paths.filter(\n    (filePath: string) =>\n      !exceptions.includes(filePath) && !isSnakeCase(filePath)\n  );\n\n  expect(nonCompliantFiles).toHaveLength(0);\n\n  nonCompliantFiles.forEach((filePath: string) => {\n    invariant(\n      false,\n      `${filePath} does not follow the file path convention (snake-case.js) ${convention.toString()}`,\n    );\n  });\n});\n",10,2,20,802.5384603950748,0.014490519668047711,100
34,"it('should end all nested docs with a link back to the documentation root', async () => {\n const files: string[] = await globby('docs/**/*.md');\n expect(files.length).toBeGreaterThan(0);\n const backLink: string =\n '[â† Back to documentation](/README.md#documentation-)';\n\n for (const file of files) {\n const contents: string = await fs.readFile(file, 'utf8');\n\n // Printing a nice message to allow for quick fixing\n const endsWithBacklink: boolean = contents.trim().endsWith(backLink);\n\n if (!endsWithBacklink) {\n expect(`\n File: ""${file}""\n Did not end with back link\n `).toBe(true);\n }\n\n // need at least one assertion\n expect(true).toBe(true);\n }\n});",14,3,21.428571428571427,498.72270565528567,0.012208523980002346,99.90876630390645,"it('should end all nested docs with a link back to the documentation root', async () => {\n  const files: string[] = await globby('docs/**/*.md');\n  expect(files.length).toBeGreaterThan(0);\n  const backLink: string =\n    '[â† Back to documentation](/README.md#documentation-)';\n\n  const results = await Promise.all(\n    files.map(async (file) => {\n      const contents: string = await fs.readFile(file, 'utf8');\n      return { file, endsWithBacklink: contents.trim().endsWith(backLink) };\n    })\n  );\n\n  results.forEach(({ file, endsWithBacklink }) => {\n    expect(endsWithBacklink).toBe(\n      true,\n      `File: ""${file}"" did not end with back link`\n    );\n  });\n});\n",12,1,8.333333333333332,464.0770202111545,0.014605803922978977,100
35,"it('should return false if an element has overflow:visible', () => {\n ['overflowY', 'overflowX'].forEach((overflow: string) => {\n const el: HTMLElement = document.createElement('div');\n // $ExpectError - flow being mean\n el.style[overflow] = 'visible';\n expect(getClosestScrollable(el)).toBe(null);\n });\n});",7,1,14.285714285714285,234.56524738296298,0.008627890130576228,100,"it('should return false if an element has overflow:visible', () => {\n  ['overflowY', 'overflowX'].forEach((overflow: string) => {\n    const el: HTMLElement = document.createElement('div');\n    // $ExpectError - flow being mean\n    el.style[overflow] = 'visible';\n    expect(getClosestScrollable(el)).toBeNull();\n  });\n});",7,1,14.285714285714285,234.56524738296298,0.008627890130576228,100
36,"it('should warn if the body might be a scroll container', () => {\n body.style.overflowX = 'auto';\n html.style.overflowY = 'auto';\n\n expect(getClosestScrollable(body)).toBe(null);\n expect(console.warn).toHaveBeenCalled();\n });",6,1,16.666666666666664,260.1378136824323,0.008767126040623019,100,"  it('should warn if the body might be a scroll container', () => {\n    body.style.overflowX = 'auto';\n    html.style.overflowY = 'auto';\n\n    expect(getClosestScrollable(body)).toBeNull();\n    expect(console.warn).toHaveBeenCalledWith(\n      expect.stringContaining('A potential scroll container was detected')\n    );\n  });",6,1,16.666666666666664,317.79807709949824,0.00988217501962691,100
37,"it('should not mark the body as a scroll container if it does not have any overflow set', () => {\n body.style.overflowX = 'visible';\n expect(getClosestScrollable(body)).toBe(null);\n expect(console.warn).not.toHaveBeenCalled();\n });",5,1,20,193.84615384615384,0.007745047644751603,100,"  it('should not mark the body as a scroll container if it does not have any overflow set', () => {\n    body.style.overflowX = 'visible';\n    expect(getClosestScrollable(body)).toBeNull();\n    expect(console.warn).not.toHaveBeenCalledWith(expect.any(String));\n  });",5,1,20,247.69354508567335,0.008884647488325967,100
38,"it('should not mark the body as a scroll container if the html element has visible overflow', () => {\n body.style.overflowX = 'auto';\n html.style.overflowY = 'visible';\n expect(getClosestScrollable(body)).toBe(null);\n expect(console.warn).not.toHaveBeenCalled();\n });",6,1,16.666666666666664,264.8317309162485,0.0093549651308736,100,"  it('should not mark the body as a scroll container if the html element has visible overflow', () => {\n    body.style.overflowX = 'auto';\n    html.style.overflowY = 'visible';\n    expect(getClosestScrollable(body)).toBeNull();\n    expect(console.warn).not.toHaveBeenCalledWith(expect.any(String));\n  });",6,1,16.666666666666664,322.1032776704425,0.010456376640062838,100
39,"it('should animate a mount', () => {\n const wrapper: ReactWrapper<*> = mount(\n <Placeholder\n contextId={contextId}\n animate=""open""\n placeholder={placeholder}\n onClose={jest.fn()}\n onTransitionEnd={jest.fn()}\n />,\n );\n\n expect(getCreatePlaceholderCalls().length).toBe(1);\n\n // first call had an empty size\n const onMount: PlaceholderStyle = getPlaceholderStyle(wrapper);\n expectIsEmpty(onMount);\n\n // Will trigger a .setState\n act(() => {\n jest.runOnlyPendingTimers();\n });\n\n // tell enzyme that something has changed\n wrapper.update();\n\n const postMount: PlaceholderStyle = getPlaceholderStyle(wrapper);\n expectIsFull(postMount);\n});",12,1,8.333333333333332,359.5836384377935,0.013362885383856537,100,"it('should animate a mount', () => {\n  const wrapper: ReactWrapper<*> = mount(\n    <Placeholder\n      contextId={contextId}\n      animate=""open""\n      placeholder={placeholder}\n      onClose={jest.fn()}\n      onTransitionEnd={jest.fn()}\n    />,\n  );\n\n  expect(getCreatePlaceholderCalls()).toHaveLength(1);\n\n  // first call had an empty size\n  const onMount: PlaceholderStyle = getPlaceholderStyle(wrapper);\n  expectIsEmpty(onMount);\n\n  // Will trigger a .setState\n  act(() => {\n    jest.runOnlyPendingTimers();\n  });\n\n  // tell enzyme that something has changed\n  wrapper.update();\n\n  const postMount: PlaceholderStyle = getPlaceholderStyle(wrapper);\n  expect(postMount).toEqual(expect.objectContaining({\n    width: expect.any(Number),\n    height: expect.any(Number),\n  }));\n});",12,1,8.333333333333332,547.4687935957504,0.016503975152354727,100
40,"it('should announce with the default message if no responder is provided', () => {\n // This test is not relevant for onDragEnd as it must always be provided\n if (current.responder === 'onDragEnd') {\n expect(true).toBe(true);\n return;\n }\n // unsetting responder\n responders[current.responder] = undefined;\n current.execute(store);\n expect(announce).toHaveBeenCalledWith(current.defaultMessage);\n });",9,2,22.22222222222222,384.82450727596193,0.009063240809455704,100,"    if (current.responder !== 'onDragEnd') {\n      it('should announce with the default message if no responder is provided', () => {\n      // unsetting responder\n      responders[current.responder] = undefined;\n      current.execute(store);\n      expect(announce).toHaveBeenCalledWith(current.defaultMessage);\n      });\n    }",7,2,28.57142857142857,310.01833549791036,0.008043528820279,100
41,"it('should recover from rbd errors', () => {\n let hasThrown: boolean = false;\n function CanThrow(props: { shouldThrow: boolean }) {\n if (!hasThrown && props.shouldThrow) {\n hasThrown = true;\n invariant(false, 'throwing');\n }\n return null;\n }\n\n const { rerender, getByTestId } = render(\n <App anotherChild={<CanThrow shouldThrow={false} />} />,\n );\n\n simpleLift(keyboard, getByTestId('0'));\n expect(isDragging(getByTestId('0'))).toBe(true);\n\n withError(() => {\n rerender(<App anotherChild={<CanThrow shouldThrow />} />);\n });\n\n expect(isDragging(getByTestId('0'))).toBe(false);\n});",16,3,18.75,1119.5815841241106,0.013025516312370856,97.2403062514302,"it('should recover from rbd errors', () => {\n  function CanThrowOnce() {\n    throw new Error('throwing');\n  }\n\n  const { rerender, getByTestId } = render(\n    <App anotherChild={null} />,\n  );\n\n  simpleLift(keyboard, getByTestId('0'));\n  expect(isDragging(getByTestId('0'))).toBe(true);\n\n  withError(() => {\n    rerender(<App anotherChild={<CanThrowOnce />} />);\n  });\n\n  expect(isDragging(getByTestId('0'))).toBe(false);\n});\n",11,1,9.090909090909092,297.5672948430247,0.010296291210669795,100
42,"it('should not recover from non-rbd errors', () => {\n let hasThrown: boolean = false;\n function CanThrow(props: { shouldThrow: boolean }) {\n if (!hasThrown && props.shouldThrow) {\n hasThrown = true;\n throw new Error('Boom');\n }\n return null;\n }\n\n const { rerender, getByTestId } = render(\n <App anotherChild={<CanThrow shouldThrow={false} />} />,\n );\n\n simpleLift(keyboard, getByTestId('0'));\n expect(isDragging(getByTestId('0'))).toBe(true);\n\n withError(() => {\n expect(() => {\n rerender(<App anotherChild={<CanThrow shouldThrow />} />);\n }).toThrow();\n });\n});",17,3,17.647058823529413,868.7297369787454,0.012150573090249537,96.8005517228359,"it('should not recover from non-rbd errors', () => {\n  function AlwaysThrows() {\n    throw new Error('Boom');\n  }\n\n  const { rerender, getByTestId } = render(\n    <App anotherChild={<AlwaysThrows />} />,\n  );\n\n  simpleLift(keyboard, getByTestId('0'));\n  expect(isDragging(getByTestId('0'))).toBe(true);\n\n  withError(() => {\n    expect(() => {\n      rerender(<App anotherChild={<AlwaysThrows />} />);\n    }).toThrow();\n  });\n});",12,1,8.333333333333332,221.78788601421297,0.009588824956116475,100
43,"it('should not log a warning if warnings are disabled', () => {\n window['__react-beautiful-dnd-disable-dev-warnings'] = true;\n\n warning('hey');\n warning('sup');\n warning('hi');\n\n expect(warn).not.toHaveBeenCalled();\n\n // re-enable\n\n window['__react-beautiful-dnd-disable-dev-warnings'] = false;\n\n warning('hey');\n\n expect(warn).toHaveBeenCalled();\n});",10,1,10,379.45674909847736,0.0091812270577072,100,"it('should not log a warning if warnings are disabled', () => {\n  window['__react-beautiful-dnd-disable-dev-warnings'] = true;\n\n  warning('hey');\n  warning('sup');\n  warning('hi');\n\n  expect(warn).not.toHaveBeenCalled();\n\n  // re-enable\n  window['__react-beautiful-dnd-disable-dev-warnings'] = false;\n\n  warning('hey');\n\n  const callsAfterReEnable = warn.mock.calls.length;\n  expect(callsAfterReEnable).toBe(1);\n});",11,1,9.090909090909092,454.6048532576017,0.011477477368815745,100
44,"it('should not log a warning if warnings are disabled', () => {\n window['__react-beautiful-dnd-disable-dev-warnings'] = true;\n\n warning('hey');\n warning('sup');\n warning('hi');\n\n expect(warn).not.toHaveBeenCalled();\n\n // re-enable\n\n window['__react-beautiful-dnd-disable-dev-warnings'] = false;\n\n warning('hey');\n\n expect(warn).toHaveBeenCalled();\n});",10,1,10,379.45674909847736,0.0091812270577072,100,"it('should not log a warning if warnings are disabled', () => {\n  window['__react-beautiful-dnd-disable-dev-warnings'] = true;\n\n  warning('hey');\n  warning('sup');\n  warning('hi');\n\n  expect(warn).not.toHaveBeenCalled();\n\n  // re-enable\n  window['__react-beautiful-dnd-disable-dev-warnings'] = false;\n\n  warning('hey');\n\n  const callsAfterReEnable = warn.mock.calls.length;\n  expect(callsAfterReEnable).toBe(1);\n});",11,1,9.090909090909092,454.6048532576017,0.011477477368815745,100
45,"it('should register itself when mounting', () => {\n const registry: Registry = createRegistry();\n const registerSpy = jest.spyOn(registry.draggable, 'register');\n mount(<Item registry={registry} />);\n\n const expected: DraggableEntry = {\n // $ExpectError\n uniqueId: expect.any(String),\n descriptor: preset.inHome1.descriptor,\n options: defaultOptions,\n // $ExpectError\n getDimension: expect.any(Function),\n };\n expect(registerSpy).toHaveBeenCalledTimes(1);\n expect(registerSpy).toHaveBeenCalledWith(expected);\n });",8,1,12.5,366.1478268549855,0.013827948261584615,100,"  it('should register itself when mounting', () => {\n    const registry: Registry = createRegistry();\n    const registerSpy = jest.spyOn(registry.draggable, 'register');\n    mount(<Item registry={registry} />);\n\n    const expected: DraggableEntry = {\n      // $ExpectError\n      uniqueId: expect.any(String),\n      descriptor: preset.inHome1.descriptor,\n      options: defaultOptions,\n      // $ExpectError\n      getDimension: expect.any(Function),\n    };\n\n    const [actualCall] = registerSpy.mock.calls;\n    expect(registerSpy).toHaveBeenCalledTimes(1);\n    expect(actualCall[0]).toEqual(expected);\n  });",9,1,11.11111111111111,430.56344644588603,0.015523099887158753,100
46,"it('should register itself when mounting', () => {\n const registry: Registry = createRegistry();\n const registerSpy = jest.spyOn(registry.draggable, 'register');\n mount(<Item registry={registry} />);\n\n const expected: DraggableEntry = {\n // $ExpectError\n uniqueId: expect.any(String),\n descriptor: preset.inHome1.descriptor,\n options: defaultOptions,\n // $ExpectError\n getDimension: expect.any(Function),\n };\n expect(registerSpy).toHaveBeenCalledTimes(1);\n expect(registerSpy).toHaveBeenCalledWith(expected);\n });",8,1,12.5,366.1478268549855,0.013827948261584615,100,"  it('should register itself when mounting', () => {\n    const registry: Registry = createRegistry();\n    const registerSpy = jest.spyOn(registry.draggable, 'register');\n    mount(<Item registry={registry} />);\n\n    const expected: DraggableEntry = {\n      // $ExpectError\n      uniqueId: expect.any(String),\n      descriptor: preset.inHome1.descriptor,\n      options: defaultOptions,\n      // $ExpectError\n      getDimension: expect.any(Function),\n    };\n\n    const [actual] = registerSpy.mock.calls[0] || [];\n    expect(registerSpy).toHaveBeenCalledTimes(1);\n    expect(actual).toEqual(expected);\n  });",9,2,22.22222222222222,661.698392771657,0.015776096763738867,100
47,"it('should unregister itself when unmounting', () => {\n const registry: Registry = createRegistry();\n const registerSpy = jest.spyOn(registry.draggable, 'register');\n const unregisterSpy = jest.spyOn(registry.draggable, 'unregister');\n const wrapper = mount(<Item registry={registry} />);\n\n const expected: DraggableEntry = {\n // $ExpectError\n uniqueId: expect.any(String),\n descriptor: preset.inHome1.descriptor,\n options: defaultOptions,\n // $ExpectError\n getDimension: expect.any(Function),\n };\n\n expect(unregisterSpy).not.toHaveBeenCalled();\n expect(registerSpy).toHaveBeenCalledTimes(1);\n expect(registerSpy).toHaveBeenCalledWith(expected);\n const entry = registerSpy.mock.calls[0][0];\n expect(entry).toEqual(expected);\n\n wrapper.unmount();\n expect(unregisterSpy).toHaveBeenCalledTimes(1);\n expect(unregisterSpy.mock.calls[0][0]).toBe(entry);\n });",15,1,6.666666666666667,1147.3403677582114,0.02427513581153119,93.68268054135075,"  it('should unregister itself when unmounting', () => {\n    const registry: Registry = createRegistry();\n    const registerSpy = jest.spyOn(registry.draggable, 'register');\n    const unregisterSpy = jest.spyOn(registry.draggable, 'unregister');\n    const wrapper = mount(<Item registry={registry} />);\n\n    const expected: DraggableEntry = {\n      // $ExpectError\n      uniqueId: expect.any(String),\n      descriptor: preset.inHome1.descriptor,\n      options: defaultOptions,\n      // $ExpectError\n      getDimension: expect.any(Function),\n    };\n\n    expect(registerSpy).toHaveBeenCalledWith(expected);\n    const entry = registerSpy.mock.calls[0][0];\n\n    wrapper.unmount();\n    expect(unregisterSpy).toHaveBeenCalledWith(entry);\n  });",11,1,9.090909090909092,638.5180192003007,0.018253013762524764,100
48,"it('should apply the appropriate aria attributes and non visibility styles', () => {\n render(<WithAnnouncer contextId=""5"">{getMock()}</WithAnnouncer>);\n\n const el: ?HTMLElement = getElement('5');\n invariant(el, 'Cannot find node');\n\n expect(el.getAttribute('aria-live')).toBe('assertive');\n expect(el.getAttribute('aria-atomic')).toBe('true');\n\n // not checking all the styles - just enough to know we are doing something\n expect(el.style.overflow).toBe('hidden');\n});",8,1,12.5,334.4573713977973,0.012256837285571486,100,"it('should apply the appropriate aria-live attribute', () => {\n  render(<WithAnnouncer contextId=""5"">{getMock()}</WithAnnouncer>);\n\n  const el: ?HTMLElement = getElement('5');\n  invariant(el, 'Cannot find node');\n\n  expect(el.getAttribute('aria-live')).toBe('assertive');\n});\n\nit('should apply the appropriate aria-atomic attribute', () => {\n  render(<WithAnnouncer contextId=""5"">{getMock()}</WithAnnouncer>);\n\n  const el: ?HTMLElement = getElement('5');\n  invariant(el, 'Cannot find node');\n\n  expect(el.getAttribute('aria-atomic')).toBe('true');\n});\n\nit('should apply non-visibility styles', () => {\n  render(<WithAnnouncer contextId=""5"">{getMock()}</WithAnnouncer>);\n\n  const el: ?HTMLElement = getElement('5');\n  invariant(el, 'Cannot find node');\n\n  expect(el.style.overflow).toBe('hidden');\n});",18,1,5.555555555555555,945.3359046941438,0.01764501890531614,93.2172641477582
49,"it('should set the text content of the announcement element', () => {\n // arrange\n const mock = getMock();\n render(<WithAnnouncer contextId=""6"">{mock}</WithAnnouncer>);\n const el: ?HTMLElement = getElement('6');\n invariant(el, 'Could not find announcer');\n\n // act\n const announce: Announce = getAnnounce(mock);\n announce('test');\n\n // assert\n expect(el.textContent).toBe('test');\n});",9,1,11.11111111111111,216.09640474436813,0.00964270255730497,100,"it('should set the text content of the announcement element when announce is called', () => {\n  // arrange\n  const mock = getMock();\n  render(<WithAnnouncer contextId=""6"">{mock}</WithAnnouncer>);\n  const el: ?HTMLElement = getElement('6');\n  invariant(el, 'Could not find announcer');\n\n  // act\n  const announce: Announce = getAnnounce(mock);\n  announce('test');\n\n  // assert\n  expect(el.textContent).toBe('test');\n});\n\nit('should not modify the text content of the announcement element initially', () => {\n  // arrange\n  const mock = getMock();\n  render(<WithAnnouncer contextId=""6"">{mock}</WithAnnouncer>);\n  const el: ?HTMLElement = getElement('6');\n  invariant(el, 'Could not find announcer');\n\n  // assert\n  expect(el.textContent).toBe('');\n});",16,1,6.25,627.8879719041315,0.01444946388280169,96.68375981189949
50,"it('should throw if the droppable has no closest scrollable', () => {\n const marshal: DimensionMarshal = getMarshalStub();\n const registry: Registry = createRegistry();\n const registerSpy = jest.spyOn(registry.droppable, 'register');\n // no scroll parent\n const wrapper = mount(\n <WithAppContext marshal={marshal} registry={registry}>\n <App parentIsScrollable={false} droppableIsScrollable={false} />,\n </WithAppContext>,\n );\n const droppable: ?HTMLElement = wrapper.find('.droppable').getDOMNode();\n invariant(droppable);\n const parent: ?HTMLElement = wrapper.find('.scroll-parent').getDOMNode();\n invariant(parent);\n jest\n .spyOn(droppable, 'getBoundingClientRect')\n .mockImplementation(() => smallFrameClient.borderBox);\n jest\n .spyOn(parent, 'getBoundingClientRect')\n .mockImplementation(() => bigClient.borderBox);\n\n // validating no initial scroll\n expect(parent.scrollTop).toBe(0);\n expect(parent.scrollLeft).toBe(0);\n expect(droppable.scrollTop).toBe(0);\n expect(droppable.scrollLeft).toBe(0);\n\n const callbacks: DroppableCallbacks = registerSpy.mock.calls[0][0].callbacks;\n // request the droppable start listening for scrolling\n callbacks.getDimensionAndWatchScroll(preset.windowScroll, scheduled);\n\n // ask it to scroll\n expect(() => callbacks.scroll({ x: 100, y: 100 })).toThrow();\n\n // no scroll changes\n expect(parent.scrollTop).toBe(0);\n expect(parent.scrollLeft).toBe(0);\n expect(droppable.scrollTop).toBe(0);\n expect(droppable.scrollLeft).toBe(0);\n});",23,1,4.3478260869565215,2435.2551878832915,0.03345279485656603,84.25676222684999,"it('should throw if the droppable has no closest scrollable', () => {\n  const marshal: DimensionMarshal = getMarshalStub();\n  const registry: Registry = createRegistry();\n  const registerSpy = jest.spyOn(registry.droppable, 'register');\n  // no scroll parent\n  const wrapper = mount(\n    <WithAppContext marshal={marshal} registry={registry}>\n      <App parentIsScrollable={false} droppableIsScrollable={false} />,\n    </WithAppContext>,\n  );\n  const droppable: ?HTMLElement = wrapper.find('.droppable').getDOMNode();\n  invariant(droppable);\n  const parent: ?HTMLElement = wrapper.find('.scroll-parent').getDOMNode();\n  invariant(parent);\n  jest\n    .spyOn(droppable, 'getBoundingClientRect')\n    .mockImplementation(() => smallFrameClient.borderBox);\n  jest\n    .spyOn(parent, 'getBoundingClientRect')\n    .mockImplementation(() => bigClient.borderBox);\n\n  // validating no initial scroll\n  expect(parent.scrollTop).toBe(0);\n  expect(parent.scrollLeft).toBe(0);\n  expect(droppable.scrollTop).toBe(0);\n  expect(droppable.scrollLeft).toBe(0);\n\n  const callbacks: DroppableCallbacks = registerSpy.mock.calls[0][0].callbacks;\n  // request the droppable start listening for scrolling\n  callbacks.getDimensionAndWatchScroll(preset.windowScroll, scheduled);\n\n  // define scroll values for clarity\n  const scrollX = 100;\n  const scrollY = 100;\n\n  // ask it to scroll\n  expect(() => callbacks.scroll({ x: scrollX, y: scrollY })).toThrow();\n\n  // no scroll changes\n  expect(parent.scrollTop).toBe(0);\n  expect(parent.scrollLeft).toBe(0);\n  expect(droppable.scrollTop).toBe(0);\n  expect(droppable.scrollLeft).toBe(0);\n});",25,1,4,2497.3512615154987,0.03418834748496004,82.73633380578444
51,"it('should throw if the droppable has no closest scrollable', () => {\n const marshal: DimensionMarshal = getMarshalStub();\n const registry: Registry = createRegistry();\n const registerSpy = jest.spyOn(registry.droppable, 'register');\n // no scroll parent\n const wrapper = mount(\n <WithAppContext marshal={marshal} registry={registry}>\n <App parentIsScrollable={false} droppableIsScrollable={false} />,\n </WithAppContext>,\n );\n const droppable: ?HTMLElement = wrapper.find('.droppable').getDOMNode();\n invariant(droppable);\n const parent: ?HTMLElement = wrapper.find('.scroll-parent').getDOMNode();\n invariant(parent);\n jest\n .spyOn(droppable, 'getBoundingClientRect')\n .mockImplementation(() => smallFrameClient.borderBox);\n jest\n .spyOn(parent, 'getBoundingClientRect')\n .mockImplementation(() => bigClient.borderBox);\n\n // validating no initial scroll\n expect(parent.scrollTop).toBe(0);\n expect(parent.scrollLeft).toBe(0);\n expect(droppable.scrollTop).toBe(0);\n expect(droppable.scrollLeft).toBe(0);\n\n const callbacks: DroppableCallbacks = registerSpy.mock.calls[0][0].callbacks;\n // request the droppable start listening for scrolling\n callbacks.getDimensionAndWatchScroll(preset.windowScroll, scheduled);\n\n // ask it to scroll\n expect(() => callbacks.scroll({ x: 100, y: 100 })).toThrow();\n\n // no scroll changes\n expect(parent.scrollTop).toBe(0);\n expect(parent.scrollLeft).toBe(0);\n expect(droppable.scrollTop).toBe(0);\n expect(droppable.scrollLeft).toBe(0);\n});",23,1,4.3478260869565215,2435.2551878832915,0.03345279485656603,84.25676222684999,"it('should throw if the droppable has no closest scrollable', () => {\n  const marshal: DimensionMarshal = getMarshalStub();\n  const registry: Registry = createRegistry();\n  const registerSpy = jest.spyOn(registry.droppable, 'register');\n  // no scroll parent\n  const wrapper = mount(\n    <WithAppContext marshal={marshal} registry={registry}>\n      <App parentIsScrollable={false} droppableIsScrollable={false} />,\n    </WithAppContext>,\n  );\n  const droppable: ?HTMLElement = wrapper.find('.droppable').getDOMNode();\n  invariant(droppable);\n  const parent: ?HTMLElement = wrapper.find('.scroll-parent').getDOMNode();\n  invariant(parent);\n  jest\n    .spyOn(droppable, 'getBoundingClientRect')\n    .mockImplementation(() => smallFrameClient.borderBox);\n  jest\n    .spyOn(parent, 'getBoundingClientRect')\n    .mockImplementation(() => bigClient.borderBox);\n\n  // validating no initial scroll\n  expect(parent.scrollTop).toBe(0);\n  expect(parent.scrollLeft).toBe(0);\n  expect(droppable.scrollTop).toBe(0);\n  expect(droppable.scrollLeft).toBe(0);\n\n  const callbacks: DroppableCallbacks = registerSpy.mock.calls[0][0].callbacks;\n  // request the droppable start listening for scrolling\n  callbacks.getDimensionAndWatchScroll(preset.windowScroll, scheduled);\n\n  const scrollAmount = { x: 100, y: 100 }; // Refactored to eliminate magic number\n\n  // ask it to scroll\n  expect(() => callbacks.scroll(scrollAmount)).toThrow();\n\n  // no scroll changes\n  expect(parent.scrollTop).toBe(0);\n  expect(parent.scrollLeft).toBe(0);\n  expect(droppable.scrollTop).toBe(0);\n  expect(droppable.scrollLeft).toBe(0);\n});",24,1,4.166666666666666,2466.2465929814966,0.03382150892080064,83.48179581887439
52,"it('should throw if the droppable has no closest scrollable', () => {\n const marshal: DimensionMarshal = getMarshalStub();\n const registry: Registry = createRegistry();\n const registerSpy = jest.spyOn(registry.droppable, 'register');\n // no scroll parent\n const wrapper = mount(\n <WithAppContext marshal={marshal} registry={registry}>\n <App parentIsScrollable={false} droppableIsScrollable={false} />,\n </WithAppContext>,\n );\n const droppable: ?HTMLElement = wrapper.find('.droppable').getDOMNode();\n invariant(droppable);\n const parent: ?HTMLElement = wrapper.find('.scroll-parent').getDOMNode();\n invariant(parent);\n jest\n .spyOn(droppable, 'getBoundingClientRect')\n .mockImplementation(() => smallFrameClient.borderBox);\n jest\n .spyOn(parent, 'getBoundingClientRect')\n .mockImplementation(() => bigClient.borderBox);\n\n // validating no initial scroll\n expect(parent.scrollTop).toBe(0);\n expect(parent.scrollLeft).toBe(0);\n expect(droppable.scrollTop).toBe(0);\n expect(droppable.scrollLeft).toBe(0);\n\n const callbacks: DroppableCallbacks = registerSpy.mock.calls[0][0].callbacks;\n // request the droppable start listening for scrolling\n callbacks.getDimensionAndWatchScroll(preset.windowScroll, scheduled);\n\n // ask it to scroll\n expect(() => callbacks.scroll({ x: 100, y: 100 })).toThrow();\n\n // no scroll changes\n expect(parent.scrollTop).toBe(0);\n expect(parent.scrollLeft).toBe(0);\n expect(droppable.scrollTop).toBe(0);\n expect(droppable.scrollLeft).toBe(0);\n});",23,1,4.3478260869565215,2435.2551878832915,0.03345279485656603,84.25676222684999,"it('should throw if the droppable has no closest scrollable', () => {\n  const marshal: DimensionMarshal = getMarshalStub();\n  const registry: Registry = createRegistry();\n  const registerSpy = jest.spyOn(registry.droppable, 'register');\n  // no scroll parent\n  const wrapper = mount(\n    <WithAppContext marshal={marshal} registry={registry}>\n      <App parentIsScrollable={false} droppableIsScrollable={false} />,\n    </WithAppContext>,\n  );\n  const droppable: ?HTMLElement = wrapper.find('.droppable').getDOMNode();\n  invariant(droppable);\n  const parent: ?HTMLElement = wrapper.find('.scroll-parent').getDOMNode();\n  invariant(parent);\n  jest\n    .spyOn(droppable, 'getBoundingClientRect')\n    .mockImplementation(() => smallFrameClient.borderBox);\n  jest\n    .spyOn(parent, 'getBoundingClientRect')\n    .mockImplementation(() => bigClient.borderBox);\n\n  // validating no initial scroll\n  expect(parent.scrollTop).toBe(0);\n  expect(parent.scrollLeft).toBe(0);\n  expect(droppable.scrollTop).toBe(0);\n  expect(droppable.scrollLeft).toBe(0);\n\n  const callbacks: DroppableCallbacks = registerSpy.mock.calls[0][0].callbacks;\n  // request the droppable start listening for scrolling\n  callbacks.getDimensionAndWatchScroll(preset.windowScroll, scheduled);\n\n  const scrollAmount = { x: 100, y: 100 }; // Refactored to eliminate magic number\n\n  // ask it to scroll\n  expect(() => callbacks.scroll(scrollAmount)).toThrow();\n\n  // no scroll changes\n  expect(parent.scrollTop).toBe(0);\n  expect(parent.scrollLeft).toBe(0);\n  expect(droppable.scrollTop).toBe(0);\n  expect(droppable.scrollLeft).toBe(0);\n});",24,1,4.166666666666666,2466.2465929814966,0.03382150892080064,83.48179581887439
53,"it('should throw if the droppable has no closest scrollable', () => {\n const marshal: DimensionMarshal = getMarshalStub();\n const registry: Registry = createRegistry();\n const registerSpy = jest.spyOn(registry.droppable, 'register');\n // no scroll parent\n const wrapper = mount(\n <WithAppContext marshal={marshal} registry={registry}>\n <App parentIsScrollable={false} droppableIsScrollable={false} />,\n </WithAppContext>,\n );\n const droppable: ?HTMLElement = wrapper.find('.droppable').getDOMNode();\n invariant(droppable);\n const parent: ?HTMLElement = wrapper.find('.scroll-parent').getDOMNode();\n invariant(parent);\n jest\n .spyOn(droppable, 'getBoundingClientRect')\n .mockImplementation(() => smallFrameClient.borderBox);\n jest\n .spyOn(parent, 'getBoundingClientRect')\n .mockImplementation(() => bigClient.borderBox);\n\n // validating no initial scroll\n expect(parent.scrollTop).toBe(0);\n expect(parent.scrollLeft).toBe(0);\n expect(droppable.scrollTop).toBe(0);\n expect(droppable.scrollLeft).toBe(0);\n\n const callbacks: DroppableCallbacks = registerSpy.mock.calls[0][0].callbacks;\n // request the droppable start listening for scrolling\n callbacks.getDimensionAndWatchScroll(preset.windowScroll, scheduled);\n\n // ask it to scroll\n expect(() => callbacks.scroll({ x: 100, y: 100 })).toThrow();\n\n // no scroll changes\n expect(parent.scrollTop).toBe(0);\n expect(parent.scrollLeft).toBe(0);\n expect(droppable.scrollTop).toBe(0);\n expect(droppable.scrollLeft).toBe(0);\n});",23,1,4.3478260869565215,2435.2551878832915,0.03345279485656603,84.25676222684999,"it('should throw if the droppable has no closest scrollable', () => {\n  const marshal: DimensionMarshal = getMarshalStub();\n  const registry: Registry = createRegistry();\n  const registerSpy = jest.spyOn(registry.droppable, 'register');\n  // no scroll parent\n  const wrapper = mount(\n    <WithAppContext marshal={marshal} registry={registry}>\n      <App parentIsScrollable={false} droppableIsScrollable={false} />,\n    </WithAppContext>,\n  );\n  const droppable: ?HTMLElement = wrapper.find('.droppable').getDOMNode();\n  invariant(droppable);\n  const parent: ?HTMLElement = wrapper.find('.scroll-parent').getDOMNode();\n  invariant(parent);\n  jest\n    .spyOn(droppable, 'getBoundingClientRect')\n    .mockImplementation(() => smallFrameClient.borderBox);\n  jest\n    .spyOn(parent, 'getBoundingClientRect')\n    .mockImplementation(() => bigClient.borderBox);\n\n  // validating no initial scroll\n  expect(parent.scrollTop).toBe(0);\n  expect(parent.scrollLeft).toBe(0);\n  expect(droppable.scrollTop).toBe(0);\n  expect(droppable.scrollLeft).toBe(0);\n\n  const callbacks: DroppableCallbacks = registerSpy.mock.calls[0][0].callbacks;\n  // request the droppable start listening for scrolling\n  callbacks.getDimensionAndWatchScroll(preset.windowScroll, scheduled);\n\n  const scrollAmount = { x: 100, y: 100 }; // Refactored magic number\n\n  // ask it to scroll\n  expect(() => callbacks.scroll(scrollAmount)).toThrow();\n\n  // no scroll changes\n  expect(parent.scrollTop).toBe(0);\n  expect(parent.scrollLeft).toBe(0);\n  expect(droppable.scrollTop).toBe(0);\n  expect(droppable.scrollLeft).toBe(0);\n});",24,1,4.166666666666666,2466.2465929814966,0.03382150892080064,83.48179581887439
54,"it('should throw if the droppable has no closest scrollable', () => {\n const marshal: DimensionMarshal = getMarshalStub();\n const registry: Registry = createRegistry();\n const registerSpy = jest.spyOn(registry.droppable, 'register');\n // no scroll parent\n const wrapper = mount(\n <WithAppContext marshal={marshal} registry={registry}>\n <App parentIsScrollable={false} droppableIsScrollable={false} />,\n </WithAppContext>,\n );\n const droppable: ?HTMLElement = wrapper.find('.droppable').getDOMNode();\n invariant(droppable);\n const parent: ?HTMLElement = wrapper.find('.scroll-parent').getDOMNode();\n invariant(parent);\n jest\n .spyOn(droppable, 'getBoundingClientRect')\n .mockImplementation(() => smallFrameClient.borderBox);\n jest\n .spyOn(parent, 'getBoundingClientRect')\n .mockImplementation(() => bigClient.borderBox);\n\n // validating no initial scroll\n expect(parent.scrollTop).toBe(0);\n expect(parent.scrollLeft).toBe(0);\n expect(droppable.scrollTop).toBe(0);\n expect(droppable.scrollLeft).toBe(0);\n\n const callbacks: DroppableCallbacks = registerSpy.mock.calls[0][0].callbacks;\n // request the droppable start listening for scrolling\n callbacks.getDimensionAndWatchScroll(preset.windowScroll, scheduled);\n\n // ask it to scroll\n expect(() => callbacks.scroll({ x: 100, y: 100 })).toThrow();\n\n // no scroll changes\n expect(parent.scrollTop).toBe(0);\n expect(parent.scrollLeft).toBe(0);\n expect(droppable.scrollTop).toBe(0);\n expect(droppable.scrollLeft).toBe(0);\n});",23,1,4.3478260869565215,2435.2551878832915,0.03345279485656603,84.25676222684999,"it('should throw if the droppable has no closest scrollable', () => {\n  const marshal: DimensionMarshal = getMarshalStub();\n  const registry: Registry = createRegistry();\n  const registerSpy = jest.spyOn(registry.droppable, 'register');\n  // no scroll parent\n  const wrapper = mount(\n    <WithAppContext marshal={marshal} registry={registry}>\n      <App parentIsScrollable={false} droppableIsScrollable={false} />,\n    </WithAppContext>,\n  );\n  const droppable: ?HTMLElement = wrapper.find('.droppable').getDOMNode();\n  invariant(droppable);\n  const parent: ?HTMLElement = wrapper.find('.scroll-parent').getDOMNode();\n  invariant(parent);\n  jest\n    .spyOn(droppable, 'getBoundingClientRect')\n    .mockImplementation(() => smallFrameClient.borderBox);\n  jest\n    .spyOn(parent, 'getBoundingClientRect')\n    .mockImplementation(() => bigClient.borderBox);\n\n  // validating no initial scroll\n  expect(parent.scrollTop).toBe(0);\n  expect(parent.scrollLeft).toBe(0);\n  expect(droppable.scrollTop).toBe(0);\n  expect(droppable.scrollLeft).toBe(0);\n\n  const callbacks: DroppableCallbacks = registerSpy.mock.calls[0][0].callbacks;\n  // request the droppable start listening for scrolling\n  callbacks.getDimensionAndWatchScroll(preset.windowScroll, scheduled);\n\n  const invalidScrollPosition = { x: 100, y: 100 }; // Refactored to eliminate magic number\n\n  // ask it to scroll\n  expect(() => callbacks.scroll(invalidScrollPosition)).toThrow();\n\n  // no scroll changes\n  expect(parent.scrollTop).toBe(0);\n  expect(parent.scrollLeft).toBe(0);\n  expect(droppable.scrollTop).toBe(0);\n  expect(droppable.scrollLeft).toBe(0);\n});",24,1,4.166666666666666,2466.2465929814966,0.03382150892080064,83.48179581887439
55,"it('should not fire an onClose if not closing when a transitionend occurs', () => {\n const onClose = jest.fn();\n\n const wrapper: ReactWrapper<*> = mount(\n <Placeholder\n animate=""none""\n contextId=""1""\n placeholder={placeholder}\n onClose={onClose}\n onTransitionEnd={jest.fn()}\n />,\n );\n const assert = () => {\n // $ExpectError - not a complete event\n const height: TransitionEvent = {\n propertyName: 'height',\n };\n wrapper.simulate('transitionend', height);\n expect(onClose).not.toHaveBeenCalled();\n onClose.mockClear();\n };\n expectIsFull(getPlaceholderStyle(wrapper));\n assert();\n\n wrapper.setProps({ animate: 'open' });\n assert();\n});",14,1,7.142857142857142,407.5157787774984,0.014226613473282445,98.96820309823849,"it('should not fire an onClose if not closing when a transitionend occurs', () => {\n  const onClose = jest.fn();\n\n  const wrapper: ReactWrapper<*> = mount(\n    <Placeholder\n      animate=""none""\n      contextId=""1""\n      placeholder={placeholder}\n      onClose={onClose}\n      onTransitionEnd={jest.fn()}\n    />,\n  );\n\n  const simulateAndAssert = (expectedCallCount: number, propertyName: string) => {\n    // Simulate a transitionend event with the given propertyName\n    const event: TransitionEvent = {\n      propertyName,\n    };\n    wrapper.simulate('transitionend', event);\n\n    // Assert that onClose has been called the expected number of times\n    expect(onClose).toHaveBeenCalledTimes(expectedCallCount);\n    onClose.mockClear();\n  };\n\n  // Assert initial state\n  expectIsFull(getPlaceholderStyle(wrapper));\n  simulateAndAssert(0, 'height'); // No onClose call expected for 'height'\n\n  // Update props and assert again\n  wrapper.setProps({ animate: 'open' });\n  simulateAndAssert(0, 'height'); // No onClose call expected for 'height' after prop change\n});",14,1,7.142857142857142,485.7821689652434,0.01523970972429828,98.43164028432417
56,"it('should not fire an onClose if not closing when a transitionend occurs', () => {\n const onClose = jest.fn();\n\n const wrapper: ReactWrapper<*> = mount(\n <Placeholder\n animate=""none""\n contextId=""1""\n placeholder={placeholder}\n onClose={onClose}\n onTransitionEnd={jest.fn()}\n />,\n );\n const assert = () => {\n // $ExpectError - not a complete event\n const height: TransitionEvent = {\n propertyName: 'height',\n };\n wrapper.simulate('transitionend', height);\n expect(onClose).not.toHaveBeenCalled();\n onClose.mockClear();\n };\n expectIsFull(getPlaceholderStyle(wrapper));\n assert();\n\n wrapper.setProps({ animate: 'open' });\n assert();\n});",14,1,7.142857142857142,407.5157787774984,0.014226613473282445,98.96820309823849,"it('should not fire an onClose if not closing when a transitionend occurs', () => {\n  const onClose = jest.fn();\n\n  const wrapper: ReactWrapper<*> = mount(\n    <Placeholder\n      animate=""none""\n      contextId=""1""\n      placeholder={placeholder}\n      onClose={onClose}\n      onTransitionEnd={jest.fn()}\n    />,\n  );\n\n  const simulateAndAssertNoOnClose = (propertyName: string) => {\n    // Simulate a transitionend event with the given propertyName\n    const event: TransitionEvent = {\n      propertyName,\n    };\n    wrapper.simulate('transitionend', event);\n\n    // Assert that onClose has not been called\n    expect(onClose).not.toHaveBeenCalled();\n    onClose.mockClear();\n  };\n\n  // Assert initial state\n  expectIsFull(getPlaceholderStyle(wrapper));\n\n  // Simulate and assert for ""height"" property\n  simulateAndAssertNoOnClose('height');\n\n  // Update props and assert again\n  wrapper.setProps({ animate: 'open' });\n  simulateAndAssertNoOnClose('height');\n});",14,1,7.142857142857142,449.9929803264466,0.014816166264210708,98.65148799035842
57,"it('should collect and publish the draggables', () => {\n const beforeInHome1: DraggableDimension = {\n ...preset.inHome1,\n descriptor: {\n ...preset.inHome1.descriptor,\n id: 'addition1',\n index: 0,\n },\n };\n const beforeInHome2: DraggableDimension = {\n ...preset.inHome2,\n descriptor: {\n ...preset.inHome2.descriptor,\n id: 'addition2',\n index: 1,\n },\n };\n const registry: Registry = createRegistry();\n const callbacks: Callbacks = getCallbacksStub();\n const marshal: DimensionMarshal = createDimensionMarshal(\n registry,\n callbacks,\n );\n populate(registry, withScrollables);\n\n // A publish has started\n marshal.startPublishing(defaultRequest);\n expect(callbacks.publishWhileDragging).not.toHaveBeenCalled();\n\n registry.draggable.register(\n getDraggableEntry({ dimension: beforeInHome1 }),\n );\n registry.draggable.register(\n getDraggableEntry({ dimension: beforeInHome2 }),\n );\n expect(callbacks.collectionStarting).toHaveBeenCalled();\n expect(callbacks.publishWhileDragging).not.toHaveBeenCalled();\n\n // Fire the collection / publish step\n requestAnimationFrame.step();\n const expected: Published = {\n ...empty,\n additions: [beforeInHome1, beforeInHome2],\n modified: [{ droppableId: scrollableHome.descriptor.id, scroll: origin }],\n };\n expect(callbacks.publishWhileDragging).toHaveBeenCalledWith(expected);\n });",17,1,5.88235294117647,1359.9929166832883,0.027485726782689086,90.68616659266496,"  describe('when collecting and publishing draggables', () => {\n    it('should collect the draggables', () => {\n      const beforeInHome1: DraggableDimension = {\n        ...preset.inHome1,\n        descriptor: {\n          ...preset.inHome1.descriptor,\n          id: 'addition1',\n          index: 0,\n        },\n      };\n      const beforeInHome2: DraggableDimension = {\n        ...preset.inHome2,\n        descriptor: {\n          ...preset.inHome2.descriptor,\n          id: 'addition2',\n          index: 1,\n        },\n      };\n      const registry: Registry = createRegistry();\n      const callbacks: Callbacks = getCallbacksStub();\n      const marshal: DimensionMarshal = createDimensionMarshal(\n        registry,\n        callbacks,\n      );\n      populate(registry, withScrollables);\n\n      // A publish has started\n      marshal.startPublishing(defaultRequest);\n      expect(callbacks.publishWhileDragging).not.toHaveBeenCalled();\n\n      registry.draggable.register(\n        getDraggableEntry({ dimension: beforeInHome1 }),\n      );\n      registry.draggable.register(\n        getDraggableEntry({ dimension: beforeInHome2 }),\n      );\n      expect(callbacks.collectionStarting).toHaveBeenCalled();\n      expect(callbacks.publishWhileDragging).not.toHaveBeenCalled();\n    });\n\n    it('should publish the collected draggables', () => {\n      const beforeInHome1: DraggableDimension = {\n        ...preset.inHome1,\n        descriptor: {\n          ...preset.inHome1.descriptor,\n          id: 'addition1',\n          index: 0,\n        },\n      };\n      const beforeInHome2: DraggableDimension = {\n        ...preset.inHome2,\n        descriptor: {\n          ...preset.inHome2.descriptor,\n          id: 'addition2',\n          index: 1,\n        },\n      };\n      const registry: Registry = createRegistry();\n      const callbacks: Callbacks = getCallbacksStub();\n      const marshal: DimensionMarshal = createDimensionMarshal(\n        registry,\n        callbacks,\n      );\n      populate(registry, withScrollables);\n\n      // A publish has started\n      marshal.startPublishing(defaultRequest);\n      registry.draggable.register(\n        getDraggableEntry({ dimension: beforeInHome1 }),\n      );\n      registry.draggable.register(\n        getDraggableEntry({ dimension: beforeInHome2 }),\n      );\n\n      // Fire the collection / publish step\n      requestAnimationFrame.step();\n      const expected: Published = {\n        ...empty,\n        additions: [beforeInHome1, beforeInHome2],\n        modified: [{ droppableId: scrollableHome.descriptor.id, scroll: origin }],\n      };\n      expect(callbacks.publishWhileDragging).toHaveBeenCalledWith(expected);\n    });\n  });",30,1,3.3333333333333335,3409.328161377842,0.03793950040566066,78.97068275347073
58,"it('should not do anything if trying to add a draggable that does not have the same type as the dragging item', () => {\n const callbacks: Callbacks = getCallbacksStub();\n const registry: Registry = createRegistry();\n const marshal: DimensionMarshal = createDimensionMarshal(\n registry,\n callbacks,\n );\n populate(registry, withScrollables);\n\n // A publish has started\n marshal.startPublishing(defaultRequest);\n expect(callbacks.collectionStarting).not.toHaveBeenCalled();\n\n // Registering a new draggable (inserted before inHome1)\n\n registry.draggable.register(\n getDraggableEntry({ dimension: inAnotherType }),\n );\n expect(callbacks.collectionStarting).not.toHaveBeenCalled();\n });",10,1,10,383.8692436481891,0.01369082927563323,100,"  describe('when adding a draggable with a different type', () => {\n    it('should not start a collection if the draggable type does not match the dragging item type', () => {\n      const callbacks: Callbacks = getCallbacksStub();\n      const registry: Registry = createRegistry();\n      const marshal: DimensionMarshal = createDimensionMarshal(\n        registry,\n        callbacks,\n      );\n      populate(registry, withScrollables);\n\n      // A publish has started\n      marshal.startPublishing(defaultRequest);\n      expect(callbacks.collectionStarting).not.toHaveBeenCalled();\n\n      // Registering a new draggable with a different type\n      registry.draggable.register(\n        getDraggableEntry({ dimension: inAnotherType }),\n      );\n      expect(callbacks.collectionStarting).not.toHaveBeenCalled();\n    });\n\n    it('should not publish while dragging if the draggable type does not match', () => {\n      const callbacks: Callbacks = getCallbacksStub();\n      const registry: Registry = createRegistry();\n      const marshal: DimensionMarshal = createDimensionMarshal(\n        registry,\n        callbacks,\n      );\n      populate(registry, withScrollables);\n\n      // A publish has started\n      marshal.startPublishing(defaultRequest);\n      expect(callbacks.publishWhileDragging).not.toHaveBeenCalled();\n\n      // Registering a new draggable with a different type\n      registry.draggable.register(\n        getDraggableEntry({ dimension: inAnotherType }),\n      );\n      expect(callbacks.publishWhileDragging).not.toHaveBeenCalled();\n    });\n  });",22,1,4.545454545454546,1451.0376475585192,0.02276223427309272,87.98013478943372
59,"it('should order published draggables by their index', () => {\n const beforeInHome1: DraggableDimension = {\n ...preset.inHome1,\n descriptor: {\n ...preset.inHome1.descriptor,\n id: 'b',\n index: 0,\n },\n };\n const beforeInHome2: DraggableDimension = {\n ...preset.inHome2,\n descriptor: {\n ...preset.inHome2.descriptor,\n // if ordered by a key, this would be first\n id: 'a',\n index: 1,\n },\n };\n const callbacks: Callbacks = getCallbacksStub();\n const registry: Registry = createRegistry();\n const marshal: DimensionMarshal = createDimensionMarshal(\n registry,\n callbacks,\n );\n populate(registry, withScrollables);\n\n // A publish has started\n marshal.startPublishing(defaultRequest);\n expect(callbacks.publishWhileDragging).not.toHaveBeenCalled();\n\n // publishing the higher index value first\n registry.draggable.register(\n getDraggableEntry({ dimension: beforeInHome2 }),\n );\n // publishing the lower index value second\n registry.draggable.register(\n getDraggableEntry({ dimension: beforeInHome1 }),\n );\n expect(callbacks.publishWhileDragging).not.toHaveBeenCalled();\n\n // Fire the collection / publish step\n requestAnimationFrame.step();\n const expected: Published = {\n ...empty,\n // we expect this to be ordered by index\n additions: [beforeInHome1, beforeInHome2],\n modified: [{ droppableId: scrollableHome.descriptor.id, scroll: origin }],\n };\n expect(callbacks.publishWhileDragging).toHaveBeenCalledWith(expected);\n });",16,1,6.25,1239.2967550046997,0.026275066754848315,92.01964728052478,"  describe('ordering of published draggables', () => {\n    it('should publish draggables in the order of their index', () => {\n      const beforeInHome1: DraggableDimension = {\n        ...preset.inHome1,\n        descriptor: {\n          ...preset.inHome1.descriptor,\n          id: 'b',\n          index: 0,\n        },\n      };\n      const beforeInHome2: DraggableDimension = {\n        ...preset.inHome2,\n        descriptor: {\n          ...preset.inHome2.descriptor,\n          id: 'a',\n          index: 1,\n        },\n      };\n      const callbacks: Callbacks = getCallbacksStub();\n      const registry: Registry = createRegistry();\n      const marshal: DimensionMarshal = createDimensionMarshal(\n        registry,\n        callbacks,\n      );\n      populate(registry, withScrollables);\n\n      // A publish has started\n      marshal.startPublishing(defaultRequest);\n      expect(callbacks.publishWhileDragging).not.toHaveBeenCalled();\n\n      // Registering draggables\n      registry.draggable.register(\n        getDraggableEntry({ dimension: beforeInHome2 }),\n      );\n      registry.draggable.register(\n        getDraggableEntry({ dimension: beforeInHome1 }),\n      );\n      expect(callbacks.publishWhileDragging).not.toHaveBeenCalled();\n\n      // Fire the collection / publish step\n      requestAnimationFrame.step();\n      const expected: Published = {\n        ...empty,\n        additions: [beforeInHome1, beforeInHome2],\n        modified: [{ droppableId: scrollableHome.descriptor.id, scroll: origin }],\n      };\n      expect(callbacks.publishWhileDragging).toHaveBeenCalledWith(expected);\n    });\n\n    it('should handle publishing when draggables are registered out of order', () => {\n      const beforeInHome1: DraggableDimension = {\n        ...preset.inHome1,\n        descriptor: {\n          ...preset.inHome1.descriptor,\n          id: 'b',\n          index: 0,\n        },\n      };\n      const beforeInHome2: DraggableDimension = {\n        ...preset.inHome2,\n        descriptor: {\n          ...preset.inHome2.descriptor,\n          id: 'a',\n          index: 1,\n        },\n      };\n      const callbacks: Callbacks = getCallbacksStub();\n      const registry: Registry = createRegistry();\n      const marshal: DimensionMarshal = createDimensionMarshal(\n        registry,\n        callbacks,\n      );\n      populate(registry, withScrollables);\n\n      // A publish has started\n      marshal.startPublishing(defaultRequest);\n      expect(callbacks.publishWhileDragging).not.toHaveBeenCalled();\n\n      // Registering draggables in reverse order\n      registry.draggable.register(\n        getDraggableEntry({ dimension: beforeInHome1 }),\n      );\n      registry.draggable.register(\n        getDraggableEntry({ dimension: beforeInHome2 }),\n      );\n      expect(callbacks.publishWhileDragging).not.toHaveBeenCalled();\n\n      // Fire the collection / publish step\n      requestAnimationFrame.step();\n      const expected: Published = {\n        ...empty,\n        additions: [beforeInHome1, beforeInHome2],\n        modified: [{ droppableId: scrollableHome.descriptor.id, scroll: origin }],\n      };\n      expect(callbacks.publishWhileDragging).toHaveBeenCalledWith(expected);\n    });\n  });",34,1,2.941176470588235,4848.740820870636,0.04246122751246729,76.06477099704716
60,"it(""resolves the promise"", async () => {\n expect(loadResult).toBeAPromise();\n await expect(loadResult).resolves.toBe(true);\n });",4,1,25,69.2855036029534,0.004755658758365788,100,"    it(""resolves the promise"", async () => {\n      await expect(loadResult).resolves.toBe(true);\n    });",3,1,33.33333333333333,33,0.0034294254927005915,100
61,"it(""resolves the promise"", async () => {\n expect(loadResult).toBeAPromise();\n await expect(loadResult).resolves.toBe(true);\n });",4,1,25,69.2855036029534,0.004755658758365788,100,"    it(""resolves the promise"", async () => {\n      await expect(loadResult).resolves.toBe(true);\n    });\n",3,1,33.33333333333333,33,0.0034294254927005915,100
62,"test(""typing/deleting different area codes should update the selected country"", async () => {\n // typing area code starting with 1 changes to Russia\n await user.type(input, ""1"");\n expect(checkFlagSelected(container, ""ru"")).toBe(true);\n\n // deleting area code keeps Russia selected\n await user.type(input, ""{backspace}"");\n expect(checkFlagSelected(container, ""ru"")).toBe(true);\n\n // typing area code starting with 7 changes to Kazakhstan\n await user.type(input, ""7"");\n expect(checkFlagSelected(container, ""kz"")).toBe(true);\n\n // deleting area code keeps Kazakhstan selected\n await user.type(input, ""{backspace}"");\n expect(checkFlagSelected(container, ""kz"")).toBe(true);\n });",10,1,10,684,0.013298799522301948,100,"  test(""typing/deleting different area codes should update the selected country"", async () => {\n    // typing area code starting with 1 changes to Russia\n    await user.type(input, ""1"");\n    let selectedCountry = checkFlagSelected(container, ""ru"");\n    expect(selectedCountry).toBe(true);\n\n    // deleting area code keeps the current country selected\n    await user.type(input, ""{backspace}"");\n    expect(selectedCountry).toBe(true);\n\n    // typing area code starting with 7 changes to Kazakhstan\n    await user.type(input, ""7"");\n    selectedCountry = checkFlagSelected(container, ""kz"");\n    expect(selectedCountry).toBe(true);\n\n    // deleting area code keeps the current country selected\n    await user.type(input, ""{backspace}"");\n    expect(selectedCountry).toBe(true);\n  });",12,1,8.333333333333332,982.4343303398086,0.013527743737301137,100
63,"test(""typing/deleting different area codes should update the selected country"", async () => {\n // typing area code starting with 1 changes to Russia\n await user.type(input, ""1"");\n expect(checkFlagSelected(container, ""ru"")).toBe(true);\n\n // deleting area code keeps Russia selected\n await user.type(input, ""{backspace}"");\n expect(checkFlagSelected(container, ""ru"")).toBe(true);\n\n // typing area code starting with 7 changes to Kazakhstan\n await user.type(input, ""7"");\n expect(checkFlagSelected(container, ""kz"")).toBe(true);\n\n // deleting area code keeps Kazakhstan selected\n await user.type(input, ""{backspace}"");\n expect(checkFlagSelected(container, ""kz"")).toBe(true);\n });",10,1,10,684,0.013298799522301948,100,"  test(""typing/deleting different area codes should update the selected country"", async () => {\n    // typing area code starting with 1 changes to Russia\n    await user.type(input, ""1"");\n    let selectedCountry = checkFlagSelected(container, ""ru"");\n    expect(selectedCountry).toBe(true);\n\n    // deleting area code keeps the current country selected\n    await user.type(input, ""{backspace}"");\n    expect(selectedCountry).toBe(true);\n\n    // typing area code starting with 7 changes to Kazakhstan\n    await user.type(input, ""7"");\n    selectedCountry = checkFlagSelected(container, ""kz"");\n    expect(selectedCountry).toBe(true);\n\n    // deleting area code keeps the current country selected\n    await user.type(input, ""{backspace}"");\n    expect(selectedCountry).toBe(true);\n  });",12,1,8.333333333333332,982.4343303398086,0.013527743737301137,100
64,"test(""instances have different country lists"", () => {\n expect(getCountryListLength(container1)).toEqual(2);\n expect(getCountryListLength(container2)).toEqual(4);\n });",4,1,25,96.86408532184431,0.005803563964543929,100,"  test(""instances have different country lists"", () => {\n    const expectedCountryListLengthInstance1 = 2;\n    const expectedCountryListLengthInstance2 = 4;\n\n    expect(getCountryListLength(container1)).toEqual(expectedCountryListLengthInstance1);\n    expect(getCountryListLength(container2)).toEqual(expectedCountryListLengthInstance2);\n  });",6,1,16.666666666666664,134.56144429603972,0.006818271755542721,100
65,"test(""instances have different country lists"", () => {\n expect(getCountryListLength(container1)).toEqual(2);\n expect(getCountryListLength(container2)).toEqual(4);\n });",4,1,25,96.86408532184431,0.005803563964543929,100,"  test(""instances have different country lists"", () => {\n    const expectedCountryListLengthInstance1 = 2;\n    const expectedCountryListLengthInstance2 = 4;\n\n    expect(getCountryListLength(container1)).toEqual(expectedCountryListLengthInstance1);\n    expect(getCountryListLength(container2)).toEqual(expectedCountryListLengthInstance2);\n  });",6,1,16.666666666666664,134.56144429603972,0.006818271755542721,100
66,"test(""shows the right number of results"", () => {\n expect(getCountryListLength(container)).toBe(6);\n });",3,1,33.33333333333333,38.039100017307746,0.0037702102294917654,100,"    test(""shows the right number of results"", () => {\n      const expectedResultsCount = 6; // Number of countries matching the search query 'x'\n      expect(getCountryListLength(container)).toBe(expectedResultsCount);\n    });",4,1,25,52.32036749447595,0.004310797154389855,100
67,"test(""undefined shorthand updates the record and returns the model"", () => {\n let handler = new PutShorthandRouteHandler(\n schema,\n serializer,\n undefined,\n ""/authors/:id""\n );\n let request = {\n requestBody: JSON.stringify(body),\n url: ""/authors/1"",\n params: { id: ""1"" },\n };\n\n let model = handler.handle(request);\n\n expect(schema.db.authors).toHaveLength(1);\n expect(model instanceof Model).toBeTruthy();\n expect(model.modelName).toBe(""author"");\n expect(model.firstName).toBe(""Ganondorf"");\n });",9,1,11.11111111111111,661.698392771657,0.015776096763738867,100,"  test(""undefined shorthand updates the record and returns the model"", () => {\n    let handler = new PutShorthandRouteHandler(\n      schema,\n      serializer,\n      undefined,\n      ""/authors/:id""\n    );\n    let request = {\n      requestBody: JSON.stringify(body),\n      url: ""/authors/1"",\n      params: { id: ""1"" },\n    };\n\n    let model = handler.handle(request);\n\n    expect(schema.db.authors).toHaveLength(1);\n    expect(model).toBeInstanceOf(Model);\n    expect(model.modelName).toBe(""author"");\n    expect(model.firstName).toBe(""Ganondorf"");\n  });",9,1,11.11111111111111,430.56344644588603,0.015523099887158753,100
68,"test(""query params are ignored"", () => {\n let handler = new PutShorthandRouteHandler(schema, serializer, ""author"");\n let request = {\n requestBody: JSON.stringify(body),\n url: ""/authors/1?foo=bar"",\n params: { id: ""1"" },\n queryParams: { foo: ""bar"" },\n };\n\n let model = handler.handle(request);\n\n expect(schema.db.authors).toHaveLength(1);\n expect(model instanceof Model).toBeTruthy();\n expect(model.modelName).toBe(""author"");\n expect(model.firstName).toBe(""Ganondorf"");\n });",9,1,11.11111111111111,698.2236506816334,0.016191203977699763,100,"  test(""query params are ignored"", () => {\n    let handler = new PutShorthandRouteHandler(schema, serializer, ""author"");\n    let request = {\n      requestBody: JSON.stringify(body),\n      url: ""/authors/1?foo=bar"",\n      params: { id: ""1"" },\n      queryParams: { foo: ""bar"" },\n    };\n\n    let model = handler.handle(request);\n\n    expect(schema.db.authors).toHaveLength(1);\n    expect(model).toBeInstanceOf(Model);\n    expect(model.modelName).toBe(""author"");\n    expect(model.firstName).toBe(""Ganondorf"");\n  });",9,1,11.11111111111111,454.69199143674905,0.015940006096108274,100
69,"test(""string shorthand updates the record of the specified type and returns the model"", () => {\n let handler = new PutShorthandRouteHandler(\n schema,\n serializer,\n undefined,\n ""/authors/:id""\n );\n let request = {\n requestBody: JSON.stringify(body),\n url: ""/authors/1"",\n params: { id: ""1"" },\n };\n\n let model = handler.handle(request);\n\n expect(schema.db.authors).toHaveLength(1);\n expect(model instanceof Model).toBeTruthy();\n expect(model.modelName).toBe(""author"");\n expect(model.firstName).toBe(""Ganondorf"");\n });",9,1,11.11111111111111,661.698392771657,0.015776096763738867,100,"  test(""string shorthand updates the record of the specified type and returns the model"", () => {\n    let handler = new PutShorthandRouteHandler(\n      schema,\n      serializer,\n      undefined,\n      ""/authors/:id""\n    );\n    let request = {\n      requestBody: JSON.stringify(body),\n      url: ""/authors/1"",\n      params: { id: ""1"" },\n    };\n\n    let model = handler.handle(request);\n\n    expect(schema.db.authors).toEqual([\n      { id: ""1"", firstName: ""Ganondorf"" }\n    ]);\n    expect(model).toBeInstanceOf(Model);\n    expect(model.modelName).toBe(""author"");\n    expect(model.attrs).toEqual({ id: ""1"", firstName: ""Ganondorf"" });\n  });",9,1,11.11111111111111,526.5524040694102,0.01658742501271,100
70,"test(""string shorthand creates a record of the specified type and returns the new model"", () => {\n let request = { requestBody: JSON.stringify(body), url: ""/people"" };\n let handler = new PostShorthandRouteHandler(schema, serializer, ""author"");\n\n let model = handler.handle(request);\n\n expect(schema.db.authors).toHaveLength(1);\n expect(model instanceof Model).toBeTruthy();\n expect(model.modelName).toBe(""author"");\n expect(model.firstName).toBe(""Ganon"");\n });",9,1,11.11111111111111,621.5394754437457,0.014751986135897779,100,"  test(""string shorthand creates a record of the specified type and returns the new model"", () => {\n    let request = { requestBody: JSON.stringify(body), url: ""/people"" };\n    let handler = new PostShorthandRouteHandler(schema, serializer, ""author"");\n\n    let model = handler.handle(request);\n\n    expect(schema.db.authors).toHaveLength(1);\n    expect(model).toBeInstanceOf(Model);\n    expect(model.modelName).toBe(""author"");\n    expect(model.firstName).toBe(""Ganon"");\n  });",9,1,11.11111111111111,403.39234781763025,0.014490519668047711,100
71,"test(""query params are ignored"", () => {\n let request = {\n requestBody: JSON.stringify(body),\n url: ""/authors?foo=bar"",\n queryParams: { foo: ""bar"" },\n };\n let handler = new PostShorthandRouteHandler(schema, serializer, ""author"");\n\n let model = handler.handle(request);\n\n expect(schema.db.authors).toHaveLength(1);\n expect(model instanceof Model).toBeTruthy();\n expect(model.modelName).toBe(""author"");\n expect(model.firstName).toBe(""Ganon"");\n });",9,1,11.11111111111111,651.4835005151442,0.015523099887158753,100,"  test(""query params are ignored"", () => {\n    let request = {\n      requestBody: JSON.stringify(body),\n      url: ""/authors?foo=bar"",\n      queryParams: { foo: ""bar"" },\n    };\n    let handler = new PostShorthandRouteHandler(schema, serializer, ""author"");\n\n    let model = handler.handle(request);\n\n    expect(schema.db.authors).toHaveLength(1);\n    expect(model).toBeInstanceOf(Model);\n    expect(model.modelName).toBe(""author"");\n    expect(model.firstName).toBe(""Ganon"");\n  });",9,1,11.11111111111111,423.6666666666667,0.015268154331276774,100
72,"test(""create allows to create objects with associations"", () => {\n let AuthorFactory = Factory.extend({\n name: ""Sam"",\n });\n let CategoryFactory = Factory.extend({\n name: ""splendid software"",\n });\n let ArticleFactory = Factory.extend({\n title: ""Lorem ipsum"",\n\n withCategory: trait({\n awesomeCategory: association(),\n }),\n\n author: association(),\n });\n\n let server = new Server({\n environment: ""test"",\n models: {\n author: Model.extend({\n articles: hasMany(),\n }),\n category: Model.extend({}),\n article: Model.extend({\n author: belongsTo(),\n awesomeCategory: belongsTo(""category""),\n }),\n },\n factories: {\n article: ArticleFactory,\n author: AuthorFactory,\n category: CategoryFactory,\n },\n });\n\n let article = server.create(""article"", ""withCategory"");\n\n expect(article.attrs).toEqual({\n title: ""Lorem ipsum"",\n id: ""1"",\n authorId: ""1"",\n awesomeCategoryId: ""1"",\n });\n expect(server.db.authors).toHaveLength(1);\n expect(server.db.categories).toHaveLength(1);\n\n let anotherArticle = server.create(""article"", ""withCategory"");\n expect(anotherArticle.attrs).toEqual({\n title: ""Lorem ipsum"",\n id: ""2"",\n authorId: ""2"",\n awesomeCategoryId: ""2"",\n });\n expect(server.db.authors).toHaveLength(2);\n expect(server.db.categories).toHaveLength(2);\n\n server.shutdown();\n });",15,1,6.666666666666667,2324.9696224554746,0.031087604039888205,91.75329947526893,"  test(""create allows to create objects with associations"", () => {\n    let AuthorFactory = Factory.extend({\n      name: ""Sam"",\n    });\n    let CategoryFactory = Factory.extend({\n      name: ""splendid software"",\n    });\n    let ArticleFactory = Factory.extend({\n      title: ""Lorem ipsum"",\n\n      withCategory: trait({\n        awesomeCategory: association(),\n      }),\n\n      author: association(),\n    });\n\n    let server = new Server({\n      environment: ""test"",\n      models: {\n        author: Model.extend({\n          articles: hasMany(),\n        }),\n        category: Model.extend({}),\n        article: Model.extend({\n          author: belongsTo(),\n          awesomeCategory: belongsTo(""category""),\n        }),\n      },\n      factories: {\n        article: ArticleFactory,\n        author: AuthorFactory,\n        category: CategoryFactory,\n      },\n    });\n\n    let articles = server.createList(""article"", 2, ""withCategory"");\n\n    articles.forEach((article, index) => {\n      expect(article.attrs).toEqual({\n        title: ""Lorem ipsum"",\n        id: `${index + 1}`,\n        authorId: `${index + 1}`,\n        awesomeCategoryId: `${index + 1}`,\n      });\n    });\n\n    expect(server.db.authors).toHaveLength(2);\n    expect(server.db.categories).toHaveLength(2);\n\n    server.shutdown();\n  });",13,1,7.6923076923076925,2249.6084849294434,0.027103745551240527,95.14120349915848
73,"test(""create allows to create objects with associations"", () => {\n let AuthorFactory = Factory.extend({\n name: ""Sam"",\n });\n let CategoryFactory = Factory.extend({\n name: ""splendid software"",\n });\n let ArticleFactory = Factory.extend({\n title: ""Lorem ipsum"",\n\n withCategory: trait({\n awesomeCategory: association(),\n }),\n\n author: association(),\n });\n\n let server = new Server({\n environment: ""test"",\n models: {\n author: Model.extend({\n articles: hasMany(),\n }),\n category: Model.extend({}),\n article: Model.extend({\n author: belongsTo(),\n awesomeCategory: belongsTo(""category""),\n }),\n },\n factories: {\n article: ArticleFactory,\n author: AuthorFactory,\n category: CategoryFactory,\n },\n });\n\n let article = server.create(""article"", ""withCategory"");\n\n expect(article.attrs).toEqual({\n title: ""Lorem ipsum"",\n id: ""1"",\n authorId: ""1"",\n awesomeCategoryId: ""1"",\n });\n expect(server.db.authors).toHaveLength(1);\n expect(server.db.categories).toHaveLength(1);\n\n let anotherArticle = server.create(""article"", ""withCategory"");\n expect(anotherArticle.attrs).toEqual({\n title: ""Lorem ipsum"",\n id: ""2"",\n authorId: ""2"",\n awesomeCategoryId: ""2"",\n });\n expect(server.db.authors).toHaveLength(2);\n expect(server.db.categories).toHaveLength(2);\n\n server.shutdown();\n });",15,1,6.666666666666667,2324.9696224554746,0.031087604039888205,91.75329947526893,"  test(""create allows to create objects with associations"", () => {\n    let AuthorFactory = Factory.extend({\n      name: ""Sam"",\n    });\n    let CategoryFactory = Factory.extend({\n      name: ""splendid software"",\n    });\n    let ArticleFactory = Factory.extend({\n      title: ""Lorem ipsum"",\n\n      withCategory: trait({\n        awesomeCategory: association(),\n      }),\n\n      author: association(),\n    });\n\n    let server = new Server({\n      environment: ""test"",\n      models: {\n        author: Model.extend({\n          articles: hasMany(),\n        }),\n        category: Model.extend({}),\n        article: Model.extend({\n          author: belongsTo(),\n          awesomeCategory: belongsTo(""category""),\n        }),\n      },\n      factories: {\n        article: ArticleFactory,\n        author: AuthorFactory,\n        category: CategoryFactory,\n      },\n    });\n\n    let article1 = server.create(""article"", ""withCategory"");\n    let article2 = server.create(""article"", ""withCategory"");\n\n    expect(article1.attrs).toEqual({\n      title: ""Lorem ipsum"",\n      id: ""1"",\n      authorId: ""1"",\n      awesomeCategoryId: ""1"",\n    });\n    expect(article2.attrs).toEqual({\n      title: ""Lorem ipsum"",\n      id: ""2"",\n      authorId: ""2"",\n      awesomeCategoryId: ""2"",\n    });\n    expect(server.db.authors).toHaveLength(2);\n    expect(server.db.categories).toHaveLength(2);\n\n    server.shutdown();\n  });\n",13,1,7.6923076923076925,1764.7780449602155,0.028349830154090122,94.7906004523881
74,"test(""create allows to create objects with associations"", () => {\n let AuthorFactory = Factory.extend({\n name: ""Sam"",\n });\n let CategoryFactory = Factory.extend({\n name: ""splendid software"",\n });\n let ArticleFactory = Factory.extend({\n title: ""Lorem ipsum"",\n\n withCategory: trait({\n awesomeCategory: association(),\n }),\n\n author: association(),\n });\n\n let server = new Server({\n environment: ""test"",\n models: {\n author: Model.extend({\n articles: hasMany(),\n }),\n category: Model.extend({}),\n article: Model.extend({\n author: belongsTo(),\n awesomeCategory: belongsTo(""category""),\n }),\n },\n factories: {\n article: ArticleFactory,\n author: AuthorFactory,\n category: CategoryFactory,\n },\n });\n\n let article = server.create(""article"", ""withCategory"");\n\n expect(article.attrs).toEqual({\n title: ""Lorem ipsum"",\n id: ""1"",\n authorId: ""1"",\n awesomeCategoryId: ""1"",\n });\n expect(server.db.authors).toHaveLength(1);\n expect(server.db.categories).toHaveLength(1);\n\n let anotherArticle = server.create(""article"", ""withCategory"");\n expect(anotherArticle.attrs).toEqual({\n title: ""Lorem ipsum"",\n id: ""2"",\n authorId: ""2"",\n awesomeCategoryId: ""2"",\n });\n expect(server.db.authors).toHaveLength(2);\n expect(server.db.categories).toHaveLength(2);\n\n server.shutdown();\n });",15,1,6.666666666666667,2324.9696224554746,0.031087604039888205,91.75329947526893,"  test(""create allows to create objects with associations"", () => {\n    let AuthorFactory = Factory.extend({\n      name: ""Sam"",\n    });\n    let CategoryFactory = Factory.extend({\n      name: ""splendid software"",\n    });\n    let ArticleFactory = Factory.extend({\n      title: ""Lorem ipsum"",\n\n      withCategory: trait({\n        awesomeCategory: association(),\n      }),\n\n      author: association(),\n    });\n\n    let server = new Server({\n      environment: ""test"",\n      models: {\n        author: Model.extend({\n          articles: hasMany(),\n        }),\n        category: Model.extend({}),\n        article: Model.extend({\n          author: belongsTo(),\n          awesomeCategory: belongsTo(""category""),\n        }),\n      },\n      factories: {\n        article: ArticleFactory,\n        author: AuthorFactory,\n        category: CategoryFactory,\n      },\n    });\n\n    let articles = server.createList(""article"", 2, ""withCategory"");\n\n    articles.forEach((article, index) => {\n      expect(article.attrs).toEqual({\n        title: ""Lorem ipsum"",\n        id: `${index + 1}`,\n        authorId: `${index + 1}`,\n        awesomeCategoryId: `${index + 1}`,\n      });\n    });\n\n    expect(server.db.authors).toHaveLength(2);\n    expect(server.db.categories).toHaveLength(2);\n\n    server.shutdown();\n  });",13,1,7.6923076923076925,2249.6084849294434,0.027103745551240527,95.14120349915848
75,"test(""create allows to create objects with associations"", () => {\n let AuthorFactory = Factory.extend({\n name: ""Sam"",\n });\n let CategoryFactory = Factory.extend({\n name: ""splendid software"",\n });\n let ArticleFactory = Factory.extend({\n title: ""Lorem ipsum"",\n\n withCategory: trait({\n awesomeCategory: association(),\n }),\n\n author: association(),\n });\n\n let server = new Server({\n environment: ""test"",\n models: {\n author: Model.extend({\n articles: hasMany(),\n }),\n category: Model.extend({}),\n article: Model.extend({\n author: belongsTo(),\n awesomeCategory: belongsTo(""category""),\n }),\n },\n factories: {\n article: ArticleFactory,\n author: AuthorFactory,\n category: CategoryFactory,\n },\n });\n\n let article = server.create(""article"", ""withCategory"");\n\n expect(article.attrs).toEqual({\n title: ""Lorem ipsum"",\n id: ""1"",\n authorId: ""1"",\n awesomeCategoryId: ""1"",\n });\n expect(server.db.authors).toHaveLength(1);\n expect(server.db.categories).toHaveLength(1);\n\n let anotherArticle = server.create(""article"", ""withCategory"");\n expect(anotherArticle.attrs).toEqual({\n title: ""Lorem ipsum"",\n id: ""2"",\n authorId: ""2"",\n awesomeCategoryId: ""2"",\n });\n expect(server.db.authors).toHaveLength(2);\n expect(server.db.categories).toHaveLength(2);\n\n server.shutdown();\n });",15,1,6.666666666666667,2324.9696224554746,0.031087604039888205,91.75329947526893,"  test(""create allows to create objects with associations"", () => {\n    let AuthorFactory = Factory.extend({\n      name: ""Sam"",\n    });\n    let CategoryFactory = Factory.extend({\n      name: ""splendid software"",\n    });\n    let ArticleFactory = Factory.extend({\n      title: ""Lorem ipsum"",\n\n      withCategory: trait({\n        awesomeCategory: association(),\n      }),\n\n      author: association(),\n    });\n\n    let server = new Server({\n      environment: ""test"",\n      models: {\n        author: Model.extend({\n          articles: hasMany(),\n        }),\n        category: Model.extend({}),\n        article: Model.extend({\n          author: belongsTo(),\n          awesomeCategory: belongsTo(""category""),\n        }),\n      },\n      factories: {\n        article: ArticleFactory,\n        author: AuthorFactory,\n        category: CategoryFactory,\n      },\n    });\n\n    let articles = server.createList(""article"", 2, ""withCategory"");\n\n    articles.forEach((article, index) => {\n      expect(article.attrs).toEqual({\n        title: ""Lorem ipsum"",\n        id: `${index + 1}`,\n        authorId: `${index + 1}`,\n        awesomeCategoryId: `${index + 1}`,\n      });\n    });\n\n    expect(server.db.authors).toHaveLength(2);\n    expect(server.db.categories).toHaveLength(2);\n\n    server.shutdown();\n  });\n",13,1,7.6923076923076925,2249.6084849294434,0.027103745551240527,95.14120349915848
76,"test(""routes return pretender handler"", () => {\n let server = new Server({ environment: ""test"" });\n\n let handler = server.post(""foo"");\n\n expect(handler.numberOfCalls).toBe(0);\n\n server.shutdown();\n });",6,1,16.666666666666664,132.83428025068963,0.0072568555296063835,100,"  test(""routes return pretender handler"", () => {\n    let server = new Server({ environment: ""test"" });\n\n    let handler = server.post(""foo"");\n\n    const expectedNumberOfCalls = 0; // Magic number replaced with a named constant\n    expect(handler.numberOfCalls).toBe(expectedNumberOfCalls);\n\n    server.shutdown();\n  });",7,1,14.285714285714285,152,0.007745047644751603,100
77,"test(""routes return pretender handler"", async () => {\n let server = createServer({ environment: ""test"" });\n\n let handler = server.post(""foo"");\n\n expect(handler.numberOfCalls).toBe(0);\n\n server.shutdown();\n });",6,1,16.666666666666664,137.94329102956232,0.0074417559145820295,100,"  test(""routes return pretender handler"", async () => {\n    let server = createServer({ environment: ""test"" });\n\n    let handler = server.post(""foo"");\n\n    const expectedNumberOfCalls = 0; // Magic number replaced with a named constant\n    expect(handler.numberOfCalls).toBe(expectedNumberOfCalls);\n\n    server.shutdown();\n  });",7,1,14.285714285714285,157.42857142857144,0.007928372955436724,100
78,"test(""forces timing to be 0 in test environment"", async () => {\n let server = createServer({ environment: ""test"" });\n\n expect(server.timing).toBe(0);\n\n server.shutdown();\n });",5,1,20,97.86947626968757,0.0059431225621341555,100,"  test(""forces timing to be 0 in test environment"", async () => {\n    const TEST_ENVIRONMENT_TIMING = 0;\n    let server = createServer({ environment: ""test"" });\n\n    expect(server.timing).toBe(TEST_ENVIRONMENT_TIMING);\n\n    server.shutdown();\n  });",6,1,16.666666666666664,116.05924570533425,0.0064496011531267276,100
79,"test(""allows setting the timing to 0"", async () => {\n let server = createServer({ timing: 0 });\n\n expect(server.timing).toBe(0);\n\n server.shutdown();\n });",5,1,20,104.936092431998,0.005803563964543929,100,"  test(""allows setting the timing to 0"", async () => {\n    const DEFAULT_TIMING = 0;\n    let server = createServer({ timing: DEFAULT_TIMING });\n\n    expect(server.timing).toBe(DEFAULT_TIMING);\n\n    server.shutdown();\n  });",6,1,16.666666666666664,123.68120627487988,0.006314714413404747,100
80,"test(""forces timing to 0 in test environment"", () => {\n let server = new Server({ environment: ""test"" });\n\n server.loadConfig(function () {\n this.timing = 50;\n });\n\n expect(server.timing).toBe(0);\n\n server.shutdown();\n });",8,1,12.5,232.45999043870685,0.00762438701005102,100,"  test(""forces timing to 0 in test environment"", () => {\n    const DEFAULT_TIMING = 0;\n    let server = new Server({ environment: ""test"" });\n\n    server.loadConfig(function () {\n      this.timing = 50;\n    });\n\n    expect(server.timing).toBe(DEFAULT_TIMING);\n\n    server.shutdown();\n  });",9,1,11.11111111111111,263.07692307692304,0.008109602660764532,100
81,"test(""`first()` returns null when nothing is found"", () => {\n expect.assertions(2);\n\n let db = new Db();\n let schema = new Schema(db);\n\n let authorModel = Model.extend({});\n schema.registerModel(""author"", authorModel);\n\n expect(schema.first(""author"")).toBeNull();\n\n let record = schema.create(""author"", { id: 1, name: ""Mary Roach"" });\n\n expect(schema.first(""author"")).toEqual(record);\n });",10,1,10,399.77544590234584,0.013418574436768223,100,"  test(""`first()` returns the first record or null when no records exist"", () => {\n    let db = new Db();\n    let schema = new Schema(db);\n\n    let authorModel = Model.extend({});\n    schema.registerModel(""author"", authorModel);\n\n    // No records exist\n    expect(schema.first(""author"")).toBeNull();\n\n    // Create a record and verify it is returned\n    let record = schema.create(""author"", { id: 1, name: ""Mary Roach"" });\n    let firstRecord = schema.first(""author"");\n\n    expect(firstRecord).toEqual(record);\n  });",10,1,10,379.30144324147744,0.01281656073002471,100
82,"it("""", () => {\n uiframe.default();\n });",3,1,33.33333333333333,18.094737505048094,0.0022974545934948596,100,"    it(""should initialize the uiframe default functionality"", () => {\n        uiframe.default();\n    });",3,1,33.33333333333333,18.094737505048094,0.0022974545934948596,100
83,"test(""verify local shortcuts for markdown preview"", async () => {\n document.execCommand = jest.fn();\n\n expect(normal.mappings.find('of')).toBe(undefined);\n expect(document.execCommand).toHaveBeenCalledTimes(0);\n\n await waitForEvent(document, ""surfingkeys:defaultSettingsLoaded"", () => {\n return true;\n }, () => {\n dispatchSKEvent('defaultSettingsLoaded', {normal, api});\n });\n\n expect(normal.mappings.find('of').meta.word).toBe('of');\n expect(document.execCommand).toHaveBeenCalledTimes(1);\n });",12,1,8.333333333333332,879.7996950694521,0.01588680007216953,100,"    test(""verify local shortcuts for markdown preview"", async () => {\n        document.execCommand = jest.fn();\n\n        expect(normal.mappings.find('of')).toBeUndefined();\n        expect(document.execCommand).not.toHaveBeenCalled();\n\n        await waitForEvent(document, ""surfingkeys:defaultSettingsLoaded"", () => {\n            return true;\n        }, () => {\n            dispatchSKEvent('defaultSettingsLoaded', {normal, api});\n        });\n\n        const mapping = normal.mappings.find('of');\n        expect(mapping).toBeDefined();\n        expect(mapping.meta.word).toBe('of');\n        expect(document.execCommand).toHaveBeenCalledTimes(1);\n    });",14,1,7.142857142857142,983.7411515133333,0.01745469862860696,97.37314618527375
84,"test(""render markdown from clipboard"", async () => {\n jest.spyOn(clipboard, 'read').mockImplementationOnce((onReady) => {\n onReady({data: ""* [github](https://github.com)\n* [google](https://google.com)""});\n });\n await waitForEvent(document, ""surfingkeys:defaultSettingsLoaded"", () => {\n return true;\n }, () => {\n dispatchSKEvent('defaultSettingsLoaded', {normal, api});\n });\n const links = document.querySelectorAll(""a"");\n expect(links.length).toBe(2);\n expect(links[0].href).toBe(""https://github.com/"");\n });",13,1,7.6923076923076925,340.05866965893006,0.013659824705468218,100,"    test(""render markdown from clipboard"", async () => {\n        jest.spyOn(clipboard, 'read').mockImplementationOnce((onReady) => {\n            onReady({data: ""* [github](https://github.com)\n* [google](https://google.com)""});\n        });\n        await waitForEvent(document, ""surfingkeys:defaultSettingsLoaded"", () => {\n            return true;\n        }, () => {\n            dispatchSKEvent('defaultSettingsLoaded', {normal, api});\n        });\n        const links = Array.from(document.querySelectorAll(""a""));\n        expect(links).toHaveLength(2);\n        expect(links.map(link => link.href)).toEqual([\n            ""https://github.com/"",\n            ""https://google.com/""\n        ]);\n    });",13,1,7.6923076923076925,380.77039481608966,0.015026306830267828,99.74218541869021
85,"test(""follow links generated from markdown"", async () => {\n jest.spyOn(clipboard, 'read').mockImplementationOnce((onReady) => {\n onReady({data: ""* [github](https://github.com)\n* [google](https://google.com)""});\n });\n await waitForEvent(document, ""surfingkeys:defaultSettingsLoaded"", () => {\n return true;\n }, () => {\n dispatchSKEvent('defaultSettingsLoaded', {normal, api});\n });\n\n const links = document.querySelectorAll(""a"");\n links.forEach((l, i) => {\n l.getBoundingClientRect = jest.fn(() => {\n return { width: 100, height: 10, top: 100 * i, left: 0, bottom: 0, right: 0 };\n });\n });\n document.elementFromPoint = jest.fn(() => {\n return null;\n });\n expect(document.querySelector(""div.surfingkeys_hints_host"")).toBe(null);\n\n document.body.dispatchEvent(new KeyboardEvent('keydown', {'key': 'f'}));\n const hint_labels = document.querySelector(""div.surfingkeys_hints_host"").shadowRoot.querySelectorAll(""section>div"");\n expect(hint_labels.length).toBe(2);\n expect(hint_labels[0].label).toBe(""A"");\n expect(hint_labels[1].label).toBe(""S"");\n });",25,1,4,2452.7583388858225,0.02822356120721142,84.23181014885022,"    test(""follow links generated from markdown"", async () => {\n        jest.spyOn(clipboard, 'read').mockImplementationOnce((onReady) => {\n            onReady({data: ""* [github](https://github.com)\n* [google](https://google.com)""});\n        });\n        await waitForEvent(document, ""surfingkeys:defaultSettingsLoaded"", () => {\n            return true;\n        }, () => {\n            dispatchSKEvent('defaultSettingsLoaded', {normal, api});\n        });\n\n        const links = document.querySelectorAll(""a"");\n        links.forEach((l, i) => {\n            l.getBoundingClientRect = jest.fn(() => {\n                return { width: 100, height: 10, top: 100 * i, left: 0, bottom: 0, right: 0 };\n            });\n        });\n        document.elementFromPoint = jest.fn(() => {\n            return null;\n        });\n        expect(document.querySelector(""div.surfingkeys_hints_host"")).toBeNull();\n\n        document.body.dispatchEvent(new KeyboardEvent('keydown', {'key': 'f'}));\n        const hintHost = document.querySelector(""div.surfingkeys_hints_host"");\n        expect(hintHost).not.toBeNull();\n\n        const hintLabels = hintHost.shadowRoot.querySelectorAll(""section>div"");\n        expect(hintLabels).toHaveLength(2);\n        expect(Array.from(hintLabels).map(label => label.label)).toEqual([""A"", ""S""]);\n    });",26,1,3.8461538461538463,2488.574644760203,0.029317967975841085,83.29969578984483
86,"test(""follow links generated from markdown"", async () => {\n jest.spyOn(clipboard, 'read').mockImplementationOnce((onReady) => {\n onReady({data: ""* [github](https://github.com)\n* [google](https://google.com)""});\n });\n await waitForEvent(document, ""surfingkeys:defaultSettingsLoaded"", () => {\n return true;\n }, () => {\n dispatchSKEvent('defaultSettingsLoaded', {normal, api});\n });\n\n const links = document.querySelectorAll(""a"");\n links.forEach((l, i) => {\n l.getBoundingClientRect = jest.fn(() => {\n return { width: 100, height: 10, top: 100 * i, left: 0, bottom: 0, right: 0 };\n });\n });\n document.elementFromPoint = jest.fn(() => {\n return null;\n });\n expect(document.querySelector(""div.surfingkeys_hints_host"")).toBe(null);\n\n document.body.dispatchEvent(new KeyboardEvent('keydown', {'key': 'f'}));\n const hint_labels = document.querySelector(""div.surfingkeys_hints_host"").shadowRoot.querySelectorAll(""section>div"");\n expect(hint_labels.length).toBe(2);\n expect(hint_labels[0].label).toBe(""A"");\n expect(hint_labels[1].label).toBe(""S"");\n });",25,1,4,2452.7583388858225,0.02822356120721142,84.23181014885022,"    test(""follow links generated from markdown"", async () => {\n        jest.spyOn(clipboard, 'read').mockImplementationOnce((onReady) => {\n            onReady({data: ""* [github](https://github.com)\n* [google](https://google.com)""});\n        });\n        await waitForEvent(document, ""surfingkeys:defaultSettingsLoaded"", () => {\n            return true;\n        }, () => {\n            dispatchSKEvent('defaultSettingsLoaded', {normal, api});\n        });\n\n        const links = document.querySelectorAll(""a"");\n        links.forEach((l, i) => {\n            l.getBoundingClientRect = jest.fn(() => {\n                return { width: 100, height: 10, top: 100 * i, left: 0, bottom: 0, right: 0 };\n            });\n        });\n        document.elementFromPoint = jest.fn(() => {\n            return null;\n        });\n        expect(document.querySelector(""div.surfingkeys_hints_host"")).toBe(null);\n\n        document.body.dispatchEvent(new KeyboardEvent('keydown', {'key': 'f'}));\n        const hintHost = document.querySelector(""div.surfingkeys_hints_host"");\n        expect(hintHost).not.toBeNull();\n\n        const hintLabels = hintHost.shadowRoot.querySelectorAll(""section>div"");\n        expect(hintLabels).toHaveLength(2);\n        expect(Array.from(hintLabels).map(label => label.label)).toEqual([""A"", ""S""]);\n    });",26,1,3.8461538461538463,2456.4,0.029392214144503066,83.27996768124865
87,"test(""normal /"", async () => {\n normal.enter();\n await new Promise((r) => {\n document.addEventListener(""surfingkeys:front"", function(evt) {\n if (evt.detail.length && evt.detail[0] === ""openFinder"") {\n r(evt);\n }\n });\n document.body.dispatchEvent(new KeyboardEvent('keydown',{'key':'/'}));\n });\n });",11,3,27.27272727272727,488.7570025768752,0.010938518570501323,100,"    test(""normal /"", async () => {\n        normal.enter();\n        const handleEvent = jest.fn((evt) => {\n            expect(evt.detail.length).toBeGreaterThan(0);\n            expect(evt.detail[0]).toBe(""openFinder"");\n        });\n\n        document.addEventListener(""surfingkeys:front"", handleEvent);\n        document.body.dispatchEvent(new KeyboardEvent('keydown', {'key': '/'}));\n\n        // Ensure the event listener was triggered\n        expect(handleEvent).toHaveBeenCalled();\n        document.removeEventListener(""surfingkeys:front"", handleEvent);\n    });",11,1,9.090909090909092,442.6464493617655,0.01503291618651981,100
88,"test(""normal mouse up"", async () => {\n runtime.conf.mouseSelectToQuery = [ ""http://localhost"" ];\n await new Promise((r) => {\n document.addEventListener(""surfingkeys:front"", function(evt) {\n if (evt.detail.length && evt.detail[0] === ""querySelectedWord"") {\n r(evt);\n }\n });\n document.body.dispatchEvent(new MouseEvent('mouseup', {\n bubbles: true,\n cancelable: true,\n view: window,\n button: 0\n }));\n });\n });",11,3,27.27272727272727,753.6983954854685,0.012712876271219028,100,"    test(""normal mouse up triggers querySelectedWord"", async () => {\n        runtime.conf.mouseSelectToQuery = [ ""http://localhost"" ];\n        await new Promise((r) => {\n            document.addEventListener(""surfingkeys:front"", function(evt) {\n                r(evt.detail);\n            });\n            document.body.dispatchEvent(new MouseEvent('mouseup', {\n                bubbles: true,\n                cancelable: true,\n                view: window,\n                button: 0\n            }));\n        }).then((detail) => {\n            expect(detail).toContain(""querySelectedWord"");\n        });\n    });",11,1,9.090909090909092,418.7213308252602,0.012712876271219028,100
89,"test(""verify local shortcuts for markdown preview"", async () => {\n document.execCommand = jest.fn();\n\n expect(normal.mappings.find('of')).toBe(undefined);\n expect(document.execCommand).toHaveBeenCalledTimes(0);\n\n await waitForEvent(document, ""surfingkeys:defaultSettingsLoaded"", () => {\n return true;\n }, () => {\n dispatchSKEvent('defaultSettingsLoaded', {normal, api});\n });\n\n expect(normal.mappings.find('of').meta.word).toBe('of');\n expect(document.execCommand).toHaveBeenCalledTimes(1);\n });",12,1,8.333333333333332,879.7996950694521,0.01588680007216953,100,"    test(""verify local shortcuts for markdown preview"", async () => {\n        document.execCommand = jest.fn();\n\n        expect(normal.mappings.find('of')).toBe(undefined);\n\n        await waitForEvent(document, ""surfingkeys:defaultSettingsLoaded"", () => {\n            return true;\n        }, () => {\n            dispatchSKEvent('defaultSettingsLoaded', {normal, api});\n        });\n\n        const shortcut = normal.mappings.find('of');\n        expect(shortcut.meta.word).toBe('of');\n        expect(document.execCommand).toHaveBeenCalledTimes(1);\n    });",12,1,8.333333333333332,733.8816968628114,0.014809194479950586,100
90,"test(""verify local shortcuts for markdown preview"", async () => {\n document.execCommand = jest.fn();\n\n expect(normal.mappings.find('of')).toBe(undefined);\n expect(document.execCommand).toHaveBeenCalledTimes(0);\n\n await waitForEvent(document, ""surfingkeys:defaultSettingsLoaded"", () => {\n return true;\n }, () => {\n dispatchSKEvent('defaultSettingsLoaded', {normal, api});\n });\n\n expect(normal.mappings.find('of').meta.word).toBe('of');\n expect(document.execCommand).toHaveBeenCalledTimes(1);\n });",12,1,8.333333333333332,879.7996950694521,0.01588680007216953,100,"    test(""verify local shortcuts for markdown preview"", async () => {\n        document.execCommand = jest.fn();\n\n        expect(normal.mappings.find('of')).toBe(undefined);\n\n        await waitForEvent(document, ""surfingkeys:defaultSettingsLoaded"", () => {\n            return true;\n        }, () => {\n            dispatchSKEvent('defaultSettingsLoaded', {normal, api});\n        });\n\n        const mapping = normal.mappings.find('of');\n        expect(mapping.meta.word).toBe('of');\n        expect(document.execCommand).toHaveBeenCalledTimes(1);\n    });",12,1,8.333333333333332,733.8816968628114,0.014809194479950586,100
91,"test(""render markdown from clipboard"", async () => {\n jest.spyOn(clipboard, 'read').mockImplementationOnce((onReady) => {\n onReady({data: ""* [github](https://github.com)\n* [google](https://google.com)""});\n });\n await waitForEvent(document, ""surfingkeys:defaultSettingsLoaded"", () => {\n return true;\n }, () => {\n dispatchSKEvent('defaultSettingsLoaded', {normal, api});\n });\n const links = document.querySelectorAll(""a"");\n expect(links.length).toBe(2);\n expect(links[0].href).toBe(""https://github.com/"");\n });",13,1,7.6923076923076925,340.05866965893006,0.013659824705468218,100,"    test(""render markdown from clipboard"", async () => {\n        const expectedLinkCount = 2; // Refactored to eliminate magic number\n        const expectedFirstLinkHref = ""https://github.com/""; // Refactored to provide context\n\n        jest.spyOn(clipboard, 'read').mockImplementationOnce((onReady) => {\n            onReady({data: ""* [github](https://github.com)\n* [google](https://google.com)""});\n        });\n        await waitForEvent(document, ""surfingkeys:defaultSettingsLoaded"", () => {\n            return true;\n        }, () => {\n            dispatchSKEvent('defaultSettingsLoaded', {normal, api});\n        });\n        const links = document.querySelectorAll(""a"");\n        expect(links.length).toBe(expectedLinkCount);\n        expect(links[0].href).toBe(expectedFirstLinkHref);\n    });",15,1,6.666666666666667,386.4273122101763,0.014514861026835576,97.6940613112952
92,"test(""follow links generated from markdown"", async () => {\n jest.spyOn(clipboard, 'read').mockImplementationOnce((onReady) => {\n onReady({data: ""* [github](https://github.com)\n* [google](https://google.com)""});\n });\n await waitForEvent(document, ""surfingkeys:defaultSettingsLoaded"", () => {\n return true;\n }, () => {\n dispatchSKEvent('defaultSettingsLoaded', {normal, api});\n });\n\n const links = document.querySelectorAll(""a"");\n links.forEach((l, i) => {\n l.getBoundingClientRect = jest.fn(() => {\n return { width: 100, height: 10, top: 100 * i, left: 0, bottom: 0, right: 0 };\n });\n });\n document.elementFromPoint = jest.fn(() => {\n return null;\n });\n expect(document.querySelector(""div.surfingkeys_hints_host"")).toBe(null);\n\n document.body.dispatchEvent(new KeyboardEvent('keydown', {'key': 'f'}));\n const hint_labels = document.querySelector(""div.surfingkeys_hints_host"").shadowRoot.querySelectorAll(""section>div"");\n expect(hint_labels.length).toBe(2);\n expect(hint_labels[0].label).toBe(""A"");\n expect(hint_labels[1].label).toBe(""S"");\n });",25,1,4,2452.7583388858225,0.02822356120721142,84.23181014885022,"    test(""follow links generated from markdown"", async () => {\n        jest.spyOn(clipboard, 'read').mockImplementationOnce((onReady) => {\n            onReady({data: ""* [github](https://github.com)\n* [google](https://google.com)""});\n        });\n        await waitForEvent(document, ""surfingkeys:defaultSettingsLoaded"", () => {\n            return true;\n        }, () => {\n            dispatchSKEvent('defaultSettingsLoaded', {normal, api});\n        });\n\n        const links = document.querySelectorAll(""a"");\n        const linkHeight = 10;\n        const linkWidth = 100;\n        const linkTopOffset = 100;\n\n        links.forEach((l, i) => {\n            l.getBoundingClientRect = jest.fn(() => {\n                return { width: linkWidth, height: linkHeight, top: linkTopOffset * i, left: 0, bottom: 0, right: 0 };\n            });\n        });\n        document.elementFromPoint = jest.fn(() => {\n            return null;\n        });\n        expect(document.querySelector(""div.surfingkeys_hints_host"")).toBe(null);\n\n        document.body.dispatchEvent(new KeyboardEvent('keydown', {'key': 'f'}));\n        const hint_labels = document.querySelector(""div.surfingkeys_hints_host"").shadowRoot.querySelectorAll(""section>div"");\n        expect(hint_labels.length).toBe(2);\n        expect(hint_labels[0].label).toBe(""A"");\n        expect(hint_labels[1].label).toBe(""S"");\n    });",28,1,3.571428571428571,2632.2068976432615,0.02930630548371461,82.10225004623082
93,"test(""toggle Omnibar's position"", async () => {\n const elmOmnibarClass = document.getElementById(""sk_omnibar"").classList;\n window.postMessage({surfingkeys_frontend_data: { action: ""openOmnibar"", type: ""URLs"", extra: ""getAllSites"" }}, document.location.origin);\n await new Promise((r) => setTimeout(r, 100));\n expect(elmOmnibarClass.value).toContain('sk_omnibar_middle');\n Mode.handleMapKey.call(omnibar, {\n sk_keyName: KeyboardUtils.encodeKeystroke(""<Ctrl-j>"")\n });\n await new Promise((r) => setTimeout(r, 100));\n expect(elmOmnibarClass.value).toContain('sk_omnibar_bottom');\n });",9,1,11.11111111111111,489.68861636912123,0.017013965260313183,100,"    test(""toggle Omnibar's position"", async () => {\n        const elmOmnibarClass = document.getElementById(""sk_omnibar"").classList;\n        window.postMessage({surfingkeys_frontend_data: { action: ""openOmnibar"", type: ""URLs"", extra: ""getAllSites"" }}, document.location.origin);\n        await new Promise((r) => setTimeout(r, 100));\n        const initialPosition = elmOmnibarClass.value;\n        expect(initialPosition).toContain('sk_omnibar_middle');\n\n        Mode.handleMapKey.call(omnibar, {\n            sk_keyName: KeyboardUtils.encodeKeystroke(""<Ctrl-j>"")\n        });\n        await new Promise((r) => setTimeout(r, 100));\n        const updatedPosition = elmOmnibarClass.value;\n        expect(updatedPosition).toContain('sk_omnibar_bottom');\n    });",11,1,9.090909090909092,539.1110263239493,0.017827286891253343,100
94,"test(""toggle Omnibar's position"", async () => {\n const elmOmnibarClass = document.getElementById(""sk_omnibar"").classList;\n window.postMessage({surfingkeys_frontend_data: { action: ""openOmnibar"", type: ""URLs"", extra: ""getAllSites"" }}, document.location.origin);\n await new Promise((r) => setTimeout(r, 100));\n expect(elmOmnibarClass.value).toContain('sk_omnibar_middle');\n Mode.handleMapKey.call(omnibar, {\n sk_keyName: KeyboardUtils.encodeKeystroke(""<Ctrl-j>"")\n });\n await new Promise((r) => setTimeout(r, 100));\n expect(elmOmnibarClass.value).toContain('sk_omnibar_bottom');\n });",9,1,11.11111111111111,489.68861636912123,0.017013965260313183,100,"    test(""toggle Omnibar's position"", async () => {\n        const elmOmnibarClass = document.getElementById(""sk_omnibar"").classList;\n        window.postMessage({surfingkeys_frontend_data: { action: ""openOmnibar"", type: ""URLs"", extra: ""getAllSites"" }}, document.location.origin);\n        await new Promise((r) => setTimeout(r, 100));\n        const initialPosition = elmOmnibarClass.value;\n        expect(initialPosition).toContain('sk_omnibar_middle');\n\n        Mode.handleMapKey.call(omnibar, {\n            sk_keyName: KeyboardUtils.encodeKeystroke(""<Ctrl-j>"")\n        });\n        await new Promise((r) => setTimeout(r, 100));\n        const updatedPosition = elmOmnibarClass.value;\n        expect(updatedPosition).toContain('sk_omnibar_bottom');\n    });",11,1,9.090909090909092,539.1110263239493,0.017827286891253343,100
95,"test('show omnibar', async () => {\n const elmOmnibarStyle = document.getElementById(""sk_omnibar"").style;\n expect(elmOmnibarStyle).toHaveProperty('display', 'none');\n await waitForEvent(window, ""message"", (_msg) => {\n return _msg.surfingkeys_uihost_data && _msg.surfingkeys_uihost_data.action === ""setFrontFrame"";\n }, () => {\n window.postMessage({surfingkeys_frontend_data: { action: ""openOmnibar"", type: ""SearchEngine"", extra: ""b"" }}, document.location.origin);\n });\n expect(elmOmnibarStyle).not.toHaveProperty('display', 'none');\n });",10,2,20,871.4285714285714,0.015103536107907947,100,"    test('show omnibar', async () => {\n        const elmOmnibarStyle = document.getElementById(""sk_omnibar"").style;\n        expect(elmOmnibarStyle.display).toBe('none');\n        await waitForEvent(window, ""message"", (_msg) => {\n            return _msg.surfingkeys_uihost_data && _msg.surfingkeys_uihost_data.action === ""setFrontFrame"";\n        }, () => {\n            window.postMessage({surfingkeys_frontend_data: { action: ""openOmnibar"", type: ""SearchEngine"", extra: ""b"" }}, document.location.origin);\n        });\n        expect(elmOmnibarStyle.display).not.toBe('none');\n    });",10,2,20,900,0.01543188984079292,100
96,"it('gets default classes when no options set', () => {\n expect(element.classList.length, 'element - only one class').toEqual(1);\n expect(target.classList.length, 'target - only one class').toEqual(1);\n const tether = new Tether({\n element: '.element',\n target: '.target',\n attachment: 'top left',\n targetAttachment: 'top right'\n });\n\n tether.enable();\n\n expect(element.classList.length, 'element - tether classes added').toEqual(12);\n expect(element).toHaveClass('tether-element');\n expect(element).not.toHaveClass('tether-target');\n\n expect(target.classList.length, 'target - tether classes added').toEqual(12);\n expect(target).toHaveClass('tether-target');\n expect(target).not.toHaveClass('tether-element');\n\n tether.destroy();\n\n expect(element.classList.length, 'element - destroy sets classes back to initial state').toEqual(1);\n expect(target.classList.length, 'target - destroy sets classes back to initial state').toEqual(1);\n });",15,1,6.666666666666667,1583.3333333333333,0.024366814485107212,93.6532781635149,"    it('gets default classes when no options set', () => {\n      expect(element.classList.length, 'element - only one class').toEqual(1);\n      expect(target.classList.length, 'target - only one class').toEqual(1);\n      const tether = new Tether({\n      element: '.element',\n      target: '.target',\n      attachment: 'top left',\n      targetAttachment: 'top right'\n      });\n\n      tether.enable();\n\n      expect(element.classList).toContain('tether-element');\n      expect(target.classList).toContain('tether-target');\n\n      tether.destroy();\n\n      expect(element.classList.length, 'element - destroy sets classes back to initial state').toEqual(1);\n      expect(target.classList.length, 'target - destroy sets classes back to initial state').toEqual(1);\n    });",11,1,9.090909090909092,868.6520547625624,0.018642137414420654,100
97,"it('gets default classes when no options set', () => {\n expect(element.classList.length, 'element - only one class').toEqual(1);\n expect(target.classList.length, 'target - only one class').toEqual(1);\n const tether = new Tether({\n element: '.element',\n target: '.target',\n attachment: 'top left',\n targetAttachment: 'top right'\n });\n\n tether.enable();\n\n expect(element.classList.length, 'element - tether classes added').toEqual(12);\n expect(element).toHaveClass('tether-element');\n expect(element).not.toHaveClass('tether-target');\n\n expect(target.classList.length, 'target - tether classes added').toEqual(12);\n expect(target).toHaveClass('tether-target');\n expect(target).not.toHaveClass('tether-element');\n\n tether.destroy();\n\n expect(element.classList.length, 'element - destroy sets classes back to initial state').toEqual(1);\n expect(target.classList.length, 'target - destroy sets classes back to initial state').toEqual(1);\n });",15,1,6.666666666666667,1583.3333333333333,0.024366814485107212,93.6532781635149,"    it('gets default classes when no options set', () => {\n      expect(element.classList.length, 'element - only one class').toEqual(1);\n      expect(target.classList.length, 'target - only one class').toEqual(1);\n      const tether = new Tether({\n      element: '.element',\n      target: '.target',\n      attachment: 'top left',\n      targetAttachment: 'top right'\n      });\n\n      tether.enable();\n\n      expect(element.classList).toContain('tether-element');\n      expect(target.classList).toContain('tether-target');\n\n      tether.destroy();\n\n      expect(element.classList.length, 'element - destroy sets classes back to initial state').toEqual(1);\n      expect(target.classList.length, 'target - destroy sets classes back to initial state').toEqual(1);\n    });",11,1,9.090909090909092,868.6520547625624,0.018642137414420654,100
98,"it('gets default classes when no options set', () => {\n expect(element.classList.length, 'element - only one class').toEqual(1);\n expect(target.classList.length, 'target - only one class').toEqual(1);\n const tether = new Tether({\n element: '.element',\n target: '.target',\n attachment: 'top left',\n targetAttachment: 'top right'\n });\n\n tether.enable();\n\n expect(element.classList.length, 'element - tether classes added').toEqual(12);\n expect(element).toHaveClass('tether-element');\n expect(element).not.toHaveClass('tether-target');\n\n expect(target.classList.length, 'target - tether classes added').toEqual(12);\n expect(target).toHaveClass('tether-target');\n expect(target).not.toHaveClass('tether-element');\n\n tether.destroy();\n\n expect(element.classList.length, 'element - destroy sets classes back to initial state').toEqual(1);\n expect(target.classList.length, 'target - destroy sets classes back to initial state').toEqual(1);\n });",15,1,6.666666666666667,1583.3333333333333,0.024366814485107212,93.6532781635149,"    it('gets default classes when no options set', () => {\n      expect(element.classList.length, 'element - only one class').toEqual(1);\n      expect(target.classList.length, 'target - only one class').toEqual(1);\n      const tether = new Tether({\n      element: '.element',\n      target: '.target',\n      attachment: 'top left',\n      targetAttachment: 'top right'\n      });\n\n      tether.enable();\n\n      expect(element.classList).toContain('tether-element');\n      expect(target.classList).toContain('tether-target');\n\n      tether.destroy();\n\n      expect(element.classList.length, 'element - destroy sets classes back to initial state').toEqual(1);\n      expect(target.classList.length, 'target - destroy sets classes back to initial state').toEqual(1);\n    });\n",11,1,9.090909090909092,868.6520547625624,0.018642137414420654,100
99,"it('gets default classes when no options set', () => {\n expect(element.classList.length, 'element - only one class').toEqual(1);\n expect(target.classList.length, 'target - only one class').toEqual(1);\n const tether = new Tether({\n element: '.element',\n target: '.target',\n attachment: 'top left',\n targetAttachment: 'top right'\n });\n\n tether.enable();\n\n expect(element.classList.length, 'element - tether classes added').toEqual(12);\n expect(element).toHaveClass('tether-element');\n expect(element).not.toHaveClass('tether-target');\n\n expect(target.classList.length, 'target - tether classes added').toEqual(12);\n expect(target).toHaveClass('tether-target');\n expect(target).not.toHaveClass('tether-element');\n\n tether.destroy();\n\n expect(element.classList.length, 'element - destroy sets classes back to initial state').toEqual(1);\n expect(target.classList.length, 'target - destroy sets classes back to initial state').toEqual(1);\n });",15,1,6.666666666666667,1583.3333333333333,0.024366814485107212,93.6532781635149,"    it('gets default classes when no options set', () => {\n      expect(element.classList.length, 'element - only one class').toEqual(1);\n      expect(target.classList.length, 'target - only one class').toEqual(1);\n      const tether = new Tether({\n      element: '.element',\n      target: '.target',\n      attachment: 'top left',\n      targetAttachment: 'top right'\n      });\n\n      tether.enable();\n\n      expect(element.classList).toContain('tether-element');\n      expect(target.classList).toContain('tether-target');\n\n      tether.destroy();\n\n      expect(element.classList.length, 'element - destroy sets classes back to initial state').toEqual(1);\n      expect(target.classList.length, 'target - destroy sets classes back to initial state').toEqual(1);\n    });",11,1,9.090909090909092,868.6520547625624,0.018642137414420654,100
100,"it('gets prefixed classes when classPrefix set', () => {\n expect(element.classList.length, 'element - only one class').toEqual(1);\n expect(target.classList.length, 'target - only one class').toEqual(1);\n const tether = new Tether({\n element: '.element',\n target: '.target',\n attachment: 'top left',\n targetAttachment: 'top right',\n classPrefix: 'foo'\n });\n\n tether.enable();\n\n expect(element.classList.length, 'element - foo classes added').toEqual(12);\n expect(element).toHaveClass('foo-element');\n expect(element).not.toHaveClass('foo-target');\n\n expect(target.classList.length, 'target - foo classes added').toEqual(12);\n expect(target).toHaveClass('foo-target');\n expect(target).not.toHaveClass('foo-element');\n\n tether.destroy();\n\n expect(element.classList.length, 'element - destroy sets classes back to initial state').toEqual(1);\n expect(target.classList.length, 'target - destroy sets classes back to initial state').toEqual(1);\n });",15,1,6.666666666666667,1574.887715794558,0.02491238991952825,93.48056180914281,"    it('gets prefixed classes when classPrefix set', () => {\n      expect(element.classList.length, 'element - only one class').toEqual(1);\n      expect(target.classList.length, 'target - only one class').toEqual(1);\n      const tether = new Tether({\n      element: '.element',\n      target: '.target',\n      attachment: 'top left',\n      targetAttachment: 'top right',\n      classPrefix: 'foo'\n      });\n\n      tether.enable();\n\n      const elementClasses = Array.from(element.classList);\n      const targetClasses = Array.from(target.classList);\n\n      expect(elementClasses, 'element - foo classes added').toContain('foo-element');\n      expect(elementClasses, 'element - foo classes added').not.toContain('foo-target');\n\n      expect(targetClasses, 'target - foo classes added').toContain('foo-target');\n      expect(targetClasses, 'target - foo classes added').not.toContain('foo-element');\n\n      tether.destroy();\n\n      expect(element.classList.length, 'element - destroy sets classes back to initial state').toEqual(1);\n      expect(target.classList.length, 'target - destroy sets classes back to initial state').toEqual(1);\n    });",15,1,6.666666666666667,1427.9855882812615,0.024774805633986256,93.52375845802047
101,"it('removes classes on destroy', () => {\n expect(element.classList.length, 'element - only one class').toEqual(1);\n expect(target.classList.length, 'target - only one class').toEqual(1);\n const tether = new Tether({\n element: '.element',\n target: '.target',\n attachment: 'top left',\n targetAttachment: 'top right'\n });\n\n tether.enable();\n\n expect(element.classList.length, 'element - tether classes added').toEqual(12);\n expect(target.classList.length, 'target - tether classes added').toEqual(12);\n\n tether.destroy();\n\n expect(element.classList.length, 'element - destroy sets classes back to initial state').toEqual(1);\n expect(target.classList.length, 'target - destroy sets classes back to initial state').toEqual(1);\n });",11,1,9.090909090909092,997.3412480607199,0.01948968570001463,100,"    it('removes classes on destroy', () => {\n      const initialClassCount = 1; // Initial state with one class\n      const tetherClassCount = 12; // Total classes added by Tether\n\n      expect(element.classList.length, 'element - only one class').toEqual(initialClassCount);\n      expect(target.classList.length, 'target - only one class').toEqual(initialClassCount);\n      const tether = new Tether({\n      element: '.element',\n      target: '.target',\n      attachment: 'top left',\n      targetAttachment: 'top right'\n      });\n\n      tether.enable();\n\n      expect(element.classList.length, 'element - tether classes added').toEqual(tetherClassCount);\n      expect(target.classList.length, 'target - tether classes added').toEqual(tetherClassCount);\n\n      tether.destroy();\n\n      expect(element.classList.length, 'element - destroy sets classes back to initial state').toEqual(initialClassCount);\n      expect(target.classList.length, 'target - destroy sets classes back to initial state').toEqual(initialClassCount);\n    });",13,1,7.6923076923076925,1053.9300014996297,0.02032033288116001,97.38799292223283
102,"it('removes classes on destroy', () => {\n expect(element.classList.length, 'element - only one class').toEqual(1);\n expect(target.classList.length, 'target - only one class').toEqual(1);\n const tether = new Tether({\n element: '.element',\n target: '.target',\n attachment: 'top left',\n targetAttachment: 'top right'\n });\n\n tether.enable();\n\n expect(element.classList.length, 'element - tether classes added').toEqual(12);\n expect(target.classList.length, 'target - tether classes added').toEqual(12);\n\n tether.destroy();\n\n expect(element.classList.length, 'element - destroy sets classes back to initial state').toEqual(1);\n expect(target.classList.length, 'target - destroy sets classes back to initial state').toEqual(1);\n });",11,1,9.090909090909092,997.3412480607199,0.01948968570001463,100,"    it('removes classes on destroy', () => {\n      const initialClassCount = 1; // Initial state with one class\n      const tetherClassCount = 12; // Total classes after tether is enabled\n\n      expect(element.classList.length, 'element - only one class').toEqual(initialClassCount);\n      expect(target.classList.length, 'target - only one class').toEqual(initialClassCount);\n      const tether = new Tether({\n      element: '.element',\n      target: '.target',\n      attachment: 'top left',\n      targetAttachment: 'top right'\n      });\n\n      tether.enable();\n\n      expect(element.classList.length, 'element - tether classes added').toEqual(tetherClassCount);\n      expect(target.classList.length, 'target - tether classes added').toEqual(tetherClassCount);\n\n      tether.destroy();\n\n      expect(element.classList.length, 'element - destroy sets classes back to initial state').toEqual(initialClassCount);\n      expect(target.classList.length, 'target - destroy sets classes back to initial state').toEqual(initialClassCount);\n    });",13,1,7.6923076923076925,1053.9300014996297,0.02032033288116001,97.38799292223283
103,"it('removes classes on destroy', () => {\n expect(element.classList.length, 'element - only one class').toEqual(1);\n expect(target.classList.length, 'target - only one class').toEqual(1);\n const tether = new Tether({\n element: '.element',\n target: '.target',\n attachment: 'top left',\n targetAttachment: 'top right'\n });\n\n tether.enable();\n\n expect(element.classList.length, 'element - tether classes added').toEqual(12);\n expect(target.classList.length, 'target - tether classes added').toEqual(12);\n\n tether.destroy();\n\n expect(element.classList.length, 'element - destroy sets classes back to initial state').toEqual(1);\n expect(target.classList.length, 'target - destroy sets classes back to initial state').toEqual(1);\n });",11,1,9.090909090909092,997.3412480607199,0.01948968570001463,100,"    it('removes classes on destroy', () => {\n      const initialClassCount = 1;\n      const tetherClassCount = 12;\n\n      expect(element.classList.length, 'element - only one class').toEqual(initialClassCount);\n      expect(target.classList.length, 'target - only one class').toEqual(initialClassCount);\n      const tether = new Tether({\n      element: '.element',\n      target: '.target',\n      attachment: 'top left',\n      targetAttachment: 'top right'\n      });\n\n      tether.enable();\n\n      expect(element.classList.length, 'element - tether classes added').toEqual(tetherClassCount);\n      expect(target.classList.length, 'target - tether classes added').toEqual(tetherClassCount);\n\n      tether.destroy();\n\n      expect(element.classList.length, 'element - destroy sets classes back to initial state').toEqual(initialClassCount);\n      expect(target.classList.length, 'target - destroy sets classes back to initial state').toEqual(initialClassCount);\n    });",13,1,7.6923076923076925,1053.9300014996297,0.02032033288116001,97.38799292223283
104,"it('removes classes on destroy', () => {\n expect(element.classList.length, 'element - only one class').toEqual(1);\n expect(target.classList.length, 'target - only one class').toEqual(1);\n const tether = new Tether({\n element: '.element',\n target: '.target',\n attachment: 'top left',\n targetAttachment: 'top right'\n });\n\n tether.enable();\n\n expect(element.classList.length, 'element - tether classes added').toEqual(12);\n expect(target.classList.length, 'target - tether classes added').toEqual(12);\n\n tether.destroy();\n\n expect(element.classList.length, 'element - destroy sets classes back to initial state').toEqual(1);\n expect(target.classList.length, 'target - destroy sets classes back to initial state').toEqual(1);\n });",11,1,9.090909090909092,997.3412480607199,0.01948968570001463,100,"    it('removes classes on destroy', () => {\n      const initialClassCount = 1; // Initial state with only one class\n      const tetherClassCount = 12; // Total classes added by Tether\n\n      expect(element.classList.length, 'element - only one class').toEqual(initialClassCount);\n      expect(target.classList.length, 'target - only one class').toEqual(initialClassCount);\n      const tether = new Tether({\n      element: '.element',\n      target: '.target',\n      attachment: 'top left',\n      targetAttachment: 'top right'\n      });\n\n      tether.enable();\n\n      expect(element.classList.length, 'element - tether classes added').toEqual(tetherClassCount);\n      expect(target.classList.length, 'target - tether classes added').toEqual(tetherClassCount);\n\n      tether.destroy();\n\n      expect(element.classList.length, 'element - destroy sets classes back to initial state').toEqual(initialClassCount);\n      expect(target.classList.length, 'target - destroy sets classes back to initial state').toEqual(initialClassCount);\n    });",13,1,7.6923076923076925,1053.9300014996297,0.02032033288116001,97.38799292223283
105,"it('removes classes on destroy', () => {\n expect(element.classList.length, 'element - only one class').toEqual(1);\n expect(target.classList.length, 'target - only one class').toEqual(1);\n const tether = new Tether({\n element: '.element',\n target: '.target',\n attachment: 'top left',\n targetAttachment: 'top right'\n });\n\n tether.enable();\n\n expect(element.classList.length, 'element - tether classes added').toEqual(12);\n expect(target.classList.length, 'target - tether classes added').toEqual(12);\n\n tether.destroy();\n\n expect(element.classList.length, 'element - destroy sets classes back to initial state').toEqual(1);\n expect(target.classList.length, 'target - destroy sets classes back to initial state').toEqual(1);\n });",11,1,9.090909090909092,997.3412480607199,0.01948968570001463,100,"    it('removes classes on destroy', () => {\n      const initialClassCount = 1; // Initial state with only one class\n      const tetherClassCount = 12; // Total classes added by Tether\n\n      expect(element.classList.length, 'element - only one class').toEqual(initialClassCount);\n      expect(target.classList.length, 'target - only one class').toEqual(initialClassCount);\n      const tether = new Tether({\n      element: '.element',\n      target: '.target',\n      attachment: 'top left',\n      targetAttachment: 'top right'\n      });\n\n      tether.enable();\n\n      expect(element.classList.length, 'element - tether classes added').toEqual(tetherClassCount);\n      expect(target.classList.length, 'target - tether classes added').toEqual(tetherClassCount);\n\n      tether.destroy();\n\n      expect(element.classList.length, 'element - destroy sets classes back to initial state').toEqual(initialClassCount);\n      expect(target.classList.length, 'target - destroy sets classes back to initial state').toEqual(initialClassCount);\n    });",13,1,7.6923076923076925,1053.9300014996297,0.02032033288116001,97.38799292223283
106,"it('top left', () => {\n expect(attachmentToOffset({ left: 'left', top: 'top' })).toStrictEqual({ left: 0, top: 0 });\n });",3,1,33.33333333333333,97.16639677545534,0.005097069638023333,100,"    describe('top left attachment', () => {\n      it('returns 0% for top and left', () => {\n      expect(attachmentToOffset({ left: 'left', top: 'top' })).toStrictEqual({ left: 0, top: 0 });\n      });\n    });",5,1,20,112.92631877271641,0.0059431225621341555,100
107,"it('middle center', () => {\n expect(attachmentToOffset({ left: 'center', top: 'middle' })).toStrictEqual({ left: '50%', top: '50%' });\n });",3,1,33.33333333333333,83.88812251687506,0.0053626998907691775,100,"    describe('when attachment is middle center', () => {\n      it('returns 50% for both left and top', () => {\n      expect(attachmentToOffset({ left: 'center', top: 'middle' })).toStrictEqual({ left: '50%', top: '50%' });\n      });\n    });",5,1,20,99.94306670401213,0.006186435902304354,100
108,"it('bottom right', () => {\n expect(attachmentToOffset({ left: 'right', top: 'bottom' })).toStrictEqual({ left: '100%', top: '100%' });\n });",3,1,33.33333333333333,83.88812251687506,0.0053626998907691775,100,"    describe('bottom right attachment', () => {\n      it('calculates bottom right offset', () => {\n      expect(attachmentToOffset({ left: 'right', top: 'bottom' })).toStrictEqual({ left: '100%', top: '100%' });\n      });\n    });",5,1,20,99.94306670401213,0.006186435902304354,100
109,"it('mirror left', () => {\n expect(autoToFixedAttachment(\n { left: 'auto', top: 'top' },\n { left: 'left', top: 'top' }\n )).toStrictEqual({ left: 'right', top: 'top' });\n });",3,1,33.33333333333333,143.75860281892767,0.005986371980462904,100,"    describe('when mirroring left attachment', () => {\n      it('mirrors to right', () => {\n      expect(autoToFixedAttachment(\n        { left: 'auto', top: 'top' },\n        { left: 'left', top: 'top' }\n      )).toStrictEqual({ left: 'right', top: 'top' });\n      });\n    });",5,1,20,159.79171510154717,0.006818271755542721,100
110,"it('mirror center', () => {\n expect(autoToFixedAttachment(\n { left: 'auto', top: 'top' },\n { left: 'center', top: 'top' }\n )).toStrictEqual({ left: 'center', top: 'top' });\n });",3,1,33.33333333333333,143.75860281892767,0.005986371980462904,100,"    describe('when left is auto and top is top', () => {\n      it('returns center for left and top remains top', () => {\n      expect(autoToFixedAttachment(\n        { left: 'auto', top: 'top' },\n        { left: 'center', top: 'top' }\n      )).toStrictEqual({ left: 'center', top: 'top' });\n      });\n    });",5,1,20,159.79171510154717,0.006818271755542721,100
111,"it(""scriptFromCodepoint() should return correct values"", () => {\n outer: for (let codepoint = 0; codepoint <= 0xffff; codepoint++) {\n const character = String.fromCharCode(codepoint);\n const script = scriptFromCodepoint(codepoint);\n\n for (const scriptName of scriptNames) {\n if (scriptRegExps[scriptName].test(character)) {\n expect(script).toEqual(scriptName);\n continue outer;\n }\n }\n\n expect(script).toBe(null);\n expect(supportedCodepoint(codepoint)).toBe(false);\n }\n });",16,4,25,817.0981385888247,0.012701879927583678,97.37038908027709,"    describe(""scriptFromCodepoint() should return correct values"", () => {\n        scriptNames.forEach(scriptName => {\n            it(`should return '${scriptName}' for codepoints in the ${scriptName} script`, () => {\n                for (let codepoint = 0; codepoint <= 0xffff; codepoint++) {\n                    const character = String.fromCharCode(codepoint);\n                    if (scriptRegExps[scriptName].test(character)) {\n                        expect(scriptFromCodepoint(codepoint)).toEqual(scriptName);\n                    }\n                }\n            });\n        });\n\n        it(""should return null for unsupported codepoints"", () => {\n            for (let codepoint = 0; codepoint <= 0xffff; codepoint++) {\n                const character = String.fromCharCode(codepoint);\n                const isSupported = scriptNames.some(scriptName =>\n                    scriptRegExps[scriptName].test(character)\n                );\n\n                if (!isSupported) {\n                    expect(scriptFromCodepoint(codepoint)).toBe(null);\n                    expect(supportedCodepoint(codepoint)).toBe(false);\n                }\n            }\n        });\n    });",24,5,20.833333333333336,2567.639251168273,0.01864778947449702,87.7555060015111
112,"it(""scriptFromCodepoint() should return correct values"", () => {\n outer: for (let codepoint = 0; codepoint <= 0xffff; codepoint++) {\n const character = String.fromCharCode(codepoint);\n const script = scriptFromCodepoint(codepoint);\n\n for (const scriptName of scriptNames) {\n if (scriptRegExps[scriptName].test(character)) {\n expect(script).toEqual(scriptName);\n continue outer;\n }\n }\n\n expect(script).toBe(null);\n expect(supportedCodepoint(codepoint)).toBe(false);\n }\n });",16,4,25,817.0981385888247,0.012701879927583678,97.37038908027709,"    it(""scriptFromCodepoint() should return correct values"", () => {\n        outer: for (let codepoint = 0; codepoint <= 0xffff; codepoint++) {\n            const character = String.fromCharCode(codepoint);\n            const script = scriptFromCodepoint(codepoint);\n\n            for (const scriptName of scriptNames) {\n                if (scriptRegExps[scriptName].test(character)) {\n                    expect(script).toBe(scriptName); // Use toBe for strict equality\n                    continue outer;\n                }\n            }\n\n            expect(script).toBeNull(); // Use toBeNull for clarity\n            expect(supportedCodepoint(codepoint)).toBe(false); // Explicitly check for false\n        }\n    });",16,4,25,817.0981385888247,0.012701879927583678,97.37038908027709
113,"it(""should build some surrogate pairs"", function() {\n let wideCharStr = """";\n wideCharStr += String.fromCharCode(0xD835, 0xDC00); // bold A\n wideCharStr += String.fromCharCode(0xD835, 0xDC68); // bold italic A\n wideCharStr += String.fromCharCode(0xD835, 0xDD04); // Fraktur A\n wideCharStr += String.fromCharCode(0xD835, 0xDD6C); // bold Fraktur A\n wideCharStr += String.fromCharCode(0xD835, 0xDD38); // double-struck\n wideCharStr += String.fromCharCode(0xD835, 0xDC9C); // script A\n wideCharStr += String.fromCharCode(0xD835, 0xDDA0); // sans serif A\n wideCharStr += String.fromCharCode(0xD835, 0xDDD4); // bold sans A\n wideCharStr += String.fromCharCode(0xD835, 0xDE08); // italic sans A\n wideCharStr += String.fromCharCode(0xD835, 0xDE70); // monospace A\n wideCharStr += String.fromCharCode(0xD835, 0xDFCE); // bold zero\n wideCharStr += String.fromCharCode(0xD835, 0xDFE2); // sans serif zero\n wideCharStr += String.fromCharCode(0xD835, 0xDFEC); // bold sans zero\n wideCharStr += String.fromCharCode(0xD835, 0xDFF6); // monospace zero\n expect(wideCharStr).toBuild(strictSettings);\n\n let wideCharText = ""\text{"";\n wideCharText += String.fromCharCode(0xD835, 0xDC00); // bold A\n wideCharText += String.fromCharCode(0xD835, 0xDC68); // bold italic A\n wideCharText += String.fromCharCode(0xD835, 0xDD04); // Fraktur A\n wideCharStr += String.fromCharCode(0xD835, 0xDD6C); // bold Fraktur A\n wideCharText += String.fromCharCode(0xD835, 0xDD38); // double-struck\n wideCharText += String.fromCharCode(0xD835, 0xDC9C); // script A\n wideCharText += String.fromCharCode(0xD835, 0xDDA0); // sans serif A\n wideCharText += String.fromCharCode(0xD835, 0xDDD4); // bold sans A\n wideCharText += String.fromCharCode(0xD835, 0xDE08); // italic sans A\n wideCharText += String.fromCharCode(0xD835, 0xDE70); // monospace A\n wideCharText += String.fromCharCode(0xD835, 0xDFCE); // bold zero\n wideCharText += String.fromCharCode(0xD835, 0xDFE2); // sans serif zero\n wideCharText += String.fromCharCode(0xD835, 0xDFEC); // bold sans zero\n wideCharText += String.fromCharCode(0xD835, 0xDFF6); // monospace zero\n wideCharText += ""}"";\n expect(wideCharText).toBuild(strictSettings);\n });",35,1,2.857142857142857,10546.543520161242,0.03799421265710983,76.46220152514091,"    it(""should build some surrogate pairs"", function() {\n        const wideCharStr = [\n            0xD835, 0xDC00,  // bold A\n            0xD835, 0xDC68,  // bold italic A\n            0xD835, 0xDD04,  // Fraktur A\n            0xD835, 0xDD6C,  // bold Fraktur A\n            0xD835, 0xDD38,  // double-struck\n            0xD835, 0xDC9C,  // script A\n            0xD835, 0xDDA0,  // sans serif A\n            0xD835, 0xDDD4,  // bold sans A\n            0xD835, 0xDE08,  // italic sans A\n            0xD835, 0xDE70,  // monospace A\n            0xD835, 0xDFCE,  // bold zero\n            0xD835, 0xDFE2,  // sans serif zero\n            0xD835, 0xDFEC,  // bold sans zero\n            0xD835, 0xDFF6   // monospace zero\n        ].map(code => String.fromCharCode(code)).join("""");\n        expect(wideCharStr).toBuild(strictSettings);\n\n        const wideCharText = `\\text{${wideCharStr}}`;\n        expect(wideCharText).toBuild(strictSettings);\n    });",6,1,16.666666666666664,513.1205594264908,0.014915445124972988,100
114,"it(""should build a list of rels"", function() {\n const parse = getParsed(expression);\n\n for (let i = 0; i < parse.length; i++) {\n let group = parse[i];\n if (group.type === ""htmlmathml"") {\n expect(group.html).toHaveLength(1);\n group = group.html[0];\n }\n if (group.type === ""mclass"") {\n expect(group.mclass).toEqual(""mrel"");\n } else {\n expect(group.type).toEqual(""atom"");\n expect(group.family).toEqual(""rel"");\n }\n }\n });",17,4,23.52941176470588,2181.814093849866,0.016463448754722304,94.36500723755444,"    it(""should build a list of rels"", function() {\n        const parse = getParsed(expression);\n\n        const validateGroup = (group) => {\n            if (group.type === ""htmlmathml"") {\n                expect(group.html).toHaveLength(1);\n                group = group.html[0];\n            }\n            if (group.type === ""mclass"") {\n                expect(group.mclass).toEqual(""mrel"");\n            } else {\n                expect(group.type).toEqual(""atom"");\n                expect(group.family).toEqual(""rel"");\n            }\n        };\n\n        parse.forEach(validateGroup);\n    });",16,3,18.75,1185.289008437739,0.015305509402358204,95.98214575085153
115,"it(""should build a list of rels"", function() {\n const parse = getParsed(expression);\n\n for (let i = 0; i < parse.length; i++) {\n let group = parse[i];\n if (group.type === ""htmlmathml"") {\n expect(group.html).toHaveLength(1);\n group = group.html[0];\n }\n if (group.type === ""mclass"") {\n expect(group.mclass).toEqual(""mrel"");\n } else {\n expect(group.type).toEqual(""atom"");\n expect(group.family).toEqual(""rel"");\n }\n }\n });",17,4,23.52941176470588,2181.814093849866,0.016463448754722304,94.36500723755444,"    it(""should build a list of rels"", function() {\n        const parse = getParsed(expression);\n\n        const flattenedGroups = parse.flatMap(group => \n            group.type === ""htmlmathml"" ? group.html : [group]\n        );\n\n        flattenedGroups.forEach(group => {\n            if (group.type === ""mclass"") {\n                expect(group.mclass).toEqual(""mrel"");\n            } else {\n                expect(group.type).toEqual(""atom"");\n                expect(group.family).toEqual(""rel"");\n            }\n        });\n    });",12,3,25,747.7762703672856,0.013686731857902095,100
116,"it(""should parse comments before and between \\hline"", () => {\n expect(""\\begin{matrix}a&b\\\\ %hline\n"" +\n ""\\hline %hline\n"" +\n ""\\hline c&d\\end{matrix}"").toParse();\n });",3,1,33.33333333333333,64.77759785030356,0.004102996362278855,100,"    it(""should parse comments before and between \\hline"", () => {\n        const parsed = getParsed(""\\begin{matrix}a&b\\\\ %hline\n"" +\n            ""\\hline %hline\n"" +\n            ""\\hline c&d\\end{matrix}"");\n        expect(parsed[0].type).toBe(""array"");\n        expect(parsed[0].body).toHaveLength(3); // 3 rows: a&b, hline, c&d\n    });",5,1,20,261.454297590433,0.008884647488325967,100
117,"it(""should render wide characters with mord and with the correct font"", function() {\n const markup = katex.renderToString(String.fromCharCode(0xD835, 0xDC00));\n expect(markup).toContain(""<span class=\""mord mathbf\"">A</span>"");\n\n expect(String.fromCharCode(0xD835, 0xDC00) +\n "" = "" + String.fromCharCode(0xD835, 0xDC1A))\n .toBuildLike`\mathbf A = \mathbf a`;\n });",5,1,20,400.312800138462,0.010100376640899413,100,"    it(""should render wide characters with mord and with the correct font"", function() {\n        const markup = katex.renderToString(String.fromCharCode(0xD835, 0xDC00));\n        expect(markup).toMatch(/<span class=""mord mathbf"">A<\/span>/);\n\n        const wideChar = String.fromCharCode(0xD835, 0xDC00);\n        const wideCharLower = String.fromCharCode(0xD835, 0xDC1A);\n        expect(`${wideChar} = ${wideCharLower}`)\n            .toBuildLike`\mathbf A = \mathbf a`;\n    });",7,1,14.285714285714285,283.39742366002355,0.00996677416688531,100
118,"it(""should contain affected position and length information"", function() {\n try {\n katex.renderToString(""1 + \\fraq{}{}"");\n\n // Render is expected to throw, so this should not be called.\n expect(true).toBe(false);\n } catch (error) {\n expect(error).toBeInstanceOf(ParseError);\n expect(error.message).toBe(""KaTeX parse error: Undefined control sequence: \\fraq at position 5: 1 + \\Ì²fÌ²rÌ²aÌ²qÌ²{}{}"");\n expect(error.rawMessage).toBe(""Undefined control sequence: \\fraq"");\n expect(error.position).toBe(4);\n expect(error.length).toBe(5);\n }\n });",12,2,16.666666666666664,437.9553802819194,0.01309926738524326,100,"    it(""should contain affected position and length information"", function() {\n        try {\n            katex.renderToString(""1 + \\fraq{}{}"");\n\n            // Render is expected to throw, so this should not be called.\n            fail(""Expected a ParseError to be thrown, but none was thrown."");\n        } catch (error) {\n            expect(error).toBeInstanceOf(ParseError);\n            expect(error).toMatchObject({\n                message: ""KaTeX parse error: Undefined control sequence: \\fraq at position 5: 1 + \\Ì²fÌ²rÌ²aÌ²qÌ²{}{}"",\n                rawMessage: ""Undefined control sequence: \\fraq"",\n                position: 4,\n                length: 5,\n            });\n        }\n    });",9,2,22.22222222222222,169.23542992728542,0.00929125496166311,100
119,"it(""should contain position and length information at end of input"", function() {\n try {\n katex.renderToString(""\\frac{}"");\n\n // Render is expected to throw, so this should not be called.\n expect(true).toBe(false);\n } catch (error) {\n expect(error).toBeInstanceOf(ParseError);\n expect(error.message).toBe(""KaTeX parse error: Unexpected end of input in a macro argument, expected '}' at end of input: \\frac{}"");\n expect(error.rawMessage).toBe(""Unexpected end of input in a macro argument, expected '}'"");\n expect(error.position).toBe(7);\n expect(error.length).toBe(0);\n }\n });",12,2,16.666666666666664,437.9553802819194,0.01309926738524326,100,"    it(""should contain position and length information at end of input"", function() {\n        try {\n            katex.renderToString(""\\frac{}"");\n\n            // Render is expected to throw, so this should not be called.\n            fail(""Expected ParseError was not thrown"");\n        } catch (error) {\n            expect(error).toBeInstanceOf(ParseError);\n            expect(error).toMatchObject({\n                message: ""KaTeX parse error: Unexpected end of input in a macro argument, expected '}' at end of input: \\frac{}"",\n                rawMessage: ""Unexpected end of input in a macro argument, expected '}'"",\n                position: 7,\n                length: 0,\n            });\n        }\n    });",9,2,22.22222222222222,169.23542992728542,0.00929125496166311,100
120,"it(""scriptFromCodepoint() should return correct values"", () => {\n outer: for (let codepoint = 0; codepoint <= 0xffff; codepoint++) {\n const character = String.fromCharCode(codepoint);\n const script = scriptFromCodepoint(codepoint);\n\n for (const scriptName of scriptNames) {\n if (scriptRegExps[scriptName].test(character)) {\n expect(script).toEqual(scriptName);\n continue outer;\n }\n }\n\n expect(script).toBe(null);\n expect(supportedCodepoint(codepoint)).toBe(false);\n }\n });",16,4,25,817.0981385888247,0.012701879927583678,97.37038908027709,"    it(""scriptFromCodepoint() should return correct values"", () => {\n        outer: for (let codepoint = 0; codepoint <= 0xffff; codepoint++) {\n            const character = String.fromCharCode(codepoint);\n            const script = scriptFromCodepoint(codepoint);\n            const isSupported = supportedCodepoint(codepoint);\n\n            for (const scriptName of scriptNames) {\n                if (scriptRegExps[scriptName].test(character)) {\n                    expect(script).toEqual(scriptName);\n                    expect(isSupported).toBe(true);\n                    continue outer;\n                }\n            }\n\n            expect(script).toBe(null);\n            expect(isSupported).toBe(false);\n        }\n    });",18,4,22.22222222222222,1045.3714501644235,0.014099491094424542,94.64807207513094
121,"it(""scriptFromCodepoint() should return correct values"", () => {\n outer: for (let codepoint = 0; codepoint <= 0xffff; codepoint++) {\n const character = String.fromCharCode(codepoint);\n const script = scriptFromCodepoint(codepoint);\n\n for (const scriptName of scriptNames) {\n if (scriptRegExps[scriptName].test(character)) {\n expect(script).toEqual(scriptName);\n continue outer;\n }\n }\n\n expect(script).toBe(null);\n expect(supportedCodepoint(codepoint)).toBe(false);\n }\n });",16,4,25,817.0981385888247,0.012701879927583678,97.37038908027709,"    it(""scriptFromCodepoint() should return correct values"", () => {\n        outer: for (let codepoint = 0; codepoint <= 0xffff; codepoint++) {\n            const character = String.fromCharCode(codepoint);\n            const script = scriptFromCodepoint(codepoint);\n            const isSupported = supportedCodepoint(codepoint);\n\n            for (const scriptName of scriptNames) {\n                if (scriptRegExps[scriptName].test(character)) {\n                    expect(script).toEqual(scriptName);\n                    expect(isSupported).toBe(true);\n                    continue outer;\n                }\n            }\n\n            expect(script).toBe(null);\n            expect(isSupported).toBe(false);\n        }\n    });",18,4,22.22222222222222,1045.3714501644235,0.014099491094424542,94.64807207513094
122,"it(""supportedCodepoint() should return the correct values"", () => {\n for (let codepoint = 0; codepoint <= 0xffff; codepoint++) {\n expect(supportedCodepoint(codepoint)).toBe(\n allRegExp.test(String.fromCharCode(codepoint))\n );\n }\n });",6,2,33.33333333333333,288,0.007559526299369237,100,"    describe(""supportedCodepoint()"", () => {\n        it(""should return true for supported codepoints"", () => {\n            for (let codepoint = 0; codepoint <= 0xffff; codepoint++) {\n                if (allRegExp.test(String.fromCharCode(codepoint))) {\n                    expect(supportedCodepoint(codepoint)).toBe(true);\n                }\n            }\n        });\n\n        it(""should return false for unsupported codepoints"", () => {\n            for (let codepoint = 0; codepoint <= 0xffff; codepoint++) {\n                if (!allRegExp.test(String.fromCharCode(codepoint))) {\n                    expect(supportedCodepoint(codepoint)).toBe(false);\n                }\n            }\n        });\n    });\n",18,5,27.77777777777778,1420.4737005196464,0.013252030672535085,95.0802547184585
123,"it(""scriptFromCodepoint() should return correct values"", () => {\n outer: for (let codepoint = 0; codepoint <= 0xffff; codepoint++) {\n const character = String.fromCharCode(codepoint);\n const script = scriptFromCodepoint(codepoint);\n\n for (const scriptName of scriptNames) {\n if (scriptRegExps[scriptName].test(character)) {\n expect(script).toEqual(scriptName);\n continue outer;\n }\n }\n\n expect(script).toBe(null);\n expect(supportedCodepoint(codepoint)).toBe(false);\n }\n });",16,4,25,817.0981385888247,0.012701879927583678,97.37038908027709,"    describe(""scriptFromCodepoint()"", () => {\n        it(""should return the correct script name for supported codepoints"", () => {\n            for (let codepoint = 0; codepoint <= 0xffff; codepoint++) {\n                const character = String.fromCharCode(codepoint);\n                const script = scriptFromCodepoint(codepoint);\n\n                for (const scriptName of scriptNames) {\n                    if (scriptRegExps[scriptName].test(character)) {\n                        expect(script).toEqual(scriptName);\n                        return;\n                    }\n                }\n            }\n        });\n\n        it(""should return null for unsupported codepoints"", () => {\n            for (let codepoint = 0; codepoint <= 0xffff; codepoint++) {\n                const character = String.fromCharCode(codepoint);\n                const script = scriptFromCodepoint(codepoint);\n\n                let isSupported = false;\n                for (const scriptName of scriptNames) {\n                    if (scriptRegExps[scriptName].test(character)) {\n                        isSupported = true;\n                        break;\n                    }\n                }\n\n                if (!isSupported) {\n                    expect(script).toBe(null);\n                    expect(supportedCodepoint(codepoint)).toBe(false);\n                }\n            }\n        });\n    });",35,8,22.857142857142858,3193.8317973088156,0.018642137414420654,81.53760312512834
124,"it(""should produce a frac"", function() {\n let parse;\n\n parse = getParsed(simpleOver)[0];\n\n expect(parse.type).toEqual(""genfrac"");\n expect(parse.numer).toBeDefined();\n expect(parse.denom).toBeDefined();\n\n parse = getParsed(complexOver)[0];\n\n expect(parse.type).toEqual(""genfrac"");\n expect(parse.numer).toBeDefined();\n expect(parse.denom).toBeDefined();\n\n const parseBraceFrac = getParsed(braceFrac)[0];\n\n expect(parseBraceFrac.type).toEqual(""genfrac"");\n expect(parseBraceFrac.numer).toBeDefined();\n expect(parseBraceFrac.denom).toBeDefined();\n expect(parseBraceFrac.leftDelim).toBeDefined();\n expect(parseBraceFrac.rightDelim).toBeDefined();\n\n const parseBrackFrac = getParsed(brackFrac)[0];\n\n expect(parseBrackFrac.type).toEqual(""genfrac"");\n expect(parseBrackFrac.numer).toBeDefined();\n expect(parseBrackFrac.denom).toBeDefined();\n expect(parseBrackFrac.leftDelim).toBeDefined();\n expect(parseBrackFrac.rightDelim).toBeDefined();\n });",23,1,4.3478260869565215,4781.631165650066,0.02709416576826131,85.90113417898192,"    it(""should produce a frac"", function() {\n        const testGenfrac = (expression) => {\n            const parse = getParsed(expression)[0];\n            expect(parse.type).toEqual(""genfrac"");\n            expect(parse.numer).toBeDefined();\n            expect(parse.denom).toBeDefined();\n        };\n\n        testGenfrac(simpleOver);\n        testGenfrac(complexOver);\n\n        const testGenfracWithDelims = (expression) => {\n            const parse = getParsed(expression)[0];\n            expect(parse.type).toEqual(""genfrac"");\n            expect(parse.numer).toBeDefined();\n            expect(parse.denom).toBeDefined();\n            expect(parse.leftDelim).toBeDefined();\n            expect(parse.rightDelim).toBeDefined();\n        };\n\n        testGenfracWithDelims(braceFrac);\n        testGenfracWithDelims(brackFrac);\n    });\n",20,1,5,1170.094692633414,0.019247763039704914,90.83228150045029
125,"it(""should produce a frac"", function() {\n let parse;\n\n parse = getParsed(simpleOver)[0];\n\n expect(parse.type).toEqual(""genfrac"");\n expect(parse.numer).toBeDefined();\n expect(parse.denom).toBeDefined();\n\n parse = getParsed(complexOver)[0];\n\n expect(parse.type).toEqual(""genfrac"");\n expect(parse.numer).toBeDefined();\n expect(parse.denom).toBeDefined();\n\n const parseBraceFrac = getParsed(braceFrac)[0];\n\n expect(parseBraceFrac.type).toEqual(""genfrac"");\n expect(parseBraceFrac.numer).toBeDefined();\n expect(parseBraceFrac.denom).toBeDefined();\n expect(parseBraceFrac.leftDelim).toBeDefined();\n expect(parseBraceFrac.rightDelim).toBeDefined();\n\n const parseBrackFrac = getParsed(brackFrac)[0];\n\n expect(parseBrackFrac.type).toEqual(""genfrac"");\n expect(parseBrackFrac.numer).toBeDefined();\n expect(parseBrackFrac.denom).toBeDefined();\n expect(parseBrackFrac.leftDelim).toBeDefined();\n expect(parseBrackFrac.rightDelim).toBeDefined();\n });",23,1,4.3478260869565215,4781.631165650066,0.02709416576826131,85.90113417898192,"    it(""should produce a frac"", function() {\n        const testGenfrac = (parsedFrac) => {\n            expect(parsedFrac.type).toEqual(""genfrac"");\n            expect(parsedFrac.numer).toBeDefined();\n            expect(parsedFrac.denom).toBeDefined();\n        };\n\n        testGenfrac(getParsed(simpleOver)[0]);\n        testGenfrac(getParsed(complexOver)[0]);\n\n        const parseBraceFrac = getParsed(braceFrac)[0];\n        testGenfrac(parseBraceFrac);\n        expect(parseBraceFrac.leftDelim).toBeDefined();\n        expect(parseBraceFrac.rightDelim).toBeDefined();\n\n        const parseBrackFrac = getParsed(brackFrac)[0];\n        testGenfrac(parseBrackFrac);\n        expect(parseBrackFrac.leftDelim).toBeDefined();\n        expect(parseBrackFrac.rightDelim).toBeDefined();\n    });",17,1,5.88235294117647,1073.161222146478,0.018848827633103037,93.62845237872781
126,"it(""should build a list of ords"", function() {\n const parse = getParsed(expression);\n\n for (let i = 0; i < parse.length; i++) {\n const group = parse[i];\n expect(group.type).toMatch(""ord"");\n }\n });",8,2,25,346.49108085060567,0.008043528820279,100,"    it(""should build a list of ords with correct type"", function() {\n        const parse = getParsed(expression);\n\n        parse.forEach((group) => {\n            expect(group.type).toMatch(""ord"");\n        });\n    });\n\n    it(""should build a list of ords with correct length"", function() {\n        const parse = getParsed(expression);\n\n        expect(parse).toHaveLength(expression.length);\n    });",10,1,10,243.14285714285714,0.009326525647961437,100
127,"it(""should parse the right number of ords"", function() {\n const parse = getParsed(expression);\n\n expect(parse).toHaveLength(expression.length);\n });",4,1,25,66.43856189774725,0.0047121475995650485,100,"    it(""should parse each character as an ord"", function() {\n        const parse = getParsed(expression);\n\n        for (let i = 0; i < expression.length; i++) {\n            expect(parse[i].type).toBe(""ord"");\n        }\n    });\n\n    it(""should parse the correct number of ords"", function() {\n        const parse = getParsed(expression);\n\n        expect(parse).toHaveLength(expression.length);\n    });",11,2,18.181818181818183,691.6118466677892,0.010599284392700244,100
128,"it(""should build a list of bins"", function() {\n const parse = getParsed(expression);\n\n for (let i = 0; i < parse.length; i++) {\n const group = parse[i];\n expect(group.type).toEqual(""atom"");\n expect(group.family).toEqual(""bin"");\n }\n });",9,2,22.22222222222222,516.54798563474,0.00988217501962691,100,"    it(""should parse without failing"", function() {\n        const parse = getParsed(expression);\n        expect(parse).toBeDefined();\n    });\n\n    it(""should build a list of bins with correct type"", function() {\n        const parse = getParsed(expression);\n\n        for (let i = 0; i < parse.length; i++) {\n            const group = parse[i];\n            expect(group.type).toEqual(""atom"");\n        }\n    });\n\n    it(""should build a list of bins with correct family"", function() {\n        const parse = getParsed(expression);\n\n        for (let i = 0; i < parse.length; i++) {\n            const group = parse[i];\n            expect(group.family).toEqual(""bin"");\n        }\n    });",20,3,15,1618.278185163268,0.01548474235285276,92.27641012707109
129,"it(""should build a list of rels"", function() {\n const parse = getParsed(expression);\n\n for (let i = 0; i < parse.length; i++) {\n let group = parse[i];\n if (group.type === ""htmlmathml"") {\n expect(group.html).toHaveLength(1);\n group = group.html[0];\n }\n if (group.type === ""mclass"") {\n expect(group.mclass).toEqual(""mrel"");\n } else {\n expect(group.type).toEqual(""atom"");\n expect(group.family).toEqual(""rel"");\n }\n }\n });",17,4,23.52941176470588,2181.814093849866,0.016463448754722304,94.36500723755444,"    it(""should build a list of rels"", function() {\n        const parse = getParsed(expression);\n        const expectedHtmlLength = 1; // Magic number replaced with a named constant for clarity\n\n        for (let i = 0; i < parse.length; i++) {\n            let group = parse[i];\n            if (group.type === ""htmlmathml"") {\n                expect(group.html).toHaveLength(expectedHtmlLength);\n                group = group.html[0];\n            }\n            if (group.type === ""mclass"") {\n                expect(group.mclass).toEqual(""mrel"");\n            } else {\n                expect(group.type).toEqual(""atom"");\n                expect(group.family).toEqual(""rel"");\n            }\n        }\n    });",18,4,22.22222222222222,2261.6419746952815,0.0168858805237494,93.2414271214828
130,"it(""should return one group, not a fragment"", function() {\n const contents = ""\\mathinner{\\langle{\\psi}\\rangle}"";\n const mml = buildMathML(getParsed(contents), contents, defaultOptions);\n expect(mml.children.length).toEqual(1);\n });",5,1,20,115.40353759335932,0.006879767152454626,100,"    it(""should return one group, not a fragment"", function() {\n        const contents = ""\\mathinner{\\langle{\\psi}\\rangle}"";\n        const expectedChildCount = 1; // Number of expected children in the MathML\n        const mml = buildMathML(getParsed(contents), contents, defaultOptions);\n        expect(mml.children.length).toEqual(expectedChildCount);\n    });",6,1,16.666666666666664,133.71428571428572,0.007371699751571828,100
131,"it(""should produce a single ord"", function() {\n const parse = getParsed`{xy}`;\n\n expect(parse).toHaveLength(1);\n\n const ord = parse[0];\n\n expect(ord.type).toMatch(""ord"");\n expect(ord.body).toBeTruthy();\n });",7,1,14.285714285714285,198.34983023858635,0.008506982481307674,100,"    it(""should produce a single ord"", function() {\n        const parse = getParsed`{xy}`;\n\n        const expectedLength = 1; // Clarifies the expected number of elements\n        expect(parse).toHaveLength(expectedLength);\n\n        const ord = parse[0];\n\n        expect(ord.type).toMatch(""ord"");\n        expect(ord.body).toBeTruthy();\n    });",8,1,12.5,220,0.0089873316659195,100
132,"it(""should produce a semi-simple group"", function() {\n const parse = getParsed`\begingroup xy \endgroup`;\n\n expect(parse).toHaveLength(1);\n\n const ord = parse[0];\n\n expect(ord.type).toMatch(""ord"");\n expect(ord.body).toBeTruthy();\n expect(ord.semisimple).toBeTruthy();\n });",8,1,12.5,281.1428571428571,0.00998714397316727,100,"    it(""should produce a semi-simple group"", function() {\n        const parse = getParsed`\begingroup xy \endgroup`;\n\n        expect(parse).toHaveLength(1);\n\n        const ord = parse[0];\n\n        const expectedType = ""ord""; // Refactored to eliminate magic number\n        expect(ord.type).toMatch(expectedType);\n        expect(ord.body).toBeTruthy();\n        expect(ord.semisimple).toBeTruthy();\n    });",9,1,11.11111111111111,304.6522304345253,0.010459082629143265,100
133,"it(""should produce a single object"", function() {\n const parse = getParsed`\Large abc`;\n\n expect(parse).toHaveLength(1);\n\n const sizing = parse[0];\n\n expect(sizing.type).toEqual(""sizing"");\n expect(sizing.body).toBeTruthy();\n expect(sizing.size).toBeDefined();\n });",8,1,12.5,268.13756238602224,0.01013220251266821,100,"    it(""should produce a single object"", function() {\n        const parse = getParsed`\Large abc`;\n\n        const expectedLength = 1; // Define a constant for clarity\n        expect(parse).toHaveLength(expectedLength);\n\n        const sizing = parse[0];\n\n        expect(sizing.type).toEqual(""sizing"");\n        expect(sizing.body).toBeTruthy();\n        expect(sizing.size).toBeDefined();\n    });",9,1,11.11111111111111,291.3735094757816,0.010599284392700244,100
134,"    test('custom logger', async () => {\n      app = express()\n      router = express.Router()\n      app.use('/', router)\n      router.get('/users', (req, res) => {\n        res.json({})\n      })\n      const event = makeEvent({\n        eventSourceName,\n        path: '/users',\n        httpMethod: 'GET'\n      })\n      const customLogger = {\n        error: jest.fn(),\n        warn: jest.fn(),\n        info: jest.fn(),\n        verbose: jest.fn(),\n        debug: jest.fn()\n      }\n      serverlessExpressInstance = serverlessExpress({ app, log: customLogger })\n      await serverlessExpressInstance(event)\n\n      expect(customLogger.debug.mock.calls.length).toBe(6)\n\n      // TODO: test log levels\n      // customLogger.level = 'error'\n      // customLogger.debug.mockClear()\n      // customLogger.debug.mockReset()\n      // customLogger.debug = jest.fn()\n\n      // serverlessExpressInstance = serverlessExpress({ app, log: customLogger })\n      // await serverlessExpressInstance(event)\n      // expect(customLogger.debug.mock.calls.length).toBe(0)\n    })",13,1,7.6923076923076925,1162.3480379647897,0.02046248474371267,97.33361761994476,"    test('custom logger', async () => {\n      app = express()\n      router = express.Router()\n      app.use('/', router)\n      router.get('/users', (req, res) => {\n      res.json({})\n      })\n      const event = makeEvent({\n      eventSourceName,\n      path: '/users',\n      httpMethod: 'GET'\n      })\n      const customLogger = {\n      error: jest.fn(),\n      warn: jest.fn(),\n      info: jest.fn(),\n      verbose: jest.fn(),\n      debug: jest.fn()\n      }\n      serverlessExpressInstance = serverlessExpress({ app, log: customLogger })\n      await serverlessExpressInstance(event)\n\n      expect(customLogger.debug).toHaveBeenCalledTimes(6)\n    })",13,1,7.6923076923076925,1098.6090628064912,0.01926700415607841,97.80317132936725
135,"    test('custom logger', async () => {\n      app = express()\n      router = express.Router()\n      app.use('/', router)\n      router.get('/users', (req, res) => {\n        res.json({})\n      })\n      const event = makeEvent({\n        eventSourceName,\n        path: '/users',\n        httpMethod: 'GET'\n      })\n      const customLogger = {\n        error: jest.fn(),\n        warn: jest.fn(),\n        info: jest.fn(),\n        verbose: jest.fn(),\n        debug: jest.fn()\n      }\n      serverlessExpressInstance = serverlessExpress({ app, log: customLogger })\n      await serverlessExpressInstance(event)\n\n      expect(customLogger.debug.mock.calls.length).toBe(6)\n\n      // TODO: test log levels\n      // customLogger.level = 'error'\n      // customLogger.debug.mockClear()\n      // customLogger.debug.mockReset()\n      // customLogger.debug = jest.fn()\n\n      // serverlessExpressInstance = serverlessExpress({ app, log: customLogger })\n      // await serverlessExpressInstance(event)\n      // expect(customLogger.debug.mock.calls.length).toBe(0)\n    })",13,1,7.6923076923076925,1162.3480379647897,0.02046248474371267,97.33361761994476,"    test('custom logger', async () => {\n      app = express()\n      router = express.Router()\n      app.use('/', router)\n      router.get('/users', (req, res) => {\n      res.json({})\n      })\n      const event = makeEvent({\n      eventSourceName,\n      path: '/users',\n      httpMethod: 'GET'\n      })\n      const customLogger = {\n      error: jest.fn(),\n      warn: jest.fn(),\n      info: jest.fn(),\n      verbose: jest.fn(),\n      debug: jest.fn()\n      }\n      serverlessExpressInstance = serverlessExpress({ app, log: customLogger })\n      await serverlessExpressInstance(event)\n\n      expect(customLogger.debug).toHaveBeenCalledTimes(6)\n\n      // TODO: test log levels\n      // customLogger.level = 'error'\n      // customLogger.debug.mockClear()\n      // customLogger.debug.mockReset()\n      // customLogger.debug = jest.fn()\n\n      // serverlessExpressInstance = serverlessExpress({ app, log: customLogger })\n      // await serverlessExpressInstance(event)\n      // expect(customLogger.debug).not.toHaveBeenCalled()\n    })",13,1,7.6923076923076925,1098.6090628064912,0.01926700415607841,97.80317132936725
136,"  test('CONTEXT (specified)', () => {\n    return new Promise(\n      (resolve, reject) => {\n        const context = new MockContext(resolve, reject)\n        const contextResolver = makeResolver({\n          context,\n          resolutionMode: 'CONTEXT'\n        })\n\n        return contextResolver.succeed({\n          response: 'success'\n        })\n      }).then(successResponse => expect(successResponse).toEqual('success'))\n  })",7,1,14.285714285714285,204.09104892523658,0.00928217420207791,100,"  describe('CONTEXT (specified)', () => {\n    test('succeed method resolves with success response', () => {\n      return new Promise(\n        (resolve, reject) => {\n          const context = new MockContext(resolve, reject)\n          const contextResolver = makeResolver({\n            context,\n            resolutionMode: 'CONTEXT'\n          })\n\n          return contextResolver.succeed({\n            response: 'success'\n          })\n        }).then(successResponse => expect(successResponse).toEqual('success'))\n    })\n\n    test('fail method rejects with error response', () => {\n      return new Promise(\n        (resolve, reject) => {\n          const context = new MockContext(resolve, reject)\n          const contextResolver = makeResolver({\n            context,\n            resolutionMode: 'CONTEXT'\n          })\n\n          return contextResolver.fail({\n            error: 'failure'\n          })\n        }).catch(errorResponse => expect(errorResponse).toEqual('failure'))\n    })\n  })",16,1,6.25,682.6443989321797,0.016280026306155784,95.75336283194777
137,"  test('CALLBACK', () => {\n    const callback = (e, response) => response\n    const callbackResolver = makeResolver({\n      callback,\n      resolutionMode: 'CALLBACK',\n      context: {}\n    })\n    const successResponse = callbackResolver.succeed({\n      response: 'success'\n    })\n\n    expect(successResponse).toEqual('success')\n  })",6,1,16.666666666666664,182.28571428571428,0.007928372955436724,100,"  describe('CALLBACK resolution mode', () => {\n    test('succeed method returns expected response', () => {\n      const callback = (e, response) => response\n      const callbackResolver = makeResolver({\n        callback,\n        resolutionMode: 'CALLBACK',\n        context: {}\n      })\n      const successResponse = callbackResolver.succeed({\n        response: 'success'\n      })\n\n      expect(successResponse).toEqual('success')\n    })\n\n    test('fail method handles error correctly', () => {\n      const callback = (error) => error\n      const callbackResolver = makeResolver({\n        callback,\n        resolutionMode: 'CALLBACK',\n        context: {}\n      })\n      const errorResponse = callbackResolver.fail({\n        error: 'failure'\n      })\n\n      expect(errorResponse).toEqual('failure')\n    })\n  })",14,1,7.142857142857142,562.6999432703236,0.014099491094424542,99.0382135163392
138,"  test('PROMISE', () => {\n    return new Promise((resolve, reject) => {\n      const promise = {\n        resolve,\n        reject\n      }\n      const promiseResolver = makeResolver({\n        promise,\n        resolutionMode: 'PROMISE'\n      })\n\n      return promiseResolver.succeed({\n        response: 'success'\n      })\n    }).then(successResponse => {\n      expect(successResponse).toEqual('success')\n    })\n  })",9,1,11.11111111111111,237.1644844570315,0.009240091478856466,100,"  describe('PROMISE resolution mode', () => {\n    test('resolves successfully', () => {\n      return new Promise((resolve, reject) => {\n        const promise = {\n          resolve,\n          reject\n        }\n        const promiseResolver = makeResolver({\n          promise,\n          resolutionMode: 'PROMISE'\n        })\n\n        promiseResolver.succeed({\n          response: 'success'\n        })\n      }).then(successResponse => {\n        expect(successResponse).toEqual('success')\n      })\n    })\n\n    test('rejects with an error', () => {\n      return new Promise((resolve, reject) => {\n        const promise = {\n          resolve,\n          reject\n        }\n        const promiseResolver = makeResolver({\n          promise,\n          resolutionMode: 'PROMISE'\n        })\n\n        promiseResolver.fail({\n          error: 'failure'\n        })\n      }).catch(errorResponse => {\n        expect(errorResponse).toEqual({ error: 'failure' })\n      })\n    })\n  })",20,1,5,774.0956853522126,0.016613458690840945,91.980298892058
139,"  test('GET image', async () => {\n    const samLogoPath = path.join(jestHelpersPath, 'sam-logo.png')\n    router.get('/sam', (req, res) => {\n      res.sendFile(samLogoPath)\n    })\n    const event = makeEvent({\n      eventSourceName,\n      path: '/sam',\n      httpMethod: 'GET'\n    })\n\n    const response = await serverlessExpressInstance(event)\n\n    const samLogoImage = fs.readFileSync(samLogoPath)\n    const samLogoBase64 = Buffer.from(samLogoImage).toString('base64')\n    const expectedResponse = makeResponse({\n      eventSourceName,\n      body: samLogoBase64,\n      multiValueHeaders: {\n        'accept-ranges': ['bytes'],\n        'cache-control': ['public, max-age=0'],\n        'content-length': ['15933'],\n        'content-type': ['image/png']\n      },\n      isBase64Encoded: true\n    }, { shouldConvertContentLengthToInt: true })\n    const etagRegex = /^W\/.*$/\n    const lastModifiedRegex = /^.* GMT$/\n    switch (eventSourceName) {\n      case 'alb':\n      case 'apiGatewayV1':\n        expect(response.multiValueHeaders.etag.length).toEqual(1)\n        expect(response.multiValueHeaders.etag[0]).toMatch(etagRegex)\n        expect(response.multiValueHeaders['last-modified'].length).toEqual(1)\n        expect(response.multiValueHeaders['last-modified'][0]).toMatch(lastModifiedRegex)\n        delete response.multiValueHeaders.etag\n        delete response.multiValueHeaders['last-modified']\n        break\n      case 'azureHttpFunctionV4':\n      case 'azureHttpFunctionV3':\n        expectedResponse.body = Buffer.from(samLogoBase64, 'base64')\n        expectedResponse.isBase64Encoded = false\n        expect(response.headers.etag).toMatch(etagRegex)\n        expect(response.headers['last-modified']).toMatch(lastModifiedRegex)\n        delete response.headers.etag\n        delete response.headers['last-modified']\n        break\n      case 'apiGatewayV2':\n        expect(response.headers.etag).toMatch(etagRegex)\n        expect(response.headers['last-modified']).toMatch(lastModifiedRegex)\n        delete response.headers.etag\n        delete response.headers['last-modified']\n        break\n      case 'lambdaEdge':\n        expect(response.headers.etag.length).toEqual(1)\n        expect(response.headers.etag[0].key).toMatch('etag')\n        expect(response.headers.etag[0].value).toMatch(etagRegex)\n        expect(response.headers['last-modified'].length).toEqual(1)\n        expect(response.headers['last-modified'][0].key).toMatch('last-modified')\n        expect(response.headers['last-modified'][0].value).toMatch(lastModifiedRegex)\n        delete response.headers.etag\n        delete response.headers['last-modified']\n        break\n    }\n    expect(response).toEqual(expectedResponse)\n  })",43,7,16.27906976744186,12732.667739518913,0.05258406968203459,70.14499985415776,"  test('GET image', async () => {\n    const samLogoPath = path.join(jestHelpersPath, 'sam-logo.png')\n    router.get('/sam', (req, res) => {\n      res.sendFile(samLogoPath)\n    })\n    const event = makeEvent({\n      eventSourceName,\n      path: '/sam',\n      httpMethod: 'GET'\n    })\n\n    const response = await serverlessExpressInstance(event)\n\n    const samLogoImage = fs.readFileSync(samLogoPath)\n    const samLogoBase64 = Buffer.from(samLogoImage).toString('base64')\n    const expectedResponse = makeResponse({\n      eventSourceName,\n      body: samLogoBase64,\n      multiValueHeaders: {\n        'accept-ranges': ['bytes'],\n        'cache-control': ['public, max-age=0'],\n        'content-length': ['15933'],\n        'content-type': ['image/png']\n      },\n      isBase64Encoded: true\n    }, { shouldConvertContentLengthToInt: true })\n    const etagRegex = /^W\/.*$/\n    const lastModifiedRegex = /^.* GMT$/\n\n    const validateHeaders = (headers, etagKey, lastModifiedKey) => {\n      expect(headers[etagKey]).toMatch(etagRegex)\n      expect(headers[lastModifiedKey]).toMatch(lastModifiedRegex)\n      delete headers[etagKey]\n      delete headers[lastModifiedKey]\n    }\n\n    switch (eventSourceName) {\n      case 'alb':\n      case 'apiGatewayV1':\n        validateHeaders(response.multiValueHeaders, 'etag', 'last-modified')\n        break\n      case 'azureHttpFunctionV4':\n      case 'azureHttpFunctionV3':\n        expectedResponse.body = Buffer.from(samLogoBase64, 'base64')\n        expectedResponse.isBase64Encoded = false\n        validateHeaders(response.headers, 'etag', 'last-modified')\n        break\n      case 'apiGatewayV2':\n        validateHeaders(response.headers, 'etag', 'last-modified')\n        break\n      case 'lambdaEdge':\n        validateHeaders(\n          response.headers,\n          'etag',\n          'last-modified'\n        )\n        break\n    }\n    expect(response).toEqual(expectedResponse)\n  })\n",31,7,22.58064516129032,3562.864073722798,0.03195073918886525,79.33194863385702
140,"  test('GET image', async () => {\n    const samLogoPath = path.join(jestHelpersPath, 'sam-logo.png')\n    router.get('/sam', (req, res) => {\n      res.sendFile(samLogoPath)\n    })\n    const event = makeEvent({\n      eventSourceName,\n      path: '/sam',\n      httpMethod: 'GET'\n    })\n\n    const response = await serverlessExpressInstance(event)\n\n    const samLogoImage = fs.readFileSync(samLogoPath)\n    const samLogoBase64 = Buffer.from(samLogoImage).toString('base64')\n    const expectedResponse = makeResponse({\n      eventSourceName,\n      body: samLogoBase64,\n      multiValueHeaders: {\n        'accept-ranges': ['bytes'],\n        'cache-control': ['public, max-age=0'],\n        'content-length': ['15933'],\n        'content-type': ['image/png']\n      },\n      isBase64Encoded: true\n    }, { shouldConvertContentLengthToInt: true })\n    const etagRegex = /^W\/.*$/\n    const lastModifiedRegex = /^.* GMT$/\n    switch (eventSourceName) {\n      case 'alb':\n      case 'apiGatewayV1':\n        expect(response.multiValueHeaders.etag.length).toEqual(1)\n        expect(response.multiValueHeaders.etag[0]).toMatch(etagRegex)\n        expect(response.multiValueHeaders['last-modified'].length).toEqual(1)\n        expect(response.multiValueHeaders['last-modified'][0]).toMatch(lastModifiedRegex)\n        delete response.multiValueHeaders.etag\n        delete response.multiValueHeaders['last-modified']\n        break\n      case 'azureHttpFunctionV4':\n      case 'azureHttpFunctionV3':\n        expectedResponse.body = Buffer.from(samLogoBase64, 'base64')\n        expectedResponse.isBase64Encoded = false\n        expect(response.headers.etag).toMatch(etagRegex)\n        expect(response.headers['last-modified']).toMatch(lastModifiedRegex)\n        delete response.headers.etag\n        delete response.headers['last-modified']\n        break\n      case 'apiGatewayV2':\n        expect(response.headers.etag).toMatch(etagRegex)\n        expect(response.headers['last-modified']).toMatch(lastModifiedRegex)\n        delete response.headers.etag\n        delete response.headers['last-modified']\n        break\n      case 'lambdaEdge':\n        expect(response.headers.etag.length).toEqual(1)\n        expect(response.headers.etag[0].key).toMatch('etag')\n        expect(response.headers.etag[0].value).toMatch(etagRegex)\n        expect(response.headers['last-modified'].length).toEqual(1)\n        expect(response.headers['last-modified'][0].key).toMatch('last-modified')\n        expect(response.headers['last-modified'][0].value).toMatch(lastModifiedRegex)\n        delete response.headers.etag\n        delete response.headers['last-modified']\n        break\n    }\n    expect(response).toEqual(expectedResponse)\n  })",43,7,16.27906976744186,12732.667739518913,0.05258406968203459,70.14499985415776,"  test('GET image', async () => {\n    const samLogoPath = path.join(jestHelpersPath, 'sam-logo.png')\n    router.get('/sam', (req, res) => {\n      res.sendFile(samLogoPath)\n    })\n    const event = makeEvent({\n      eventSourceName,\n      path: '/sam',\n      httpMethod: 'GET'\n    })\n\n    const response = await serverlessExpressInstance(event)\n\n    const samLogoImage = fs.readFileSync(samLogoPath)\n    const samLogoBase64 = Buffer.from(samLogoImage).toString('base64')\n    const expectedResponse = makeResponse({\n      eventSourceName,\n      body: samLogoBase64,\n      multiValueHeaders: {\n        'accept-ranges': ['bytes'],\n        'cache-control': ['public, max-age=0'],\n        'content-length': ['15933'],\n        'content-type': ['image/png']\n      },\n      isBase64Encoded: true\n    }, { shouldConvertContentLengthToInt: true })\n    const etagRegex = /^W\/.*$/\n    const lastModifiedRegex = /^.* GMT$/\n\n    const validateHeaders = (headers, etagKey, lastModifiedKey) => {\n      expect(headers[etagKey]).toMatch(etagRegex)\n      expect(headers[lastModifiedKey]).toMatch(lastModifiedRegex)\n      delete headers[etagKey]\n      delete headers[lastModifiedKey]\n    }\n\n    switch (eventSourceName) {\n      case 'alb':\n      case 'apiGatewayV1':\n        validateHeaders(response.multiValueHeaders, 'etag', 'last-modified')\n        break\n      case 'azureHttpFunctionV4':\n      case 'azureHttpFunctionV3':\n        expectedResponse.body = Buffer.from(samLogoBase64, 'base64')\n        expectedResponse.isBase64Encoded = false\n        validateHeaders(response.headers, 'etag', 'last-modified')\n        break\n      case 'apiGatewayV2':\n        validateHeaders(response.headers, 'etag', 'last-modified')\n        break\n      case 'lambdaEdge':\n        validateHeaders(\n          Object.fromEntries(\n            response.headers.etag.map(({ key, value }) => [key, value])\n          ),\n          'etag',\n          'last-modified'\n        )\n        break\n    }\n    expect(response).toEqual(expectedResponse)\n  })\n",31,7,22.58064516129032,3991.85375814991,0.03437071700696935,78.76247347535451
141,"  test('GET image', async () => {\n    const samLogoPath = path.join(jestHelpersPath, 'sam-logo.png')\n    router.get('/sam', (req, res) => {\n      res.sendFile(samLogoPath)\n    })\n    const event = makeEvent({\n      eventSourceName,\n      path: '/sam',\n      httpMethod: 'GET'\n    })\n\n    const response = await serverlessExpressInstance(event)\n\n    const samLogoImage = fs.readFileSync(samLogoPath)\n    const samLogoBase64 = Buffer.from(samLogoImage).toString('base64')\n    const expectedResponse = makeResponse({\n      eventSourceName,\n      body: samLogoBase64,\n      multiValueHeaders: {\n        'accept-ranges': ['bytes'],\n        'cache-control': ['public, max-age=0'],\n        'content-length': ['15933'],\n        'content-type': ['image/png']\n      },\n      isBase64Encoded: true\n    }, { shouldConvertContentLengthToInt: true })\n    const etagRegex = /^W\/.*$/\n    const lastModifiedRegex = /^.* GMT$/\n    switch (eventSourceName) {\n      case 'alb':\n      case 'apiGatewayV1':\n        expect(response.multiValueHeaders.etag.length).toEqual(1)\n        expect(response.multiValueHeaders.etag[0]).toMatch(etagRegex)\n        expect(response.multiValueHeaders['last-modified'].length).toEqual(1)\n        expect(response.multiValueHeaders['last-modified'][0]).toMatch(lastModifiedRegex)\n        delete response.multiValueHeaders.etag\n        delete response.multiValueHeaders['last-modified']\n        break\n      case 'azureHttpFunctionV4':\n      case 'azureHttpFunctionV3':\n        expectedResponse.body = Buffer.from(samLogoBase64, 'base64')\n        expectedResponse.isBase64Encoded = false\n        expect(response.headers.etag).toMatch(etagRegex)\n        expect(response.headers['last-modified']).toMatch(lastModifiedRegex)\n        delete response.headers.etag\n        delete response.headers['last-modified']\n        break\n      case 'apiGatewayV2':\n        expect(response.headers.etag).toMatch(etagRegex)\n        expect(response.headers['last-modified']).toMatch(lastModifiedRegex)\n        delete response.headers.etag\n        delete response.headers['last-modified']\n        break\n      case 'lambdaEdge':\n        expect(response.headers.etag.length).toEqual(1)\n        expect(response.headers.etag[0].key).toMatch('etag')\n        expect(response.headers.etag[0].value).toMatch(etagRegex)\n        expect(response.headers['last-modified'].length).toEqual(1)\n        expect(response.headers['last-modified'][0].key).toMatch('last-modified')\n        expect(response.headers['last-modified'][0].value).toMatch(lastModifiedRegex)\n        delete response.headers.etag\n        delete response.headers['last-modified']\n        break\n    }\n    expect(response).toEqual(expectedResponse)\n  })",43,7,16.27906976744186,12732.667739518913,0.05258406968203459,70.14499985415776,"  test('GET image', async () => {\n    const samLogoPath = path.join(jestHelpersPath, 'sam-logo.png')\n    router.get('/sam', (req, res) => {\n      res.sendFile(samLogoPath)\n    })\n    const event = makeEvent({\n      eventSourceName,\n      path: '/sam',\n      httpMethod: 'GET'\n    })\n\n    const response = await serverlessExpressInstance(event)\n\n    const samLogoImage = fs.readFileSync(samLogoPath)\n    const samLogoBase64 = Buffer.from(samLogoImage).toString('base64')\n    const expectedResponse = makeResponse({\n      eventSourceName,\n      body: samLogoBase64,\n      multiValueHeaders: {\n        'accept-ranges': ['bytes'],\n        'cache-control': ['public, max-age=0'],\n        'content-length': ['15933'],\n        'content-type': ['image/png']\n      },\n      isBase64Encoded: true\n    }, { shouldConvertContentLengthToInt: true })\n    const etagRegex = /^W\/.*$/\n    const lastModifiedRegex = /^.* GMT$/\n\n    const validateHeaders = (headers, etagKey, lastModifiedKey) => {\n      expect(headers[etagKey]).toMatch(etagRegex)\n      expect(headers[lastModifiedKey]).toMatch(lastModifiedRegex)\n      delete headers[etagKey]\n      delete headers[lastModifiedKey]\n    }\n\n    switch (eventSourceName) {\n      case 'alb':\n      case 'apiGatewayV1':\n        validateHeaders(response.multiValueHeaders, 'etag', 'last-modified')\n        break\n      case 'azureHttpFunctionV4':\n      case 'azureHttpFunctionV3':\n        expectedResponse.body = Buffer.from(samLogoBase64, 'base64')\n        expectedResponse.isBase64Encoded = false\n        validateHeaders(response.headers, 'etag', 'last-modified')\n        break\n      case 'apiGatewayV2':\n        validateHeaders(response.headers, 'etag', 'last-modified')\n        break\n      case 'lambdaEdge':\n        validateHeaders(response.headers, 'etag', 'last-modified')\n        break\n    }\n    expect(response).toEqual(expectedResponse)\n  })\n",31,7,22.58064516129032,3562.864073722798,0.03195073918886525,79.33194863385702
142,"  test('GET image', async () => {\n    const samLogoPath = path.join(jestHelpersPath, 'sam-logo.png')\n    router.get('/sam', (req, res) => {\n      res.sendFile(samLogoPath)\n    })\n    const event = makeEvent({\n      eventSourceName,\n      path: '/sam',\n      httpMethod: 'GET'\n    })\n\n    const response = await serverlessExpressInstance(event)\n\n    const samLogoImage = fs.readFileSync(samLogoPath)\n    const samLogoBase64 = Buffer.from(samLogoImage).toString('base64')\n    const expectedResponse = makeResponse({\n      eventSourceName,\n      body: samLogoBase64,\n      multiValueHeaders: {\n        'accept-ranges': ['bytes'],\n        'cache-control': ['public, max-age=0'],\n        'content-length': ['15933'],\n        'content-type': ['image/png']\n      },\n      isBase64Encoded: true\n    }, { shouldConvertContentLengthToInt: true })\n    const etagRegex = /^W\/.*$/\n    const lastModifiedRegex = /^.* GMT$/\n    switch (eventSourceName) {\n      case 'alb':\n      case 'apiGatewayV1':\n        expect(response.multiValueHeaders.etag.length).toEqual(1)\n        expect(response.multiValueHeaders.etag[0]).toMatch(etagRegex)\n        expect(response.multiValueHeaders['last-modified'].length).toEqual(1)\n        expect(response.multiValueHeaders['last-modified'][0]).toMatch(lastModifiedRegex)\n        delete response.multiValueHeaders.etag\n        delete response.multiValueHeaders['last-modified']\n        break\n      case 'azureHttpFunctionV4':\n      case 'azureHttpFunctionV3':\n        expectedResponse.body = Buffer.from(samLogoBase64, 'base64')\n        expectedResponse.isBase64Encoded = false\n        expect(response.headers.etag).toMatch(etagRegex)\n        expect(response.headers['last-modified']).toMatch(lastModifiedRegex)\n        delete response.headers.etag\n        delete response.headers['last-modified']\n        break\n      case 'apiGatewayV2':\n        expect(response.headers.etag).toMatch(etagRegex)\n        expect(response.headers['last-modified']).toMatch(lastModifiedRegex)\n        delete response.headers.etag\n        delete response.headers['last-modified']\n        break\n      case 'lambdaEdge':\n        expect(response.headers.etag.length).toEqual(1)\n        expect(response.headers.etag[0].key).toMatch('etag')\n        expect(response.headers.etag[0].value).toMatch(etagRegex)\n        expect(response.headers['last-modified'].length).toEqual(1)\n        expect(response.headers['last-modified'][0].key).toMatch('last-modified')\n        expect(response.headers['last-modified'][0].value).toMatch(lastModifiedRegex)\n        delete response.headers.etag\n        delete response.headers['last-modified']\n        break\n    }\n    expect(response).toEqual(expectedResponse)\n  })",43,7,16.27906976744186,12732.667739518913,0.05258406968203459,70.14499985415776,"  test('GET image', async () => {\n    const samLogoPath = path.join(jestHelpersPath, 'sam-logo.png')\n    router.get('/sam', (req, res) => {\n      res.sendFile(samLogoPath)\n    })\n    const event = makeEvent({\n      eventSourceName,\n      path: '/sam',\n      httpMethod: 'GET'\n    })\n\n    const response = await serverlessExpressInstance(event)\n\n    const samLogoImage = fs.readFileSync(samLogoPath)\n    const samLogoBase64 = Buffer.from(samLogoImage).toString('base64')\n    const expectedResponse = makeResponse({\n      eventSourceName,\n      body: samLogoBase64,\n      multiValueHeaders: {\n        'accept-ranges': ['bytes'],\n        'cache-control': ['public, max-age=0'],\n        'content-length': ['15933'],\n        'content-type': ['image/png']\n      },\n      isBase64Encoded: true\n    }, { shouldConvertContentLengthToInt: true })\n    const etagRegex = /^W\/.*$/\n    const lastModifiedRegex = /^.* GMT$/\n\n    const validateHeaders = (headers, etagKey, lastModifiedKey) => {\n      expect(headers[etagKey]).toMatch(etagRegex)\n      expect(headers[lastModifiedKey]).toMatch(lastModifiedRegex)\n      delete headers[etagKey]\n      delete headers[lastModifiedKey]\n    }\n\n    switch (eventSourceName) {\n      case 'alb':\n      case 'apiGatewayV1':\n        validateHeaders(response.multiValueHeaders, 'etag', 'last-modified')\n        break\n      case 'azureHttpFunctionV4':\n      case 'azureHttpFunctionV3':\n        expectedResponse.body = Buffer.from(samLogoBase64, 'base64')\n        expectedResponse.isBase64Encoded = false\n        validateHeaders(response.headers, 'etag', 'last-modified')\n        break\n      case 'apiGatewayV2':\n        validateHeaders(response.headers, 'etag', 'last-modified')\n        break\n      case 'lambdaEdge':\n        expect(response.headers.etag.length).toEqual(1)\n        expect(response.headers.etag[0].key).toMatch('etag')\n        expect(response.headers.etag[0].value).toMatch(etagRegex)\n        expect(response.headers['last-modified'].length).toEqual(1)\n        expect(response.headers['last-modified'][0].key).toMatch('last-modified')\n        expect(response.headers['last-modified'][0].value).toMatch(lastModifiedRegex)\n        delete response.headers.etag\n        delete response.headers['last-modified']\n        break\n    }\n    expect(response).toEqual(expectedResponse)\n  })",38,7,18.421052631578945,7501.276086130731,0.04386694747598218,73.56131219981845
143,"    test('custom levels', () => {\n      const loggerError = serverlessExpressLogger({ level: 'error' })\n\n      loggerError.error('error')\n      loggerError.info('nocall')\n      loggerError.warn('nocall')\n      loggerError.debug('nocall')\n      loggerError.verbose('nocall')\n      expect(global.console.warn).not.toHaveBeenCalled()\n      expect(global.console.debug).not.toHaveBeenCalled()\n      expect(global.console.info).not.toHaveBeenCalled()\n      expect(global.console.error).toHaveBeenLastCalledWith({\n        message: 'error'\n      })\n\n      const loggerWarn = serverlessExpressLogger({ level: 'warn' })\n\n      loggerWarn.error('error2')\n      loggerWarn.warn('warn2')\n      loggerWarn.info('nocall')\n      loggerWarn.debug('nocall')\n      loggerWarn.verbose('nocall')\n      expect(global.console.debug).not.toHaveBeenCalled()\n      expect(global.console.info).not.toHaveBeenCalled()\n      expect(global.console.error).toHaveBeenLastCalledWith({\n        message: 'error2'\n      })\n      expect(global.console.warn).toHaveBeenLastCalledWith({\n        message: 'warn2'\n      })\n\n      const loggerInfo = serverlessExpressLogger({ level: 'info' })\n\n      loggerInfo.error('error3')\n      loggerInfo.warn('warn3')\n      loggerInfo.info('info3')\n      loggerInfo.debug('nocall')\n      loggerInfo.verbose('nocall')\n      expect(global.console.debug).not.toHaveBeenCalled()\n      expect(global.console.error).toHaveBeenLastCalledWith({\n        message: 'error3'\n      })\n      expect(global.console.warn).toHaveBeenLastCalledWith({\n        message: 'warn3'\n      })\n      expect(global.console.info).toHaveBeenLastCalledWith({\n        message: 'info3'\n      })\n\n      const loggerVerbose = serverlessExpressLogger({ level: 'verbose' })\n\n      loggerVerbose.error('error4')\n      loggerVerbose.warn('warn4')\n      loggerVerbose.info('info4')\n      loggerVerbose.verbose('verbose4')\n      loggerVerbose.debug('nocall')\n      expect(global.console.error).toHaveBeenLastCalledWith({\n        message: 'error4'\n      })\n      expect(global.console.warn).toHaveBeenLastCalledWith({\n        message: 'warn4'\n      })\n      expect(global.console.info).toHaveBeenLastCalledWith({\n        message: 'info4'\n      })\n      expect(global.console.debug).toHaveBeenLastCalledWith({\n        message: 'verbose4'\n      })\n\n      const loggerDebug = serverlessExpressLogger({ level: 'debug' })\n\n      loggerDebug.error('error5')\n      loggerDebug.warn('warn5')\n      loggerDebug.info('info5')\n      loggerDebug.verbose('verbose5')\n      loggerDebug.debug('debug5')\n      expect(global.console.error).toHaveBeenLastCalledWith({\n        message: 'error5'\n      })\n      expect(global.console.warn).toHaveBeenLastCalledWith({\n        message: 'warn5'\n      })\n      expect(global.console.info).toHaveBeenLastCalledWith({\n        message: 'info5'\n      })\n      expect(global.console.debug).toHaveBeenLastCalledWith({\n        message: 'debug5'\n      })\n    })",52,1,1.9230769230769231,13233.961207026363,0.054008941280481275,67.30530893278905,"    test('custom levels', () => {\n      const loggerError = serverlessExpressLogger({ level: 'error' })\n\n      loggerError.error('error')\n      expect(global.console.error).toHaveBeenLastCalledWith({\n      message: 'error'\n      })\n\n      const loggerWarn = serverlessExpressLogger({ level: 'warn' })\n\n      loggerWarn.error('error2')\n      loggerWarn.warn('warn2')\n      expect(global.console.error).toHaveBeenLastCalledWith({\n      message: 'error2'\n      })\n      expect(global.console.warn).toHaveBeenLastCalledWith({\n      message: 'warn2'\n      })\n\n      const loggerInfo = serverlessExpressLogger({ level: 'info' })\n\n      loggerInfo.error('error3')\n      loggerInfo.warn('warn3')\n      loggerInfo.info('info3')\n      expect(global.console.error).toHaveBeenLastCalledWith({\n      message: 'error3'\n      })\n      expect(global.console.warn).toHaveBeenLastCalledWith({\n      message: 'warn3'\n      })\n      expect(global.console.info).toHaveBeenLastCalledWith({\n      message: 'info3'\n      })\n\n      const loggerVerbose = serverlessExpressLogger({ level: 'verbose' })\n\n      loggerVerbose.error('error4')\n      loggerVerbose.warn('warn4')\n      loggerVerbose.info('info4')\n      loggerVerbose.verbose('verbose4')\n      expect(global.console.error).toHaveBeenLastCalledWith({\n      message: 'error4'\n      })\n      expect(global.console.warn).toHaveBeenLastCalledWith({\n      message: 'warn4'\n      })\n      expect(global.console.info).toHaveBeenLastCalledWith({\n      message: 'info4'\n      })\n      expect(global.console.debug).toHaveBeenLastCalledWith({\n      message: 'verbose4'\n      })\n\n      const loggerDebug = serverlessExpressLogger({ level: 'debug' })\n\n      loggerDebug.error('error5')\n      loggerDebug.warn('warn5')\n      loggerDebug.info('info5')\n      loggerDebug.verbose('verbose5')\n      loggerDebug.debug('debug5')\n      expect(global.console.error).toHaveBeenLastCalledWith({\n      message: 'error5'\n      })\n      expect(global.console.warn).toHaveBeenLastCalledWith({\n      message: 'warn5'\n      })\n      expect(global.console.info).toHaveBeenLastCalledWith({\n      message: 'info5'\n      })\n      expect(global.console.debug).toHaveBeenLastCalledWith({\n      message: 'debug5'\n      })\n    })",36,1,2.7777777777777777,6950.178487960429,0.04151732664723948,75.3141527179284
144,"  test('GET image', async () => {\n    const samLogoPath = path.join(jestHelpersPath, 'sam-logo.png')\n    router.get('/sam', (req, res) => {\n      res.sendFile(samLogoPath)\n    })\n    const event = makeEvent({\n      eventSourceName,\n      path: '/sam',\n      httpMethod: 'GET'\n    })\n\n    const response = await serverlessExpressInstance(event)\n\n    const samLogoImage = fs.readFileSync(samLogoPath)\n    const samLogoBase64 = Buffer.from(samLogoImage).toString('base64')\n    const expectedResponse = makeResponse({\n      eventSourceName,\n      body: samLogoBase64,\n      multiValueHeaders: {\n        'accept-ranges': ['bytes'],\n        'cache-control': ['public, max-age=0'],\n        'content-length': ['15933'],\n        'content-type': ['image/png']\n      },\n      isBase64Encoded: true\n    }, { shouldConvertContentLengthToInt: true })\n    const etagRegex = /^W\/.*$/\n    const lastModifiedRegex = /^.* GMT$/\n    switch (eventSourceName) {\n      case 'alb':\n      case 'apiGatewayV1':\n        expect(response.multiValueHeaders.etag.length).toEqual(1)\n        expect(response.multiValueHeaders.etag[0]).toMatch(etagRegex)\n        expect(response.multiValueHeaders['last-modified'].length).toEqual(1)\n        expect(response.multiValueHeaders['last-modified'][0]).toMatch(lastModifiedRegex)\n        delete response.multiValueHeaders.etag\n        delete response.multiValueHeaders['last-modified']\n        break\n      case 'azureHttpFunctionV4':\n      case 'azureHttpFunctionV3':\n        expectedResponse.body = Buffer.from(samLogoBase64, 'base64')\n        expectedResponse.isBase64Encoded = false\n        expect(response.headers.etag).toMatch(etagRegex)\n        expect(response.headers['last-modified']).toMatch(lastModifiedRegex)\n        delete response.headers.etag\n        delete response.headers['last-modified']\n        break\n      case 'apiGatewayV2':\n        expect(response.headers.etag).toMatch(etagRegex)\n        expect(response.headers['last-modified']).toMatch(lastModifiedRegex)\n        delete response.headers.etag\n        delete response.headers['last-modified']\n        break\n      case 'lambdaEdge':\n        expect(response.headers.etag.length).toEqual(1)\n        expect(response.headers.etag[0].key).toMatch('etag')\n        expect(response.headers.etag[0].value).toMatch(etagRegex)\n        expect(response.headers['last-modified'].length).toEqual(1)\n        expect(response.headers['last-modified'][0].key).toMatch('last-modified')\n        expect(response.headers['last-modified'][0].value).toMatch(lastModifiedRegex)\n        delete response.headers.etag\n        delete response.headers['last-modified']\n        break\n    }\n    expect(response).toEqual(expectedResponse)\n  })",43,7,16.27906976744186,12732.667739518913,0.05258406968203459,70.14499985415776,"  test('GET image', async () => {\n    const samLogoPath = path.join(jestHelpersPath, 'sam-logo.png')\n    const expectedContentLength = '15933' // Length of the sam-logo.png file in bytes\n    router.get('/sam', (req, res) => {\n      res.sendFile(samLogoPath)\n    })\n    const event = makeEvent({\n      eventSourceName,\n      path: '/sam',\n      httpMethod: 'GET'\n    })\n\n    const response = await serverlessExpressInstance(event)\n\n    const samLogoImage = fs.readFileSync(samLogoPath)\n    const samLogoBase64 = Buffer.from(samLogoImage).toString('base64')\n    const expectedResponse = makeResponse({\n      eventSourceName,\n      body: samLogoBase64,\n      multiValueHeaders: {\n        'accept-ranges': ['bytes'],\n        'cache-control': ['public, max-age=0'],\n        'content-length': [expectedContentLength],\n        'content-type': ['image/png']\n      },\n      isBase64Encoded: true\n    }, { shouldConvertContentLengthToInt: true })\n    const etagRegex = /^W\/.*$/\n    const lastModifiedRegex = /^.* GMT$/\n    switch (eventSourceName) {\n      case 'alb':\n      case 'apiGatewayV1':\n        expect(response.multiValueHeaders.etag.length).toEqual(1)\n        expect(response.multiValueHeaders.etag[0]).toMatch(etagRegex)\n        expect(response.multiValueHeaders['last-modified'].length).toEqual(1)\n        expect(response.multiValueHeaders['last-modified'][0]).toMatch(lastModifiedRegex)\n        delete response.multiValueHeaders.etag\n        delete response.multiValueHeaders['last-modified']\n        break\n      case 'azureHttpFunctionV4':\n      case 'azureHttpFunctionV3':\n        expectedResponse.body = Buffer.from(samLogoBase64, 'base64')\n        expectedResponse.isBase64Encoded = false\n        expect(response.headers.etag).toMatch(etagRegex)\n        expect(response.headers['last-modified']).toMatch(lastModifiedRegex)\n        delete response.headers.etag\n        delete response.headers['last-modified']\n        break\n      case 'apiGatewayV2':\n        expect(response.headers.etag).toMatch(etagRegex)\n        expect(response.headers['last-modified']).toMatch(lastModifiedRegex)\n        delete response.headers.etag\n        delete response.headers['last-modified']\n        break\n      case 'lambdaEdge':\n        expect(response.headers.etag.length).toEqual(1)\n        expect(response.headers.etag[0].key).toMatch('etag')\n        expect(response.headers.etag[0].value).toMatch(etagRegex)\n        expect(response.headers['last-modified'].length).toEqual(1)\n        expect(response.headers['last-modified'][0].key).toMatch('last-modified')\n        expect(response.headers['last-modified'][0].value).toMatch(lastModifiedRegex)\n        delete response.headers.etag\n        delete response.headers['last-modified']\n        break\n    }\n    expect(response).toEqual(expectedResponse)\n  })",44,7,15.909090909090908,12778.629090145623,0.05292561631496968,69.72207054090288
145,"  test('GET image', async () => {\n    const samLogoPath = path.join(jestHelpersPath, 'sam-logo.png')\n    router.get('/sam', (req, res) => {\n      res.sendFile(samLogoPath)\n    })\n    const event = makeEvent({\n      eventSourceName,\n      path: '/sam',\n      httpMethod: 'GET'\n    })\n\n    const response = await serverlessExpressInstance(event)\n\n    const samLogoImage = fs.readFileSync(samLogoPath)\n    const samLogoBase64 = Buffer.from(samLogoImage).toString('base64')\n    const expectedResponse = makeResponse({\n      eventSourceName,\n      body: samLogoBase64,\n      multiValueHeaders: {\n        'accept-ranges': ['bytes'],\n        'cache-control': ['public, max-age=0'],\n        'content-length': ['15933'],\n        'content-type': ['image/png']\n      },\n      isBase64Encoded: true\n    }, { shouldConvertContentLengthToInt: true })\n    const etagRegex = /^W\/.*$/\n    const lastModifiedRegex = /^.* GMT$/\n    switch (eventSourceName) {\n      case 'alb':\n      case 'apiGatewayV1':\n        expect(response.multiValueHeaders.etag.length).toEqual(1)\n        expect(response.multiValueHeaders.etag[0]).toMatch(etagRegex)\n        expect(response.multiValueHeaders['last-modified'].length).toEqual(1)\n        expect(response.multiValueHeaders['last-modified'][0]).toMatch(lastModifiedRegex)\n        delete response.multiValueHeaders.etag\n        delete response.multiValueHeaders['last-modified']\n        break\n      case 'azureHttpFunctionV4':\n      case 'azureHttpFunctionV3':\n        expectedResponse.body = Buffer.from(samLogoBase64, 'base64')\n        expectedResponse.isBase64Encoded = false\n        expect(response.headers.etag).toMatch(etagRegex)\n        expect(response.headers['last-modified']).toMatch(lastModifiedRegex)\n        delete response.headers.etag\n        delete response.headers['last-modified']\n        break\n      case 'apiGatewayV2':\n        expect(response.headers.etag).toMatch(etagRegex)\n        expect(response.headers['last-modified']).toMatch(lastModifiedRegex)\n        delete response.headers.etag\n        delete response.headers['last-modified']\n        break\n      case 'lambdaEdge':\n        expect(response.headers.etag.length).toEqual(1)\n        expect(response.headers.etag[0].key).toMatch('etag')\n        expect(response.headers.etag[0].value).toMatch(etagRegex)\n        expect(response.headers['last-modified'].length).toEqual(1)\n        expect(response.headers['last-modified'][0].key).toMatch('last-modified')\n        expect(response.headers['last-modified'][0].value).toMatch(lastModifiedRegex)\n        delete response.headers.etag\n        delete response.headers['last-modified']\n        break\n    }\n    expect(response).toEqual(expectedResponse)\n  })",43,7,16.27906976744186,12732.667739518913,0.05258406968203459,70.14499985415776,"  test('GET image', async () => {\n    const samLogoPath = path.join(jestHelpersPath, 'sam-logo.png')\n    const expectedContentLength = '15933' // Length of the sam-logo.png file\n    router.get('/sam', (req, res) => {\n      res.sendFile(samLogoPath)\n    })\n    const event = makeEvent({\n      eventSourceName,\n      path: '/sam',\n      httpMethod: 'GET'\n    })\n\n    const response = await serverlessExpressInstance(event)\n\n    const samLogoImage = fs.readFileSync(samLogoPath)\n    const samLogoBase64 = Buffer.from(samLogoImage).toString('base64')\n    const expectedResponse = makeResponse({\n      eventSourceName,\n      body: samLogoBase64,\n      multiValueHeaders: {\n        'accept-ranges': ['bytes'],\n        'cache-control': ['public, max-age=0'],\n        'content-length': [expectedContentLength],\n        'content-type': ['image/png']\n      },\n      isBase64Encoded: true\n    }, { shouldConvertContentLengthToInt: true })\n    const etagRegex = /^W\/.*$/\n    const lastModifiedRegex = /^.* GMT$/\n    switch (eventSourceName) {\n      case 'alb':\n      case 'apiGatewayV1':\n        expect(response.multiValueHeaders.etag.length).toEqual(1)\n        expect(response.multiValueHeaders.etag[0]).toMatch(etagRegex)\n        expect(response.multiValueHeaders['last-modified'].length).toEqual(1)\n        expect(response.multiValueHeaders['last-modified'][0]).toMatch(lastModifiedRegex)\n        delete response.multiValueHeaders.etag\n        delete response.multiValueHeaders['last-modified']\n        break\n      case 'azureHttpFunctionV4':\n      case 'azureHttpFunctionV3':\n        expectedResponse.body = Buffer.from(samLogoBase64, 'base64')\n        expectedResponse.isBase64Encoded = false\n        expect(response.headers.etag).toMatch(etagRegex)\n        expect(response.headers['last-modified']).toMatch(lastModifiedRegex)\n        delete response.headers.etag\n        delete response.headers['last-modified']\n        break\n      case 'apiGatewayV2':\n        expect(response.headers.etag).toMatch(etagRegex)\n        expect(response.headers['last-modified']).toMatch(lastModifiedRegex)\n        delete response.headers.etag\n        delete response.headers['last-modified']\n        break\n      case 'lambdaEdge':\n        expect(response.headers.etag.length).toEqual(1)\n        expect(response.headers.etag[0].key).toMatch('etag')\n        expect(response.headers.etag[0].value).toMatch(etagRegex)\n        expect(response.headers['last-modified'].length).toEqual(1)\n        expect(response.headers['last-modified'][0].key).toMatch('last-modified')\n        expect(response.headers['last-modified'][0].value).toMatch(lastModifiedRegex)\n        delete response.headers.etag\n        delete response.headers['last-modified']\n        break\n    }\n    expect(response).toEqual(expectedResponse)\n  })",44,7,15.909090909090908,12778.629090145623,0.05292561631496968,69.72207054090288
146,"  test('GET image', async () => {\n    const samLogoPath = path.join(jestHelpersPath, 'sam-logo.png')\n    router.get('/sam', (req, res) => {\n      res.sendFile(samLogoPath)\n    })\n    const event = makeEvent({\n      eventSourceName,\n      path: '/sam',\n      httpMethod: 'GET'\n    })\n\n    const response = await serverlessExpressInstance(event)\n\n    const samLogoImage = fs.readFileSync(samLogoPath)\n    const samLogoBase64 = Buffer.from(samLogoImage).toString('base64')\n    const expectedResponse = makeResponse({\n      eventSourceName,\n      body: samLogoBase64,\n      multiValueHeaders: {\n        'accept-ranges': ['bytes'],\n        'cache-control': ['public, max-age=0'],\n        'content-length': ['15933'],\n        'content-type': ['image/png']\n      },\n      isBase64Encoded: true\n    }, { shouldConvertContentLengthToInt: true })\n    const etagRegex = /^W\/.*$/\n    const lastModifiedRegex = /^.* GMT$/\n    switch (eventSourceName) {\n      case 'alb':\n      case 'apiGatewayV1':\n        expect(response.multiValueHeaders.etag.length).toEqual(1)\n        expect(response.multiValueHeaders.etag[0]).toMatch(etagRegex)\n        expect(response.multiValueHeaders['last-modified'].length).toEqual(1)\n        expect(response.multiValueHeaders['last-modified'][0]).toMatch(lastModifiedRegex)\n        delete response.multiValueHeaders.etag\n        delete response.multiValueHeaders['last-modified']\n        break\n      case 'azureHttpFunctionV4':\n      case 'azureHttpFunctionV3':\n        expectedResponse.body = Buffer.from(samLogoBase64, 'base64')\n        expectedResponse.isBase64Encoded = false\n        expect(response.headers.etag).toMatch(etagRegex)\n        expect(response.headers['last-modified']).toMatch(lastModifiedRegex)\n        delete response.headers.etag\n        delete response.headers['last-modified']\n        break\n      case 'apiGatewayV2':\n        expect(response.headers.etag).toMatch(etagRegex)\n        expect(response.headers['last-modified']).toMatch(lastModifiedRegex)\n        delete response.headers.etag\n        delete response.headers['last-modified']\n        break\n      case 'lambdaEdge':\n        expect(response.headers.etag.length).toEqual(1)\n        expect(response.headers.etag[0].key).toMatch('etag')\n        expect(response.headers.etag[0].value).toMatch(etagRegex)\n        expect(response.headers['last-modified'].length).toEqual(1)\n        expect(response.headers['last-modified'][0].key).toMatch('last-modified')\n        expect(response.headers['last-modified'][0].value).toMatch(lastModifiedRegex)\n        delete response.headers.etag\n        delete response.headers['last-modified']\n        break\n    }\n    expect(response).toEqual(expectedResponse)\n  })",43,7,16.27906976744186,12732.667739518913,0.05258406968203459,70.14499985415776,"  test('GET image', async () => {\n    const samLogoPath = path.join(jestHelpersPath, 'sam-logo.png')\n    const expectedContentLength = '15933' // Length of the sam-logo.png file in bytes\n    router.get('/sam', (req, res) => {\n      res.sendFile(samLogoPath)\n    })\n    const event = makeEvent({\n      eventSourceName,\n      path: '/sam',\n      httpMethod: 'GET'\n    })\n\n    const response = await serverlessExpressInstance(event)\n\n    const samLogoImage = fs.readFileSync(samLogoPath)\n    const samLogoBase64 = Buffer.from(samLogoImage).toString('base64')\n    const expectedResponse = makeResponse({\n      eventSourceName,\n      body: samLogoBase64,\n      multiValueHeaders: {\n        'accept-ranges': ['bytes'],\n        'cache-control': ['public, max-age=0'],\n        'content-length': [expectedContentLength],\n        'content-type': ['image/png']\n      },\n      isBase64Encoded: true\n    }, { shouldConvertContentLengthToInt: true })\n    const etagRegex = /^W\/.*$/\n    const lastModifiedRegex = /^.* GMT$/\n    switch (eventSourceName) {\n      case 'alb':\n      case 'apiGatewayV1':\n        expect(response.multiValueHeaders.etag.length).toEqual(1)\n        expect(response.multiValueHeaders.etag[0]).toMatch(etagRegex)\n        expect(response.multiValueHeaders['last-modified'].length).toEqual(1)\n        expect(response.multiValueHeaders['last-modified'][0]).toMatch(lastModifiedRegex)\n        delete response.multiValueHeaders.etag\n        delete response.multiValueHeaders['last-modified']\n        break\n      case 'azureHttpFunctionV4':\n      case 'azureHttpFunctionV3':\n        expectedResponse.body = Buffer.from(samLogoBase64, 'base64')\n        expectedResponse.isBase64Encoded = false\n        expect(response.headers.etag).toMatch(etagRegex)\n        expect(response.headers['last-modified']).toMatch(lastModifiedRegex)\n        delete response.headers.etag\n        delete response.headers['last-modified']\n        break\n      case 'apiGatewayV2':\n        expect(response.headers.etag).toMatch(etagRegex)\n        expect(response.headers['last-modified']).toMatch(lastModifiedRegex)\n        delete response.headers.etag\n        delete response.headers['last-modified']\n        break\n      case 'lambdaEdge':\n        expect(response.headers.etag.length).toEqual(1)\n        expect(response.headers.etag[0].key).toMatch('etag')\n        expect(response.headers.etag[0].value).toMatch(etagRegex)\n        expect(response.headers['last-modified'].length).toEqual(1)\n        expect(response.headers['last-modified'][0].key).toMatch('last-modified')\n        expect(response.headers['last-modified'][0].value).toMatch(lastModifiedRegex)\n        delete response.headers.etag\n        delete response.headers['last-modified']\n        break\n    }\n    expect(response).toEqual(expectedResponse)\n  })",44,7,15.909090909090908,12778.629090145623,0.05292561631496968,69.72207054090288
147,"  test('GET image', async () => {\n    const samLogoPath = path.join(jestHelpersPath, 'sam-logo.png')\n    router.get('/sam', (req, res) => {\n      res.sendFile(samLogoPath)\n    })\n    const event = makeEvent({\n      eventSourceName,\n      path: '/sam',\n      httpMethod: 'GET'\n    })\n\n    const response = await serverlessExpressInstance(event)\n\n    const samLogoImage = fs.readFileSync(samLogoPath)\n    const samLogoBase64 = Buffer.from(samLogoImage).toString('base64')\n    const expectedResponse = makeResponse({\n      eventSourceName,\n      body: samLogoBase64,\n      multiValueHeaders: {\n        'accept-ranges': ['bytes'],\n        'cache-control': ['public, max-age=0'],\n        'content-length': ['15933'],\n        'content-type': ['image/png']\n      },\n      isBase64Encoded: true\n    }, { shouldConvertContentLengthToInt: true })\n    const etagRegex = /^W\/.*$/\n    const lastModifiedRegex = /^.* GMT$/\n    switch (eventSourceName) {\n      case 'alb':\n      case 'apiGatewayV1':\n        expect(response.multiValueHeaders.etag.length).toEqual(1)\n        expect(response.multiValueHeaders.etag[0]).toMatch(etagRegex)\n        expect(response.multiValueHeaders['last-modified'].length).toEqual(1)\n        expect(response.multiValueHeaders['last-modified'][0]).toMatch(lastModifiedRegex)\n        delete response.multiValueHeaders.etag\n        delete response.multiValueHeaders['last-modified']\n        break\n      case 'azureHttpFunctionV4':\n      case 'azureHttpFunctionV3':\n        expectedResponse.body = Buffer.from(samLogoBase64, 'base64')\n        expectedResponse.isBase64Encoded = false\n        expect(response.headers.etag).toMatch(etagRegex)\n        expect(response.headers['last-modified']).toMatch(lastModifiedRegex)\n        delete response.headers.etag\n        delete response.headers['last-modified']\n        break\n      case 'apiGatewayV2':\n        expect(response.headers.etag).toMatch(etagRegex)\n        expect(response.headers['last-modified']).toMatch(lastModifiedRegex)\n        delete response.headers.etag\n        delete response.headers['last-modified']\n        break\n      case 'lambdaEdge':\n        expect(response.headers.etag.length).toEqual(1)\n        expect(response.headers.etag[0].key).toMatch('etag')\n        expect(response.headers.etag[0].value).toMatch(etagRegex)\n        expect(response.headers['last-modified'].length).toEqual(1)\n        expect(response.headers['last-modified'][0].key).toMatch('last-modified')\n        expect(response.headers['last-modified'][0].value).toMatch(lastModifiedRegex)\n        delete response.headers.etag\n        delete response.headers['last-modified']\n        break\n    }\n    expect(response).toEqual(expectedResponse)\n  })",43,7,16.27906976744186,12732.667739518913,0.05258406968203459,70.14499985415776,"  test('GET image', async () => {\n    const samLogoPath = path.join(jestHelpersPath, 'sam-logo.png')\n    const samLogoSize = 15933 // Size of the sam-logo.png file in bytes\n    router.get('/sam', (req, res) => {\n      res.sendFile(samLogoPath)\n    })\n    const event = makeEvent({\n      eventSourceName,\n      path: '/sam',\n      httpMethod: 'GET'\n    })\n\n    const response = await serverlessExpressInstance(event)\n\n    const samLogoImage = fs.readFileSync(samLogoPath)\n    const samLogoBase64 = Buffer.from(samLogoImage).toString('base64')\n    const expectedResponse = makeResponse({\n      eventSourceName,\n      body: samLogoBase64,\n      multiValueHeaders: {\n        'accept-ranges': ['bytes'],\n        'cache-control': ['public, max-age=0'],\n        'content-length': [samLogoSize.toString()],\n        'content-type': ['image/png']\n      },\n      isBase64Encoded: true\n    }, { shouldConvertContentLengthToInt: true })\n    const etagRegex = /^W\/.*$/\n    const lastModifiedRegex = /^.* GMT$/\n    switch (eventSourceName) {\n      case 'alb':\n      case 'apiGatewayV1':\n        expect(response.multiValueHeaders.etag.length).toEqual(1)\n        expect(response.multiValueHeaders.etag[0]).toMatch(etagRegex)\n        expect(response.multiValueHeaders['last-modified'].length).toEqual(1)\n        expect(response.multiValueHeaders['last-modified'][0]).toMatch(lastModifiedRegex)\n        delete response.multiValueHeaders.etag\n        delete response.multiValueHeaders['last-modified']\n        break\n      case 'azureHttpFunctionV4':\n      case 'azureHttpFunctionV3':\n        expectedResponse.body = Buffer.from(samLogoBase64, 'base64')\n        expectedResponse.isBase64Encoded = false\n        expect(response.headers.etag).toMatch(etagRegex)\n        expect(response.headers['last-modified']).toMatch(lastModifiedRegex)\n        delete response.headers.etag\n        delete response.headers['last-modified']\n        break\n      case 'apiGatewayV2':\n        expect(response.headers.etag).toMatch(etagRegex)\n        expect(response.headers['last-modified']).toMatch(lastModifiedRegex)\n        delete response.headers.etag\n        delete response.headers['last-modified']\n        break\n      case 'lambdaEdge':\n        expect(response.headers.etag.length).toEqual(1)\n        expect(response.headers.etag[0].key).toMatch('etag')\n        expect(response.headers.etag[0].value).toMatch(etagRegex)\n        expect(response.headers['last-modified'].length).toEqual(1)\n        expect(response.headers['last-modified'][0].key).toMatch('last-modified')\n        expect(response.headers['last-modified'][0].value).toMatch(lastModifiedRegex)\n        delete response.headers.etag\n        delete response.headers['last-modified']\n        break\n    }\n    expect(response).toEqual(expectedResponse)\n  })",44,7,15.909090909090908,12959.57095281545,0.05324492742438477,69.67515292938478
148,"    test('custom logger', async () => {\n      app = express()\n      router = express.Router()\n      app.use('/', router)\n      router.get('/users', (req, res) => {\n        res.json({})\n      })\n      const event = makeEvent({\n        eventSourceName,\n        path: '/users',\n        httpMethod: 'GET'\n      })\n      const customLogger = {\n        error: jest.fn(),\n        warn: jest.fn(),\n        info: jest.fn(),\n        verbose: jest.fn(),\n        debug: jest.fn()\n      }\n      serverlessExpressInstance = serverlessExpress({ app, log: customLogger })\n      await serverlessExpressInstance(event)\n\n      expect(customLogger.debug.mock.calls.length).toBe(6)\n\n      // TODO: test log levels\n      // customLogger.level = 'error'\n      // customLogger.debug.mockClear()\n      // customLogger.debug.mockReset()\n      // customLogger.debug = jest.fn()\n\n      // serverlessExpressInstance = serverlessExpress({ app, log: customLogger })\n      // await serverlessExpressInstance(event)\n      // expect(customLogger.debug.mock.calls.length).toBe(0)\n    })",13,1,7.6923076923076925,1162.3480379647897,0.02046248474371267,97.33361761994476,"    test('custom logger', async () => {\n      app = express()\n      router = express.Router()\n      app.use('/', router)\n      router.get('/users', (req, res) => {\n      res.json({})\n      })\n      const event = makeEvent({\n      eventSourceName,\n      path: '/users',\n      httpMethod: 'GET'\n      })\n      const customLogger = {\n      error: jest.fn(),\n      warn: jest.fn(),\n      info: jest.fn(),\n      verbose: jest.fn(),\n      debug: jest.fn()\n      }\n      serverlessExpressInstance = serverlessExpress({ app, log: customLogger })\n      await serverlessExpressInstance(event)\n\n      const expectedDebugCallCount = 6; // Number of debug calls expected during the test\n      expect(customLogger.debug.mock.calls.length).toBe(expectedDebugCallCount)\n\n      // TODO: test log levels\n      // customLogger.level = 'error'\n      // customLogger.debug.mockClear()\n      // customLogger.debug.mockReset()\n      // customLogger.debug = jest.fn()\n\n      // serverlessExpressInstance = serverlessExpress({ app, log: customLogger })\n      // await serverlessExpressInstance(event)\n      // expect(customLogger.debug.mock.calls.length).toBe(0)\n    })",14,1,7.142857142857142,1203.9064366001953,0.020856753704259292,95.98420845580239
