<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title></title>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bulma@0.9.0/css/bulma.min.css">
  <style type="text/css">
    .details-row.hidden {
      display: none;
    }
  </style>
</head>

<body>
  <section class="hero is-dark welcome is-small is-bold">
    <div class="hero-body">
      <div class="container">
        <h1 class="title">
          STEEL - teST smElls dEtection tooL
        </h1>
        <h2 class="subtitle">
          Report for "steel" () project.
        </h2>
      </div>
    </div>
  </section>
  <section class="section">
    <div class="container">
      <div>
        <div class="columns">
          <div class="column">
            <div class="box notification is-info">
              <div class="heading">Test Suites</div>
              <div class="title">8</div>
            </div>
          </div>
          <div class="column">
            <div class="box notification is-success">
              <div class="heading">Test Cases</div>
              <div class="title">670</div>
            </div>
          </div>
          <div class="column">
            <div class="box notification is-warning">
              <div class="heading">Smelled Test Suites</div>
              <div class="title">7</div>
            </div>
          </div>
          <div class="column">
            <div class="box notification is-danger">
              <div class="heading">Detected Smells</div>
              <div class="title">678</div>
            </div>
          </div>
        </div>

        <table class="table is-fullwidth" id="table-of-suites">
          <thead>
            <tr>
              <th>File</th>
              <th class="has-text-right">smells</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td>
                <a class="toggle-link" href="javascript:;" onclick="toggleDetails(this)">+ &#x2F;home&#x2F;gabriel&#x2F;Desktop&#x2F;research&#x2F;projects&#x2F;katex&#x2F;test&#x2F;unicode-spec.js</a>
              </td>
              <td class="has-text-right">33</td>
            </tr>
            <tr class="details-row hidden">
              <td colspan="2">
                <div class="columns is-multiline is-centered">
                  <div class="column is-one-quarter">
                    <div class="box px-4 py-4">
                      <div class="heading">Physical SLOC</div>
                      <div class="title has-text-weight-light is-size-4">168</div>
                    </div>
                  </div>
                  <div class="column is-one-quarter">
                    <div class="box px-4 py-4">
                      <div class="heading">Logical SLOC</div>
                      <div class="title has-text-weight-light is-size-4">168</div>
                    </div>
                  </div>
                  <div class="column is-one-quarter">
                    <div class="box px-4 py-4">
                      <div class="heading">Cyclomatic</div>
                      <div class="title has-text-weight-light is-size-4">36</div>
                    </div>
                  </div>
                  <div class="column is-one-quarter">
                    <div class="box px-4 py-4">
                      <div class="heading">Cyclomatic Density</div>
                      <div class="title has-text-weight-light is-size-4">21.429</div>
                    </div>
                  </div>
                  <div class="column is-one-quarter">
                    <div class="box px-4 py-4">
                      <div class="heading">Halstead Bugs</div>
                      <div class="title has-text-weight-light is-size-4">1.245</div>
                    </div>
                  </div>
                  <div class="column is-one-quarter">
                    <div class="box px-4 py-4">
                      <div class="heading">Halstead Difficulty</div>
                      <div class="title has-text-weight-light is-size-4">25.636</div>
                    </div>
                  </div>
                  <div class="column is-one-quarter">
                    <div class="box px-4 py-4">
                      <div class="heading">Halstead effort</div>
                      <div class="title has-text-weight-light is-size-4">95774.883</div>
                    </div>
                  </div>
                  <div class="column is-one-quarter">
                    <div class="box px-4 py-4">
                      <div class="heading">Halstead Length</div>
                      <div class="title has-text-weight-light is-size-4">532</div>
                    </div>
                  </div>
                  <div class="column is-one-quarter">
                    <div class="box px-4 py-4">
                      <div class="heading">Halstead Time</div>
                      <div class="title has-text-weight-light is-size-4">5320.827</div>
                    </div>
                  </div>
                  <div class="column is-one-quarter">
                    <div class="box px-4 py-4">
                      <div class="heading">Halstead Vocabulary</div>
                      <div class="title has-text-weight-light is-size-4">130</div>
                    </div>
                  </div>
                  <div class="column is-one-quarter">
                    <div class="box px-4 py-4">
                      <div class="heading">Halstead Volume</div>
                      <div class="title has-text-weight-light is-size-4">3735.9</div>
                    </div>
                  </div>
                  <div class="column is-one-quarter">
                    <div class="box px-4 py-4">
                      <div class="heading">Maintainability</div>
                      <div class="title has-text-weight-light is-size-4">115.991</div>
                    </div>
                  </div>
                </div>
                <hr>
                <table class="table is-fullwidth" id="table-of-smell">
                  <thead>
                    <tr>
                      <td>Conditional Test Logic</td>
                    </tr>
                  </thead>
                  <tbody>
                    <tr>
                      <td>
                        <pre><code>  18 |     it(&quot;should not parse Latin-1 outside \\text{} with strict&quot;, function() {
  19 |         const chars &#x3D; &#39;ÀÁÂÃÄÅÈÉÊËÌÍÎÏÑÒÓÔÕÖÙÚÛÜÝàáâãäåèéêëìíîïñòóôõöùúûüýÿÇÐÞçþ&#39;;
&gt; 20 |         for (const ch of chars) {
     |        ^ Conditional Test Logic
  21 |             expect(ch).not.toParse(strictSettings);
  22 |         }
  23 |     });</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  142 |
  143 |     it(&quot;supportedCodepoint() should return the correct values&quot;, () &#x3D;&gt; {
&gt; 144 |         for (let codepoint &#x3D; 0; codepoint &lt;&#x3D; 0xffff; codepoint++) {
      |        ^ Conditional Test Logic
  145 |             expect(supportedCodepoint(codepoint)).toBe(
  146 |                 allRegExp.test(String.fromCharCode(codepoint))
  147 |             );</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  150 |
  151 |     it(&quot;scriptFromCodepoint() should return correct values&quot;, () &#x3D;&gt; {
&gt; 152 |         outer: for (let codepoint &#x3D; 0; codepoint &lt;&#x3D; 0xffff; codepoint++) {
      |               ^ Conditional Test Logic
  153 |             const character &#x3D; String.fromCharCode(codepoint);
  154 |             const script &#x3D; scriptFromCodepoint(codepoint);
  155 |</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  154 |             const script &#x3D; scriptFromCodepoint(codepoint);
  155 |
&gt; 156 |             for (const scriptName of scriptNames) {
      |            ^ Conditional Test Logic
  157 |                 if (scriptRegExps[scriptName].test(character)) {
  158 |                     expect(script).toEqual(scriptName);
  159 |                     continue outer;</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  155 |
  156 |             for (const scriptName of scriptNames) {
&gt; 157 |                 if (scriptRegExps[scriptName].test(character)) {
      |                ^ Conditional Test Logic
  158 |                     expect(script).toEqual(scriptName);
  159 |                     continue outer;
  160 |                 }</code></pre><br>
                      </td>
                    </tr>
                  </tbody>
                </table>
                <hr>
                <table class="table is-fullwidth" id="table-of-smell">
                  <thead>
                    <tr>
                      <td>Duplicate Assert</td>
                    </tr>
                  </thead>
                  <tbody>
                    <tr>
                      <td>
                        <pre><code>  156 |             for (const scriptName of scriptNames) {
  157 |                 if (scriptRegExps[scriptName].test(character)) {
&gt; 158 |                     expect(script).toEqual(scriptName);
      |                    ^ Duplicate Assert
  159 |                     continue outer;
  160 |                 }
  161 |             }</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  161 |             }
  162 |
&gt; 163 |             expect(script).toBe(null);
      |            ^ Duplicate Assert
  164 |             expect(supportedCodepoint(codepoint)).toBe(false);
  165 |         }
  166 |     });</code></pre><br>
                      </td>
                    </tr>
                  </tbody>
                </table>
                <hr>
                <table class="table is-fullwidth" id="table-of-smell">
                  <thead>
                    <tr>
                      <td>Eager Test</td>
                    </tr>
                  </thead>
                  <tbody>
                    <tr>
                      <td>
                        <pre><code>  152 |         outer: for (let codepoint &#x3D; 0; codepoint &lt;&#x3D; 0xffff; codepoint++) {
  153 |             const character &#x3D; String.fromCharCode(codepoint);
&gt; 154 |             const script &#x3D; scriptFromCodepoint(codepoint);
      |                           ^ Eager Test
  155 |
  156 |             for (const scriptName of scriptNames) {
  157 |                 if (scriptRegExps[scriptName].test(character)) {</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  162 |
  163 |             expect(script).toBe(null);
&gt; 164 |             expect(supportedCodepoint(codepoint)).toBe(false);
      |                   ^ Eager Test
  165 |         }
  166 |     });
  167 | });</code></pre><br>
                      </td>
                    </tr>
                  </tbody>
                </table>
                <hr>
                <table class="table is-fullwidth" id="table-of-smell">
                  <thead>
                    <tr>
                      <td>Lazy Test</td>
                    </tr>
                  </thead>
                  <tbody>
                    <tr>
                      <td>
                        <pre><code>  143 |     it(&quot;supportedCodepoint() should return the correct values&quot;, () &#x3D;&gt; {
  144 |         for (let codepoint &#x3D; 0; codepoint &lt;&#x3D; 0xffff; codepoint++) {
&gt; 145 |             expect(supportedCodepoint(codepoint)).toBe(
      |                   ^ Lazy Test
  146 |                 allRegExp.test(String.fromCharCode(codepoint))
  147 |             );
  148 |         }</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  162 |
  163 |             expect(script).toBe(null);
&gt; 164 |             expect(supportedCodepoint(codepoint)).toBe(false);
      |                   ^ Lazy Test
  165 |         }
  166 |     });
  167 | });</code></pre><br>
                      </td>
                    </tr>
                  </tbody>
                </table>
                <hr>
                <table class="table is-fullwidth" id="table-of-smell">
                  <thead>
                    <tr>
                      <td>Unknown Test</td>
                    </tr>
                  </thead>
                  <tbody>
                    <tr>
                      <td>
                        <pre><code>   5 |
   6 | describe(&quot;unicode&quot;, function() {
&gt;  7 |     it(&quot;should build Latin-1 inside \\text{}&quot;, function() {
     |    ^ Unknown Test
   8 |         expect&#x60;\text{ÀÁÂÃÄÅÈÉÊËÌÍÎÏÑÒÓÔÕÖÙÚÛÜÝàáâãäåèéêëìíîïñòóôõöùúûüýÿÆÇÐØÞßæçðøþ}&#x60;
   9 |             .toBuild();
  10 |     });</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  10 |     });
  11 |
&gt; 12 |     it(&quot;should build Latin-1 inside \\text{} like accent commands&quot;, function() {
     |    ^ Unknown Test
  13 |         expect&#x60;\text{ÀÁÂÃÄÅÈÉÊËÌÍÎÏÑÒÓÔÕÖÙÚÛÜÝàáâãäåèéêëìíîïñòóôõöùúûüýÿÇç}&#x60;
  14 |             .toParseLike&#x60;\text{\&#x60;A\&#39;A\^A\~A\&quot;A\r A\&#x60;E\&#39;E\^E\&quot;E\&#x60;I\&#39;I\^I\&quot;I\~N\&#x60;O\&#39;O\^O\~O\&quot;O\&#x60;U\&#39;U\^U\&quot;U\&#39;Y\&#x60;a\&#39;a\^a\~a\&quot;a\r a\&#x60;e\&#39;e\^e\&quot;e\&#x60;ı\&#39;ı\^ı\&quot;ı\~n\&#x60;o\&#39;o\^o\~o\&quot;o\&#x60;u\&#39;u\^u\&quot;u\&#39;y\&quot;y\c C\c c}&#x60;;
  15 |         &#x2F;&#x2F; TODO(edemaine): A few characters don&#39;t have analogs yet.</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  23 |     });
  24 |
&gt; 25 |     it(&quot;should build Latin-1 outside \\text{}&quot;, function() {
     |    ^ Unknown Test
  26 |         expect&#x60;ÀÁÂÃÄÅÈÉÊËÌÍÎÏÑÒÓÔÕÖÙÚÛÜÝàáâãäåèéêëìíîïñòóôõöùúûüýÿÇÐÞçðþ&#x60;
  27 |             .toBuild(nonstrictSettings);
  28 |     });</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  28 |     });
  29 |
&gt; 30 |     it(&quot;should build all lower case Greek letters&quot;, function() {
     |    ^ Unknown Test
  31 |         expect&#x60;αβγδεϵζηθϑικλμνξοπϖρϱςστυφϕχψω&#x60;.toBuild();
  32 |     });
  33 |</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  32 |     });
  33 |
&gt; 34 |     it(&quot;should build math upper case Greek letters&quot;, function() {
     |    ^ Unknown Test
  35 |         expect&#x60;ΓΔΘΛΞΠΣΥΦΨΩ&#x60;.toBuild();
  36 |     });
  37 |</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  36 |     });
  37 |
&gt; 38 |     it(&quot;should build Cyrillic inside \\text{}&quot;, function() {
     |    ^ Unknown Test
  39 |         expect&#x60;\text{БГДЖЗЙЛФЦШЫЮЯ}&#x60;.toBuild();
  40 |     });
  41 |</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  40 |     });
  41 |
&gt; 42 |     it(&quot;should build Cyrillic outside \\text{}&quot;, function() {
     |    ^ Unknown Test
  43 |         expect&#x60;БГДЖЗЙЛФЦШЫЮЯ&#x60;.toBuild(nonstrictSettings);
  44 |     });
  45 |</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  44 |     });
  45 |
&gt; 46 |     it(&quot;should not parse Cyrillic outside \\text{} with strict&quot;, function() {
     |    ^ Unknown Test
  47 |         expect&#x60;БГДЖЗЙЛФЦШЫЮЯ&#x60;.not.toParse(strictSettings);
  48 |     });
  49 |</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  48 |     });
  49 |
&gt; 50 |     it(&quot;should build CJK inside \\text{}&quot;, function() {
     |    ^ Unknown Test
  51 |         expect&#x60;\text{私はバナナです}&#x60;.toBuild();
  52 |         expect&#x60;\text{여보세요}&#x60;.toBuild();
  53 |     });</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  53 |     });
  54 |
&gt; 55 |     it(&quot;should build CJK outside \\text{}&quot;, function() {
     |    ^ Unknown Test
  56 |         expect&#x60;私はバナナです&#x60;.toBuild(nonstrictSettings);
  57 |         expect&#x60;여보세요&#x60;.toBuild(nonstrictSettings);
  58 |     });</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  58 |     });
  59 |
&gt; 60 |     it(&quot;should not parse CJK outside \\text{} with strict&quot;, function() {
     |    ^ Unknown Test
  61 |         expect&#x60;私はバナナです。&#x60;.not.toParse(strictSettings);
  62 |         expect&#x60;여보세요&#x60;.not.toParse(strictSettings);
  63 |     });</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  63 |     });
  64 |
&gt; 65 |     it(&quot;should build Devanagari inside \\text{}&quot;, function() {
     |    ^ Unknown Test
  66 |         expect&#x60;\text{नमस्ते}&#x60;.toBuild();
  67 |     });
  68 |</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  67 |     });
  68 |
&gt; 69 |     it(&quot;should build Devanagari outside \\text{}&quot;, function() {
     |    ^ Unknown Test
  70 |         expect&#x60;नमस्ते&#x60;.toBuild(nonstrictSettings);
  71 |     });
  72 |</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  71 |     });
  72 |
&gt; 73 |     it(&quot;should not parse Devanagari outside \\text{} with strict&quot;, function() {
     |    ^ Unknown Test
  74 |         expect&#x60;नमस्ते&#x60;.not.toParse(strictSettings);
  75 |     });
  76 |</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  75 |     });
  76 |
&gt; 77 |     it(&quot;should build Georgian inside \\text{}&quot;, function() {
     |    ^ Unknown Test
  78 |         expect&#x60;\text{გამარჯობა}&#x60;.toBuild();
  79 |     });
  80 |</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  79 |     });
  80 |
&gt; 81 |     it(&quot;should build Georgian outside \\text{}&quot;, function() {
     |    ^ Unknown Test
  82 |         expect&#x60;გამარჯობა&#x60;.toBuild(nonstrictSettings);
  83 |     });
  84 |</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  83 |     });
  84 |
&gt; 85 |     it(&quot;should not parse Georgian outside \\text{} with strict&quot;, function() {
     |    ^ Unknown Test
  86 |         expect&#x60;გამარჯობა&#x60;.not.toParse(strictSettings);
  87 |     });
  88 |</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  87 |     });
  88 |
&gt; 89 |     it(&quot;should build Armenian both inside and outside \\text{}&quot;, function() {
     |    ^ Unknown Test
  90 |         expect&#x60;ԱԲԳաբգ&#x60;.toBuild(nonstrictSettings);
  91 |         expect&#x60;\text{ԱԲԳաբգ}&#x60;.toBuild(nonstrictSettings);
  92 |     });</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  92 |     });
  93 |
&gt; 94 |     it(&quot;should build extended Latin characters inside \\text{}&quot;, function() {
     |    ^ Unknown Test
  95 |         expect&#x60;\text{ěščřžůřťďňőİı}&#x60;.toBuild();
  96 |     });
  97 |</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>   96 |     });
   97 |
&gt;  98 |     it(&quot;should not parse extended Latin outside \\text{} with strict&quot;, function() {
      |    ^ Unknown Test
   99 |         expect&#x60;ěščřžůřťďňőİı&#x60;.not.toParse(strictSettings);
  100 |     });
  101 |</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  100 |     });
  101 |
&gt; 102 |     it(&quot;should not allow emoji in strict mode&quot;, function() {
      |    ^ Unknown Test
  103 |         expect&#x60;✌&#x60;.not.toParse(strictSettings);
  104 |         expect&#x60;\text{✌}&#x60;.not.toParse(strictSettings);
  105 |         const settings &#x3D; new Settings({</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  111 |     });
  112 |
&gt; 113 |     it(&quot;should allow emoji outside strict mode&quot;, function() {
      |    ^ Unknown Test
  114 |         expect&#x60;✌&#x60;.toWarn();
  115 |         expect&#x60;\text{✌}&#x60;.toWarn();
  116 |         const settings &#x3D; new Settings({</code></pre><br>
                      </td>
                    </tr>
                  </tbody>
                </table>
              </td>
            </tr>
            <tr>
              <td>
                <a class="toggle-link" href="javascript:;" onclick="toggleDetails(this)">+ &#x2F;home&#x2F;gabriel&#x2F;Desktop&#x2F;research&#x2F;projects&#x2F;katex&#x2F;test&#x2F;screenshotter-spec.js</a>
              </td>
              <td class="has-text-right">2</td>
            </tr>
            <tr class="details-row hidden">
              <td colspan="2">
                <div class="columns is-multiline is-centered">
                  <div class="column is-one-quarter">
                    <div class="box px-4 py-4">
                      <div class="heading">Physical SLOC</div>
                      <div class="title has-text-weight-light is-size-4">20</div>
                    </div>
                  </div>
                  <div class="column is-one-quarter">
                    <div class="box px-4 py-4">
                      <div class="heading">Logical SLOC</div>
                      <div class="title has-text-weight-light is-size-4">18</div>
                    </div>
                  </div>
                  <div class="column is-one-quarter">
                    <div class="box px-4 py-4">
                      <div class="heading">Cyclomatic</div>
                      <div class="title has-text-weight-light is-size-4">4</div>
                    </div>
                  </div>
                  <div class="column is-one-quarter">
                    <div class="box px-4 py-4">
                      <div class="heading">Cyclomatic Density</div>
                      <div class="title has-text-weight-light is-size-4">22.222</div>
                    </div>
                  </div>
                  <div class="column is-one-quarter">
                    <div class="box px-4 py-4">
                      <div class="heading">Halstead Bugs</div>
                      <div class="title has-text-weight-light is-size-4">0.125</div>
                    </div>
                  </div>
                  <div class="column is-one-quarter">
                    <div class="box px-4 py-4">
                      <div class="heading">Halstead Difficulty</div>
                      <div class="title has-text-weight-light is-size-4">10.292</div>
                    </div>
                  </div>
                  <div class="column is-one-quarter">
                    <div class="box px-4 py-4">
                      <div class="heading">Halstead effort</div>
                      <div class="title has-text-weight-light is-size-4">3860.205</div>
                    </div>
                  </div>
                  <div class="column is-one-quarter">
                    <div class="box px-4 py-4">
                      <div class="heading">Halstead Length</div>
                      <div class="title has-text-weight-light is-size-4">72</div>
                    </div>
                  </div>
                  <div class="column is-one-quarter">
                    <div class="box px-4 py-4">
                      <div class="heading">Halstead Time</div>
                      <div class="title has-text-weight-light is-size-4">214.456</div>
                    </div>
                  </div>
                  <div class="column is-one-quarter">
                    <div class="box px-4 py-4">
                      <div class="heading">Halstead Vocabulary</div>
                      <div class="title has-text-weight-light is-size-4">37</div>
                    </div>
                  </div>
                  <div class="column is-one-quarter">
                    <div class="box px-4 py-4">
                      <div class="heading">Halstead Volume</div>
                      <div class="title has-text-weight-light is-size-4">375.081</div>
                    </div>
                  </div>
                  <div class="column is-one-quarter">
                    <div class="box px-4 py-4">
                      <div class="heading">Maintainability</div>
                      <div class="title has-text-weight-light is-size-4">117.199</div>
                    </div>
                  </div>
                </div>
                <hr>
                <table class="table is-fullwidth" id="table-of-smell">
                  <thead>
                    <tr>
                      <td>Conditional Test Logic</td>
                    </tr>
                  </thead>
                  <tbody>
                    <tr>
                      <td>
                        <pre><code>  2 |
  3 | describe(&quot;Screenshotter item&quot;, function() {
&gt; 4 |     for (const key in data) {
    |    ^ Conditional Test Logic
  5 |         if (data.hasOwnProperty(key)) {
  6 |             const item &#x3D; data[key];
  7 |             it(&#x60;&quot;${item.tex}&quot; should build successfully&#x60;, function() {</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  3 | describe(&quot;Screenshotter item&quot;, function() {
  4 |     for (const key in data) {
&gt; 5 |         if (data.hasOwnProperty(key)) {
    |        ^ Conditional Test Logic
  6 |             const item &#x3D; data[key];
  7 |             it(&#x60;&quot;${item.tex}&quot; should build successfully&#x60;, function() {
  8 |                 expect(item.tex).toBuild({</code></pre><br>
                      </td>
                    </tr>
                  </tbody>
                </table>
              </td>
            </tr>
            <tr>
              <td>
                <a class="toggle-link" href="javascript:;" onclick="toggleDetails(this)">+ &#x2F;home&#x2F;gabriel&#x2F;Desktop&#x2F;research&#x2F;projects&#x2F;katex&#x2F;test&#x2F;mathml-spec.js</a>
              </td>
              <td class="has-text-right">1</td>
            </tr>
            <tr class="details-row hidden">
              <td colspan="2">
                <div class="columns is-multiline is-centered">
                  <div class="column is-one-quarter">
                    <div class="box px-4 py-4">
                      <div class="heading">Physical SLOC</div>
                      <div class="title has-text-weight-light is-size-4">154</div>
                    </div>
                  </div>
                  <div class="column is-one-quarter">
                    <div class="box px-4 py-4">
                      <div class="heading">Logical SLOC</div>
                      <div class="title has-text-weight-light is-size-4">156</div>
                    </div>
                  </div>
                  <div class="column is-one-quarter">
                    <div class="box px-4 py-4">
                      <div class="heading">Cyclomatic</div>
                      <div class="title has-text-weight-light is-size-4">27</div>
                    </div>
                  </div>
                  <div class="column is-one-quarter">
                    <div class="box px-4 py-4">
                      <div class="heading">Cyclomatic Density</div>
                      <div class="title has-text-weight-light is-size-4">17.308</div>
                    </div>
                  </div>
                  <div class="column is-one-quarter">
                    <div class="box px-4 py-4">
                      <div class="heading">Halstead Bugs</div>
                      <div class="title has-text-weight-light is-size-4">1.081</div>
                    </div>
                  </div>
                  <div class="column is-one-quarter">
                    <div class="box px-4 py-4">
                      <div class="heading">Halstead Difficulty</div>
                      <div class="title has-text-weight-light is-size-4">18.851</div>
                    </div>
                  </div>
                  <div class="column is-one-quarter">
                    <div class="box px-4 py-4">
                      <div class="heading">Halstead effort</div>
                      <div class="title has-text-weight-light is-size-4">61131.825</div>
                    </div>
                  </div>
                  <div class="column is-one-quarter">
                    <div class="box px-4 py-4">
                      <div class="heading">Halstead Length</div>
                      <div class="title has-text-weight-light is-size-4">472</div>
                    </div>
                  </div>
                  <div class="column is-one-quarter">
                    <div class="box px-4 py-4">
                      <div class="heading">Halstead Time</div>
                      <div class="title has-text-weight-light is-size-4">3396.213</div>
                    </div>
                  </div>
                  <div class="column is-one-quarter">
                    <div class="box px-4 py-4">
                      <div class="heading">Halstead Vocabulary</div>
                      <div class="title has-text-weight-light is-size-4">117</div>
                    </div>
                  </div>
                  <div class="column is-one-quarter">
                    <div class="box px-4 py-4">
                      <div class="heading">Halstead Volume</div>
                      <div class="title has-text-weight-light is-size-4">3242.812</div>
                    </div>
                  </div>
                  <div class="column is-one-quarter">
                    <div class="box px-4 py-4">
                      <div class="heading">Maintainability</div>
                      <div class="title has-text-weight-light is-size-4">115.387</div>
                    </div>
                  </div>
                </div>
                <hr>
                <table class="table is-fullwidth" id="table-of-smell">
                  <thead>
                    <tr>
                      <td>Conditional Test Logic</td>
                    </tr>
                  </thead>
                  <tbody>
                    <tr>
                      <td>
                        <pre><code>   7 | const getMathML &#x3D; function(expr, settings &#x3D; new Settings()) {
   8 |     let startStyle &#x3D; Style.TEXT;
&gt;  9 |     if (settings.displayMode) {
     |    ^ Conditional Test Logic
  10 |         startStyle &#x3D; Style.DISPLAY;
  11 |     }
  12 |</code></pre><br>
                      </td>
                    </tr>
                  </tbody>
                </table>
              </td>
            </tr>
            <tr>
              <td>
                <a class="toggle-link" href="javascript:;" onclick="toggleDetails(this)">+ &#x2F;home&#x2F;gabriel&#x2F;Desktop&#x2F;research&#x2F;projects&#x2F;katex&#x2F;test&#x2F;katex-spec.js</a>
              </td>
              <td class="has-text-right">565</td>
            </tr>
            <tr class="details-row hidden">
              <td colspan="2">
                <div class="columns is-multiline is-centered">
                  <div class="column is-one-quarter">
                    <div class="box px-4 py-4">
                      <div class="heading">Physical SLOC</div>
                      <div class="title has-text-weight-light is-size-4">4315</div>
                    </div>
                  </div>
                  <div class="column is-one-quarter">
                    <div class="box px-4 py-4">
                      <div class="heading">Logical SLOC</div>
                      <div class="title has-text-weight-light is-size-4">5524</div>
                    </div>
                  </div>
                  <div class="column is-one-quarter">
                    <div class="box px-4 py-4">
                      <div class="heading">Cyclomatic</div>
                      <div class="title has-text-weight-light is-size-4">730</div>
                    </div>
                  </div>
                  <div class="column is-one-quarter">
                    <div class="box px-4 py-4">
                      <div class="heading">Cyclomatic Density</div>
                      <div class="title has-text-weight-light is-size-4">13.215</div>
                    </div>
                  </div>
                  <div class="column is-one-quarter">
                    <div class="box px-4 py-4">
                      <div class="heading">Halstead Bugs</div>
                      <div class="title has-text-weight-light is-size-4">67.108</div>
                    </div>
                  </div>
                  <div class="column is-one-quarter">
                    <div class="box px-4 py-4">
                      <div class="heading">Halstead Difficulty</div>
                      <div class="title has-text-weight-light is-size-4">65.741</div>
                    </div>
                  </div>
                  <div class="column is-one-quarter">
                    <div class="box px-4 py-4">
                      <div class="heading">Halstead effort</div>
                      <div class="title has-text-weight-light is-size-4">13235293.802</div>
                    </div>
                  </div>
                  <div class="column is-one-quarter">
                    <div class="box px-4 py-4">
                      <div class="heading">Halstead Length</div>
                      <div class="title has-text-weight-light is-size-4">18073</div>
                    </div>
                  </div>
                  <div class="column is-one-quarter">
                    <div class="box px-4 py-4">
                      <div class="heading">Halstead Time</div>
                      <div class="title has-text-weight-light is-size-4">735294.1</div>
                    </div>
                  </div>
                  <div class="column is-one-quarter">
                    <div class="box px-4 py-4">
                      <div class="heading">Halstead Vocabulary</div>
                      <div class="title has-text-weight-light is-size-4">2256</div>
                    </div>
                  </div>
                  <div class="column is-one-quarter">
                    <div class="box px-4 py-4">
                      <div class="heading">Halstead Volume</div>
                      <div class="title has-text-weight-light is-size-4">201325.112</div>
                    </div>
                  </div>
                  <div class="column is-one-quarter">
                    <div class="box px-4 py-4">
                      <div class="heading">Maintainability</div>
                      <div class="title has-text-weight-light is-size-4">104.194</div>
                    </div>
                  </div>
                </div>
                <hr>
                <table class="table is-fullwidth" id="table-of-smell">
                  <thead>
                    <tr>
                      <td>Conditional Test Logic</td>
                    </tr>
                  </thead>
                  <tbody>
                    <tr>
                      <td>
                        <pre><code>  44 |         const parse &#x3D; getParsed(expression);
  45 |
&gt; 46 |         for (let i &#x3D; 0; i &lt; parse.length; i++) {
     |        ^ Conditional Test Logic
  47 |             const group &#x3D; parse[i];
  48 |             expect(group.type).toMatch(&quot;ord&quot;);
  49 |         }</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  67 |         const parse &#x3D; getParsed(expression);
  68 |
&gt; 69 |         for (let i &#x3D; 0; i &lt; parse.length; i++) {
     |        ^ Conditional Test Logic
  70 |             const group &#x3D; parse[i];
  71 |             expect(group.type).toEqual(&quot;atom&quot;);
  72 |             expect(group.family).toEqual(&quot;bin&quot;);</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  87 |         const parse &#x3D; getParsed(expression);
  88 |
&gt; 89 |         for (let i &#x3D; 0; i &lt; parse.length; i++) {
     |        ^ Conditional Test Logic
  90 |             let group &#x3D; parse[i];
  91 |             if (group.type &#x3D;&#x3D;&#x3D; &quot;htmlmathml&quot;) {
  92 |                 expect(group.html).toHaveLength(1);</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  89 |         for (let i &#x3D; 0; i &lt; parse.length; i++) {
  90 |             let group &#x3D; parse[i];
&gt; 91 |             if (group.type &#x3D;&#x3D;&#x3D; &quot;htmlmathml&quot;) {
     |            ^ Conditional Test Logic
  92 |                 expect(group.html).toHaveLength(1);
  93 |                 group &#x3D; group.html[0];
  94 |             }</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  93 |                 group &#x3D; group.html[0];
  94 |             }
&gt; 95 |             if (group.type &#x3D;&#x3D;&#x3D; &quot;mclass&quot;) {
     |            ^ Conditional Test Logic
  96 |                 expect(group.mclass).toEqual(&quot;mrel&quot;);
  97 |             } else {
  98 |                 expect(group.type).toEqual(&quot;atom&quot;);</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  126 |         const parse &#x3D; getParsed(expression);
  127 |
&gt; 128 |         for (let i &#x3D; 0; i &lt; parse.length; i++) {
      |        ^ Conditional Test Logic
  129 |             const group &#x3D; parse[i];
  130 |             expect(group.type).toEqual(&quot;atom&quot;);
  131 |             expect(group.family).toEqual(&quot;punct&quot;);</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  144 |         const parse &#x3D; getParsed(expression);
  145 |
&gt; 146 |         for (let i &#x3D; 0; i &lt; parse.length; i++) {
      |        ^ Conditional Test Logic
  147 |             const group &#x3D; parse[i];
  148 |             expect(group.type).toEqual(&quot;atom&quot;);
  149 |             expect(group.family).toEqual(&quot;open&quot;);</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  162 |         const parse &#x3D; getParsed(expression);
  163 |
&gt; 164 |         for (let i &#x3D; 0; i &lt; parse.length; i++) {
      |        ^ Conditional Test Logic
  165 |             const group &#x3D; parse[i];
  166 |             expect(group.type).toEqual(&quot;atom&quot;);
  167 |             expect(group.family).toEqual(&quot;close&quot;);</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  1261 |     ];
  1262 |
&gt; 1263 |     for (const [actual, expected] of cases) {
       |    ^ Conditional Test Logic
  1264 |         it(&#x60;should build &quot;${actual}&quot; like &quot;${expected}&quot;&#x60;, () &#x3D;&gt; {
  1265 |             expect(actual).toBuildLike(expected);
  1266 |         });</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  1410 |         ];
  1411 |
&gt; 1412 |         for (let i &#x3D; 0; i &lt; missingGroups.length; i++) {
       |        ^ Conditional Test Logic
  1413 |             expect(missingGroups[i]).not.toParse();
  1414 |         }
  1415 |     });</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  1437 |         ];
  1438 |
&gt; 1439 |         for (let i &#x3D; 0; i &lt; badArguments.length; i++) {
       |        ^ Conditional Test Logic
  1440 |             expect(badArguments[i]).not.toParse();
  1441 |         }
  1442 |     });</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  1455 |         ];
  1456 |
&gt; 1457 |         for (let i &#x3D; 0; i &lt; goodArguments.length; i++) {
       |        ^ Conditional Test Logic
  1458 |             expect(goodArguments[i]).toParse();
  1459 |         }
  1460 |     });</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  1468 |         ];
  1469 |
&gt; 1470 |         for (let i &#x3D; 0; i &lt; badSupSubscripts.length; i++) {
       |        ^ Conditional Test Logic
  1471 |             expect(badSupSubscripts[i]).not.toParse();
  1472 |         }
  1473 |     });</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  1481 |         ];
  1482 |
&gt; 1483 |         for (let i &#x3D; 0; i &lt; goodSupSubscripts.length; i++) {
       |        ^ Conditional Test Logic
  1484 |             expect(goodSupSubscripts[i]).toParse();
  1485 |         }
  1486 |     });</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  1519 |         ];
  1520 |
&gt; 1521 |         for (let i &#x3D; 0; i &lt; badLeftArguments.length; i++) {
       |        ^ Conditional Test Logic
  1522 |             expect(badLeftArguments[i]).not.toParse();
  1523 |         }
  1524 |     });</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  1533 |         ];
  1534 |
&gt; 1535 |         for (let i &#x3D; 0; i &lt; goodLeftArguments.length; i++) {
       |        ^ Conditional Test Logic
  1536 |             expect(goodLeftArguments[i]).toParse();
  1537 |         }
  1538 |     });</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  2171 |
  2172 |     it(&quot;should throw Error when HTML attribute name is invalid&quot;, function() {
&gt; 2173 |         for (const char of [&quot;&gt;&quot;, &quot; &quot;, &quot;\t&quot;, &quot;\n&quot;, &quot;\r&quot;, &quot;\&quot;&quot;, &quot;&#39;&quot;, &quot;&#x2F;&quot;]) {
       |        ^ Conditional Test Logic
  2174 |             try {
  2175 |                 katex.renderToString(
  2176 |                     &#x60;\\htmlData{a${char}b&#x3D;foo}{bar}&#x60;, trustNonStrictSettings);</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  3834 | describe(&quot;leqno and fleqn rendering options&quot;, () &#x3D;&gt; {
  3835 |     const expr &#x3D; r&#x60;\tag{hi}x+y&#x60;;
&gt; 3836 |     for (const opt of [&quot;leqno&quot;, &quot;fleqn&quot;]) {
       |    ^ Conditional Test Logic
  3837 |         it(&#x60;should not add ${opt} class by default&#x60;, () &#x3D;&gt; {
  3838 |             const settings &#x3D; new Settings({displayMode: true});
  3839 |             const built &#x3D; katex.__renderToDomTree(expr, settings);</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  4239 |         &#x2F;&#x2F; add eastern arabic numbers to symbols table
  4240 |         &#x2F;&#x2F; these symbols are ۰۱۲۳۴۵۶۷۸۹ and ٠١٢٣٤٥٦٧٨٩
&gt; 4241 |         for (let number &#x3D; 0; number &lt;&#x3D; 9; number++) {
       |        ^ Conditional Test Logic
  4242 |             const persianNum &#x3D; String.fromCharCode(0x0660 + number);
  4243 |             katex.__defineSymbol(
  4244 |                 &quot;math&quot;, fontName, &quot;textord&quot;, persianNum, persianNum);</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  4258 |         const mockMetrics &#x3D; {};
  4259 |         &#x2F;&#x2F; mock font metrics for the symbols that we added previously
&gt; 4260 |         for (let number &#x3D; 0; number &lt;&#x3D; 9; number++) {
       |        ^ Conditional Test Logic
  4261 |             mockMetrics[0x0660 + number] &#x3D; [-0.00244140625, 0.6875, 0, 0];
  4262 |             mockMetrics[0x06F0 + number] &#x3D; [-0.00244140625, 0.6875, 0, 0];
  4263 |         }</code></pre><br>
                      </td>
                    </tr>
                  </tbody>
                </table>
                <hr>
                <table class="table is-fullwidth" id="table-of-smell">
                  <thead>
                    <tr>
                      <td>Duplicate Assert</td>
                    </tr>
                  </thead>
                  <tbody>
                    <tr>
                      <td>
                        <pre><code>  573 |         parse &#x3D; getParsed(simpleOver)[0];
  574 |
&gt; 575 |         expect(parse.type).toEqual(&quot;genfrac&quot;);
      |        ^ Duplicate Assert
  576 |         expect(parse.numer).toBeDefined();
  577 |         expect(parse.denom).toBeDefined();
  578 |</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  573 |         parse &#x3D; getParsed(simpleOver)[0];
  574 |
&gt; 575 |         expect(parse.type).toEqual(&quot;genfrac&quot;);
      |        ^ Duplicate Assert
  576 |         expect(parse.numer).toBeDefined();
  577 |         expect(parse.denom).toBeDefined();
  578 |</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  574 |
  575 |         expect(parse.type).toEqual(&quot;genfrac&quot;);
&gt; 576 |         expect(parse.numer).toBeDefined();
      |        ^ Duplicate Assert
  577 |         expect(parse.denom).toBeDefined();
  578 |
  579 |         parse &#x3D; getParsed(complexOver)[0];</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  574 |
  575 |         expect(parse.type).toEqual(&quot;genfrac&quot;);
&gt; 576 |         expect(parse.numer).toBeDefined();
      |        ^ Duplicate Assert
  577 |         expect(parse.denom).toBeDefined();
  578 |
  579 |         parse &#x3D; getParsed(complexOver)[0];</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  575 |         expect(parse.type).toEqual(&quot;genfrac&quot;);
  576 |         expect(parse.numer).toBeDefined();
&gt; 577 |         expect(parse.denom).toBeDefined();
      |        ^ Duplicate Assert
  578 |
  579 |         parse &#x3D; getParsed(complexOver)[0];
  580 |</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  575 |         expect(parse.type).toEqual(&quot;genfrac&quot;);
  576 |         expect(parse.numer).toBeDefined();
&gt; 577 |         expect(parse.denom).toBeDefined();
      |        ^ Duplicate Assert
  578 |
  579 |         parse &#x3D; getParsed(complexOver)[0];
  580 |</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  579 |         parse &#x3D; getParsed(complexOver)[0];
  580 |
&gt; 581 |         expect(parse.type).toEqual(&quot;genfrac&quot;);
      |        ^ Duplicate Assert
  582 |         expect(parse.numer).toBeDefined();
  583 |         expect(parse.denom).toBeDefined();
  584 |</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  579 |         parse &#x3D; getParsed(complexOver)[0];
  580 |
&gt; 581 |         expect(parse.type).toEqual(&quot;genfrac&quot;);
      |        ^ Duplicate Assert
  582 |         expect(parse.numer).toBeDefined();
  583 |         expect(parse.denom).toBeDefined();
  584 |</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  580 |
  581 |         expect(parse.type).toEqual(&quot;genfrac&quot;);
&gt; 582 |         expect(parse.numer).toBeDefined();
      |        ^ Duplicate Assert
  583 |         expect(parse.denom).toBeDefined();
  584 |
  585 |         const parseBraceFrac &#x3D; getParsed(braceFrac)[0];</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  580 |
  581 |         expect(parse.type).toEqual(&quot;genfrac&quot;);
&gt; 582 |         expect(parse.numer).toBeDefined();
      |        ^ Duplicate Assert
  583 |         expect(parse.denom).toBeDefined();
  584 |
  585 |         const parseBraceFrac &#x3D; getParsed(braceFrac)[0];</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  581 |         expect(parse.type).toEqual(&quot;genfrac&quot;);
  582 |         expect(parse.numer).toBeDefined();
&gt; 583 |         expect(parse.denom).toBeDefined();
      |        ^ Duplicate Assert
  584 |
  585 |         const parseBraceFrac &#x3D; getParsed(braceFrac)[0];
  586 |</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  581 |         expect(parse.type).toEqual(&quot;genfrac&quot;);
  582 |         expect(parse.numer).toBeDefined();
&gt; 583 |         expect(parse.denom).toBeDefined();
      |        ^ Duplicate Assert
  584 |
  585 |         const parseBraceFrac &#x3D; getParsed(braceFrac)[0];
  586 |</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  1638 |         expect(bbBody).toHaveLength(3);
  1639 |         expect(bbBody[0].type).toEqual(&quot;mathord&quot;);
&gt; 1640 |         expect(bbBody[2].type).toEqual(&quot;font&quot;);
       |        ^ Duplicate Assert
  1641 |         expect(bbBody[2].font).toEqual(&quot;mathrm&quot;);
  1642 |         expect(bbBody[2].type).toEqual(&quot;font&quot;);
  1643 |     });</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  1638 |         expect(bbBody).toHaveLength(3);
  1639 |         expect(bbBody[0].type).toEqual(&quot;mathord&quot;);
&gt; 1640 |         expect(bbBody[2].type).toEqual(&quot;font&quot;);
       |        ^ Duplicate Assert
  1641 |         expect(bbBody[2].font).toEqual(&quot;mathrm&quot;);
  1642 |         expect(bbBody[2].type).toEqual(&quot;font&quot;);
  1643 |     });</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  1640 |         expect(bbBody[2].type).toEqual(&quot;font&quot;);
  1641 |         expect(bbBody[2].font).toEqual(&quot;mathrm&quot;);
&gt; 1642 |         expect(bbBody[2].type).toEqual(&quot;font&quot;);
       |        ^ Duplicate Assert
  1643 |     });
  1644 |
  1645 |     it(&quot;should work with \\textcolor&quot;, function() {</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  1640 |         expect(bbBody[2].type).toEqual(&quot;font&quot;);
  1641 |         expect(bbBody[2].font).toEqual(&quot;mathrm&quot;);
&gt; 1642 |         expect(bbBody[2].type).toEqual(&quot;font&quot;);
       |        ^ Duplicate Assert
  1643 |     });
  1644 |
  1645 |     it(&quot;should work with \\textcolor&quot;, function() {</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  1833 |     it(&quot;should render \\text{R\\textit{S}T} with the correct fonts&quot;, function() {
  1834 |         const markup &#x3D; katex.renderToString(r&#x60;\text{R\textit{S}T}&#x60;);
&gt; 1835 |         expect(markup).toContain(&quot;&lt;span class&#x3D;\&quot;mord\&quot;&gt;R&lt;&#x2F;span&gt;&quot;);
       |        ^ Duplicate Assert
  1836 |         expect(markup).toContain(&quot;&lt;span class&#x3D;\&quot;mord textit\&quot;&gt;S&lt;&#x2F;span&gt;&quot;);
  1837 |         expect(markup).toContain(&quot;&lt;span class&#x3D;\&quot;mord\&quot;&gt;T&lt;&#x2F;span&gt;&quot;);
  1838 |     });</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  1834 |         const markup &#x3D; katex.renderToString(r&#x60;\text{R\textit{S}T}&#x60;);
  1835 |         expect(markup).toContain(&quot;&lt;span class&#x3D;\&quot;mord\&quot;&gt;R&lt;&#x2F;span&gt;&quot;);
&gt; 1836 |         expect(markup).toContain(&quot;&lt;span class&#x3D;\&quot;mord textit\&quot;&gt;S&lt;&#x2F;span&gt;&quot;);
       |        ^ Duplicate Assert
  1837 |         expect(markup).toContain(&quot;&lt;span class&#x3D;\&quot;mord\&quot;&gt;T&lt;&#x2F;span&gt;&quot;);
  1838 |     });
  1839 |</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  1835 |         expect(markup).toContain(&quot;&lt;span class&#x3D;\&quot;mord\&quot;&gt;R&lt;&#x2F;span&gt;&quot;);
  1836 |         expect(markup).toContain(&quot;&lt;span class&#x3D;\&quot;mord textit\&quot;&gt;S&lt;&#x2F;span&gt;&quot;);
&gt; 1837 |         expect(markup).toContain(&quot;&lt;span class&#x3D;\&quot;mord\&quot;&gt;T&lt;&#x2F;span&gt;&quot;);
       |        ^ Duplicate Assert
  1838 |     });
  1839 |
  1840 |     it(&quot;should render \\textbf{R } with the correct font&quot;, function() {</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  1859 |     it(&quot;should render \\textsf{\\textit{R}G\\textbf{B}} with the correct font&quot;, function() {
  1860 |         const markup &#x3D; katex.renderToString(r&#x60;\textsf{\textit{R}G\textbf{B}}&#x60;);
&gt; 1861 |         expect(markup).toContain(&quot;&lt;span class&#x3D;\&quot;mord textsf textit\&quot;&gt;R&lt;&#x2F;span&gt;&quot;);
       |        ^ Duplicate Assert
  1862 |         expect(markup).toContain(&quot;&lt;span class&#x3D;\&quot;mord textsf\&quot;&gt;G&lt;&#x2F;span&gt;&quot;);
  1863 |         expect(markup).toContain(&quot;&lt;span class&#x3D;\&quot;mord textsf textbf\&quot;&gt;B&lt;&#x2F;span&gt;&quot;);
  1864 |     });</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  1860 |         const markup &#x3D; katex.renderToString(r&#x60;\textsf{\textit{R}G\textbf{B}}&#x60;);
  1861 |         expect(markup).toContain(&quot;&lt;span class&#x3D;\&quot;mord textsf textit\&quot;&gt;R&lt;&#x2F;span&gt;&quot;);
&gt; 1862 |         expect(markup).toContain(&quot;&lt;span class&#x3D;\&quot;mord textsf\&quot;&gt;G&lt;&#x2F;span&gt;&quot;);
       |        ^ Duplicate Assert
  1863 |         expect(markup).toContain(&quot;&lt;span class&#x3D;\&quot;mord textsf textbf\&quot;&gt;B&lt;&#x2F;span&gt;&quot;);
  1864 |     });
  1865 |</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  1861 |         expect(markup).toContain(&quot;&lt;span class&#x3D;\&quot;mord textsf textit\&quot;&gt;R&lt;&#x2F;span&gt;&quot;);
  1862 |         expect(markup).toContain(&quot;&lt;span class&#x3D;\&quot;mord textsf\&quot;&gt;G&lt;&#x2F;span&gt;&quot;);
&gt; 1863 |         expect(markup).toContain(&quot;&lt;span class&#x3D;\&quot;mord textsf textbf\&quot;&gt;B&lt;&#x2F;span&gt;&quot;);
       |        ^ Duplicate Assert
  1864 |     });
  1865 |
  1866 |     it(&quot;should render \\textsf{\\textbf{$\\mathrm{A}$}} with the correct font&quot;, function() {</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  1882 |         let markup &#x3D; katex.renderToString(r&#x60;\textcolor{blue}{\mathbb R}&#x60;);
  1883 |         let span &#x3D; &quot;&lt;span class&#x3D;\&quot;mord mathbb\&quot; style&#x3D;\&quot;color:blue;\&quot;&gt;R&lt;&#x2F;span&gt;&quot;;
&gt; 1884 |         expect(markup).toContain(span);
       |        ^ Duplicate Assert
  1885 |
  1886 |         markup &#x3D; katex.renderToString(r&#x60;\mathbb{\textcolor{blue}{R}}&#x60;);
  1887 |         span &#x3D; &quot;&lt;span class&#x3D;\&quot;mord mathbb\&quot; style&#x3D;\&quot;color:blue;\&quot;&gt;R&lt;&#x2F;span&gt;&quot;;</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  1882 |         let markup &#x3D; katex.renderToString(r&#x60;\textcolor{blue}{\mathbb R}&#x60;);
  1883 |         let span &#x3D; &quot;&lt;span class&#x3D;\&quot;mord mathbb\&quot; style&#x3D;\&quot;color:blue;\&quot;&gt;R&lt;&#x2F;span&gt;&quot;;
&gt; 1884 |         expect(markup).toContain(span);
       |        ^ Duplicate Assert
  1885 |
  1886 |         markup &#x3D; katex.renderToString(r&#x60;\mathbb{\textcolor{blue}{R}}&#x60;);
  1887 |         span &#x3D; &quot;&lt;span class&#x3D;\&quot;mord mathbb\&quot; style&#x3D;\&quot;color:blue;\&quot;&gt;R&lt;&#x2F;span&gt;&quot;;</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  1886 |         markup &#x3D; katex.renderToString(r&#x60;\mathbb{\textcolor{blue}{R}}&#x60;);
  1887 |         span &#x3D; &quot;&lt;span class&#x3D;\&quot;mord mathbb\&quot; style&#x3D;\&quot;color:blue;\&quot;&gt;R&lt;&#x2F;span&gt;&quot;;
&gt; 1888 |         expect(markup).toContain(span);
       |        ^ Duplicate Assert
  1889 |     });
  1890 |
  1891 |     it(&quot;should render wide characters with mord and with the correct font&quot;, function() {</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  1886 |         markup &#x3D; katex.renderToString(r&#x60;\mathbb{\textcolor{blue}{R}}&#x60;);
  1887 |         span &#x3D; &quot;&lt;span class&#x3D;\&quot;mord mathbb\&quot; style&#x3D;\&quot;color:blue;\&quot;&gt;R&lt;&#x2F;span&gt;&quot;;
&gt; 1888 |         expect(markup).toContain(span);
       |        ^ Duplicate Assert
  1889 |     });
  1890 |
  1891 |     it(&quot;should render wide characters with mord and with the correct font&quot;, function() {</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  2079 |             &quot;&lt;mi mathvariant&#x3D;\&quot;double-struck\&quot;&gt;R&lt;&#x2F;mi&gt;&quot; +
  2080 |             &quot;&lt;&#x2F;mstyle&gt;&quot;;
&gt; 2081 |         expect(markup).toContain(node);
       |        ^ Duplicate Assert
  2082 |
  2083 |         &#x2F;&#x2F; reverse the order of the commands
  2084 |         tex &#x3D; r&#x60;\mathbb{\textcolor{blue}{R}}&#x60;;</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  2079 |             &quot;&lt;mi mathvariant&#x3D;\&quot;double-struck\&quot;&gt;R&lt;&#x2F;mi&gt;&quot; +
  2080 |             &quot;&lt;&#x2F;mstyle&gt;&quot;;
&gt; 2081 |         expect(markup).toContain(node);
       |        ^ Duplicate Assert
  2082 |
  2083 |         &#x2F;&#x2F; reverse the order of the commands
  2084 |         tex &#x3D; r&#x60;\mathbb{\textcolor{blue}{R}}&#x60;;</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  2088 |             &quot;&lt;mi mathvariant&#x3D;\&quot;double-struck\&quot;&gt;R&lt;&#x2F;mi&gt;&quot; +
  2089 |             &quot;&lt;&#x2F;mstyle&gt;&quot;;
&gt; 2090 |         expect(markup).toContain(node);
       |        ^ Duplicate Assert
  2091 |     });
  2092 |
  2093 |     it(&quot;should render text as &lt;mtext&gt;&quot;, function() {</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  2088 |             &quot;&lt;mi mathvariant&#x3D;\&quot;double-struck\&quot;&gt;R&lt;&#x2F;mi&gt;&quot; +
  2089 |             &quot;&lt;&#x2F;mstyle&gt;&quot;;
&gt; 2090 |         expect(markup).toContain(node);
       |        ^ Duplicate Assert
  2091 |     });
  2092 |
  2093 |     it(&quot;should render text as &lt;mtext&gt;&quot;, function() {</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  2102 |         const tree &#x3D; getParsed(tex);
  2103 |         const markup &#x3D; buildMathML(tree, tex, defaultOptions).toMarkup();
&gt; 2104 |         expect(markup).toContain(&quot;&lt;mrow&gt;&lt;mtext&gt;graph:\u00a0&lt;&#x2F;mtext&gt;&quot;);
       |        ^ Duplicate Assert
  2105 |         expect(markup).toContain(
  2106 |             &quot;&lt;mi&gt;y&lt;&#x2F;mi&gt;&lt;mo&gt;&#x3D;&lt;&#x2F;mo&gt;&lt;mi&gt;m&lt;&#x2F;mi&gt;&lt;mi&gt;x&lt;&#x2F;mi&gt;&lt;mo&gt;+&lt;&#x2F;mo&gt;&lt;mi&gt;b&lt;&#x2F;mi&gt;&quot;);
  2107 |     });</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  2103 |         const markup &#x3D; buildMathML(tree, tex, defaultOptions).toMarkup();
  2104 |         expect(markup).toContain(&quot;&lt;mrow&gt;&lt;mtext&gt;graph:\u00a0&lt;&#x2F;mtext&gt;&quot;);
&gt; 2105 |         expect(markup).toContain(
       |        ^ Duplicate Assert
  2106 |             &quot;&lt;mi&gt;y&lt;&#x2F;mi&gt;&lt;mo&gt;&#x3D;&lt;&#x2F;mo&gt;&lt;mi&gt;m&lt;&#x2F;mi&gt;&lt;mi&gt;x&lt;&#x2F;mi&gt;&lt;mo&gt;+&lt;&#x2F;mo&gt;&lt;mi&gt;b&lt;&#x2F;mi&gt;&quot;);
  2107 |     });
  2108 | });</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  2200 |         const built &#x3D; getBuilt&#x60;+ x&#x60;;
  2201 |
&gt; 2202 |         expect(built[0].classes).toContain(&quot;mord&quot;);
       |        ^ Duplicate Assert
  2203 |         expect(built[0].classes).not.toContain(&quot;mbin&quot;);
  2204 |     });
  2205 |</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  2201 |
  2202 |         expect(built[0].classes).toContain(&quot;mord&quot;);
&gt; 2203 |         expect(built[0].classes).not.toContain(&quot;mbin&quot;);
       |        ^ Duplicate Assert
  2204 |     });
  2205 |
  2206 |     it(&quot;should create ords after some other objects&quot;, function() {</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  2235 |         const markup &#x3D; katex.renderToString(r&#x60;\sigma^2&#x60;);
  2236 |         expect(markup.indexOf(&quot;&lt;span&quot;)).toBe(0);
&gt; 2237 |         expect(markup).toContain(&quot;\u03c3&quot;);  &#x2F;&#x2F; sigma
       |        ^ Duplicate Assert
  2238 |         expect(markup).toContain(&quot;margin-right&quot;);
  2239 |         expect(markup).not.toContain(&quot;marginRight&quot;);
  2240 |     });</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  2236 |         expect(markup.indexOf(&quot;&lt;span&quot;)).toBe(0);
  2237 |         expect(markup).toContain(&quot;\u03c3&quot;);  &#x2F;&#x2F; sigma
&gt; 2238 |         expect(markup).toContain(&quot;margin-right&quot;);
       |        ^ Duplicate Assert
  2239 |         expect(markup).not.toContain(&quot;marginRight&quot;);
  2240 |     });
  2241 |</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  2237 |         expect(markup).toContain(&quot;\u03c3&quot;);  &#x2F;&#x2F; sigma
  2238 |         expect(markup).toContain(&quot;margin-right&quot;);
&gt; 2239 |         expect(markup).not.toContain(&quot;marginRight&quot;);
       |        ^ Duplicate Assert
  2240 |     });
  2241 |
  2242 |     it(&quot;generates both MathML and HTML&quot;, function() {</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  2243 |         const markup &#x3D; katex.renderToString(&quot;a&quot;);
  2244 |
&gt; 2245 |         expect(markup).toContain(&quot;&lt;span&quot;);
       |        ^ Duplicate Assert
  2246 |         expect(markup).toContain(&quot;&lt;math&quot;);
  2247 |     });
  2248 | });</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  2244 |
  2245 |         expect(markup).toContain(&quot;&lt;span&quot;);
&gt; 2246 |         expect(markup).toContain(&quot;&lt;math&quot;);
       |        ^ Duplicate Assert
  2247 |     });
  2248 | });
  2249 |</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  2296 |     it(&quot;should produce mords&quot;, function() {
  2297 |         expect(getBuilt&#x60;\vec x&#x60;[0].classes).toContain(&quot;mord&quot;);
&gt; 2298 |         expect(getBuilt&#x60;\vec +&#x60;[0].classes).toContain(&quot;mord&quot;);
       |        ^ Duplicate Assert
  2299 |         expect(getBuilt&#x60;\vec +&#x60;[0].classes).not.toContain(&quot;mbin&quot;);
  2300 |         expect(getBuilt&#x60;\vec )^2&#x60;[0].classes).toContain(&quot;mord&quot;);
  2301 |         expect(getBuilt&#x60;\vec )^2&#x60;[0].classes).not.toContain(&quot;mclose&quot;);</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  2297 |         expect(getBuilt&#x60;\vec x&#x60;[0].classes).toContain(&quot;mord&quot;);
  2298 |         expect(getBuilt&#x60;\vec +&#x60;[0].classes).toContain(&quot;mord&quot;);
&gt; 2299 |         expect(getBuilt&#x60;\vec +&#x60;[0].classes).not.toContain(&quot;mbin&quot;);
       |        ^ Duplicate Assert
  2300 |         expect(getBuilt&#x60;\vec )^2&#x60;[0].classes).toContain(&quot;mord&quot;);
  2301 |         expect(getBuilt&#x60;\vec )^2&#x60;[0].classes).not.toContain(&quot;mclose&quot;);
  2302 |     });</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  2298 |         expect(getBuilt&#x60;\vec +&#x60;[0].classes).toContain(&quot;mord&quot;);
  2299 |         expect(getBuilt&#x60;\vec +&#x60;[0].classes).not.toContain(&quot;mbin&quot;);
&gt; 2300 |         expect(getBuilt&#x60;\vec )^2&#x60;[0].classes).toContain(&quot;mord&quot;);
       |        ^ Duplicate Assert
  2301 |         expect(getBuilt&#x60;\vec )^2&#x60;[0].classes).not.toContain(&quot;mclose&quot;);
  2302 |     });
  2303 | });</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  2299 |         expect(getBuilt&#x60;\vec +&#x60;[0].classes).not.toContain(&quot;mbin&quot;);
  2300 |         expect(getBuilt&#x60;\vec )^2&#x60;[0].classes).toContain(&quot;mord&quot;);
&gt; 2301 |         expect(getBuilt&#x60;\vec )^2&#x60;[0].classes).not.toContain(&quot;mclose&quot;);
       |        ^ Duplicate Assert
  2302 |     });
  2303 | });
  2304 |</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  2314 |     it(&quot;should produce mords&quot;, function() {
  2315 |         expect(getBuilt&#x60;\widehat{AB}&#x60;[0].classes).toContain(&quot;mord&quot;);
&gt; 2316 |         expect(getBuilt&#x60;\widehat +&#x60;[0].classes).toContain(&quot;mord&quot;);
       |        ^ Duplicate Assert
  2317 |         expect(getBuilt&#x60;\widehat +&#x60;[0].classes).not.toContain(&quot;mbin&quot;);
  2318 |         expect(getBuilt&#x60;\widehat )^2&#x60;[0].classes).toContain(&quot;mord&quot;);
  2319 |         expect(getBuilt&#x60;\widehat )^2&#x60;[0].classes).not.toContain(&quot;mclose&quot;);</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  2315 |         expect(getBuilt&#x60;\widehat{AB}&#x60;[0].classes).toContain(&quot;mord&quot;);
  2316 |         expect(getBuilt&#x60;\widehat +&#x60;[0].classes).toContain(&quot;mord&quot;);
&gt; 2317 |         expect(getBuilt&#x60;\widehat +&#x60;[0].classes).not.toContain(&quot;mbin&quot;);
       |        ^ Duplicate Assert
  2318 |         expect(getBuilt&#x60;\widehat )^2&#x60;[0].classes).toContain(&quot;mord&quot;);
  2319 |         expect(getBuilt&#x60;\widehat )^2&#x60;[0].classes).not.toContain(&quot;mclose&quot;);
  2320 |     });</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  2316 |         expect(getBuilt&#x60;\widehat +&#x60;[0].classes).toContain(&quot;mord&quot;);
  2317 |         expect(getBuilt&#x60;\widehat +&#x60;[0].classes).not.toContain(&quot;mbin&quot;);
&gt; 2318 |         expect(getBuilt&#x60;\widehat )^2&#x60;[0].classes).toContain(&quot;mord&quot;);
       |        ^ Duplicate Assert
  2319 |         expect(getBuilt&#x60;\widehat )^2&#x60;[0].classes).not.toContain(&quot;mclose&quot;);
  2320 |     });
  2321 | });</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  2317 |         expect(getBuilt&#x60;\widehat +&#x60;[0].classes).not.toContain(&quot;mbin&quot;);
  2318 |         expect(getBuilt&#x60;\widehat )^2&#x60;[0].classes).toContain(&quot;mord&quot;);
&gt; 2319 |         expect(getBuilt&#x60;\widehat )^2&#x60;[0].classes).not.toContain(&quot;mclose&quot;);
       |        ^ Duplicate Assert
  2320 |     });
  2321 | });
  2322 |</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  2331 |     it(&quot;should produce mords&quot;, function() {
  2332 |         expect(getBuilt&#x60;\overrightarrow{AB}&#x60;[0].classes).toContain(&quot;mord&quot;);
&gt; 2333 |         expect(getBuilt&#x60;\overrightarrow +&#x60;[0].classes).toContain(&quot;mord&quot;);
       |        ^ Duplicate Assert
  2334 |         expect(getBuilt&#x60;\overrightarrow +&#x60;[0].classes).not.toContain(&quot;mbin&quot;);
  2335 |         expect(getBuilt&#x60;\overrightarrow )^2&#x60;[0].classes).toContain(&quot;mord&quot;);
  2336 |         expect(getBuilt&#x60;\overrightarrow )^2&#x60;[0].classes).not.toContain(&quot;mclose&quot;);</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  2332 |         expect(getBuilt&#x60;\overrightarrow{AB}&#x60;[0].classes).toContain(&quot;mord&quot;);
  2333 |         expect(getBuilt&#x60;\overrightarrow +&#x60;[0].classes).toContain(&quot;mord&quot;);
&gt; 2334 |         expect(getBuilt&#x60;\overrightarrow +&#x60;[0].classes).not.toContain(&quot;mbin&quot;);
       |        ^ Duplicate Assert
  2335 |         expect(getBuilt&#x60;\overrightarrow )^2&#x60;[0].classes).toContain(&quot;mord&quot;);
  2336 |         expect(getBuilt&#x60;\overrightarrow )^2&#x60;[0].classes).not.toContain(&quot;mclose&quot;);
  2337 |     });</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  2333 |         expect(getBuilt&#x60;\overrightarrow +&#x60;[0].classes).toContain(&quot;mord&quot;);
  2334 |         expect(getBuilt&#x60;\overrightarrow +&#x60;[0].classes).not.toContain(&quot;mbin&quot;);
&gt; 2335 |         expect(getBuilt&#x60;\overrightarrow )^2&#x60;[0].classes).toContain(&quot;mord&quot;);
       |        ^ Duplicate Assert
  2336 |         expect(getBuilt&#x60;\overrightarrow )^2&#x60;[0].classes).not.toContain(&quot;mclose&quot;);
  2337 |     });
  2338 | });</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  2334 |         expect(getBuilt&#x60;\overrightarrow +&#x60;[0].classes).not.toContain(&quot;mbin&quot;);
  2335 |         expect(getBuilt&#x60;\overrightarrow )^2&#x60;[0].classes).toContain(&quot;mord&quot;);
&gt; 2336 |         expect(getBuilt&#x60;\overrightarrow )^2&#x60;[0].classes).not.toContain(&quot;mclose&quot;);
       |        ^ Duplicate Assert
  2337 |     });
  2338 | });
  2339 |</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  2378 |     it(&quot;should produce mords&quot;, function() {
  2379 |         expect(getBuilt&#x60;\underrightarrow x&#x60;[0].classes).toContain(&quot;mord&quot;);
&gt; 2380 |         expect(getBuilt&#x60;\underrightarrow +&#x60;[0].classes).toContain(&quot;mord&quot;);
       |        ^ Duplicate Assert
  2381 |         expect(getBuilt&#x60;\underrightarrow +&#x60;[0].classes).not.toContain(&quot;mbin&quot;);
  2382 |         expect(getBuilt&#x60;\underrightarrow )^2&#x60;[0].classes).toContain(&quot;mord&quot;);
  2383 |         expect(getBuilt&#x60;\underrightarrow )^2&#x60;[0].classes)</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  2379 |         expect(getBuilt&#x60;\underrightarrow x&#x60;[0].classes).toContain(&quot;mord&quot;);
  2380 |         expect(getBuilt&#x60;\underrightarrow +&#x60;[0].classes).toContain(&quot;mord&quot;);
&gt; 2381 |         expect(getBuilt&#x60;\underrightarrow +&#x60;[0].classes).not.toContain(&quot;mbin&quot;);
       |        ^ Duplicate Assert
  2382 |         expect(getBuilt&#x60;\underrightarrow )^2&#x60;[0].classes).toContain(&quot;mord&quot;);
  2383 |         expect(getBuilt&#x60;\underrightarrow )^2&#x60;[0].classes)
  2384 |             .not.toContain(&quot;mclose&quot;);</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  2380 |         expect(getBuilt&#x60;\underrightarrow +&#x60;[0].classes).toContain(&quot;mord&quot;);
  2381 |         expect(getBuilt&#x60;\underrightarrow +&#x60;[0].classes).not.toContain(&quot;mbin&quot;);
&gt; 2382 |         expect(getBuilt&#x60;\underrightarrow )^2&#x60;[0].classes).toContain(&quot;mord&quot;);
       |        ^ Duplicate Assert
  2383 |         expect(getBuilt&#x60;\underrightarrow )^2&#x60;[0].classes)
  2384 |             .not.toContain(&quot;mclose&quot;);
  2385 |     });</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  2381 |         expect(getBuilt&#x60;\underrightarrow +&#x60;[0].classes).not.toContain(&quot;mbin&quot;);
  2382 |         expect(getBuilt&#x60;\underrightarrow )^2&#x60;[0].classes).toContain(&quot;mord&quot;);
&gt; 2383 |         expect(getBuilt&#x60;\underrightarrow )^2&#x60;[0].classes)
       |        ^ Duplicate Assert
  2384 |             .not.toContain(&quot;mclose&quot;);
  2385 |     });
  2386 | });</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  2420 |         expect(getBuilt&#x60;\xrightarrow x&#x60;[0].classes).toContain(&quot;mrel&quot;);
  2421 |         expect(getBuilt&#x60;\xrightarrow [under]{over}&#x60;[0].classes).toContain(&quot;mrel&quot;);
&gt; 2422 |         expect(getBuilt&#x60;\xrightarrow +&#x60;[0].classes).toContain(&quot;mrel&quot;);
       |        ^ Duplicate Assert
  2423 |         expect(getBuilt&#x60;\xrightarrow +&#x60;[0].classes).not.toContain(&quot;mbin&quot;);
  2424 |         expect(getBuilt&#x60;\xrightarrow )^2&#x60;[0].classes).toContain(&quot;mrel&quot;);
  2425 |         expect(getBuilt&#x60;\xrightarrow )^2&#x60;[0].classes).not.toContain(&quot;mclose&quot;);</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  2421 |         expect(getBuilt&#x60;\xrightarrow [under]{over}&#x60;[0].classes).toContain(&quot;mrel&quot;);
  2422 |         expect(getBuilt&#x60;\xrightarrow +&#x60;[0].classes).toContain(&quot;mrel&quot;);
&gt; 2423 |         expect(getBuilt&#x60;\xrightarrow +&#x60;[0].classes).not.toContain(&quot;mbin&quot;);
       |        ^ Duplicate Assert
  2424 |         expect(getBuilt&#x60;\xrightarrow )^2&#x60;[0].classes).toContain(&quot;mrel&quot;);
  2425 |         expect(getBuilt&#x60;\xrightarrow )^2&#x60;[0].classes).not.toContain(&quot;mclose&quot;);
  2426 |     });</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  2422 |         expect(getBuilt&#x60;\xrightarrow +&#x60;[0].classes).toContain(&quot;mrel&quot;);
  2423 |         expect(getBuilt&#x60;\xrightarrow +&#x60;[0].classes).not.toContain(&quot;mbin&quot;);
&gt; 2424 |         expect(getBuilt&#x60;\xrightarrow )^2&#x60;[0].classes).toContain(&quot;mrel&quot;);
       |        ^ Duplicate Assert
  2425 |         expect(getBuilt&#x60;\xrightarrow )^2&#x60;[0].classes).not.toContain(&quot;mclose&quot;);
  2426 |     });
  2427 | });</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  2423 |         expect(getBuilt&#x60;\xrightarrow +&#x60;[0].classes).not.toContain(&quot;mbin&quot;);
  2424 |         expect(getBuilt&#x60;\xrightarrow )^2&#x60;[0].classes).toContain(&quot;mrel&quot;);
&gt; 2425 |         expect(getBuilt&#x60;\xrightarrow )^2&#x60;[0].classes).not.toContain(&quot;mclose&quot;);
       |        ^ Duplicate Assert
  2426 |     });
  2427 | });
  2428 |</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  2461 |         expect(getBuilt&#x60;\overbrace x&#x60;[0].classes).toContain(&quot;mord&quot;);
  2462 |         expect(getBuilt&#x60;\overbrace{x}^2&#x60;[0].classes).toContain(&quot;mord&quot;);
&gt; 2463 |         expect(getBuilt&#x60;\overbrace +&#x60;[0].classes).toContain(&quot;mord&quot;);
       |        ^ Duplicate Assert
  2464 |         expect(getBuilt&#x60;\overbrace +&#x60;[0].classes).not.toContain(&quot;mbin&quot;);
  2465 |         expect(getBuilt&#x60;\overbrace )^2&#x60;[0].classes).toContain(&quot;mord&quot;);
  2466 |         expect(getBuilt&#x60;\overbrace )^2&#x60;[0].classes).not.toContain(&quot;mclose&quot;);</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  2462 |         expect(getBuilt&#x60;\overbrace{x}^2&#x60;[0].classes).toContain(&quot;mord&quot;);
  2463 |         expect(getBuilt&#x60;\overbrace +&#x60;[0].classes).toContain(&quot;mord&quot;);
&gt; 2464 |         expect(getBuilt&#x60;\overbrace +&#x60;[0].classes).not.toContain(&quot;mbin&quot;);
       |        ^ Duplicate Assert
  2465 |         expect(getBuilt&#x60;\overbrace )^2&#x60;[0].classes).toContain(&quot;mord&quot;);
  2466 |         expect(getBuilt&#x60;\overbrace )^2&#x60;[0].classes).not.toContain(&quot;mclose&quot;);
  2467 |     });</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  2463 |         expect(getBuilt&#x60;\overbrace +&#x60;[0].classes).toContain(&quot;mord&quot;);
  2464 |         expect(getBuilt&#x60;\overbrace +&#x60;[0].classes).not.toContain(&quot;mbin&quot;);
&gt; 2465 |         expect(getBuilt&#x60;\overbrace )^2&#x60;[0].classes).toContain(&quot;mord&quot;);
       |        ^ Duplicate Assert
  2466 |         expect(getBuilt&#x60;\overbrace )^2&#x60;[0].classes).not.toContain(&quot;mclose&quot;);
  2467 |     });
  2468 | });</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  2464 |         expect(getBuilt&#x60;\overbrace +&#x60;[0].classes).not.toContain(&quot;mbin&quot;);
  2465 |         expect(getBuilt&#x60;\overbrace )^2&#x60;[0].classes).toContain(&quot;mord&quot;);
&gt; 2466 |         expect(getBuilt&#x60;\overbrace )^2&#x60;[0].classes).not.toContain(&quot;mclose&quot;);
       |        ^ Duplicate Assert
  2467 |     });
  2468 | });
  2469 |</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  2493 |     it(&quot;should produce mords&quot;, function() {
  2494 |         expect(getBuilt&#x60;\boxed x&#x60;[0].classes).toContain(&quot;mord&quot;);
&gt; 2495 |         expect(getBuilt&#x60;\boxed +&#x60;[0].classes).toContain(&quot;mord&quot;);
       |        ^ Duplicate Assert
  2496 |         expect(getBuilt&#x60;\boxed +&#x60;[0].classes).not.toContain(&quot;mbin&quot;);
  2497 |         expect(getBuilt&#x60;\boxed )^2&#x60;[0].classes).toContain(&quot;mord&quot;);
  2498 |         expect(getBuilt&#x60;\boxed )^2&#x60;[0].classes).not.toContain(&quot;mclose&quot;);</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  2494 |         expect(getBuilt&#x60;\boxed x&#x60;[0].classes).toContain(&quot;mord&quot;);
  2495 |         expect(getBuilt&#x60;\boxed +&#x60;[0].classes).toContain(&quot;mord&quot;);
&gt; 2496 |         expect(getBuilt&#x60;\boxed +&#x60;[0].classes).not.toContain(&quot;mbin&quot;);
       |        ^ Duplicate Assert
  2497 |         expect(getBuilt&#x60;\boxed )^2&#x60;[0].classes).toContain(&quot;mord&quot;);
  2498 |         expect(getBuilt&#x60;\boxed )^2&#x60;[0].classes).not.toContain(&quot;mclose&quot;);
  2499 |     });</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  2495 |         expect(getBuilt&#x60;\boxed +&#x60;[0].classes).toContain(&quot;mord&quot;);
  2496 |         expect(getBuilt&#x60;\boxed +&#x60;[0].classes).not.toContain(&quot;mbin&quot;);
&gt; 2497 |         expect(getBuilt&#x60;\boxed )^2&#x60;[0].classes).toContain(&quot;mord&quot;);
       |        ^ Duplicate Assert
  2498 |         expect(getBuilt&#x60;\boxed )^2&#x60;[0].classes).not.toContain(&quot;mclose&quot;);
  2499 |     });
  2500 | });</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  2496 |         expect(getBuilt&#x60;\boxed +&#x60;[0].classes).not.toContain(&quot;mbin&quot;);
  2497 |         expect(getBuilt&#x60;\boxed )^2&#x60;[0].classes).toContain(&quot;mord&quot;);
&gt; 2498 |         expect(getBuilt&#x60;\boxed )^2&#x60;[0].classes).not.toContain(&quot;mclose&quot;);
       |        ^ Duplicate Assert
  2499 |     });
  2500 | });
  2501 |</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  2613 |     it(&quot;should produce mords&quot;, function() {
  2614 |         expect(getBuilt&#x60;\cancel x&#x60;[0].classes).toContain(&quot;mord&quot;);
&gt; 2615 |         expect(getBuilt&#x60;\cancel +&#x60;[0].classes).toContain(&quot;mord&quot;);
       |        ^ Duplicate Assert
  2616 |         expect(getBuilt&#x60;\cancel +&#x60;[0].classes).not.toContain(&quot;mbin&quot;);
  2617 |         expect(getBuilt&#x60;\cancel )^2&#x60;[0].classes).toContain(&quot;mord&quot;);
  2618 |         expect(getBuilt&#x60;\cancel )^2&#x60;[0].classes).not.toContain(&quot;mclose&quot;);</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  2614 |         expect(getBuilt&#x60;\cancel x&#x60;[0].classes).toContain(&quot;mord&quot;);
  2615 |         expect(getBuilt&#x60;\cancel +&#x60;[0].classes).toContain(&quot;mord&quot;);
&gt; 2616 |         expect(getBuilt&#x60;\cancel +&#x60;[0].classes).not.toContain(&quot;mbin&quot;);
       |        ^ Duplicate Assert
  2617 |         expect(getBuilt&#x60;\cancel )^2&#x60;[0].classes).toContain(&quot;mord&quot;);
  2618 |         expect(getBuilt&#x60;\cancel )^2&#x60;[0].classes).not.toContain(&quot;mclose&quot;);
  2619 |     });</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  2615 |         expect(getBuilt&#x60;\cancel +&#x60;[0].classes).toContain(&quot;mord&quot;);
  2616 |         expect(getBuilt&#x60;\cancel +&#x60;[0].classes).not.toContain(&quot;mbin&quot;);
&gt; 2617 |         expect(getBuilt&#x60;\cancel )^2&#x60;[0].classes).toContain(&quot;mord&quot;);
       |        ^ Duplicate Assert
  2618 |         expect(getBuilt&#x60;\cancel )^2&#x60;[0].classes).not.toContain(&quot;mclose&quot;);
  2619 |     });
  2620 | });</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  2616 |         expect(getBuilt&#x60;\cancel +&#x60;[0].classes).not.toContain(&quot;mbin&quot;);
  2617 |         expect(getBuilt&#x60;\cancel )^2&#x60;[0].classes).toContain(&quot;mord&quot;);
&gt; 2618 |         expect(getBuilt&#x60;\cancel )^2&#x60;[0].classes).not.toContain(&quot;mclose&quot;);
       |        ^ Duplicate Assert
  2619 |     });
  2620 | });
  2621 |</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  3464 |     it(&quot;\\char produces literal characters&quot;, () &#x3D;&gt; {
  3465 |         expect(&quot;\\char&#x60;a&quot;).toParseLike(&quot;\\char&#x60;\\a&quot;);
&gt; 3466 |         expect(&quot;\\char&#x60;\\%&quot;).toParseLike&#x60;\char37&#x60;;
       |        ^ Duplicate Assert
  3467 |         expect(&quot;\\char&#x60;\\%&quot;).toParseLike&#x60;\char&#39;45&#x60;;
  3468 |         expect(&quot;\\char&#x60;\\%&quot;).toParseLike&#x60;\char&quot;25&#x60;;
  3469 |         expect&#x60;\char&#x60;.not.toParse();</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  3465 |         expect(&quot;\\char&#x60;a&quot;).toParseLike(&quot;\\char&#x60;\\a&quot;);
  3466 |         expect(&quot;\\char&#x60;\\%&quot;).toParseLike&#x60;\char37&#x60;;
&gt; 3467 |         expect(&quot;\\char&#x60;\\%&quot;).toParseLike&#x60;\char&#39;45&#x60;;
       |        ^ Duplicate Assert
  3468 |         expect(&quot;\\char&#x60;\\%&quot;).toParseLike&#x60;\char&quot;25&#x60;;
  3469 |         expect&#x60;\char&#x60;.not.toParse();
  3470 |         expect(&quot;\\char&#x60;&quot;).not.toParse();</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  3466 |         expect(&quot;\\char&#x60;\\%&quot;).toParseLike&#x60;\char37&#x60;;
  3467 |         expect(&quot;\\char&#x60;\\%&quot;).toParseLike&#x60;\char&#39;45&#x60;;
&gt; 3468 |         expect(&quot;\\char&#x60;\\%&quot;).toParseLike&#x60;\char&quot;25&#x60;;
       |        ^ Duplicate Assert
  3469 |         expect&#x60;\char&#x60;.not.toParse();
  3470 |         expect(&quot;\\char&#x60;&quot;).not.toParse();
  3471 |         expect&#x60;\char&#39;&#x60;.not.toParse();</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  4098 |         const example &#x3D; exp32 + r&#x60;\a{1}&#x60;;
  4099 |         const count &#x3D; 1 + 2 + 4 + 8 + 16 + 32;
&gt; 4100 |         expect(example).toParse(new Settings({maxExpand: count}));
       |        ^ Duplicate Assert
  4101 |         expect(example).not.toParse(new Settings({maxExpand: count - 1}));
  4102 |     });
  4103 |</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  4099 |         const count &#x3D; 1 + 2 + 4 + 8 + 16 + 32;
  4100 |         expect(example).toParse(new Settings({maxExpand: count}));
&gt; 4101 |         expect(example).not.toParse(new Settings({maxExpand: count - 1}));
       |        ^ Duplicate Assert
  4102 |     });
  4103 |
  4104 |     it(&quot;should count correctly with Unicode sub&#x2F;superscripts&quot;, () &#x3D;&gt; {</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  4105 |         const example &#x3D; exp32 + r&#x60;\def+{\a{1}}x⁺x⁺x⁺x⁺&#x60;;
  4106 |         const count &#x3D; (1 + 2 + 4 + 8 + 16 + 32) * 4 + 4;
&gt; 4107 |         expect(example).toParse(new Settings({maxExpand: count}));
       |        ^ Duplicate Assert
  4108 |         expect(example).not.toParse(new Settings({maxExpand: count - 1}));
  4109 |     });
  4110 | });</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  4106 |         const count &#x3D; (1 + 2 + 4 + 8 + 16 + 32) * 4 + 4;
  4107 |         expect(example).toParse(new Settings({maxExpand: count}));
&gt; 4108 |         expect(example).not.toParse(new Settings({maxExpand: count - 1}));
       |        ^ Duplicate Assert
  4109 |     });
  4110 | });
  4111 |</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  4148 |         &#x2F;&#x2F; Ensure newlines appear outside base spans (because, in this regexp,
  4149 |         &#x2F;&#x2F; base span occurs immediately after each newline span).
&gt; 4150 |         expect(markup).toMatch(
       |        ^ Duplicate Assert
  4151 |             &#x2F;(&lt;span class&#x3D;&quot;base&quot;&gt;.*?&lt;\&#x2F;span&gt;&lt;span class&#x3D;&quot;mspace newline&quot;&gt;&lt;\&#x2F;span&gt;){3}&lt;span class&#x3D;&quot;base&quot;&gt;&#x2F;);
  4152 |         expect(markup).toMatchSnapshot();
  4153 |     });</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  4150 |         expect(markup).toMatch(
  4151 |             &#x2F;(&lt;span class&#x3D;&quot;base&quot;&gt;.*?&lt;\&#x2F;span&gt;&lt;span class&#x3D;&quot;mspace newline&quot;&gt;&lt;\&#x2F;span&gt;){3}&lt;span class&#x3D;&quot;base&quot;&gt;&#x2F;);
&gt; 4152 |         expect(markup).toMatchSnapshot();
       |        ^ Duplicate Assert
  4153 |     });
  4154 | });
  4155 |</code></pre><br>
                      </td>
                    </tr>
                  </tbody>
                </table>
                <hr>
                <table class="table is-fullwidth" id="table-of-smell">
                  <thead>
                    <tr>
                      <td>Eager Test</td>
                    </tr>
                  </thead>
                  <tbody>
                    <tr>
                      <td>
                        <pre><code>  508 |
  509 |     it(&quot;should parse cfrac, dfrac, tfrac, and genfrac as fracs&quot;, function() {
&gt; 510 |         const dfracParse &#x3D; getParsed(dfracExpression)[0];
      |                           ^ Eager Test
  511 |
  512 |         expect(dfracParse.type).toEqual(&quot;genfrac&quot;);
  513 |         expect(dfracParse.numer).toBeDefined();</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  514 |         expect(dfracParse.denom).toBeDefined();
  515 |
&gt; 516 |         const tfracParse &#x3D; getParsed(tfracExpression)[0];
      |                           ^ Eager Test
  517 |
  518 |         expect(tfracParse.type).toEqual(&quot;genfrac&quot;);
  519 |         expect(tfracParse.numer).toBeDefined();</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  520 |         expect(tfracParse.denom).toBeDefined();
  521 |
&gt; 522 |         const cfracParse &#x3D; getParsed(cfracExpression)[0];
      |                           ^ Eager Test
  523 |
  524 |         expect(cfracParse.type).toEqual(&quot;genfrac&quot;);
  525 |         expect(cfracParse.numer).toBeDefined();</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  526 |         expect(cfracParse.denom).toBeDefined();
  527 |
&gt; 528 |         const genfracParse &#x3D; getParsed(genfrac1)[0];
      |                             ^ Eager Test
  529 |
  530 |         expect(genfracParse.type).toEqual(&quot;genfrac&quot;);
  531 |         expect(genfracParse.numer).toBeDefined();</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  571 |         let parse;
  572 |
&gt; 573 |         parse &#x3D; getParsed(simpleOver)[0];
      |                ^ Eager Test
  574 |
  575 |         expect(parse.type).toEqual(&quot;genfrac&quot;);
  576 |         expect(parse.numer).toBeDefined();</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  577 |         expect(parse.denom).toBeDefined();
  578 |
&gt; 579 |         parse &#x3D; getParsed(complexOver)[0];
      |                ^ Eager Test
  580 |
  581 |         expect(parse.type).toEqual(&quot;genfrac&quot;);
  582 |         expect(parse.numer).toBeDefined();</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  583 |         expect(parse.denom).toBeDefined();
  584 |
&gt; 585 |         const parseBraceFrac &#x3D; getParsed(braceFrac)[0];
      |                               ^ Eager Test
  586 |
  587 |         expect(parseBraceFrac.type).toEqual(&quot;genfrac&quot;);
  588 |         expect(parseBraceFrac.numer).toBeDefined();</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  591 |         expect(parseBraceFrac.rightDelim).toBeDefined();
  592 |
&gt; 593 |         const parseBrackFrac &#x3D; getParsed(brackFrac)[0];
      |                               ^ Eager Test
  594 |
  595 |         expect(parseBrackFrac.type).toEqual(&quot;genfrac&quot;);
  596 |         expect(parseBrackFrac.numer).toBeDefined();</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  868 |
  869 |     it(&quot;should correctly extract the custom color&quot;, function() {
&gt; 870 |         const parse1 &#x3D; getParsed(customColorExpression1)[0];
      |                       ^ Eager Test
  871 |         const parse2 &#x3D; getParsed(customColorExpression2)[0];
  872 |         const parse3 &#x3D; getParsed(customColorExpression3)[0];
  873 |</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  869 |     it(&quot;should correctly extract the custom color&quot;, function() {
  870 |         const parse1 &#x3D; getParsed(customColorExpression1)[0];
&gt; 871 |         const parse2 &#x3D; getParsed(customColorExpression2)[0];
      |                       ^ Eager Test
  872 |         const parse3 &#x3D; getParsed(customColorExpression3)[0];
  873 |
  874 |         expect(parse1.color).toEqual(&quot;#fA6&quot;);</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  870 |         const parse1 &#x3D; getParsed(customColorExpression1)[0];
  871 |         const parse2 &#x3D; getParsed(customColorExpression2)[0];
&gt; 872 |         const parse3 &#x3D; getParsed(customColorExpression3)[0];
      |                       ^ Eager Test
  873 |
  874 |         expect(parse1.color).toEqual(&quot;#fA6&quot;);
  875 |         expect(parse2.color).toEqual(&quot;#fA6fA6&quot;);</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  968 |
  969 |     it(&quot;should produce the correct direction delimiter&quot;, function() {
&gt; 970 |         const leftParse &#x3D; getParsed(normalDelim)[0];
      |                          ^ Eager Test
  971 |         const rightParse &#x3D; getParsed(bigDelim)[0];
  972 |
  973 |         expect(leftParse.mclass).toEqual(&quot;mopen&quot;);</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  969 |     it(&quot;should produce the correct direction delimiter&quot;, function() {
  970 |         const leftParse &#x3D; getParsed(normalDelim)[0];
&gt; 971 |         const rightParse &#x3D; getParsed(bigDelim)[0];
      |                           ^ Eager Test
  972 |
  973 |         expect(leftParse.mclass).toEqual(&quot;mopen&quot;);
  974 |         expect(rightParse.mclass).toEqual(&quot;mclose&quot;);</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  976 |
  977 |     it(&quot;should parse the correct size delimiter&quot;, function() {
&gt; 978 |         const smallParse &#x3D; getParsed(normalDelim)[0];
      |                           ^ Eager Test
  979 |         const bigParse &#x3D; getParsed(bigDelim)[0];
  980 |
  981 |         expect(smallParse.size).toEqual(1);</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  977 |     it(&quot;should parse the correct size delimiter&quot;, function() {
  978 |         const smallParse &#x3D; getParsed(normalDelim)[0];
&gt; 979 |         const bigParse &#x3D; getParsed(bigDelim)[0];
      |                         ^ Eager Test
  980 |
  981 |         expect(smallParse.size).toEqual(1);
  982 |         expect(bigParse.size).toEqual(4);</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  1057 |
  1058 |     it(&quot;should list the correct units&quot;, function() {
&gt; 1059 |         const emParse &#x3D; getParsed(emRule)[0];
       |                        ^ Eager Test
  1060 |         const exParse &#x3D; getParsed(exRule)[0];
  1061 |
  1062 |         expect(emParse.width.unit).toEqual(&quot;em&quot;);</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  1058 |     it(&quot;should list the correct units&quot;, function() {
  1059 |         const emParse &#x3D; getParsed(emRule)[0];
&gt; 1060 |         const exParse &#x3D; getParsed(exRule)[0];
       |                        ^ Eager Test
  1061 |
  1062 |         expect(emParse.width.unit).toEqual(&quot;em&quot;);
  1063 |         expect(emParse.height.unit).toEqual(&quot;em&quot;);</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  1095 |
  1096 |     it(&quot;should list the correct units&quot;, function() {
&gt; 1097 |         const emParse &#x3D; getParsed(emKern)[0];
       |                        ^ Eager Test
  1098 |         const exParse &#x3D; getParsed(exKern)[0];
  1099 |         const muParse &#x3D; getParsed(muKern)[0];
  1100 |         const abParse &#x3D; getParsed(abKern)[1];</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  1096 |     it(&quot;should list the correct units&quot;, function() {
  1097 |         const emParse &#x3D; getParsed(emKern)[0];
&gt; 1098 |         const exParse &#x3D; getParsed(exKern)[0];
       |                        ^ Eager Test
  1099 |         const muParse &#x3D; getParsed(muKern)[0];
  1100 |         const abParse &#x3D; getParsed(abKern)[1];
  1101 |</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  1097 |         const emParse &#x3D; getParsed(emKern)[0];
  1098 |         const exParse &#x3D; getParsed(exKern)[0];
&gt; 1099 |         const muParse &#x3D; getParsed(muKern)[0];
       |                        ^ Eager Test
  1100 |         const abParse &#x3D; getParsed(abKern)[1];
  1101 |
  1102 |         expect(emParse.dimension.unit).toEqual(&quot;em&quot;);</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  1098 |         const exParse &#x3D; getParsed(exKern)[0];
  1099 |         const muParse &#x3D; getParsed(muKern)[0];
&gt; 1100 |         const abParse &#x3D; getParsed(abKern)[1];
       |                        ^ Eager Test
  1101 |
  1102 |         expect(emParse.dimension.unit).toEqual(&quot;em&quot;);
  1103 |         expect(exParse.dimension.unit).toEqual(&quot;ex&quot;);</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  1133 |
  1134 |     it(&quot;should list the correct units&quot;, function() {
&gt; 1135 |         const emParse &#x3D; getParsed(emKern)[0];
       |                        ^ Eager Test
  1136 |         const exParse &#x3D; getParsed(exKern)[0];
  1137 |         const muParse &#x3D; getParsed(muKern)[0];
  1138 |         const abParse1 &#x3D; getParsed(abKern1)[1];</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  1134 |     it(&quot;should list the correct units&quot;, function() {
  1135 |         const emParse &#x3D; getParsed(emKern)[0];
&gt; 1136 |         const exParse &#x3D; getParsed(exKern)[0];
       |                        ^ Eager Test
  1137 |         const muParse &#x3D; getParsed(muKern)[0];
  1138 |         const abParse1 &#x3D; getParsed(abKern1)[1];
  1139 |         const abParse2 &#x3D; getParsed(abKern2)[1];</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  1135 |         const emParse &#x3D; getParsed(emKern)[0];
  1136 |         const exParse &#x3D; getParsed(exKern)[0];
&gt; 1137 |         const muParse &#x3D; getParsed(muKern)[0];
       |                        ^ Eager Test
  1138 |         const abParse1 &#x3D; getParsed(abKern1)[1];
  1139 |         const abParse2 &#x3D; getParsed(abKern2)[1];
  1140 |         const abParse3 &#x3D; getParsed(abKern3)[1];</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  1136 |         const exParse &#x3D; getParsed(exKern)[0];
  1137 |         const muParse &#x3D; getParsed(muKern)[0];
&gt; 1138 |         const abParse1 &#x3D; getParsed(abKern1)[1];
       |                         ^ Eager Test
  1139 |         const abParse2 &#x3D; getParsed(abKern2)[1];
  1140 |         const abParse3 &#x3D; getParsed(abKern3)[1];
  1141 |</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  1137 |         const muParse &#x3D; getParsed(muKern)[0];
  1138 |         const abParse1 &#x3D; getParsed(abKern1)[1];
&gt; 1139 |         const abParse2 &#x3D; getParsed(abKern2)[1];
       |                         ^ Eager Test
  1140 |         const abParse3 &#x3D; getParsed(abKern3)[1];
  1141 |
  1142 |         expect(emParse.dimension.unit).toEqual(&quot;em&quot;);</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  1138 |         const abParse1 &#x3D; getParsed(abKern1)[1];
  1139 |         const abParse2 &#x3D; getParsed(abKern2)[1];
&gt; 1140 |         const abParse3 &#x3D; getParsed(abKern3)[1];
       |                         ^ Eager Test
  1141 |
  1142 |         expect(emParse.dimension.unit).toEqual(&quot;em&quot;);
  1143 |         expect(exParse.dimension.unit).toEqual(&quot;ex&quot;);</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  1149 |
  1150 |     it(&quot;should parse elements on either side of a kern&quot;, function() {
&gt; 1151 |         const abParse1 &#x3D; getParsed(abKern1);
       |                         ^ Eager Test
  1152 |         const abParse2 &#x3D; getParsed(abKern2);
  1153 |         const abParse3 &#x3D; getParsed(abKern3);
  1154 |</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  1150 |     it(&quot;should parse elements on either side of a kern&quot;, function() {
  1151 |         const abParse1 &#x3D; getParsed(abKern1);
&gt; 1152 |         const abParse2 &#x3D; getParsed(abKern2);
       |                         ^ Eager Test
  1153 |         const abParse3 &#x3D; getParsed(abKern3);
  1154 |
  1155 |         expect(abParse1).toHaveLength(3);</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  1151 |         const abParse1 &#x3D; getParsed(abKern1);
  1152 |         const abParse2 &#x3D; getParsed(abKern2);
&gt; 1153 |         const abParse3 &#x3D; getParsed(abKern3);
       |                         ^ Eager Test
  1154 |
  1155 |         expect(abParse1).toHaveLength(3);
  1156 |         expect(abParse1[0].text).toEqual(&quot;a&quot;);</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  2074 |     it(&quot;should render a combination of font and color changes&quot;, function() {
  2075 |         let tex &#x3D; r&#x60;\textcolor{blue}{\mathbb R}&#x60;;
&gt; 2076 |         let tree &#x3D; getParsed(tex);
       |                   ^ Eager Test
  2077 |         let markup &#x3D; buildMathML(tree, tex, defaultOptions).toMarkup();
  2078 |         let node &#x3D; &quot;&lt;mstyle mathcolor&#x3D;\&quot;blue\&quot;&gt;&quot; +
  2079 |             &quot;&lt;mi mathvariant&#x3D;\&quot;double-struck\&quot;&gt;R&lt;&#x2F;mi&gt;&quot; +</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  2083 |         &#x2F;&#x2F; reverse the order of the commands
  2084 |         tex &#x3D; r&#x60;\mathbb{\textcolor{blue}{R}}&#x60;;
&gt; 2085 |         tree &#x3D; getParsed(tex);
       |               ^ Eager Test
  2086 |         markup &#x3D; buildMathML(tree, tex, defaultOptions).toMarkup();
  2087 |         node &#x3D; &quot;&lt;mstyle mathcolor&#x3D;\&quot;blue\&quot;&gt;&quot; +
  2088 |             &quot;&lt;mi mathvariant&#x3D;\&quot;double-struck\&quot;&gt;R&lt;&#x2F;mi&gt;&quot; +</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  2991 |     it(&quot;should allow letters [#$%&amp;~_^] without escaping&quot;, function() {
  2992 |         const url &#x3D; &quot;http:&#x2F;&#x2F;example.org&#x2F;~bar&#x2F;#top?foo&#x3D;$foo&amp;bar&#x3D;ba^r_boo%20baz&quot;;
&gt; 2993 |         const parsed1 &#x3D; getParsed(&#x60;\\href{${url}}{\\alpha}&#x60;, trustSettings)[0];
       |                        ^ Eager Test
  2994 |         expect(parsed1.href).toBe(url);
  2995 |         const parsed2 &#x3D; getParsed(&#x60;\\url{${url}}&#x60;, trustSettings)[0];
  2996 |         expect(parsed2.href).toBe(url);</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  2993 |         const parsed1 &#x3D; getParsed(&#x60;\\href{${url}}{\\alpha}&#x60;, trustSettings)[0];
  2994 |         expect(parsed1.href).toBe(url);
&gt; 2995 |         const parsed2 &#x3D; getParsed(&#x60;\\url{${url}}&#x60;, trustSettings)[0];
       |                        ^ Eager Test
  2996 |         expect(parsed2.href).toBe(url);
  2997 |     });
  2998 |</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  2999 |     it(&quot;should allow balanced braces in url&quot;, function() {
  3000 |         const url &#x3D; &quot;http:&#x2F;&#x2F;example.org&#x2F;{{}t{oo}}&quot;;
&gt; 3001 |         const parsed1 &#x3D; getParsed(&#x60;\\href{${url}}{\\alpha}&#x60;, trustSettings)[0];
       |                        ^ Eager Test
  3002 |         expect(parsed1.href).toBe(url);
  3003 |         const parsed2 &#x3D; getParsed(&#x60;\\url{${url}}&#x60;, trustSettings)[0];
  3004 |         expect(parsed2.href).toBe(url);</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  3001 |         const parsed1 &#x3D; getParsed(&#x60;\\href{${url}}{\\alpha}&#x60;, trustSettings)[0];
  3002 |         expect(parsed1.href).toBe(url);
&gt; 3003 |         const parsed2 &#x3D; getParsed(&#x60;\\url{${url}}&#x60;, trustSettings)[0];
       |                        ^ Eager Test
  3004 |         expect(parsed2.href).toBe(url);
  3005 |     });
  3006 |</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  3015 |         const url &#x3D; &quot;http:&#x2F;&#x2F;example.org&#x2F;~bar&#x2F;#top?foo&#x3D;$}foo{&amp;bar&#x3D;bar^r_boo%20baz&quot;;
  3016 |         const input &#x3D; url.replace(&#x2F;([#$%&amp;~_^{}])&#x2F;g, &#39;\\$1&#39;);
&gt; 3017 |         const parsed1 &#x3D; getParsed(&#x60;\\href{${input}}{\\alpha}&#x60;, trustSettings)[0];
       |                        ^ Eager Test
  3018 |         expect(parsed1.href).toBe(url);
  3019 |         const parsed2 &#x3D; getParsed(&#x60;\\url{${input}}&#x60;, trustSettings)[0];
  3020 |         expect(parsed2.href).toBe(url);</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  3017 |         const parsed1 &#x3D; getParsed(&#x60;\\href{${input}}{\\alpha}&#x60;, trustSettings)[0];
  3018 |         expect(parsed1.href).toBe(url);
&gt; 3019 |         const parsed2 &#x3D; getParsed(&#x60;\\url{${input}}&#x60;, trustSettings)[0];
       |                        ^ Eager Test
  3020 |         expect(parsed2.href).toBe(url);
  3021 |     });
  3022 |</code></pre><br>
                      </td>
                    </tr>
                  </tbody>
                </table>
                <hr>
                <table class="table is-fullwidth" id="table-of-smell">
                  <thead>
                    <tr>
                      <td>Exception Handling</td>
                    </tr>
                  </thead>
                  <tbody>
                    <tr>
                      <td>
                        <pre><code>  2172 |     it(&quot;should throw Error when HTML attribute name is invalid&quot;, function() {
  2173 |         for (const char of [&quot;&gt;&quot;, &quot; &quot;, &quot;\t&quot;, &quot;\n&quot;, &quot;\r&quot;, &quot;\&quot;&quot;, &quot;&#39;&quot;, &quot;&#x2F;&quot;]) {
&gt; 2174 |             try {
       |            ^ Exception Handling
  2175 |                 katex.renderToString(
  2176 |                     &#x60;\\htmlData{a${char}b&#x3D;foo}{bar}&#x60;, trustNonStrictSettings);
  2177 |</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  2737 | describe(&quot;A parser error&quot;, function() {
  2738 |     it(&quot;should report the position of an error&quot;, function() {
&gt; 2739 |         try {
       |        ^ Exception Handling
  2740 |             parseTree(r&#x60;\sqrt}&#x60;, new Settings());
  2741 |         } catch (e) {
  2742 |             expect(e.position).toEqual(5);</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  3156 | describe(&quot;ParseError properties&quot;, function() {
  3157 |     it(&quot;should contain affected position and length information&quot;, function() {
&gt; 3158 |         try {
       |        ^ Exception Handling
  3159 |             katex.renderToString(&quot;1 + \\fraq{}{}&quot;);
  3160 |
  3161 |             &#x2F;&#x2F; Render is expected to throw, so this should not be called.</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  3171 |
  3172 |     it(&quot;should contain position and length information at end of input&quot;, function() {
&gt; 3173 |         try {
       |        ^ Exception Handling
  3174 |             katex.renderToString(&quot;\\frac{}&quot;);
  3175 |
  3176 |             &#x2F;&#x2F; Render is expected to throw, so this should not be called.</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  3186 |
  3187 |     it(&quot;should contain no position and length information if unavailable&quot;, function() {
&gt; 3188 |         try {
       |        ^ Exception Handling
  3189 |             katex.renderToString(&quot;\\verb|hello\nworld|&quot;);
  3190 |
  3191 |             &#x2F;&#x2F; Render is expected to throw, so this should not be called.</code></pre><br>
                      </td>
                    </tr>
                  </tbody>
                </table>
                <hr>
                <table class="table is-fullwidth" id="table-of-smell">
                  <thead>
                    <tr>
                      <td>Lazy Test</td>
                    </tr>
                  </thead>
                  <tbody>
                    <tr>
                      <td>
                        <pre><code>  42 |
  43 |     it(&quot;should build a list of ords&quot;, function() {
&gt; 44 |         const parse &#x3D; getParsed(expression);
     |                      ^ Lazy Test
  45 |
  46 |         for (let i &#x3D; 0; i &lt; parse.length; i++) {
  47 |             const group &#x3D; parse[i];</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  51 |
  52 |     it(&quot;should parse the right number of ords&quot;, function() {
&gt; 53 |         const parse &#x3D; getParsed(expression);
     |                      ^ Lazy Test
  54 |
  55 |         expect(parse).toHaveLength(expression.length);
  56 |     });</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  65 |
  66 |     it(&quot;should build a list of bins&quot;, function() {
&gt; 67 |         const parse &#x3D; getParsed(expression);
     |                      ^ Lazy Test
  68 |
  69 |         for (let i &#x3D; 0; i &lt; parse.length; i++) {
  70 |             const group &#x3D; parse[i];</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  85 |
  86 |     it(&quot;should build a list of rels&quot;, function() {
&gt; 87 |         const parse &#x3D; getParsed(expression);
     |                      ^ Lazy Test
  88 |
  89 |         for (let i &#x3D; 0; i &lt; parse.length; i++) {
  90 |             let group &#x3D; parse[i];</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  111 |     it(&quot;should return one group, not a fragment&quot;, function() {
  112 |         const contents &#x3D; &quot;\\mathinner{\\langle{\\psi}\\rangle}&quot;;
&gt; 113 |         const mml &#x3D; buildMathML(getParsed(contents), contents, defaultOptions);
      |                                ^ Lazy Test
  114 |         expect(mml.children.length).toEqual(1);
  115 |     });
  116 | });</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  124 |
  125 |     it(&quot;should build a list of puncts&quot;, function() {
&gt; 126 |         const parse &#x3D; getParsed(expression);
      |                      ^ Lazy Test
  127 |
  128 |         for (let i &#x3D; 0; i &lt; parse.length; i++) {
  129 |             const group &#x3D; parse[i];</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  142 |
  143 |     it(&quot;should build a list of opens&quot;, function() {
&gt; 144 |         const parse &#x3D; getParsed(expression);
      |                      ^ Lazy Test
  145 |
  146 |         for (let i &#x3D; 0; i &lt; parse.length; i++) {
  147 |             const group &#x3D; parse[i];</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  160 |
  161 |     it(&quot;should build a list of closes&quot;, function() {
&gt; 162 |         const parse &#x3D; getParsed(expression);
      |                      ^ Lazy Test
  163 |
  164 |         for (let i &#x3D; 0; i &lt; parse.length; i++) {
  165 |             const group &#x3D; parse[i];</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  492 |
  493 |     it(&quot;should produce a frac&quot;, function() {
&gt; 494 |         const parse &#x3D; getParsed(expression)[0];
      |                      ^ Lazy Test
  495 |
  496 |         expect(parse.type).toEqual(&quot;genfrac&quot;);
  497 |         expect(parse.numer).toBeDefined();</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  508 |
  509 |     it(&quot;should parse cfrac, dfrac, tfrac, and genfrac as fracs&quot;, function() {
&gt; 510 |         const dfracParse &#x3D; getParsed(dfracExpression)[0];
      |                           ^ Lazy Test
  511 |
  512 |         expect(dfracParse.type).toEqual(&quot;genfrac&quot;);
  513 |         expect(dfracParse.numer).toBeDefined();</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  571 |         let parse;
  572 |
&gt; 573 |         parse &#x3D; getParsed(simpleOver)[0];
      |                ^ Lazy Test
  574 |
  575 |         expect(parse.type).toEqual(&quot;genfrac&quot;);
  576 |         expect(parse.numer).toBeDefined();</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  601 |
  602 |     it(&quot;should create a numerator from the atoms before \\over&quot;, function() {
&gt; 603 |         const parse &#x3D; getParsed(complexOver)[0];
      |                      ^ Lazy Test
  604 |
  605 |         const numer &#x3D; parse.numer;
  606 |         expect(numer.body).toHaveLength(4);</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  608 |
  609 |     it(&quot;should create a denominator from the atoms after \\over&quot;, function() {
&gt; 610 |         const parse &#x3D; getParsed(complexOver)[0];
      |                      ^ Lazy Test
  611 |
  612 |         const denom &#x3D; parse.denom;
  613 |         expect(denom.body).toHaveLength(4);</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  616 |     it(&quot;should handle empty numerators&quot;, function() {
  617 |         const emptyNumerator &#x3D; r&#x60;\over x&#x60;;
&gt; 618 |         const parse &#x3D; getParsed(emptyNumerator)[0];
      |                      ^ Lazy Test
  619 |         expect(parse.type).toEqual(&quot;genfrac&quot;);
  620 |         expect(parse.numer).toBeDefined();
  621 |         expect(parse.denom).toBeDefined();</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  624 |     it(&quot;should handle empty denominators&quot;, function() {
  625 |         const emptyDenominator &#x3D; r&#x60;1 \over&#x60;;
&gt; 626 |         const parse &#x3D; getParsed(emptyDenominator)[0];
      |                      ^ Lazy Test
  627 |         expect(parse.type).toEqual(&quot;genfrac&quot;);
  628 |         expect(parse.numer).toBeDefined();
  629 |         expect(parse.denom).toBeDefined();</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  632 |     it(&quot;should handle \\displaystyle correctly&quot;, function() {
  633 |         const displaystyleExpression &#x3D; r&#x60;\displaystyle 1 \over 2&#x60;;
&gt; 634 |         const parse &#x3D; getParsed(displaystyleExpression)[0];
      |                      ^ Lazy Test
  635 |         expect(parse.type).toEqual(&quot;genfrac&quot;);
  636 |         expect(parse.numer.body[0].type).toEqual(&quot;styling&quot;);
  637 |         expect(parse.denom).toBeDefined();</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  645 |     it(&quot;should handle nested factions&quot;, function() {
  646 |         const nestedOverExpression &#x3D; r&#x60;{1 \over 2} \over 3&#x60;;
&gt; 647 |         const parse &#x3D; getParsed(nestedOverExpression)[0];
      |                      ^ Lazy Test
  648 |         expect(parse.type).toEqual(&quot;genfrac&quot;);
  649 |         expect(parse.numer.body[0].type).toEqual(&quot;genfrac&quot;);
  650 |         expect(parse.numer.body[0].numer.body[0].text).toEqual(&quot;1&quot;);</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  694 |
  695 |     it(&quot;should produce a sizing node&quot;, function() {
&gt; 696 |         const parse &#x3D; getParsed(sizeExpression)[0];
      |                      ^ Lazy Test
  697 |
  698 |         expect(parse.type).toEqual(&quot;sizing&quot;);
  699 |         expect(parse.size).toBeDefined();</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  718 |
  719 |     it(&quot;should produce a text&quot;, function() {
&gt; 720 |         const parse &#x3D; getParsed(textExpression)[0];
      |                      ^ Lazy Test
  721 |
  722 |         expect(parse.type).toEqual(&quot;text&quot;);
  723 |         expect(parse.body).toBeDefined();</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  725 |
  726 |     it(&quot;should produce textords instead of mathords&quot;, function() {
&gt; 727 |         const parse &#x3D; getParsed(textExpression)[0];
      |                      ^ Lazy Test
  728 |         const group &#x3D; parse.body;
  729 |
  730 |         expect(group[0].type).toEqual(&quot;textord&quot;);</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  748 |
  749 |     it(&quot;should contract spaces&quot;, function() {
&gt; 750 |         const parse &#x3D; getParsed(spaceTextExpression)[0];
      |                      ^ Lazy Test
  751 |         const group &#x3D; parse.body;
  752 |
  753 |         expect(group.length).toEqual(4);</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  767 |
  768 |     it(&quot;should ignore a space before the text group&quot;, function() {
&gt; 769 |         const parse &#x3D; getParsed(leadingSpaceTextExpression)[0];
      |                      ^ Lazy Test
  770 |         &#x2F;&#x2F; [m, o, o]
  771 |         expect(parse.body).toHaveLength(3);
  772 |         expect(parse.body.map(n &#x3D;&gt; n.text).join(&quot;&quot;)).toBe(&quot;moo&quot;);</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  854 |
  855 |     it(&quot;should build a color node&quot;, function() {
&gt; 856 |         const parse &#x3D; getParsed(colorExpression)[0];
      |                      ^ Lazy Test
  857 |
  858 |         expect(parse.type).toEqual(&quot;color&quot;);
  859 |         expect(parse.color).toBeDefined();</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  868 |
  869 |     it(&quot;should correctly extract the custom color&quot;, function() {
&gt; 870 |         const parse1 &#x3D; getParsed(customColorExpression1)[0];
      |                       ^ Lazy Test
  871 |         const parse2 &#x3D; getParsed(customColorExpression2)[0];
  872 |         const parse3 &#x3D; getParsed(customColorExpression3)[0];
  873 |</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  927 |
  928 |     it(&quot;should produce spacing in math mode&quot;, function() {
&gt; 929 |         const parse &#x3D; getParsed(mathTie);
      |                      ^ Lazy Test
  930 |
  931 |         expect(parse[1].type).toEqual(&quot;spacing&quot;);
  932 |     });</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  933 |
  934 |     it(&quot;should produce spacing in text mode&quot;, function() {
&gt; 935 |         const text &#x3D; getParsed(textTie)[0];
      |                     ^ Lazy Test
  936 |         const parse &#x3D; text.body;
  937 |
  938 |         expect(parse[1].type).toEqual(&quot;spacing&quot;);</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  940 |
  941 |     it(&quot;should not contract with spaces in text mode&quot;, function() {
&gt; 942 |         const text &#x3D; getParsed(textTie)[0];
      |                     ^ Lazy Test
  943 |         const parse &#x3D; text.body;
  944 |
  945 |         expect(parse[2].type).toEqual(&quot;spacing&quot;);</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  962 |
  963 |     it(&quot;should produce a delimsizing&quot;, function() {
&gt; 964 |         const parse &#x3D; getParsed(normalDelim)[0];
      |                      ^ Lazy Test
  965 |
  966 |         expect(parse.type).toEqual(&quot;delimsizing&quot;);
  967 |     });</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  968 |
  969 |     it(&quot;should produce the correct direction delimiter&quot;, function() {
&gt; 970 |         const leftParse &#x3D; getParsed(normalDelim)[0];
      |                          ^ Lazy Test
  971 |         const rightParse &#x3D; getParsed(bigDelim)[0];
  972 |
  973 |         expect(leftParse.mclass).toEqual(&quot;mopen&quot;);</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  976 |
  977 |     it(&quot;should parse the correct size delimiter&quot;, function() {
&gt; 978 |         const smallParse &#x3D; getParsed(normalDelim)[0];
      |                           ^ Lazy Test
  979 |         const bigParse &#x3D; getParsed(bigDelim)[0];
  980 |
  981 |         expect(smallParse.size).toEqual(1);</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  992 |
  993 |     it(&quot;should produce an overline&quot;, function() {
&gt; 994 |         const parse &#x3D; getParsed(overline)[0];
      |                      ^ Lazy Test
  995 |
  996 |         expect(parse.type).toEqual(&quot;overline&quot;);
  997 |     });</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  1051 |
  1052 |     it(&quot;should produce a rule&quot;, function() {
&gt; 1053 |         const parse &#x3D; getParsed(emRule)[0];
       |                      ^ Lazy Test
  1054 |
  1055 |         expect(parse.type).toEqual(&quot;rule&quot;);
  1056 |     });</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  1057 |
  1058 |     it(&quot;should list the correct units&quot;, function() {
&gt; 1059 |         const emParse &#x3D; getParsed(emRule)[0];
       |                        ^ Lazy Test
  1060 |         const exParse &#x3D; getParsed(exRule)[0];
  1061 |
  1062 |         expect(emParse.width.unit).toEqual(&quot;em&quot;);</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  1068 |
  1069 |     it(&quot;should parse the number correctly&quot;, function() {
&gt; 1070 |         const hardNumberParse &#x3D; getParsed(hardNumberRule)[0];
       |                                ^ Lazy Test
  1071 |
  1072 |         expect(hardNumberParse.width.number).toBeCloseTo(1.24);
  1073 |         expect(hardNumberParse.height.number).toBeCloseTo(2.45);</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  1095 |
  1096 |     it(&quot;should list the correct units&quot;, function() {
&gt; 1097 |         const emParse &#x3D; getParsed(emKern)[0];
       |                        ^ Lazy Test
  1098 |         const exParse &#x3D; getParsed(exKern)[0];
  1099 |         const muParse &#x3D; getParsed(muKern)[0];
  1100 |         const abParse &#x3D; getParsed(abKern)[1];</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  1133 |
  1134 |     it(&quot;should list the correct units&quot;, function() {
&gt; 1135 |         const emParse &#x3D; getParsed(emKern)[0];
       |                        ^ Lazy Test
  1136 |         const exParse &#x3D; getParsed(exKern)[0];
  1137 |         const muParse &#x3D; getParsed(muKern)[0];
  1138 |         const abParse1 &#x3D; getParsed(abKern1)[1];</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  1149 |
  1150 |     it(&quot;should parse elements on either side of a kern&quot;, function() {
&gt; 1151 |         const abParse1 &#x3D; getParsed(abKern1);
       |                         ^ Lazy Test
  1152 |         const abParse2 &#x3D; getParsed(abKern2);
  1153 |         const abParse3 &#x3D; getParsed(abKern3);
  1154 |</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  1180 |
  1181 |     it(&quot;should handle whitespace&quot;, function() {
&gt; 1182 |         const abParse &#x3D; getParsed(&quot;a\\mkern\t-\r1  \n mu\nb&quot;);
       |                        ^ Lazy Test
  1183 |
  1184 |         expect(abParse).toHaveLength(3);
  1185 |         expect(abParse[0].text).toEqual(&quot;a&quot;);</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  1198 |
  1199 |     it(&quot;should produce a leftright&quot;, function() {
&gt; 1200 |         const parse &#x3D; getParsed(normalLeftRight)[0];
       |                      ^ Lazy Test
  1201 |
  1202 |         expect(parse.type).toEqual(&quot;leftright&quot;);
  1203 |         expect(parse.left).toEqual(&quot;(&quot;);</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  1375 |
  1376 |     it(&quot;should produce sqrts&quot;, function() {
&gt; 1377 |         const parse &#x3D; getParsed(sqrt)[0];
       |                      ^ Lazy Test
  1378 |
  1379 |         expect(parse.type).toEqual(&quot;sqrt&quot;);
  1380 |     });</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  1574 |     it(&quot;should only change the style within its group&quot;, function() {
  1575 |         const text &#x3D; r&#x60;a b { c d \displaystyle e f } g h&#x60;;
&gt; 1576 |         const parse &#x3D; getParsed(text);
       |                      ^ Lazy Test
  1577 |
  1578 |         const displayNode &#x3D; parse[2].body[2];
  1579 |</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  2074 |     it(&quot;should render a combination of font and color changes&quot;, function() {
  2075 |         let tex &#x3D; r&#x60;\textcolor{blue}{\mathbb R}&#x60;;
&gt; 2076 |         let tree &#x3D; getParsed(tex);
       |                   ^ Lazy Test
  2077 |         let markup &#x3D; buildMathML(tree, tex, defaultOptions).toMarkup();
  2078 |         let node &#x3D; &quot;&lt;mstyle mathcolor&#x3D;\&quot;blue\&quot;&gt;&quot; +
  2079 |             &quot;&lt;mi mathvariant&#x3D;\&quot;double-struck\&quot;&gt;R&lt;&#x2F;mi&gt;&quot; +</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  2093 |     it(&quot;should render text as &lt;mtext&gt;&quot;, function() {
  2094 |         const tex &#x3D; r&#x60;\text{for }&#x60;;
&gt; 2095 |         const tree &#x3D; getParsed(tex);
       |                     ^ Lazy Test
  2096 |         const markup &#x3D; buildMathML(tree, tex, defaultOptions).toMarkup();
  2097 |         expect(markup).toContain(&quot;&lt;mtext&gt;for\u00a0&lt;&#x2F;mtext&gt;&quot;);
  2098 |     });</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  2100 |     it(&quot;should render math within text as side-by-side children&quot;, function() {
  2101 |         const tex &#x3D; r&#x60;\text{graph: $y &#x3D; mx + b$}&#x60;;
&gt; 2102 |         const tree &#x3D; getParsed(tex);
       |                     ^ Lazy Test
  2103 |         const markup &#x3D; buildMathML(tree, tex, defaultOptions).toMarkup();
  2104 |         expect(markup).toContain(&quot;&lt;mrow&gt;&lt;mtext&gt;graph:\u00a0&lt;&#x2F;mtext&gt;&quot;);
  2105 |         expect(markup).toContain(</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  2115 |
  2116 |     it(&quot;should produce mords&quot;, function() {
&gt; 2117 |         expect(getBuilt(img, trustSettings)[0].classes).toContain(&quot;mord&quot;);
       |               ^ Lazy Test
  2118 |     });
  2119 |
  2120 |     it(&quot;should not render without trust setting&quot;, function() {</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  2119 |
  2120 |     it(&quot;should not render without trust setting&quot;, function() {
&gt; 2121 |         const built &#x3D; getBuilt(img);
       |                      ^ Lazy Test
  2122 |         expect(built).toMatchSnapshot();
  2123 |     });
  2124 |</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  2124 |
  2125 |     it(&quot;should render with trust setting&quot;, function() {
&gt; 2126 |         const built &#x3D; getBuilt(img, trustSettings);
       |                      ^ Lazy Test
  2127 |         expect(built).toMatchSnapshot();
  2128 |     });
  2129 |</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  2150 |
  2151 |     it(&quot;should set HTML attributes&quot;, function() {
&gt; 2152 |         const built &#x3D; getBuilt(html, trustNonStrictSettings);
       |                      ^ Lazy Test
  2153 |         expect(built[0].attributes.id).toMatch(&quot;bar&quot;);
  2154 |         expect(built[1].classes).toContain(&quot;foo&quot;);
  2155 |         expect(built[2].attributes.style).toMatch(&quot;color: red&quot;);</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  2161 |
  2162 |     it(&quot;should not affect spacing&quot;, function() {
&gt; 2163 |         const built &#x3D; getBuilt(&quot;\\htmlId{a}{x+}y&quot;, trustNonStrictSettings);
       |                      ^ Lazy Test
  2164 |         expect(built).toMatchSnapshot();
  2165 |     });
  2166 |</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  2166 |
  2167 |     it(&quot;should render with trust and strict setting&quot;, function() {
&gt; 2168 |         const built &#x3D; getBuilt(html, trustNonStrictSettings);
       |                      ^ Lazy Test
  2169 |         expect(built).toMatchSnapshot();
  2170 |     });
  2171 |</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  2341 |     it(&quot;should properly render stretchy accents&quot;, function() {
  2342 |         const tex &#x3D; &#x60;\\widetilde{ABCD}&#x60;;
&gt; 2343 |         const tree &#x3D; getParsed(tex);
       |                     ^ Lazy Test
  2344 |         const markup &#x3D; buildMathML(tree, tex, defaultOptions).toMarkup();
  2345 |         expect(markup).toContain(&#39;&lt;mo stretchy&#x3D;&quot;true&quot;&gt;~&lt;&#x2F;mo&gt;&#39;);
  2346 |     });</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  2991 |     it(&quot;should allow letters [#$%&amp;~_^] without escaping&quot;, function() {
  2992 |         const url &#x3D; &quot;http:&#x2F;&#x2F;example.org&#x2F;~bar&#x2F;#top?foo&#x3D;$foo&amp;bar&#x3D;ba^r_boo%20baz&quot;;
&gt; 2993 |         const parsed1 &#x3D; getParsed(&#x60;\\href{${url}}{\\alpha}&#x60;, trustSettings)[0];
       |                        ^ Lazy Test
  2994 |         expect(parsed1.href).toBe(url);
  2995 |         const parsed2 &#x3D; getParsed(&#x60;\\url{${url}}&#x60;, trustSettings)[0];
  2996 |         expect(parsed2.href).toBe(url);</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  2999 |     it(&quot;should allow balanced braces in url&quot;, function() {
  3000 |         const url &#x3D; &quot;http:&#x2F;&#x2F;example.org&#x2F;{{}t{oo}}&quot;;
&gt; 3001 |         const parsed1 &#x3D; getParsed(&#x60;\\href{${url}}{\\alpha}&#x60;, trustSettings)[0];
       |                        ^ Lazy Test
  3002 |         expect(parsed1.href).toBe(url);
  3003 |         const parsed2 &#x3D; getParsed(&#x60;\\url{${url}}&#x60;, trustSettings)[0];
  3004 |         expect(parsed2.href).toBe(url);</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  3015 |         const url &#x3D; &quot;http:&#x2F;&#x2F;example.org&#x2F;~bar&#x2F;#top?foo&#x3D;$}foo{&amp;bar&#x3D;bar^r_boo%20baz&quot;;
  3016 |         const input &#x3D; url.replace(&#x2F;([#$%&amp;~_^{}])&#x2F;g, &#39;\\$1&#39;);
&gt; 3017 |         const parsed1 &#x3D; getParsed(&#x60;\\href{${input}}{\\alpha}&#x60;, trustSettings)[0];
       |                        ^ Lazy Test
  3018 |         expect(parsed1.href).toBe(url);
  3019 |         const parsed2 &#x3D; getParsed(&#x60;\\url{${input}}&#x60;, trustSettings)[0];
  3020 |         expect(parsed2.href).toBe(url);</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  3031 |
  3032 |     it(&quot;should not affect spacing around&quot;, function() {
&gt; 3033 |         const built &#x3D; getBuilt(&quot;a\\href{http:&#x2F;&#x2F;example.com&#x2F;}{+b}&quot;, trustSettings);
       |                      ^ Lazy Test
  3034 |         expect(built).toMatchSnapshot();
  3035 |     });
  3036 |</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  3041 |
  3042 |     it(&quot;should allow explicitly allowed protocols&quot;, () &#x3D;&gt; {
&gt; 3043 |         const parsed &#x3D; getParsed(
       |                       ^ Lazy Test
  3044 |             &quot;\\href{ftp:&#x2F;&#x2F;x}{foo}&quot;,
  3045 |             new Settings({trust: (context) &#x3D;&gt; context.protocol &#x3D;&#x3D;&#x3D; &quot;ftp&quot;}),
  3046 |         );</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  3049 |
  3050 |     it(&quot;should allow all protocols when trust option is true&quot;, () &#x3D;&gt; {
&gt; 3051 |         const parsed &#x3D; getParsed(&quot;\\href{ftp:&#x2F;&#x2F;x}{foo}&quot;, trustSettings);
       |                       ^ Lazy Test
  3052 |         expect(parsed).toMatchSnapshot();
  3053 |     });
  3054 |</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  3054 |
  3055 |     it(&quot;should not allow explicitly disallowed protocols&quot;, () &#x3D;&gt; {
&gt; 3056 |         const parsed &#x3D; getParsed(
       |                       ^ Lazy Test
  3057 |             &quot;\\href{javascript:alert(&#39;x&#39;)}{foo}&quot;,
  3058 |             new Settings({trust: context &#x3D;&gt; context.protocol !&#x3D;&#x3D; &quot;javascript&quot;}),
  3059 |         );</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  3062 |
  3063 |     it(&quot;should not allow explicitly uppercased disallowed protocols&quot;, () &#x3D;&gt; {
&gt; 3064 |         const parsed &#x3D; getParsed(
       |                       ^ Lazy Test
  3065 |             &quot;\\href{JavaScript:alert(&#39;x&#39;)}{foo}&quot;,
  3066 |             new Settings({trust: context &#x3D;&gt; context.protocol !&#x3D;&#x3D; &quot;javascript&quot;}),
  3067 |         );</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  3138 |
  3139 |     it(&quot;should produce color nodes with a color value given by errorColor&quot;, function() {
&gt; 3140 |         const parsedInput &#x3D; getParsed(r&#x60;\error&#x60;, noThrowSettings);
       |                            ^ Lazy Test
  3141 |         expect(parsedInput[0].type).toBe(&quot;color&quot;);
  3142 |         expect(parsedInput[0].color).toBe(errorColor);
  3143 |     });</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  3144 |
  3145 |     it(&quot;should build katex-error span for other type of KaTeX error&quot;, function() {
&gt; 3146 |         const built &#x3D; getBuilt(&#x60;2^2^2&#x60;, noThrowSettings);
       |                      ^ Lazy Test
  3147 |         expect(built).toMatchSnapshot();
  3148 |     });
  3149 |</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  3479 |         const parsedBare &#x3D; getParsed&#x60;~&#x60;;
  3480 |         expect(parsedBare[0].type).toEqual(&quot;spacing&quot;);
&gt; 3481 |         const parsedChar &#x3D; getParsed(&quot;\\char&#x60;\\~&quot;);
       |                           ^ Lazy Test
  3482 |         expect(parsedChar[0].type).toEqual(&quot;textord&quot;);
  3483 |     });
  3484 |</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  4051 |
  4052 |     it(&quot;should clamp size when set&quot;, function() {
&gt; 4053 |         const built &#x3D; getBuilt(rule, new Settings({maxSize: 5}))[0];
       |                      ^ Lazy Test
  4054 |         expect(built.style.borderRightWidth).toEqual(&quot;5em&quot;);
  4055 |         expect(built.style.borderTopWidth).toEqual(&quot;5em&quot;);
  4056 |     });</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  4057 |
  4058 |     it(&quot;should not clamp size when not set&quot;, function() {
&gt; 4059 |         const built &#x3D; getBuilt(rule)[0];
       |                      ^ Lazy Test
  4060 |         expect(built.style.borderRightWidth).toEqual(&quot;999em&quot;);
  4061 |         expect(built.style.borderTopWidth).toEqual(&quot;999em&quot;);
  4062 |     });</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  4063 |
  4064 |     it(&quot;should make zero-width rules if a negative maxSize is passed&quot;, function() {
&gt; 4065 |         const built &#x3D; getBuilt(rule, new Settings({maxSize: -5}))[0];
       |                      ^ Lazy Test
  4066 |         expect(built.style.borderRightWidth).toEqual(&quot;0em&quot;);
  4067 |         expect(built.style.borderTopWidth).toEqual(&quot;0em&quot;);
  4068 |     });</code></pre><br>
                      </td>
                    </tr>
                  </tbody>
                </table>
                <hr>
                <table class="table is-fullwidth" id="table-of-smell">
                  <thead>
                    <tr>
                      <td>Magic Number</td>
                    </tr>
                  </thead>
                  <tbody>
                    <tr>
                      <td>
                        <pre><code>  90 |             let group &#x3D; parse[i];
  91 |             if (group.type &#x3D;&#x3D;&#x3D; &quot;htmlmathml&quot;) {
&gt; 92 |                 expect(group.html).toHaveLength(1);
     |                                                ^ Magic Number
  93 |                 group &#x3D; group.html[0];
  94 |             }
  95 |             if (group.type &#x3D;&#x3D;&#x3D; &quot;mclass&quot;) {</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  112 |         const contents &#x3D; &quot;\\mathinner{\\langle{\\psi}\\rangle}&quot;;
  113 |         const mml &#x3D; buildMathML(getParsed(contents), contents, defaultOptions);
&gt; 114 |         expect(mml.children.length).toEqual(1);
      |                                            ^ Magic Number
  115 |     });
  116 | });
  117 |</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  344 |         const parse &#x3D; getParsed&#x60;{xy}&#x60;;
  345 |
&gt; 346 |         expect(parse).toHaveLength(1);
      |                                   ^ Magic Number
  347 |
  348 |         const ord &#x3D; parse[0];
  349 |</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  366 |         const parse &#x3D; getParsed&#x60;\begingroup xy \endgroup&#x60;;
  367 |
&gt; 368 |         expect(parse).toHaveLength(1);
      |                                   ^ Magic Number
  369 |
  370 |         const ord &#x3D; parse[0];
  371 |</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  402 |         const parse &#x3D; getParsed&#x60;a \Large abc&#x60;;
  403 |
&gt; 404 |         expect(parse).toHaveLength(2);
      |                                   ^ Magic Number
  405 |
  406 |         const sizing &#x3D; parse[1];
  407 |</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  407 |
  408 |         expect(sizing.type).toEqual(&quot;sizing&quot;);
&gt; 409 |         expect(sizing.body).toHaveLength(3);
      |                                         ^ Magic Number
  410 |     });
  411 |
  412 |     it(&quot;should stop at the ends of groups&quot;, function() {</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  417 |
  418 |         expect(sizing.type).toEqual(&quot;sizing&quot;);
&gt; 419 |         expect(sizing.body).toHaveLength(1);
      |                                         ^ Magic Number
  420 |     });
  421 |
  422 |     describe(&quot;within optional groups&quot;, () &#x3D;&gt; {</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  604 |
  605 |         const numer &#x3D; parse.numer;
&gt; 606 |         expect(numer.body).toHaveLength(4);
      |                                        ^ Magic Number
  607 |     });
  608 |
  609 |     it(&quot;should create a denominator from the atoms after \\over&quot;, function() {</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  611 |
  612 |         const denom &#x3D; parse.denom;
&gt; 613 |         expect(denom.body).toHaveLength(4);
      |                                        ^ Magic Number
  614 |     });
  615 |
  616 |     it(&quot;should handle empty numerators&quot;, function() {</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  751 |         const group &#x3D; parse.body;
  752 |
&gt; 753 |         expect(group.length).toEqual(4);
      |                                     ^ Magic Number
  754 |         expect(group[0].type).toEqual(&quot;spacing&quot;);
  755 |         expect(group[1].type).toEqual(&quot;textord&quot;);
  756 |         expect(group[2].type).toEqual(&quot;spacing&quot;);</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  769 |         const parse &#x3D; getParsed(leadingSpaceTextExpression)[0];
  770 |         &#x2F;&#x2F; [m, o, o]
&gt; 771 |         expect(parse.body).toHaveLength(3);
      |                                        ^ Magic Number
  772 |         expect(parse.body.map(n &#x3D;&gt; n.text).join(&quot;&quot;)).toBe(&quot;moo&quot;);
  773 |     });
  774 |</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  979 |         const bigParse &#x3D; getParsed(bigDelim)[0];
  980 |
&gt; 981 |         expect(smallParse.size).toEqual(1);
      |                                        ^ Magic Number
  982 |         expect(bigParse.size).toEqual(4);
  983 |     });
  984 | });</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  980 |
  981 |         expect(smallParse.size).toEqual(1);
&gt; 982 |         expect(bigParse.size).toEqual(4);
      |                                      ^ Magic Number
  983 |     });
  984 | });
  985 |</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  1070 |         const hardNumberParse &#x3D; getParsed(hardNumberRule)[0];
  1071 |
&gt; 1072 |         expect(hardNumberParse.width.number).toBeCloseTo(1.24);
       |                                                         ^ Magic Number
  1073 |         expect(hardNumberParse.height.number).toBeCloseTo(2.45);
  1074 |     });
  1075 |</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  1071 |
  1072 |         expect(hardNumberParse.width.number).toBeCloseTo(1.24);
&gt; 1073 |         expect(hardNumberParse.height.number).toBeCloseTo(2.45);
       |                                                          ^ Magic Number
  1074 |     });
  1075 |
  1076 |     it(&quot;should parse negative sizes&quot;, function() {</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  1118 |     it(&quot;should parse positive sizes&quot;, function() {
  1119 |         const parse &#x3D; getParsed&#x60;\kern{+1em}&#x60;[0];
&gt; 1120 |         expect(parse.dimension.number).toBeCloseTo(1);
       |                                                   ^ Magic Number
  1121 |     });
  1122 | });
  1123 |</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  1153 |         const abParse3 &#x3D; getParsed(abKern3);
  1154 |
&gt; 1155 |         expect(abParse1).toHaveLength(3);
       |                                      ^ Magic Number
  1156 |         expect(abParse1[0].text).toEqual(&quot;a&quot;);
  1157 |         expect(abParse1[2].text).toEqual(&quot;b&quot;);
  1158 |         expect(abParse2).toHaveLength(3);</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  1156 |         expect(abParse1[0].text).toEqual(&quot;a&quot;);
  1157 |         expect(abParse1[2].text).toEqual(&quot;b&quot;);
&gt; 1158 |         expect(abParse2).toHaveLength(3);
       |                                      ^ Magic Number
  1159 |         expect(abParse2[0].text).toEqual(&quot;a&quot;);
  1160 |         expect(abParse2[2].text).toEqual(&quot;b&quot;);
  1161 |         expect(abParse3).toHaveLength(3);</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  1159 |         expect(abParse2[0].text).toEqual(&quot;a&quot;);
  1160 |         expect(abParse2[2].text).toEqual(&quot;b&quot;);
&gt; 1161 |         expect(abParse3).toHaveLength(3);
       |                                      ^ Magic Number
  1162 |         expect(abParse3[0].text).toEqual(&quot;a&quot;);
  1163 |         expect(abParse3[2].text).toEqual(&quot;b&quot;);
  1164 |     });</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  1176 |     it(&quot;should parse positive sizes&quot;, function() {
  1177 |         const parse &#x3D; getParsed&#x60;\kern+1em&#x60;[0];
&gt; 1178 |         expect(parse.dimension.number).toBeCloseTo(1);
       |                                                   ^ Magic Number
  1179 |     });
  1180 |
  1181 |     it(&quot;should handle whitespace&quot;, function() {</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  1182 |         const abParse &#x3D; getParsed(&quot;a\\mkern\t-\r1  \n mu\nb&quot;);
  1183 |
&gt; 1184 |         expect(abParse).toHaveLength(3);
       |                                     ^ Magic Number
  1185 |         expect(abParse[0].text).toEqual(&quot;a&quot;);
  1186 |         expect(abParse[1].dimension.unit).toEqual(&quot;mu&quot;);
  1187 |         expect(abParse[2].text).toEqual(&quot;b&quot;);</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  1335 |     it(&quot;should eat a final newline&quot;, function() {
  1336 |         const m3 &#x3D; getParsed&#x60;\begin{matrix}a&amp;b\\ c&amp;d \\ \end{matrix}&#x60;[0];
&gt; 1337 |         expect(m3.body).toHaveLength(2);
       |                                     ^ Magic Number
  1338 |     });
  1339 |
  1340 |     it(&quot;should grab \\arraystretch&quot;, function() {</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  1582 |         const displayBody &#x3D; displayNode.body;
  1583 |
&gt; 1584 |         expect(displayBody).toHaveLength(2);
       |                                         ^ Magic Number
  1585 |         expect(displayBody[0].text).toEqual(&quot;e&quot;);
  1586 |     });
  1587 | });</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  1636 |
  1637 |         const bbBody &#x3D; nestedParse.body.body;
&gt; 1638 |         expect(bbBody).toHaveLength(3);
       |                                    ^ Magic Number
  1639 |         expect(bbBody[0].type).toEqual(&quot;mathord&quot;);
  1640 |         expect(bbBody[2].type).toEqual(&quot;font&quot;);
  1641 |         expect(bbBody[2].font).toEqual(&quot;mathrm&quot;);</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  1648 |         expect(colorMathbbParse.color).toEqual(&quot;blue&quot;);
  1649 |         const body &#x3D; colorMathbbParse.body;
&gt; 1650 |         expect(body).toHaveLength(1);
       |                                  ^ Magic Number
  1651 |         expect(body[0].type).toEqual(&quot;font&quot;);
  1652 |         expect(body[0].font).toEqual(&quot;mathbb&quot;);
  1653 |     });</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  1661 |         expect(bf.type).toEqual(&quot;font&quot;);
  1662 |         expect(bf.font).toEqual(&quot;mathbf&quot;);
&gt; 1663 |         expect(bf.body.body).toHaveLength(3);
       |                                          ^ Magic Number
  1664 |         expect(bf.body.body[0].text).toEqual(&quot;a&quot;);
  1665 |         expect(bf.body.body[1].type).toEqual(&quot;font&quot;);
  1666 |         expect(bf.body.body[1].font).toEqual(&quot;mathrm&quot;);</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  2234 |         &#x2F;&#x2F; Just a few quick sanity checks here...
  2235 |         const markup &#x3D; katex.renderToString(r&#x60;\sigma^2&#x60;);
&gt; 2236 |         expect(markup.indexOf(&quot;&lt;span&quot;)).toBe(0);
       |                                             ^ Magic Number
  2237 |         expect(markup).toContain(&quot;\u03c3&quot;);  &#x2F;&#x2F; sigma
  2238 |         expect(markup).toContain(&quot;margin-right&quot;);
  2239 |         expect(markup).not.toContain(&quot;marginRight&quot;);</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  2740 |             parseTree(r&#x60;\sqrt}&#x60;, new Settings());
  2741 |         } catch (e) {
&gt; 2742 |             expect(e.position).toEqual(5);
       |                                       ^ Magic Number
  2743 |         }
  2744 |     });
  2745 | });</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  2874 |     it(&quot;should not eat the last row when its first cell is empty&quot;, function() {
  2875 |         const ae &#x3D; getParsed&#x60;\begin{aligned}&amp;E_1 &amp; (1)\\&amp;E_2 &amp; (2)\\&amp;E_3 &amp; (3)\end{aligned}&#x60;[0];
&gt; 2876 |         expect(ae.body).toHaveLength(3);
       |                                     ^ Magic Number
  2877 |     });
  2878 | });
  2879 |</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  3165 |             expect(error.message).toBe(&quot;KaTeX parse error: Undefined control sequence: \\fraq at position 5: 1 + \\̲f̲r̲a̲q̲{}{}&quot;);
  3166 |             expect(error.rawMessage).toBe(&quot;Undefined control sequence: \\fraq&quot;);
&gt; 3167 |             expect(error.position).toBe(4);
       |                                        ^ Magic Number
  3168 |             expect(error.length).toBe(5);
  3169 |         }
  3170 |     });</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  3166 |             expect(error.rawMessage).toBe(&quot;Undefined control sequence: \\fraq&quot;);
  3167 |             expect(error.position).toBe(4);
&gt; 3168 |             expect(error.length).toBe(5);
       |                                      ^ Magic Number
  3169 |         }
  3170 |     });
  3171 |</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  3180 |             expect(error.message).toBe(&quot;KaTeX parse error: Unexpected end of input in a macro argument, expected &#39;}&#39; at end of input: \\frac{}&quot;);
  3181 |             expect(error.rawMessage).toBe(&quot;Unexpected end of input in a macro argument, expected &#39;}&#39;&quot;);
&gt; 3182 |             expect(error.position).toBe(7);
       |                                        ^ Magic Number
  3183 |             expect(error.length).toBe(0);
  3184 |         }
  3185 |     });</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  3181 |             expect(error.rawMessage).toBe(&quot;Unexpected end of input in a macro argument, expected &#39;}&#39;&quot;);
  3182 |             expect(error.position).toBe(7);
&gt; 3183 |             expect(error.length).toBe(0);
       |                                      ^ Magic Number
  3184 |         }
  3185 |     });
  3186 |</code></pre><br>
                      </td>
                    </tr>
                  </tbody>
                </table>
                <hr>
                <table class="table is-fullwidth" id="table-of-smell">
                  <thead>
                    <tr>
                      <td>Redundant Assertion</td>
                    </tr>
                  </thead>
                  <tbody>
                    <tr>
                      <td>
                        <pre><code>  759 |
  760 |     it(&quot;should handle backslash followed by newline&quot;, () &#x3D;&gt; {
&gt; 761 |         expect(&quot;\\text{\\ \t\r \n \t\r  }&quot;).toParseLike&#x60;\text{\ }&#x60;;
      |        ^ Redundant Assertion
  762 |     });
  763 |
  764 |     it(&quot;should accept math mode tokens after its argument&quot;, function() {</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  1730 | describe(&quot;A comment parser&quot;, function() {
  1731 |     it(&quot;should parse comments at the end of a line&quot;, () &#x3D;&gt; {
&gt; 1732 |         expect(&quot;a^2 + b^2 &#x3D; c^2 % Pythagoras&#39; Theorem\n&quot;).toParse();
       |        ^ Redundant Assertion
  1733 |     });
  1734 |
  1735 |     it(&quot;should parse comments at the start of a line&quot;, () &#x3D;&gt; {</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  1734 |
  1735 |     it(&quot;should parse comments at the start of a line&quot;, () &#x3D;&gt; {
&gt; 1736 |         expect(&quot;% comment\n&quot;).toParse();
       |        ^ Redundant Assertion
  1737 |     });
  1738 |
  1739 |     it(&quot;should parse multiple lines of comments in a row&quot;, () &#x3D;&gt; {</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  1738 |
  1739 |     it(&quot;should parse multiple lines of comments in a row&quot;, () &#x3D;&gt; {
&gt; 1740 |         expect(&quot;% comment 1\n% comment 2\n&quot;).toParse();
       |        ^ Redundant Assertion
  1741 |     });
  1742 |
  1743 |     it(&quot;should parse comments between subscript and superscript&quot;, () &#x3D;&gt; {</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  1742 |
  1743 |     it(&quot;should parse comments between subscript and superscript&quot;, () &#x3D;&gt; {
&gt; 1744 |         expect(&quot;x_3 %comment\n^2&quot;).toParseLike&#x60;x_3^2&#x60;;
       |        ^ Redundant Assertion
  1745 |         expect(&quot;x^ %comment\n{2}&quot;).toParseLike&#x60;x^{2}&#x60;;
  1746 |         expect(&quot;x^ %comment\n\\frac{1}{2}&quot;).toParseLike&#x60;x^\frac{1}{2}&#x60;;
  1747 |     });</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  1743 |     it(&quot;should parse comments between subscript and superscript&quot;, () &#x3D;&gt; {
  1744 |         expect(&quot;x_3 %comment\n^2&quot;).toParseLike&#x60;x_3^2&#x60;;
&gt; 1745 |         expect(&quot;x^ %comment\n{2}&quot;).toParseLike&#x60;x^{2}&#x60;;
       |        ^ Redundant Assertion
  1746 |         expect(&quot;x^ %comment\n\\frac{1}{2}&quot;).toParseLike&#x60;x^\frac{1}{2}&#x60;;
  1747 |     });
  1748 |</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  1744 |         expect(&quot;x_3 %comment\n^2&quot;).toParseLike&#x60;x_3^2&#x60;;
  1745 |         expect(&quot;x^ %comment\n{2}&quot;).toParseLike&#x60;x^{2}&#x60;;
&gt; 1746 |         expect(&quot;x^ %comment\n\\frac{1}{2}&quot;).toParseLike&#x60;x^\frac{1}{2}&#x60;;
       |        ^ Redundant Assertion
  1747 |     });
  1748 |
  1749 |     it(&quot;should parse comments in size and color groups&quot;, () &#x3D;&gt; {</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  1748 |
  1749 |     it(&quot;should parse comments in size and color groups&quot;, () &#x3D;&gt; {
&gt; 1750 |         expect(&quot;\\kern{1 %kern\nem}&quot;).toParse();
       |        ^ Redundant Assertion
  1751 |         expect(&quot;\\kern1 %kern\nem&quot;).toParse();
  1752 |         expect(&quot;\\color{#f00%red\n}&quot;).toParse();
  1753 |     });</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  1749 |     it(&quot;should parse comments in size and color groups&quot;, () &#x3D;&gt; {
  1750 |         expect(&quot;\\kern{1 %kern\nem}&quot;).toParse();
&gt; 1751 |         expect(&quot;\\kern1 %kern\nem&quot;).toParse();
       |        ^ Redundant Assertion
  1752 |         expect(&quot;\\color{#f00%red\n}&quot;).toParse();
  1753 |     });
  1754 |</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  1750 |         expect(&quot;\\kern{1 %kern\nem}&quot;).toParse();
  1751 |         expect(&quot;\\kern1 %kern\nem&quot;).toParse();
&gt; 1752 |         expect(&quot;\\color{#f00%red\n}&quot;).toParse();
       |        ^ Redundant Assertion
  1753 |     });
  1754 |
  1755 |     it(&quot;should parse comments before an expression&quot;, () &#x3D;&gt; {</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  1754 |
  1755 |     it(&quot;should parse comments before an expression&quot;, () &#x3D;&gt; {
&gt; 1756 |         expect(&quot;%comment\n{2}&quot;).toParseLike&#x60;{2}&#x60;;
       |        ^ Redundant Assertion
  1757 |     });
  1758 |
  1759 |     it(&quot;should parse comments before and between \\hline&quot;, () &#x3D;&gt; {</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  1764 |
  1765 |     it(&quot;should parse comments in the macro definition&quot;, () &#x3D;&gt; {
&gt; 1766 |         expect(&quot;\\def\\foo{1 %}\n2}\n\\foo&quot;).toParseLike&#x60;12&#x60;;
       |        ^ Redundant Assertion
  1767 |     });
  1768 |
  1769 |     it(&quot;should not expand nor ignore spaces after a command sequence in a comment&quot;, () &#x3D;&gt; {</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  1768 |
  1769 |     it(&quot;should not expand nor ignore spaces after a command sequence in a comment&quot;, () &#x3D;&gt; {
&gt; 1770 |         expect(&quot;\\def\\foo{1\n2}\nx %\\foo\n&quot;).toParseLike&#x60;x&#x60;;
       |        ^ Redundant Assertion
  1771 |     });
  1772 |
  1773 |     it(&quot;should not parse a comment without newline in strict mode&quot;, () &#x3D;&gt; {</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  1777 |
  1778 |     it(&quot;should not produce or consume space&quot;, () &#x3D;&gt; {
&gt; 1779 |         expect(&quot;\\text{hello% comment 1\nworld}&quot;).toParseLike&#x60;\text{helloworld}&#x60;;
       |        ^ Redundant Assertion
  1780 |         expect(&quot;\\text{hello% comment\n\nworld}&quot;).toParseLike&#x60;\text{hello world}&#x60;;
  1781 |     });
  1782 |</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  1778 |     it(&quot;should not produce or consume space&quot;, () &#x3D;&gt; {
  1779 |         expect(&quot;\\text{hello% comment 1\nworld}&quot;).toParseLike&#x60;\text{helloworld}&#x60;;
&gt; 1780 |         expect(&quot;\\text{hello% comment\n\nworld}&quot;).toParseLike&#x60;\text{hello world}&#x60;;
       |        ^ Redundant Assertion
  1781 |     });
  1782 |
  1783 |     it(&quot;should not include comments in the output&quot;, () &#x3D;&gt; {</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  1782 |
  1783 |     it(&quot;should not include comments in the output&quot;, () &#x3D;&gt; {
&gt; 1784 |         expect(&quot;5 % comment\n&quot;).toParseLike&#x60;5&#x60;;
       |        ^ Redundant Assertion
  1785 |     });
  1786 | });
  1787 |</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  2177 |
  2178 |                 &#x2F;&#x2F; Render is expected to throw, so this should not be called.
&gt; 2179 |                 expect(true).toBe(false);
       |                ^ Redundant Assertion
  2180 |             } catch (error) {
  2181 |                 expect(error).toBeInstanceOf(ParseError);
  2182 |                 const message &#x3D;</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  2979 |         expect&#x60;\href%end&#x60;.toParseLike(&quot;\\href{%}end&quot;, trustSettings);
  2980 |         expect&#x60;\url%end&#x60;.toParseLike(&quot;\\url{%}end&quot;, trustSettings);
&gt; 2981 |         expect(&quot;\\url%%end\n&quot;).toParseLike(&quot;\\url{%}&quot;, trustSettings);
       |        ^ Redundant Assertion
  2982 |         expect&#x60;\url end&#x60;.toParseLike(&quot;\\url{e}nd&quot;, trustSettings);
  2983 |         expect&#x60;\url%end&#x60;.toParseLike(&quot;\\url {%}end&quot;, trustSettings);
  2984 |     });</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  3022 |
  3023 |     it(&quot;should allow comments after URLs&quot;, function() {
&gt; 3024 |         expect(&quot;\\url{http:&#x2F;&#x2F;example.com&#x2F;}%comment\n&quot;).toBuild();
       |        ^ Redundant Assertion
  3025 |     });
  3026 |
  3027 |     it(&quot;should be marked up correctly&quot;, function() {</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  3160 |
  3161 |             &#x2F;&#x2F; Render is expected to throw, so this should not be called.
&gt; 3162 |             expect(true).toBe(false);
       |            ^ Redundant Assertion
  3163 |         } catch (error) {
  3164 |             expect(error).toBeInstanceOf(ParseError);
  3165 |             expect(error.message).toBe(&quot;KaTeX parse error: Undefined control sequence: \\fraq at position 5: 1 + \\̲f̲r̲a̲q̲{}{}&quot;);</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  3175 |
  3176 |             &#x2F;&#x2F; Render is expected to throw, so this should not be called.
&gt; 3177 |             expect(true).toBe(false);
       |            ^ Redundant Assertion
  3178 |         } catch (error) {
  3179 |             expect(error).toBeInstanceOf(ParseError);
  3180 |             expect(error.message).toBe(&quot;KaTeX parse error: Unexpected end of input in a macro argument, expected &#39;}&#39; at end of input: \\frac{}&quot;);</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  3190 |
  3191 |             &#x2F;&#x2F; Render is expected to throw, so this should not be called.
&gt; 3192 |             expect(true).toBe(false);
       |            ^ Redundant Assertion
  3193 |         } catch (error) {
  3194 |             expect(error).toBeInstanceOf(ParseError);
  3195 |             expect(error.message).toBe(&quot;KaTeX parse error: \\verb ended by end of line instead of matching delimiter&quot;);</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  3463 |
  3464 |     it(&quot;\\char produces literal characters&quot;, () &#x3D;&gt; {
&gt; 3465 |         expect(&quot;\\char&#x60;a&quot;).toParseLike(&quot;\\char&#x60;\\a&quot;);
       |        ^ Redundant Assertion
  3466 |         expect(&quot;\\char&#x60;\\%&quot;).toParseLike&#x60;\char37&#x60;;
  3467 |         expect(&quot;\\char&#x60;\\%&quot;).toParseLike&#x60;\char&#39;45&#x60;;
  3468 |         expect(&quot;\\char&#x60;\\%&quot;).toParseLike&#x60;\char&quot;25&#x60;;</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  3464 |     it(&quot;\\char produces literal characters&quot;, () &#x3D;&gt; {
  3465 |         expect(&quot;\\char&#x60;a&quot;).toParseLike(&quot;\\char&#x60;\\a&quot;);
&gt; 3466 |         expect(&quot;\\char&#x60;\\%&quot;).toParseLike&#x60;\char37&#x60;;
       |        ^ Redundant Assertion
  3467 |         expect(&quot;\\char&#x60;\\%&quot;).toParseLike&#x60;\char&#39;45&#x60;;
  3468 |         expect(&quot;\\char&#x60;\\%&quot;).toParseLike&#x60;\char&quot;25&#x60;;
  3469 |         expect&#x60;\char&#x60;.not.toParse();</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  3465 |         expect(&quot;\\char&#x60;a&quot;).toParseLike(&quot;\\char&#x60;\\a&quot;);
  3466 |         expect(&quot;\\char&#x60;\\%&quot;).toParseLike&#x60;\char37&#x60;;
&gt; 3467 |         expect(&quot;\\char&#x60;\\%&quot;).toParseLike&#x60;\char&#39;45&#x60;;
       |        ^ Redundant Assertion
  3468 |         expect(&quot;\\char&#x60;\\%&quot;).toParseLike&#x60;\char&quot;25&#x60;;
  3469 |         expect&#x60;\char&#x60;.not.toParse();
  3470 |         expect(&quot;\\char&#x60;&quot;).not.toParse();</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  3466 |         expect(&quot;\\char&#x60;\\%&quot;).toParseLike&#x60;\char37&#x60;;
  3467 |         expect(&quot;\\char&#x60;\\%&quot;).toParseLike&#x60;\char&#39;45&#x60;;
&gt; 3468 |         expect(&quot;\\char&#x60;\\%&quot;).toParseLike&#x60;\char&quot;25&#x60;;
       |        ^ Redundant Assertion
  3469 |         expect&#x60;\char&#x60;.not.toParse();
  3470 |         expect(&quot;\\char&#x60;&quot;).not.toParse();
  3471 |         expect&#x60;\char&#39;&#x60;.not.toParse();</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  3468 |         expect(&quot;\\char&#x60;\\%&quot;).toParseLike&#x60;\char&quot;25&#x60;;
  3469 |         expect&#x60;\char&#x60;.not.toParse();
&gt; 3470 |         expect(&quot;\\char&#x60;&quot;).not.toParse();
       |        ^ Redundant Assertion
  3471 |         expect&#x60;\char&#39;&#x60;.not.toParse();
  3472 |         expect&#x60;\char&quot;&#x60;.not.toParse();
  3473 |         expect&#x60;\char&#39;a&#x60;.not.toParse();</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  3932 |
  3933 |     it(&quot;should parse combining characters&quot;, function() {
&gt; 3934 |         expect(&quot;A\u0301C\u0301&quot;).toParseLike(r&#x60;Á\acute C&#x60;, nonstrictSettings);
       |        ^ Redundant Assertion
  3935 |         expect(&quot;\\text{A\u0301C\u0301}&quot;).toParseLike(r&#x60;\text{Á\&#39;C}&#x60;, strictSettings);
  3936 |     });
  3937 |</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  3933 |     it(&quot;should parse combining characters&quot;, function() {
  3934 |         expect(&quot;A\u0301C\u0301&quot;).toParseLike(r&#x60;Á\acute C&#x60;, nonstrictSettings);
&gt; 3935 |         expect(&quot;\\text{A\u0301C\u0301}&quot;).toParseLike(r&#x60;\text{Á\&#39;C}&#x60;, strictSettings);
       |        ^ Redundant Assertion
  3936 |     });
  3937 |
  3938 |     it(&quot;should parse multi-accented characters&quot;, function() {</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  3971 |
  3972 |     it(&quot;should parse symbols&quot;, function() {
&gt; 3973 |         expect(&quot;£¥ℂℍℑℎℓℕ℘ℙℚℜℝℤℲℵðℶℷℸ⅁∀∁∂∃∇∞∠∡∢♠♡♢♣♭♮♯✓°¬‼⋮\u00B7\u00A9&quot;).toBuild(strictSettings);
       |        ^ Redundant Assertion
  3974 |         expect(&quot;\\text{£¥ℂℍℎ\u00A9\u00AE\uFE0F}&quot;).toBuild(strictSettings);
  3975 |     });
  3976 |</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  3972 |     it(&quot;should parse symbols&quot;, function() {
  3973 |         expect(&quot;£¥ℂℍℑℎℓℕ℘ℙℚℜℝℤℲℵðℶℷℸ⅁∀∁∂∃∇∞∠∡∢♠♡♢♣♭♮♯✓°¬‼⋮\u00B7\u00A9&quot;).toBuild(strictSettings);
&gt; 3974 |         expect(&quot;\\text{£¥ℂℍℎ\u00A9\u00AE\uFE0F}&quot;).toBuild(strictSettings);
       |        ^ Redundant Assertion
  3975 |     });
  3976 |
  3977 |     it(&quot;should build Greek capital letters&quot;, function() {</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  3989 |
  3990 |     it(&quot;should build binary operators&quot;, function() {
&gt; 3991 |         expect(&quot;±×÷∓∔∧∨∩∪≀⊎⊓⊔⊕⊖⊗⊘⊙⊚⊛⊝◯⊞⊟⊠⊡⊺⊻⊼⋇⋉⋊⋋⋌⋎⋏⋒⋓⩞\u22C5\u2218\u2216\u2219&quot;).toBuild(strictSettings);
       |        ^ Redundant Assertion
  3992 |     });
  3993 |
  3994 |     it(&quot;should build common ords&quot;, function() {</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  3993 |
  3994 |     it(&quot;should build common ords&quot;, function() {
&gt; 3995 |         expect(&quot;§¶£¥∇∞⋅∠∡∢♠♡♢♣♭♮♯✓…⋮⋯⋱! ‼ ⦵&quot;).toBuild(strictSettings);
       |        ^ Redundant Assertion
  3996 |     });
  3997 |
  3998 |     it(&quot;should build delimiters&quot;, function() {</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  3997 |
  3998 |     it(&quot;should build delimiters&quot;, function() {
&gt; 3999 |         expect(&quot;\\left\u230A\\frac{a}{b}\\right\u230B&quot;).toBuild();
       |        ^ Redundant Assertion
  4000 |         expect(&quot;\\left\u2308\\frac{a}{b}\\right\u2308&quot;).toBuild();
  4001 |         expect(&quot;\\left\u27ee\\frac{a}{b}\\right\u27ef&quot;).toBuild();
  4002 |         expect(&quot;\\left\u27e8\\frac{a}{b}\\right\u27e9&quot;).toBuild();</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  3998 |     it(&quot;should build delimiters&quot;, function() {
  3999 |         expect(&quot;\\left\u230A\\frac{a}{b}\\right\u230B&quot;).toBuild();
&gt; 4000 |         expect(&quot;\\left\u2308\\frac{a}{b}\\right\u2308&quot;).toBuild();
       |        ^ Redundant Assertion
  4001 |         expect(&quot;\\left\u27ee\\frac{a}{b}\\right\u27ef&quot;).toBuild();
  4002 |         expect(&quot;\\left\u27e8\\frac{a}{b}\\right\u27e9&quot;).toBuild();
  4003 |         expect(&quot;\\left\u23b0\\frac{a}{b}\\right\u23b1&quot;).toBuild();</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  3999 |         expect(&quot;\\left\u230A\\frac{a}{b}\\right\u230B&quot;).toBuild();
  4000 |         expect(&quot;\\left\u2308\\frac{a}{b}\\right\u2308&quot;).toBuild();
&gt; 4001 |         expect(&quot;\\left\u27ee\\frac{a}{b}\\right\u27ef&quot;).toBuild();
       |        ^ Redundant Assertion
  4002 |         expect(&quot;\\left\u27e8\\frac{a}{b}\\right\u27e9&quot;).toBuild();
  4003 |         expect(&quot;\\left\u23b0\\frac{a}{b}\\right\u23b1&quot;).toBuild();
  4004 |         expect&#x60;┌x┐ └x┘&#x60;.toBuild();</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  4000 |         expect(&quot;\\left\u2308\\frac{a}{b}\\right\u2308&quot;).toBuild();
  4001 |         expect(&quot;\\left\u27ee\\frac{a}{b}\\right\u27ef&quot;).toBuild();
&gt; 4002 |         expect(&quot;\\left\u27e8\\frac{a}{b}\\right\u27e9&quot;).toBuild();
       |        ^ Redundant Assertion
  4003 |         expect(&quot;\\left\u23b0\\frac{a}{b}\\right\u23b1&quot;).toBuild();
  4004 |         expect&#x60;┌x┐ └x┘&#x60;.toBuild();
  4005 |         expect(&quot;\u231Cx\u231D \u231Ex\u231F&quot;).toBuild();</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  4001 |         expect(&quot;\\left\u27ee\\frac{a}{b}\\right\u27ef&quot;).toBuild();
  4002 |         expect(&quot;\\left\u27e8\\frac{a}{b}\\right\u27e9&quot;).toBuild();
&gt; 4003 |         expect(&quot;\\left\u23b0\\frac{a}{b}\\right\u23b1&quot;).toBuild();
       |        ^ Redundant Assertion
  4004 |         expect&#x60;┌x┐ └x┘&#x60;.toBuild();
  4005 |         expect(&quot;\u231Cx\u231D \u231Ex\u231F&quot;).toBuild();
  4006 |         expect(&quot;\u27E6x\u27E7&quot;).toBuild();</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  4003 |         expect(&quot;\\left\u23b0\\frac{a}{b}\\right\u23b1&quot;).toBuild();
  4004 |         expect&#x60;┌x┐ └x┘&#x60;.toBuild();
&gt; 4005 |         expect(&quot;\u231Cx\u231D \u231Ex\u231F&quot;).toBuild();
       |        ^ Redundant Assertion
  4006 |         expect(&quot;\u27E6x\u27E7&quot;).toBuild();
  4007 |         expect(&quot;\\llbracket \\rrbracket&quot;).toBuild();
  4008 |         expect(&quot;\\lBrace \\rBrace&quot;).toBuild();</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  4004 |         expect&#x60;┌x┐ └x┘&#x60;.toBuild();
  4005 |         expect(&quot;\u231Cx\u231D \u231Ex\u231F&quot;).toBuild();
&gt; 4006 |         expect(&quot;\u27E6x\u27E7&quot;).toBuild();
       |        ^ Redundant Assertion
  4007 |         expect(&quot;\\llbracket \\rrbracket&quot;).toBuild();
  4008 |         expect(&quot;\\lBrace \\rBrace&quot;).toBuild();
  4009 |     });</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  4005 |         expect(&quot;\u231Cx\u231D \u231Ex\u231F&quot;).toBuild();
  4006 |         expect(&quot;\u27E6x\u27E7&quot;).toBuild();
&gt; 4007 |         expect(&quot;\\llbracket \\rrbracket&quot;).toBuild();
       |        ^ Redundant Assertion
  4008 |         expect(&quot;\\lBrace \\rBrace&quot;).toBuild();
  4009 |     });
  4010 |</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  4006 |         expect(&quot;\u27E6x\u27E7&quot;).toBuild();
  4007 |         expect(&quot;\\llbracket \\rrbracket&quot;).toBuild();
&gt; 4008 |         expect(&quot;\\lBrace \\rBrace&quot;).toBuild();
       |        ^ Redundant Assertion
  4009 |     });
  4010 |
  4011 |     it(&quot;should build some surrogate pairs&quot;, function() {</code></pre><br>
                      </td>
                    </tr>
                  </tbody>
                </table>
                <hr>
                <table class="table is-fullwidth" id="table-of-smell">
                  <thead>
                    <tr>
                      <td>Redundant Print</td>
                    </tr>
                  </thead>
                  <tbody>
                    <tr>
                      <td>
                        <pre><code>  4276 |             expect&#x60;\message{Hello, world}&#x60;.toParse();
  4277 |             &#x2F;&#x2F; eslint-disable-next-line no-console
&gt; 4278 |             expect(console.log).toHaveBeenCalledWith(&quot;Hello, world&quot;);
       |                   ^ Redundant Print
  4279 |         });
  4280 |     });
  4281 |</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  4285 |             expect&#x60;\errmessage{Hello, world}&#x60;.toParse();
  4286 |             &#x2F;&#x2F; eslint-disable-next-line no-console
&gt; 4287 |             expect(console.error).toHaveBeenCalledWith(&quot;Hello, world&quot;);
       |                   ^ Redundant Print
  4288 |         });
  4289 |     });
  4290 | });</code></pre><br>
                      </td>
                    </tr>
                  </tbody>
                </table>
                <hr>
                <table class="table is-fullwidth" id="table-of-smell">
                  <thead>
                    <tr>
                      <td>Unknown Test</td>
                    </tr>
                  </thead>
                  <tbody>
                    <tr>
                      <td>
                        <pre><code>  21 |
  22 | describe(&quot;A parser&quot;, function() {
&gt; 23 |     it(&quot;should not fail on an empty string&quot;, function() {
     |    ^ Unknown Test
  24 |         expect&#x60;&#x60;.toParse(strictSettings);
  25 |     });
  26 |</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  25 |     });
  26 |
&gt; 27 |     it(&quot;should ignore whitespace&quot;, function() {
     |    ^ Unknown Test
  28 |         expect&#x60;    x    y    &#x60;.toParseLike(&quot;xy&quot;, strictSettings);
  29 |     });
  30 |</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  29 |     });
  30 |
&gt; 31 |     it(&quot;should ignore whitespace in atom&quot;, function() {
     |    ^ Unknown Test
  32 |         expect&#x60;    x   ^ y    &#x60;.toParseLike(&quot;x^y&quot;, strictSettings);
  33 |     });
  34 | });</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  104 |
  105 | describe(&quot;A mathinner parser&quot;, function() {
&gt; 106 |     it(&quot;should not fail&quot;, function() {
      |    ^ Unknown Test
  107 |         expect&#x60;\mathinner{\langle{\psi}\rangle}&#x60;.toParse();
  108 |         expect&#x60;\frac 1 {\mathinner{\langle{\psi}\rangle}}&#x60;.toParse();
  109 |     });</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  171 |
  172 | describe(&quot;A \\KaTeX parser&quot;, function() {
&gt; 173 |     it(&quot;should not fail&quot;, function() {
      |    ^ Unknown Test
  174 |         expect&#x60;\KaTeX&#x60;.toParse();
  175 |     });
  176 | });</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  177 |
  178 | describe(&quot;A subscript and superscript parser&quot;, function() {
&gt; 179 |     it(&quot;should not fail on superscripts&quot;, function() {
      |    ^ Unknown Test
  180 |         expect&#x60;x^2&#x60;.toParse();
  181 |     });
  182 |</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  181 |     });
  182 |
&gt; 183 |     it(&quot;should not fail on subscripts&quot;, function() {
      |    ^ Unknown Test
  184 |         expect&#x60;x_3&#x60;.toParse();
  185 |     });
  186 |</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  185 |     });
  186 |
&gt; 187 |     it(&quot;should not fail on both subscripts and superscripts&quot;, function() {
      |    ^ Unknown Test
  188 |         expect&#x60;x^2_3&#x60;.toParse();
  189 |
  190 |         expect&#x60;x_2^3&#x60;.toParse();</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  191 |     });
  192 |
&gt; 193 |     it(&quot;should not fail when there is no nucleus&quot;, function() {
      |    ^ Unknown Test
  194 |         expect&#x60;^3&#x60;.toParse();
  195 |         expect&#x60;^3+&#x60;.toParse();
  196 |         expect&#x60;_2&#x60;.toParse();</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  235 |     });
  236 |
&gt; 237 |     it(&quot;should produce the same thing regardless of order&quot;, function() {
      |    ^ Unknown Test
  238 |         expect&#x60;x^2_3&#x60;.toParseLike&#x60;x_3^2&#x60;;
  239 |     });
  240 |</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  239 |     });
  240 |
&gt; 241 |     it(&quot;should not parse double subscripts or superscripts&quot;, function() {
      |    ^ Unknown Test
  242 |         expect&#x60;x^x^x&#x60;.not.toParse();
  243 |
  244 |         expect&#x60;x_x_x&#x60;.not.toParse();</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  253 |     });
  254 |
&gt; 255 |     it(&quot;should work correctly with {}s&quot;, function() {
      |    ^ Unknown Test
  256 |         expect&#x60;x^{2+3}&#x60;.toParse();
  257 |
  258 |         expect&#x60;x_{3-2}&#x60;.toParse();</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  271 |     });
  272 |
&gt; 273 |     it(&quot;should work with nested super&#x2F;subscripts&quot;, function() {
      |    ^ Unknown Test
  274 |         expect&#x60;x^{x^x}&#x60;.toParse();
  275 |         expect&#x60;x^{x_x}&#x60;.toParse();
  276 |         expect&#x60;x_{x^x}&#x60;.toParse();</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  278 |     });
  279 |
&gt; 280 |     it(&quot;should work with Unicode (sub|super)script characters&quot;, function() {
      |    ^ Unknown Test
  281 |         expect&#x60;A² + B²⁺³ + ¹²C + E₂³ + F₂₊₃&#x60;.toParseLike&#x60;A^{2} + B^{2+3} + ^{12}C + E_{2}^{3} + F_{2+3}&#x60;;
  282 |     });
  283 |</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  282 |     });
  283 |
&gt; 284 |     it(&quot;should not fail if \\relax is in an atom&quot;, function() {
      |    ^ Unknown Test
  285 |         expect&#x60;\hskip1em\relax^2&#x60;.toParse(strictSettings);
  286 |     });
  287 |</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  286 |     });
  287 |
&gt; 288 |     it(&quot;should skip \\relax in super&#x2F;subscripts&quot;, function() {
      |    ^ Unknown Test
  289 |         expect&#x60;x^\relax 2&#x60;.toParseLike&#x60;x^2&#x60;;
  290 |         expect&#x60;x_\relax 2&#x60;.toParseLike&#x60;x_2&#x60;;
  291 |     });</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  293 |
  294 | describe(&quot;A subscript and superscript tree-builder&quot;, function() {
&gt; 295 |     it(&quot;should not fail when there is no nucleus&quot;, function() {
      |    ^ Unknown Test
  296 |         expect&#x60;^3&#x60;.toBuild();
  297 |         expect&#x60;_2&#x60;.toBuild();
  298 |         expect&#x60;^3_2&#x60;.toBuild();</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  302 |
  303 | describe(&quot;A parser with limit controls&quot;, function() {
&gt; 304 |     it(&quot;should fail when the limit control is not preceded by an op node&quot;, function() {
      |    ^ Unknown Test
  305 |         expect&#x60;3\nolimits_2^2&#x60;.not.toParse();
  306 |         expect&#x60;\sqrt\limits_2^2&#x60;.not.toParse();
  307 |         expect&#x60;45 +\nolimits 45&#x60;.not.toParse();</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  308 |     });
  309 |
&gt; 310 |     it(&quot;should parse when the limit control directly follows an op node&quot;, function() {
      |    ^ Unknown Test
  311 |         expect&#x60;\int\limits_2^2 3&#x60;.toParse();
  312 |         expect&#x60;\sum\nolimits_3^4 4&#x60;.toParse();
  313 |     });</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  313 |     });
  314 |
&gt; 315 |     it(&quot;should parse when the limit control is in the sup&#x2F;sub area of an op node&quot;, function() {
      |    ^ Unknown Test
  316 |         expect&#x60;\int_2^2\limits&#x60;.toParse();
  317 |         expect&#x60;\int^2\nolimits_2&#x60;.toParse();
  318 |         expect&#x60;\int_2\limits^2&#x60;.toParse();</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  319 |     });
  320 |
&gt; 321 |     it(&quot;should allow multiple limit controls in the sup&#x2F;sub area of an op node&quot;, function() {
      |    ^ Unknown Test
  322 |         expect&#x60;\int_2\nolimits^2\limits 3&#x60;.toParse();
  323 |         expect&#x60;\int\nolimits\limits_2^2&#x60;.toParse();
  324 |         expect&#x60;\int\limits\limits\limits_2^2&#x60;.toParse();</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  337 |
  338 | describe(&quot;A group parser&quot;, function() {
&gt; 339 |     it(&quot;should not fail&quot;, function() {
      |    ^ Unknown Test
  340 |         expect&#x60;{xy}&#x60;.toParse();
  341 |     });
  342 |</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  354 |
  355 | describe(&quot;A \\begingroup...\\endgroup parser&quot;, function() {
&gt; 356 |     it(&quot;should not fail&quot;, function() {
      |    ^ Unknown Test
  357 |         expect&#x60;\begingroup xy \endgroup&#x60;.toParse();
  358 |     });
  359 |</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  358 |     });
  359 |
&gt; 360 |     it(&quot;should fail when it is mismatched&quot;, function() {
      |    ^ Unknown Test
  361 |         expect&#x60;\begingroup xy&#x60;.not.toParse();
  362 |         expect&#x60;\begingroup xy }&#x60;.not.toParse();
  363 |     });</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  375 |     });
  376 |
&gt; 377 |     it(&quot;should not affect spacing in math mode&quot;, function() {
      |    ^ Unknown Test
  378 |         expect&#x60;\begingroup x+ \endgroup y&#x60;.toBuildLike&#x60;x+y&#x60;;
  379 |     });
  380 | });</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  381 |
  382 | describe(&quot;An implicit group parser&quot;, function() {
&gt; 383 |     it(&quot;should not fail&quot;, function() {
      |    ^ Unknown Test
  384 |         expect&#x60;\Large x&#x60;.toParse();
  385 |         expect&#x60;abc {abc \Large xyz} abc&#x60;.toParse();
  386 |     });</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  444 |
  445 | describe(&quot;A function parser&quot;, function() {
&gt; 446 |     it(&quot;should parse no argument functions&quot;, function() {
      |    ^ Unknown Test
  447 |         expect&#x60;\div&#x60;.toParse();
  448 |     });
  449 |</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  448 |     });
  449 |
&gt; 450 |     it(&quot;should parse 1 argument functions&quot;, function() {
      |    ^ Unknown Test
  451 |         expect&#x60;\blue x&#x60;.toParse();
  452 |     });
  453 |</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  452 |     });
  453 |
&gt; 454 |     it(&quot;should parse 2 argument functions&quot;, function() {
      |    ^ Unknown Test
  455 |         expect&#x60;\frac 1 2&#x60;.toParse();
  456 |     });
  457 |</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  456 |     });
  457 |
&gt; 458 |     it(&quot;should not parse 1 argument functions with no arguments&quot;, function() {
      |    ^ Unknown Test
  459 |         expect&#x60;\blue&#x60;.not.toParse();
  460 |     });
  461 |</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  460 |     });
  461 |
&gt; 462 |     it(&quot;should not parse 2 argument functions with 0 or 1 arguments&quot;, function() {
      |    ^ Unknown Test
  463 |         expect&#x60;\frac&#x60;.not.toParse();
  464 |
  465 |         expect&#x60;\frac 1&#x60;.not.toParse();</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  466 |     });
  467 |
&gt; 468 |     it(&quot;should not parse a function with text right after it&quot;, function() {
      |    ^ Unknown Test
  469 |         expect&#x60;\redx&#x60;.not.toParse();
  470 |     });
  471 |</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  470 |     });
  471 |
&gt; 472 |     it(&quot;should parse a function with a number right after it&quot;, function() {
      |    ^ Unknown Test
  473 |         expect&#x60;\frac12&#x60;.toParse();
  474 |     });
  475 |</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  474 |     });
  475 |
&gt; 476 |     it(&quot;should parse some functions with text right after it&quot;, function() {
      |    ^ Unknown Test
  477 |         expect&#x60;\;x&#x60;.toParse();
  478 |     });
  479 | });</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  638 |     });
  639 |
&gt; 640 |     it(&quot;should handle \\textstyle correctly&quot;, function() {
      |    ^ Unknown Test
  641 |         expect&#x60;\textstyle 1 \over 2&#x60;.toParseLike&#x60;\frac{\textstyle 1}{2}&#x60;;
  642 |         expect&#x60;{\textstyle 1} \over 2&#x60;.toParseLike&#x60;\frac{\textstyle 1}{2}&#x60;;
  643 |     });</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  664 |
  665 | describe(&quot;A genfrac builder&quot;, function() {
&gt; 666 |     it(&quot;should not fail&quot;, function() {
      |    ^ Unknown Test
  667 |         expect&#x60;\frac{x}{y}&#x60;.toBuild();
  668 |         expect&#x60;\dfrac{x}{y}&#x60;.toBuild();
  669 |         expect&#x60;\tfrac{x}{y}&#x60;.toBuild();</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  677 |
  678 | describe(&quot;A infix builder&quot;, function() {
&gt; 679 |     it(&quot;should not fail&quot;, function() {
      |    ^ Unknown Test
  680 |         expect&#x60;a \over b&#x60;.toBuild();
  681 |         expect&#x60;a \atop b&#x60;.toBuild();
  682 |         expect&#x60;a \choose b&#x60;.toBuild();</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  773 |     });
  774 |
&gt; 775 |     it(&quot;should parse math within text group&quot;, function() {
      |    ^ Unknown Test
  776 |         expect&#x60;\text{graph: $y &#x3D; mx + b$}&#x60;.toParse(strictSettings);
  777 |         expect&#x60;\text{graph: \(y &#x3D; mx + b\)}&#x60;.toParse(strictSettings);
  778 |     });</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  778 |     });
  779 |
&gt; 780 |     it(&quot;should parse math within text within math within text&quot;, function() {
      |    ^ Unknown Test
  781 |         expect&#x60;\text{hello $x + \text{world $y$} + z$}&#x60;.toParse(strictSettings);
  782 |         expect&#x60;\text{hello \(x + \text{world $y$} + z\)}&#x60;.toParse(strictSettings);
  783 |         expect&#x60;\text{hello $x + \text{world \(y\)} + z$}&#x60;.toParse(strictSettings);</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  785 |     });
  786 |
&gt; 787 |     it(&quot;should forbid \\( within math mode&quot;, function() {
      |    ^ Unknown Test
  788 |         expect&#x60;\(&#x60;.not.toParse();
  789 |         expect&#x60;\text{$\(x\)$}&#x60;.not.toParse();
  790 |     });</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  790 |     });
  791 |
&gt; 792 |     it(&quot;should forbid $ within math mode&quot;, function() {
      |    ^ Unknown Test
  793 |         expect&#x60;$x$&#x60;.not.toParse();
  794 |         expect&#x60;\text{\($x$\)}&#x60;.not.toParse();
  795 |     });</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  795 |     });
  796 |
&gt; 797 |     it(&quot;should detect unbalanced \\)&quot;, function() {
      |    ^ Unknown Test
  798 |         expect&#x60;\)&#x60;.not.toParse();
  799 |         expect&#x60;\text{\)}&#x60;.not.toParse();
  800 |     });</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  800 |     });
  801 |
&gt; 802 |     it(&quot;should detect unbalanced $&quot;, function() {
      |    ^ Unknown Test
  803 |         expect&#x60;$&#x60;.not.toParse();
  804 |         expect&#x60;\text{$}&#x60;.not.toParse();
  805 |     });</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  805 |     });
  806 |
&gt; 807 |     it(&quot;should not mix $ and \\(..\\)&quot;, function() {
      |    ^ Unknown Test
  808 |         expect&#x60;\text{$x\)}&#x60;.not.toParse();
  809 |         expect&#x60;\text{\(x$}&#x60;.not.toParse();
  810 |     });</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  810 |     });
  811 |
&gt; 812 |     it(&quot;should parse spacing functions&quot;, function() {
      |    ^ Unknown Test
  813 |         expect&#x60;a b\, \; \! \: \&gt; ~ \thinspace \medspace \quad \ &#x60;.toBuild();
  814 |         expect&#x60;\enspace \thickspace \qquad \space \nobreakspace&#x60;.toBuild();
  815 |     });</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  815 |     });
  816 |
&gt; 817 |     it(&quot;should omit spaces after commands&quot;, function() {
      |    ^ Unknown Test
  818 |         expect&#x60;\text{\textellipsis !}&#x60;.toParseLike&#x60;\text{\textellipsis!}&#x60;;
  819 |     });
  820 |</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  819 |     });
  820 |
&gt; 821 |     it(&quot;should handle ⋮ and \\vdots&quot;, function() {
      |    ^ Unknown Test
  822 |         expect&#x60;\text{a \vdots b ⋮ d}&#x60;.toParse();
  823 |     });
  824 | });</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  825 |
  826 | describe(&quot;A texvc builder&quot;, function() {
&gt; 827 |     it(&quot;should not fail&quot;, function() {
      |    ^ Unknown Test
  828 |         expect&#x60;\lang\N\darr\R\dArr\Z\Darr\alef\rang&#x60;.toBuild();
  829 |         expect&#x60;\alefsym\uarr\Alpha\uArr\Beta\Uarr\Chi&#x60;.toBuild();
  830 |         expect&#x60;\clubs\diamonds\hearts\spades\cnums\Complex&#x60;.toBuild();</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>   999 |
  1000 | describe(&quot;An lap parser&quot;, function() {
&gt; 1001 |     it(&quot;should not fail on a text argument&quot;, function() {
       |    ^ Unknown Test
  1002 |         expect&#x60;\rlap{\,&#x2F;}{&#x3D;}&#x60;.toParse();
  1003 |         expect&#x60;\mathrlap{\,&#x2F;}{&#x3D;}&#x60;.toParse();
  1004 |         expect&#x60;{&#x3D;}\llap{&#x2F;\,}&#x60;.toParse();</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  1008 |     });
  1009 |
&gt; 1010 |     it(&quot;should not fail if math version is used&quot;, function() {
       |    ^ Unknown Test
  1011 |         expect&#x60;\mathrlap{\frac{a}{b}}{&#x3D;}&#x60;.toParse();
  1012 |         expect&#x60;{&#x3D;}\mathllap{\frac{a}{b}}&#x60;.toParse();
  1013 |         expect&#x60;\sum_{\mathclap{\frac{a}{b}}}&#x60;.toParse();</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  1014 |     });
  1015 |
&gt; 1016 |     it(&quot;should fail on math if AMS version is used&quot;, function() {
       |    ^ Unknown Test
  1017 |         expect&#x60;\rlap{\frac{a}{b}}{&#x3D;}&#x60;.not.toParse();
  1018 |         expect&#x60;{&#x3D;}\llap{\frac{a}{b}}&#x60;.not.toParse();
  1019 |         expect&#x60;\sum_{\clap{\frac{a}{b}}}&#x60;.not.toParse();</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  1270 | describe(&quot;A begin&#x2F;end parser&quot;, function() {
  1271 |
&gt; 1272 |     it(&quot;should parse a simple environment&quot;, function() {
       |    ^ Unknown Test
  1273 |         expect&#x60;\begin{matrix}a&amp;b\\c&amp;d\end{matrix}&#x60;.toParse();
  1274 |     });
  1275 |</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  1274 |     });
  1275 |
&gt; 1276 |     it(&quot;should parse an environment with argument&quot;, function() {
       |    ^ Unknown Test
  1277 |         expect&#x60;\begin{array}{cc}a&amp;b\\c&amp;d\end{array}&#x60;.toParse();
  1278 |     });
  1279 |</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  1278 |     });
  1279 |
&gt; 1280 |     it(&quot;should parse and build an empty environment&quot;, function() {
       |    ^ Unknown Test
  1281 |         expect&#x60;\begin{aligned}\end{aligned}&#x60;.toBuild();
  1282 |         expect&#x60;\begin{matrix}\end{matrix}&#x60;.toBuild();
  1283 |     });</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  1283 |     });
  1284 |
&gt; 1285 |     it(&quot;should parse an environment with hlines&quot;, function() {
       |    ^ Unknown Test
  1286 |         expect&#x60;\begin{matrix}\hline a&amp;b\\ \hline c&amp;d\end{matrix}&#x60;.toParse();
  1287 |         expect&#x60;\begin{matrix}\hline a&amp;b\cr \hline c&amp;d\end{matrix}&#x60;.toParse();
  1288 |         expect&#x60;\begin{matrix}\hdashline a&amp;b\\ \hdashline c&amp;d\end{matrix}&#x60;.toParse();</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  1289 |     });
  1290 |
&gt; 1291 |     it(&quot;should forbid hlines outside array environment&quot;, () &#x3D;&gt; {
       |    ^ Unknown Test
  1292 |         expect&#x60;\hline&#x60;.not.toParse();
  1293 |     });
  1294 |</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  1293 |     });
  1294 |
&gt; 1295 |     it(&quot;should error when name is mismatched&quot;, function() {
       |    ^ Unknown Test
  1296 |         expect&#x60;\begin{matrix}a&amp;b\\c&amp;d\end{pmatrix}&#x60;.not.toParse();
  1297 |     });
  1298 |</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  1297 |     });
  1298 |
&gt; 1299 |     it(&quot;should error when commands are mismatched&quot;, function() {
       |    ^ Unknown Test
  1300 |         expect&#x60;\begin{matrix}a&amp;b\\c&amp;d\right{pmatrix}&#x60;.not.toParse();
  1301 |     });
  1302 |</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  1301 |     });
  1302 |
&gt; 1303 |     it(&quot;should error when end is missing&quot;, function() {
       |    ^ Unknown Test
  1304 |         expect&#x60;\begin{matrix}a&amp;b\\c&amp;d&#x60;.not.toParse();
  1305 |     });
  1306 |</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  1305 |     });
  1306 |
&gt; 1307 |     it(&quot;should error when braces are mismatched&quot;, function() {
       |    ^ Unknown Test
  1308 |         expect&#x60;{\begin{matrix}a&amp;b\\c&amp;d}\end{matrix}&#x60;.not.toParse();
  1309 |     });
  1310 |</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  1309 |     });
  1310 |
&gt; 1311 |     it(&quot;should cooperate with infix notation&quot;, function() {
       |    ^ Unknown Test
  1312 |         expect&#x60;\begin{matrix}0&amp;1\over2&amp;3\\4&amp;5&amp;6\end{matrix}&#x60;.toParse();
  1313 |     });
  1314 |</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  1319 |     });
  1320 |
&gt; 1321 |     it(&quot;should allow \\cr and \\\\ as a line terminator&quot;, function() {
       |    ^ Unknown Test
  1322 |         expect&#x60;\begin{matrix}a&amp;b\cr c&amp;d\end{matrix}&#x60;.toParse();
  1323 |         expect&#x60;\begin{matrix}a&amp;b\\c&amp;d\end{matrix}&#x60;.toParse();
  1324 |     });</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  1324 |     });
  1325 |
&gt; 1326 |     it(&quot;should not allow \\cr to scan for an optional size argument&quot;, function() {
       |    ^ Unknown Test
  1327 |         expect&#x60;\begin{matrix}a&amp;b\cr[c]&amp;d\end{matrix}&#x60;.toParse();
  1328 |     });
  1329 |</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  1328 |     });
  1329 |
&gt; 1330 |     it(&quot;should not treat [ after space as optional argument to \\\\&quot;, function() {
       |    ^ Unknown Test
  1331 |         expect&#x60;\begin{matrix}a&amp;b\\ [c]&amp;d\end{matrix}&#x60;.toParse();
  1332 |         expect&#x60;a\\ [b]&#x60;.toParse();
  1333 |     });</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  1343 |     });
  1344 |
&gt; 1345 |     it(&quot;should allow an optional argument in {matrix*} and company.&quot;, function() {
       |    ^ Unknown Test
  1346 |         expect&#x60;\begin{matrix*}[r] a &amp; -1 \\ -1 &amp; d \end{matrix*}&#x60;.toBuild();
  1347 |         expect&#x60;\begin{pmatrix*}[r] a &amp; -1 \\ -1 &amp; d \end{pmatrix*}&#x60;.toBuild();
  1348 |         expect&#x60;\begin{bmatrix*}[r] a &amp; -1 \\ -1 &amp; d \end{bmatrix*}&#x60;.toBuild();</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  1380 |     });
  1381 |
&gt; 1382 |     it(&quot;should build sized square roots&quot;, function() {
       |    ^ Unknown Test
  1383 |         expect&#x60;\Large\sqrt[3]{x}&#x60;.toBuild();
  1384 |     });
  1385 |</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  1384 |     });
  1385 |
&gt; 1386 |     it(&quot;should expand argument if optional argument doesn&#39;t exist&quot;, function() {
       |    ^ Unknown Test
  1387 |         expect&#x60;\sqrt\foo&#x60;.toParseLike(&quot;\\sqrt123&quot;,
  1388 |             new Settings({macros: {&quot;\\foo&quot;: &quot;123&quot;}}));
  1389 |     });</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  1389 |     });
  1390 |
&gt; 1391 |     it(&quot;should not expand argument if optional argument exists&quot;, function() {
       |    ^ Unknown Test
  1392 |         expect&#x60;\sqrt[2]\foo&#x60;.toParseLike(&quot;\\sqrt[2]{123}&quot;,
  1393 |             new Settings({macros: {&quot;\\foo&quot;: &quot;123&quot;}}));
  1394 |     });</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  1396 |
  1397 | describe(&quot;A TeX-compliant parser&quot;, function() {
&gt; 1398 |     it(&quot;should work&quot;, function() {
       |    ^ Unknown Test
  1399 |         expect&#x60;\frac 2 3&#x60;.toParse();
  1400 |     });
  1401 |</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  1415 |     });
  1416 |
&gt; 1417 |     it(&quot;should fail when there are missing sup&#x2F;subscripts&quot;, function() {
       |    ^ Unknown Test
  1418 |         expect&#x60;x^&#x60;.not.toParse();
  1419 |         expect&#x60;x_&#x60;.not.toParse();
  1420 |     });</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  1486 |     });
  1487 |
&gt; 1488 |     it(&quot;should parse multiple primes correctly&quot;, function() {
       |    ^ Unknown Test
  1489 |         expect&#x60;x&#39;&#39;&#39;&#39;&#x60;.toParse();
  1490 |         expect&#x60;x_2&#39;&#39;&#x60;.toParse();
  1491 |         expect&#x60;x&#39;&#39;_2&#x60;.toParse();</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  1492 |     });
  1493 |
&gt; 1494 |     it(&quot;should fail when sup&#x2F;subscripts are interspersed with arguments&quot;, function() {
       |    ^ Unknown Test
  1495 |         expect&#x60;\sqrt^23&#x60;.not.toParse();
  1496 |         expect&#x60;\frac^234&#x60;.not.toParse();
  1497 |         expect&#x60;\frac2^34&#x60;.not.toParse();</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  1498 |     });
  1499 |
&gt; 1500 |     it(&quot;should succeed when sup&#x2F;subscripts come after whole functions&quot;, function() {
       |    ^ Unknown Test
  1501 |         expect&#x60;\sqrt2^3&#x60;.toParse();
  1502 |         expect&#x60;\frac23^4&#x60;.toParse();
  1503 |     });</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  1503 |     });
  1504 |
&gt; 1505 |     it(&quot;should succeed with a sqrt around a text&#x2F;frac&quot;, function() {
       |    ^ Unknown Test
  1506 |         expect&#x60;\sqrt \frac x y&#x60;.toParse();
  1507 |         expect&#x60;\sqrt \text x&#x60;.toParse();
  1508 |         expect&#x60;x^\frac x y&#x60;.toParse();</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  1540 |
  1541 | describe(&quot;An op symbol builder&quot;, function() {
&gt; 1542 |     it(&quot;should not fail&quot;, function() {
       |    ^ Unknown Test
  1543 |         expect&#x60;\int_i^n&#x60;.toBuild();
  1544 |         expect&#x60;\iint_i^n&#x60;.toBuild();
  1545 |         expect&#x60;\iiint_i^n&#x60;.toBuild();</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  1557 |
  1558 | describe(&quot;A style change parser&quot;, function() {
&gt; 1559 |     it(&quot;should not fail&quot;, function() {
       |    ^ Unknown Test
  1560 |         expect&#x60;\displaystyle x&#x60;.toParse();
  1561 |         expect&#x60;\textstyle x&#x60;.toParse();
  1562 |         expect&#x60;\scriptstyle x&#x60;.toParse();</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  1588 |
  1589 | describe(&quot;A font parser&quot;, function() {
&gt; 1590 |     it(&quot;should parse \\mathrm, \\mathbb, \\mathit, and \\mathnormal&quot;, function() {
       |    ^ Unknown Test
  1591 |         expect&#x60;\mathrm x&#x60;.toParse();
  1592 |         expect&#x60;\mathbb x&#x60;.toParse();
  1593 |         expect&#x60;\mathit x&#x60;.toParse();</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  1599 |     });
  1600 |
&gt; 1601 |     it(&quot;should parse \\mathcal and \\mathfrak&quot;, function() {
       |    ^ Unknown Test
  1602 |         expect&#x60;\mathcal{ABC123}&#x60;.toParse();
  1603 |         expect&#x60;\mathfrak{abcABC123}&#x60;.toParse();
  1604 |     });</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  1653 |     });
  1654 |
&gt; 1655 |     it(&quot;should not parse a series of font commands&quot;, function() {
       |    ^ Unknown Test
  1656 |         expect&#x60;\mathbb \mathrm R&#x60;.not.toParse();
  1657 |     });
  1658 |</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  1668 |     });
  1669 |
&gt; 1670 |     it(&quot;should be allowed in the argument&quot;, function() {
       |    ^ Unknown Test
  1671 |         expect&#x60;e^\mathbf{x}&#x60;.toParse();
  1672 |     });
  1673 |</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  1677 |     });
  1678 |
&gt; 1679 |     it(&quot;old-style fonts work like new-style fonts&quot;, () &#x3D;&gt; {
       |    ^ Unknown Test
  1680 |         expect&#x60;\rm xyz&#x60;.toParseLike&#x60;\mathrm{xyz}&#x60;;
  1681 |         expect&#x60;\sf xyz&#x60;.toParseLike&#x60;\mathsf{xyz}&#x60;;
  1682 |         expect&#x60;\tt xyz&#x60;.toParseLike&#x60;\mathtt{xyz}&#x60;;</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  1688 |
  1689 | describe(&quot;A \\pmb builder&quot;, function() {
&gt; 1690 |     it(&quot;should not fail&quot;, function() {
       |    ^ Unknown Test
  1691 |         expect&#x60;\pmb{\mu}&#x60;.toBuild();
  1692 |         expect&#x60;\pmb{&#x3D;}&#x60;.toBuild();
  1693 |         expect&#x60;\pmb{+}&#x60;.toBuild();</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  1699 |
  1700 | describe(&quot;A raise parser&quot;, function() {
&gt; 1701 |     it(&quot;should parse and build text in \\raisebox&quot;, function() {
       |    ^ Unknown Test
  1702 |         expect&#x60;\raisebox{5pt}{text}&#x60;.toBuild(strictSettings);
  1703 |         expect&#x60;\raisebox{-5pt}{text}&#x60;.toBuild(strictSettings);
  1704 |     });</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  1704 |     });
  1705 |
&gt; 1706 |     it(&quot;should parse and build math in non-strict \\vcenter&quot;, function() {
       |    ^ Unknown Test
  1707 |         expect&#x60;\vcenter{\frac a b}&#x60;.toBuild(nonstrictSettings);
  1708 |     });
  1709 |</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  1708 |     });
  1709 |
&gt; 1710 |     it(&quot;should fail to parse math in \\raisebox&quot;, function() {
       |    ^ Unknown Test
  1711 |         expect&#x60;\raisebox{5pt}{\frac a b}&#x60;.not.toParse(nonstrictSettings);
  1712 |         expect&#x60;\raisebox{-5pt}{\frac a b}&#x60;.not.toParse(nonstrictSettings);
  1713 |     });</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  1713 |     });
  1714 |
&gt; 1715 |     it(&quot;should fail to parse math in an \\hbox&quot;, function() {
       |    ^ Unknown Test
  1716 |         expect&#x60;\hbox{\frac a b}&#x60;.not.toParse(nonstrictSettings);
  1717 |     });
  1718 |</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  1717 |     });
  1718 |
&gt; 1719 |     it(&quot;should fail to build, given an unbraced length&quot;, function() {
       |    ^ Unknown Test
  1720 |         expect&#x60;\raisebox5pt{text}&#x60;.not.toBuild(strictSettings);
  1721 |         expect&#x60;\raisebox-5pt{text}&#x60;.not.toBuild(strictSettings);
  1722 |     });</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  1722 |     });
  1723 |
&gt; 1724 |     it(&quot;should build math in an hbox when math mode is set&quot;, function() {
       |    ^ Unknown Test
  1725 |         expect&#x60;a + \vcenter{\hbox{$\frac{\frac a b}c$}}&#x60;
  1726 |             .toBuild(strictSettings);
  1727 |     });</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  1771 |     });
  1772 |
&gt; 1773 |     it(&quot;should not parse a comment without newline in strict mode&quot;, () &#x3D;&gt; {
       |    ^ Unknown Test
  1774 |         expect&#x60;x%y&#x60;.not.toParse(strictSettings);
  1775 |         expect&#x60;x%y&#x60;.toParse(nonstrictSettings);
  1776 |     });</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  2256 |
  2257 | describe(&quot;An accent parser&quot;, function() {
&gt; 2258 |     it(&quot;should not fail&quot;, function() {
       |    ^ Unknown Test
  2259 |         expect&#x60;\vec{x}&#x60;.toParse();
  2260 |         expect&#x60;\vec{x^2}&#x60;.toParse();
  2261 |         expect&#x60;\vec{x}^2&#x60;.toParse();</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  2276 |     });
  2277 |
&gt; 2278 |     it(&quot;should parse stretchy, shifty accents&quot;, function() {
       |    ^ Unknown Test
  2279 |         expect&#x60;\widehat{x}&#x60;.toParse();
  2280 |         expect&#x60;\widecheck{x}&#x60;.toParse();
  2281 |     });</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  2281 |     });
  2282 |
&gt; 2283 |     it(&quot;should parse stretchy, non-shifty accents&quot;, function() {
       |    ^ Unknown Test
  2284 |         expect&#x60;\overrightarrow{x}&#x60;.toParse();
  2285 |     });
  2286 | });</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  2287 |
  2288 | describe(&quot;An accent builder&quot;, function() {
&gt; 2289 |     it(&quot;should not fail&quot;, function() {
       |    ^ Unknown Test
  2290 |         expect&#x60;\vec{x}&#x60;.toBuild();
  2291 |         expect&#x60;\vec{x}^2&#x60;.toBuild();
  2292 |         expect&#x60;\vec{x}_2&#x60;.toBuild();</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  2304 |
  2305 | describe(&quot;A stretchy and shifty accent builder&quot;, function() {
&gt; 2306 |     it(&quot;should not fail&quot;, function() {
       |    ^ Unknown Test
  2307 |         expect&#x60;\widehat{AB}&#x60;.toBuild();
  2308 |         expect&#x60;\widecheck{AB}&#x60;.toBuild();
  2309 |         expect&#x60;\widehat{AB}^2&#x60;.toBuild();</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  2322 |
  2323 | describe(&quot;A stretchy and non-shifty accent builder&quot;, function() {
&gt; 2324 |     it(&quot;should not fail&quot;, function() {
       |    ^ Unknown Test
  2325 |         expect&#x60;\overrightarrow{AB}&#x60;.toBuild();
  2326 |         expect&#x60;\overrightarrow{AB}^2&#x60;.toBuild();
  2327 |         expect&#x60;\overrightarrow{AB}_2&#x60;.toBuild();</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  2348 |
  2349 | describe(&quot;An under-accent parser&quot;, function() {
&gt; 2350 |     it(&quot;should not fail&quot;, function() {
       |    ^ Unknown Test
  2351 |         expect&#x60;\underrightarrow{x}&#x60;.toParse();
  2352 |         expect&#x60;\underrightarrow{x^2}&#x60;.toParse();
  2353 |         expect&#x60;\underrightarrow{x}^2&#x60;.toParse();</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  2369 |
  2370 | describe(&quot;An under-accent builder&quot;, function() {
&gt; 2371 |     it(&quot;should not fail&quot;, function() {
       |    ^ Unknown Test
  2372 |         expect&#x60;\underrightarrow{x}&#x60;.toBuild();
  2373 |         expect&#x60;\underrightarrow{x}^2&#x60;.toBuild();
  2374 |         expect&#x60;\underrightarrow{x}_2&#x60;.toBuild();</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  2387 |
  2388 | describe(&quot;An extensible arrow parser&quot;, function() {
&gt; 2389 |     it(&quot;should not fail&quot;, function() {
       |    ^ Unknown Test
  2390 |         expect&#x60;\xrightarrow{x}&#x60;.toParse();
  2391 |         expect&#x60;\xrightarrow{x^2}&#x60;.toParse();
  2392 |         expect&#x60;\xrightarrow{x}^2&#x60;.toParse();</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  2409 |
  2410 | describe(&quot;An extensible arrow builder&quot;, function() {
&gt; 2411 |     it(&quot;should not fail&quot;, function() {
       |    ^ Unknown Test
  2412 |         expect&#x60;\xrightarrow{x}&#x60;.toBuild();
  2413 |         expect&#x60;\xrightarrow{x}^2&#x60;.toBuild();
  2414 |         expect&#x60;\xrightarrow{x}_2&#x60;.toBuild();</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  2428 |
  2429 | describe(&quot;A horizontal brace parser&quot;, function() {
&gt; 2430 |     it(&quot;should not fail&quot;, function() {
       |    ^ Unknown Test
  2431 |         expect&#x60;\overbrace{x}&#x60;.toParse();
  2432 |         expect&#x60;\overbrace{x^2}&#x60;.toParse();
  2433 |         expect&#x60;\overbrace{x}^2&#x60;.toParse();</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  2451 |
  2452 | describe(&quot;A horizontal brace builder&quot;, function() {
&gt; 2453 |     it(&quot;should not fail&quot;, function() {
       |    ^ Unknown Test
  2454 |         expect&#x60;\overbrace{x}&#x60;.toBuild();
  2455 |         expect&#x60;\overbrace{x}^2&#x60;.toBuild();
  2456 |         expect&#x60;\underbrace{x}_2&#x60;.toBuild();</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  2469 |
  2470 | describe(&quot;A boxed parser&quot;, function() {
&gt; 2471 |     it(&quot;should not fail&quot;, function() {
       |    ^ Unknown Test
  2472 |         expect&#x60;\boxed{x}&#x60;.toParse();
  2473 |         expect&#x60;\boxed{x^2}&#x60;.toParse();
  2474 |         expect&#x60;\boxed{x}^2&#x60;.toParse();</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  2484 |
  2485 | describe(&quot;A boxed builder&quot;, function() {
&gt; 2486 |     it(&quot;should not fail&quot;, function() {
       |    ^ Unknown Test
  2487 |         expect&#x60;\boxed{x}&#x60;.toBuild();
  2488 |         expect&#x60;\boxed{x}^2&#x60;.toBuild();
  2489 |         expect&#x60;\boxed{x}_2&#x60;.toBuild();</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  2501 |
  2502 | describe(&quot;An fbox parser, unlike a boxed parser,&quot;, function() {
&gt; 2503 |     it(&quot;should fail when given math&quot;, function() {
       |    ^ Unknown Test
  2504 |         expect&#x60;\fbox{\frac a b}&#x60;.not.toParse();
  2505 |     });
  2506 | });</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  2507 |
  2508 | describe(&quot;A colorbox parser&quot;, function() {
&gt; 2509 |     it(&quot;should not fail, given a text argument&quot;, function() {
       |    ^ Unknown Test
  2510 |         expect&#x60;\colorbox{red}{a b}&#x60;.toParse();
  2511 |         expect&#x60;\colorbox{red}{x}^2&#x60;.toParse();
  2512 |         expect&#x60;\colorbox{red} x&#x60;.toParse();</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  2513 |     });
  2514 |
&gt; 2515 |     it(&quot;should fail, given a math argument&quot;, function() {
       |    ^ Unknown Test
  2516 |         expect&#x60;\colorbox{red}{\alpha}&#x60;.not.toParse();
  2517 |         expect&#x60;\colorbox{red}{\frac{a}{b}}&#x60;.not.toParse();
  2518 |     });</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  2518 |     });
  2519 |
&gt; 2520 |     it(&quot;should parse a color&quot;, function() {
       |    ^ Unknown Test
  2521 |         expect&#x60;\colorbox{red}{a b}&#x60;.toParse();
  2522 |         expect&#x60;\colorbox{#197}{a b}&#x60;.toParse();
  2523 |         expect&#x60;\colorbox{#1a9b7c}{a b}&#x60;.toParse();</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  2531 |
  2532 | describe(&quot;A colorbox builder&quot;, function() {
&gt; 2533 |     it(&quot;should not fail&quot;, function() {
       |    ^ Unknown Test
  2534 |         expect&#x60;\colorbox{red}{a b}&#x60;.toBuild();
  2535 |         expect&#x60;\colorbox{red}{a b}^2&#x60;.toBuild();
  2536 |         expect&#x60;\colorbox{red} x&#x60;.toBuild();</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  2543 |
  2544 | describe(&quot;An fcolorbox parser&quot;, function() {
&gt; 2545 |     it(&quot;should not fail, given a text argument&quot;, function() {
       |    ^ Unknown Test
  2546 |         expect&#x60;\fcolorbox{blue}{yellow}{a b}&#x60;.toParse();
  2547 |         expect&#x60;\fcolorbox{blue}{yellow}{x}^2&#x60;.toParse();
  2548 |         expect&#x60;\fcolorbox{blue}{yellow} x&#x60;.toParse();</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  2549 |     });
  2550 |
&gt; 2551 |     it(&quot;should fail, given a math argument&quot;, function() {
       |    ^ Unknown Test
  2552 |         expect&#x60;\fcolorbox{blue}{yellow}{\alpha}&#x60;.not.toParse();
  2553 |         expect&#x60;\fcolorbox{blue}{yellow}{\frac{a}{b}}&#x60;.not.toParse();
  2554 |     });</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  2554 |     });
  2555 |
&gt; 2556 |     it(&quot;should parse a color&quot;, function() {
       |    ^ Unknown Test
  2557 |         expect&#x60;\fcolorbox{blue}{yellow}{a b}&#x60;.toParse();
  2558 |         expect&#x60;\fcolorbox{blue}{#197}{a b}&#x60;.toParse();
  2559 |         expect&#x60;\fcolorbox{blue}{#1a9b7c}{a b}&#x60;.toParse();</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  2567 |
  2568 | describe(&quot;A fcolorbox builder&quot;, function() {
&gt; 2569 |     it(&quot;should not fail&quot;, function() {
       |    ^ Unknown Test
  2570 |         expect&#x60;\fcolorbox{blue}{yellow}{a b}&#x60;.toBuild();
  2571 |         expect&#x60;\fcolorbox{blue}{yellow}{a b}^2&#x60;.toBuild();
  2572 |         expect&#x60;\fcolorbox{blue}{yellow} x&#x60;.toBuild();</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  2579 |
  2580 | describe(&quot;A strike-through parser&quot;, function() {
&gt; 2581 |     it(&quot;should not fail&quot;, function() {
       |    ^ Unknown Test
  2582 |         expect&#x60;\cancel{x}&#x60;.toParse();
  2583 |         expect&#x60;\cancel{x^2}&#x60;.toParse();
  2584 |         expect&#x60;\cancel{x}^2&#x60;.toParse();</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  2600 |
  2601 | describe(&quot;A strike-through builder&quot;, function() {
&gt; 2602 |     it(&quot;should not fail&quot;, function() {
       |    ^ Unknown Test
  2603 |         expect&#x60;\cancel{x}&#x60;.toBuild();
  2604 |         expect&#x60;\cancel{x}^2&#x60;.toBuild();
  2605 |         expect&#x60;\cancel{x}_2&#x60;.toBuild();</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  2621 |
  2622 | describe(&quot;A actuarial angle parser&quot;, function() {
&gt; 2623 |     it(&quot;should not fail in math mode&quot;, function() {
       |    ^ Unknown Test
  2624 |         expect&#x60;a_{\angl{n}}&#x60;.toParse();
  2625 |     });
  2626 |     it(&quot;should fail in text mode&quot;, function() {</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  2624 |         expect&#x60;a_{\angl{n}}&#x60;.toParse();
  2625 |     });
&gt; 2626 |     it(&quot;should fail in text mode&quot;, function() {
       |    ^ Unknown Test
  2627 |         expect&#x60;\text{a_{\angl{n}}}&#x60;.not.toParse();
  2628 |     });
  2629 | });</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  2630 |
  2631 | describe(&quot;A actuarial angle builder&quot;, function() {
&gt; 2632 |     it(&quot;should not fail&quot;, function() {
       |    ^ Unknown Test
  2633 |         expect&#x60;a_{\angl{n}}&#x60;.toBuild();
  2634 |         expect&#x60;a_{\angl{n}i}&#x60;.toBuild();
  2635 |         expect&#x60;a_{\angl n}&#x60;.toBuild();</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  2639 |
  2640 | describe(&quot;\\phase&quot;, function() {
&gt; 2641 |     it(&quot;should fail in text mode&quot;, function() {
       |    ^ Unknown Test
  2642 |         expect&#x60;\text{\phase{-78.2^\circ}}&#x60;.not.toParse();
  2643 |     });
  2644 |     it(&quot;should not fail in math mode&quot;, function() {</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  2642 |         expect&#x60;\text{\phase{-78.2^\circ}}&#x60;.not.toParse();
  2643 |     });
&gt; 2644 |     it(&quot;should not fail in math mode&quot;, function() {
       |    ^ Unknown Test
  2645 |         expect&#x60;\phase{-78.2^\circ}&#x60;.toBuild();
  2646 |     });
  2647 | });</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  2648 |
  2649 | describe(&quot;A phantom parser&quot;, function() {
&gt; 2650 |     it(&quot;should not fail&quot;, function() {
       |    ^ Unknown Test
  2651 |         expect&#x60;\phantom{x}&#x60;.toParse();
  2652 |         expect&#x60;\phantom{x^2}&#x60;.toParse();
  2653 |         expect&#x60;\phantom{x}^2&#x60;.toParse();</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  2668 |
  2669 | describe(&quot;A phantom builder&quot;, function() {
&gt; 2670 |     it(&quot;should not fail&quot;, function() {
       |    ^ Unknown Test
  2671 |         expect&#x60;\phantom{x}&#x60;.toBuild();
  2672 |         expect&#x60;\phantom{x^2}&#x60;.toBuild();
  2673 |         expect&#x60;\phantom{x}^2&#x60;.toBuild();</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  2697 |
  2698 | describe(&quot;A smash parser&quot;, function() {
&gt; 2699 |     it(&quot;should not fail&quot;, function() {
       |    ^ Unknown Test
  2700 |         expect&#x60;\smash{x}&#x60;.toParse();
  2701 |         expect&#x60;\smash{x^2}&#x60;.toParse();
  2702 |         expect&#x60;\smash{x}^2&#x60;.toParse();</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  2722 |
  2723 | describe(&quot;A smash builder&quot;, function() {
&gt; 2724 |     it(&quot;should not fail&quot;, function() {
       |    ^ Unknown Test
  2725 |         expect&#x60;\smash{x}&#x60;.toBuild(nonstrictSettings);
  2726 |         expect&#x60;\smash{x^2}&#x60;.toBuild(nonstrictSettings);
  2727 |         expect&#x60;\smash{x}^2&#x60;.toBuild(nonstrictSettings);</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  2746 |
  2747 | describe(&quot;An optional argument parser&quot;, function() {
&gt; 2748 |     it(&quot;should not fail&quot;, function() {
       |    ^ Unknown Test
  2749 |         &#x2F;&#x2F; Note this doesn&#39;t actually make an optional argument, but still
  2750 |         &#x2F;&#x2F; should work
  2751 |         expect&#x60;\frac[1]{2}{3}&#x60;.toParse();</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  2754 |     });
  2755 |
&gt; 2756 |     it(&quot;should work with sqrts with optional arguments&quot;, function() {
       |    ^ Unknown Test
  2757 |         expect&#x60;\sqrt[3]{2}&#x60;.toParse();
  2758 |     });
  2759 |</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  2758 |     });
  2759 |
&gt; 2760 |     it(&quot;should work when the optional argument is missing&quot;, function() {
       |    ^ Unknown Test
  2761 |         expect&#x60;\sqrt{2}&#x60;.toParse();
  2762 |         expect&#x60;\rule{1em}{2em}&#x60;.toParse();
  2763 |     });</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  2763 |     });
  2764 |
&gt; 2765 |     it(&quot;should fail when the optional argument is malformed&quot;, function() {
       |    ^ Unknown Test
  2766 |         expect&#x60;\rule[1]{2em}{3em}&#x60;.not.toParse();
  2767 |     });
  2768 |</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  2767 |     });
  2768 |
&gt; 2769 |     it(&quot;should not work if the optional argument isn&#39;t closed&quot;, function() {
       |    ^ Unknown Test
  2770 |         expect&#x60;\sqrt[&#x60;.not.toParse();
  2771 |     });
  2772 | });</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  2817 | describe(&quot;A substack function&quot;, function() {
  2818 |
&gt; 2819 |     it(&quot;should build&quot;, function() {
       |    ^ Unknown Test
  2820 |         expect&#x60;\sum_{\substack{ 0&lt;i&lt;m \\ 0&lt;j&lt;n }}  P(i,j)&#x60;.toBuild();
  2821 |     });
  2822 |     it(&quot;should accommodate spaces in the argument&quot;, function() {</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  2820 |         expect&#x60;\sum_{\substack{ 0&lt;i&lt;m \\ 0&lt;j&lt;n }}  P(i,j)&#x60;.toBuild();
  2821 |     });
&gt; 2822 |     it(&quot;should accommodate spaces in the argument&quot;, function() {
       |    ^ Unknown Test
  2823 |         expect&#x60;\sum_{\substack{ 0&lt;i&lt;m \\ 0&lt;j&lt;n }}  P(i,j)&#x60;.toBuild();
  2824 |     });
  2825 |     it(&quot;should accommodate macros in the argument&quot;, function() {</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  2823 |         expect&#x60;\sum_{\substack{ 0&lt;i&lt;m \\ 0&lt;j&lt;n }}  P(i,j)&#x60;.toBuild();
  2824 |     });
&gt; 2825 |     it(&quot;should accommodate macros in the argument&quot;, function() {
       |    ^ Unknown Test
  2826 |         expect&#x60;\sum_{\substack{ 0&lt;i&lt;\varPi \\ 0&lt;j&lt;\pi }}  P(i,j)&#x60;.toBuild();
  2827 |     });
  2828 |     it(&quot;should accommodate an empty argument&quot;, function() {</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  2826 |         expect&#x60;\sum_{\substack{ 0&lt;i&lt;\varPi \\ 0&lt;j&lt;\pi }}  P(i,j)&#x60;.toBuild();
  2827 |     });
&gt; 2828 |     it(&quot;should accommodate an empty argument&quot;, function() {
       |    ^ Unknown Test
  2829 |         expect&#x60;\sum_{\substack{}}  P(i,j)&#x60;.toBuild();
  2830 |     });
  2831 |</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  2834 | describe(&quot;A smallmatrix environment&quot;, function() {
  2835 |
&gt; 2836 |     it(&quot;should build&quot;, function() {
       |    ^ Unknown Test
  2837 |         expect&#x60;\begin{smallmatrix} a &amp; b \\ c &amp; d \end{smallmatrix}&#x60;.toBuild();
  2838 |     });
  2839 |</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  2842 | describe(&quot;A cases environment&quot;, function() {
  2843 |
&gt; 2844 |     it(&quot;should parse its input&quot;, function() {
       |    ^ Unknown Test
  2845 |         expect&#x60;f(a,b)&#x3D;\begin{cases}a+1&amp;\text{if }b\text{ is odd}\\a&amp;\text{if }b&#x3D;0\\a-1&amp;\text{otherwise}\end{cases}&#x60;
  2846 |             .toParse();
  2847 |     });</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  2851 | describe(&quot;An rcases environment&quot;, function() {
  2852 |
&gt; 2853 |     it(&quot;should build&quot;, function() {
       |    ^ Unknown Test
  2854 |         expect&#x60;\begin{rcases} a &amp;\text{if } b \\ c &amp;\text{if } d \end{rcases}⇒…&#x60;
  2855 |             .toBuild();
  2856 |     });</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  2860 | describe(&quot;An aligned environment&quot;, function() {
  2861 |
&gt; 2862 |     it(&quot;should parse its input&quot;, function() {
       |    ^ Unknown Test
  2863 |         expect&#x60;\begin{aligned}a&amp;&#x3D;b&amp;c&amp;&#x3D;d\\e&amp;&#x3D;f\end{aligned}&#x60;.toParse();
  2864 |     });
  2865 |</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  2864 |     });
  2865 |
&gt; 2866 |     it(&quot;should allow cells in brackets&quot;, function() {
       |    ^ Unknown Test
  2867 |         expect&#x60;\begin{aligned}[a]&amp;[b]\\ [c]&amp;[d]\end{aligned}&#x60;.toParse();
  2868 |     });
  2869 |</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  2868 |     });
  2869 |
&gt; 2870 |     it(&quot;should forbid cells in brackets without space&quot;, function() {
       |    ^ Unknown Test
  2871 |         expect&#x60;\begin{aligned}[a]&amp;[b]\\[c]&amp;[d]\end{aligned}&#x60;.not.toParse();
  2872 |     });
  2873 |</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  2879 |
  2880 | describe(&quot;AMS environments&quot;, function() {
&gt; 2881 |     it(&quot;should fail outside display mode&quot;, () &#x3D;&gt; {
       |    ^ Unknown Test
  2882 |         expect&#x60;\begin{gather}a+b\\c+d\end{gather}&#x60;.not.toParse(nonstrictSettings);
  2883 |         expect&#x60;\begin{gather*}a+b\\c+d\end{gather*}&#x60;.not.toParse(nonstrictSettings);
  2884 |         expect&#x60;\begin{align}a&amp;&#x3D;b+c\\d+e&amp;&#x3D;f\end{align}&#x60;.not.toParse(nonstrictSettings);</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  2892 |
  2893 |     const displayMode &#x3D; new Settings({displayMode: true});
&gt; 2894 |     it(&quot;should build if in display mode&quot;, () &#x3D;&gt; {
       |    ^ Unknown Test
  2895 |         expect&#x60;\begin{gather}a+b\\c+d\end{gather}&#x60;.toBuild(displayMode);
  2896 |         expect&#x60;\begin{gather*}a+b\\c+d\end{gather*}&#x60;.toBuild(displayMode);
  2897 |         expect&#x60;\begin{align}a&amp;&#x3D;b+c\\d+e&amp;&#x3D;f\end{align}&#x60;.toBuild(displayMode);</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  2905 |     });
  2906 |
&gt; 2907 |     it(&quot;should build an empty environment&quot;, () &#x3D;&gt; {
       |    ^ Unknown Test
  2908 |         expect&#x60;\begin{gather}\end{gather}&#x60;.toBuild(displayMode);
  2909 |         expect&#x60;\begin{gather*}\end{gather*}&#x60;.toBuild(displayMode);
  2910 |         expect&#x60;\begin{align}\end{align}&#x60;.toBuild(displayMode);</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  2917 |     });
  2918 |
&gt; 2919 |     it(&quot;{equation} should fail if argument contains two rows.&quot;, () &#x3D;&gt; {
       |    ^ Unknown Test
  2920 |         expect&#x60;\begin{equation}a&#x3D;\cr b+c\end{equation}&#x60;.not.toParse(displayMode);
  2921 |     });
  2922 |     it(&quot;{equation} should fail if argument contains two columns.&quot;, () &#x3D;&gt; {</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  2920 |         expect&#x60;\begin{equation}a&#x3D;\cr b+c\end{equation}&#x60;.not.toParse(displayMode);
  2921 |     });
&gt; 2922 |     it(&quot;{equation} should fail if argument contains two columns.&quot;, () &#x3D;&gt; {
       |    ^ Unknown Test
  2923 |         expect&#x60;\begin{equation}a &amp;&#x3D;b+c\end{equation}&#x60;.not.toBuild(displayMode);
  2924 |     });
  2925 |     it(&quot;{split} should fail if argument contains three columns.&quot;, () &#x3D;&gt; {</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  2923 |         expect&#x60;\begin{equation}a &amp;&#x3D;b+c\end{equation}&#x60;.not.toBuild(displayMode);
  2924 |     });
&gt; 2925 |     it(&quot;{split} should fail if argument contains three columns.&quot;, () &#x3D;&gt; {
       |    ^ Unknown Test
  2926 |         expect&#x60;\begin{equation}\begin{split}a &amp;&#x3D;b &amp;+c\\&amp;&#x3D;e &amp;+f\end{split}\end{equation}&#x60;.not.toBuild(displayMode);
  2927 |     });
  2928 |     it(&quot;{array} should fail if body contains more columns than specification.&quot;, () &#x3D;&gt; {</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  2926 |         expect&#x60;\begin{equation}\begin{split}a &amp;&#x3D;b &amp;+c\\&amp;&#x3D;e &amp;+f\end{split}\end{equation}&#x60;.not.toBuild(displayMode);
  2927 |     });
&gt; 2928 |     it(&quot;{array} should fail if body contains more columns than specification.&quot;, () &#x3D;&gt; {
       |    ^ Unknown Test
  2929 |         expect&#x60;\begin{array}{2}a &amp; b &amp; c\\d &amp; e  f\end{array}&#x60;.not.toBuild(displayMode);
  2930 |     });
  2931 | });</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  2955 |
  2956 | describe(&quot;operatorname support&quot;, function() {
&gt; 2957 |     it(&quot;should not fail&quot;, function() {
       |    ^ Unknown Test
  2958 |         expect&#x60;\operatorname{x*Π∑\Pi\sum\frac a b}&#x60;.toBuild();
  2959 |         expect&#x60;\operatorname*{x*Π∑\Pi\sum\frac a b}&#x60;.toBuild();
  2960 |         expect&#x60;\operatorname*{x*Π∑\Pi\sum\frac a b}_y x&#x60;.toBuild();</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  2966 |
  2967 | describe(&quot;href and url commands&quot;, function() {
&gt; 2968 |     it(&quot;should parse its input&quot;, function() {
       |    ^ Unknown Test
  2969 |         expect&#x60;\href{http:&#x2F;&#x2F;example.com&#x2F;}{\sin}&#x60;.toBuild(trustSettings);
  2970 |         expect&#x60;\url{http:&#x2F;&#x2F;example.com&#x2F;}&#x60;.toBuild(trustSettings);
  2971 |     });</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  2971 |     });
  2972 |
&gt; 2973 |     it(&quot;should allow empty URLs&quot;, function() {
       |    ^ Unknown Test
  2974 |         expect&#x60;\href{}{example here}&#x60;.toBuild(trustSettings);
  2975 |         expect&#x60;\url{}&#x60;.toBuild(trustSettings);
  2976 |     });</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  2984 |     });
  2985 |
&gt; 2986 |     it(&quot;should allow spaces single-character URLs&quot;, () &#x3D;&gt; {
       |    ^ Unknown Test
  2987 |         expect&#x60;\href %end&#x60;.toParseLike(&quot;\\href{%}end&quot;, trustSettings);
  2988 |         expect&#x60;\url %end&#x60;.toParseLike(&quot;\\url{%}end&quot;, trustSettings);
  2989 |     });</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  3005 |     });
  3006 |
&gt; 3007 |     it(&quot;should not allow unbalanced brace(s) in url&quot;, function() {
       |    ^ Unknown Test
  3008 |         expect&#x60;\href{http:&#x2F;&#x2F;example.com&#x2F;{a}{bar}&#x60;.not.toParse();
  3009 |         expect&#x60;\href{http:&#x2F;&#x2F;example.com&#x2F;}a}{bar}&#x60;.not.toParse();
  3010 |         expect&#x60;\url{http:&#x2F;&#x2F;example.com&#x2F;{a}&#x60;.not.toParse();</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  3096 |
  3097 | describe(&quot;A raw text parser&quot;, function() {
&gt; 3098 |     it(&quot;should return null for a omitted optional string&quot;, function() {
       |    ^ Unknown Test
  3099 |         expect&#x60;\includegraphics{https:&#x2F;&#x2F;cdn.kastatic.org&#x2F;images&#x2F;apple-touch-icon-57x57-precomposed.new.png}&#x60;.toParse();
  3100 |     });
  3101 | });</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  3111 |     });
  3112 |
&gt; 3113 |     it(&quot;should still parse on unrecognized control sequences&quot;, function() {
       |    ^ Unknown Test
  3114 |         expect&#x60;\error&#x60;.toParse(noThrowSettings);
  3115 |     });
  3116 |</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  3116 |
  3117 |     describe(&quot;should allow unrecognized controls sequences anywhere, including&quot;, function() {
&gt; 3118 |         it(&quot;in superscripts and subscripts&quot;, function() {
       |        ^ Unknown Test
  3119 |             expect&#x60;2_\error&#x60;.toBuild(noThrowSettings);
  3120 |             expect&#x60;3^{\error}_\error&#x60;.toBuild(noThrowSettings);
  3121 |             expect&#x60;\int\nolimits^\error_\error&#x60;.toBuild(noThrowSettings);</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  3122 |         });
  3123 |
&gt; 3124 |         it(&quot;in fractions&quot;, function() {
       |        ^ Unknown Test
  3125 |             expect&#x60;\frac{345}{\error}&#x60;.toBuild(noThrowSettings);
  3126 |             expect&#x60;\frac\error{\error}&#x60;.toBuild(noThrowSettings);
  3127 |         });</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  3127 |         });
  3128 |
&gt; 3129 |         it(&quot;in square roots&quot;, function() {
       |        ^ Unknown Test
  3130 |             expect&#x60;\sqrt\error&#x60;.toBuild(noThrowSettings);
  3131 |             expect&#x60;\sqrt{234\error}&#x60;.toBuild(noThrowSettings);
  3132 |         });</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  3132 |         });
  3133 |
&gt; 3134 |         it(&quot;in text boxes&quot;, function() {
       |        ^ Unknown Test
  3135 |             expect&#x60;\text{\error}&#x60;.toBuild(noThrowSettings);
  3136 |         });
  3137 |     });</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  3202 |
  3203 | describe(&quot;The symbol table integrity&quot;, function() {
&gt; 3204 |     it(&quot;should treat certain symbols as synonyms&quot;, function() {
       |    ^ Unknown Test
  3205 |         expect&#x60;&lt;&#x60;.toBuildLike&#x60;\lt&#x60;;
  3206 |         expect&#x60;&gt;&#x60;.toBuildLike&#x60;\gt&#x60;;
  3207 |         expect&#x60;\left&lt;\frac{1}{x}\right&gt;&#x60;.toBuildLike&#x60;\left\lt\frac{1}{x}\right\gt&#x60;;</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  3220 |
  3221 | describe(&quot;A macro expander&quot;, function() {
&gt; 3222 |     it(&quot;should produce individual tokens&quot;, function() {
       |    ^ Unknown Test
  3223 |         expect&#x60;e^\foo&#x60;.toParseLike(&quot;e^1 23&quot;,
  3224 |             new Settings({macros: {&quot;\\foo&quot;: &quot;123&quot;}}));
  3225 |     });</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  3225 |     });
  3226 |
&gt; 3227 |     it(&quot;should preserve leading spaces inside macro definition&quot;, function() {
       |    ^ Unknown Test
  3228 |         expect&#x60;\text{\foo}&#x60;.toParseLike(r&#x60;\text{ x}&#x60;,
  3229 |             new Settings({macros: {&quot;\\foo&quot;: &quot; x&quot;}}));
  3230 |     });</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  3230 |     });
  3231 |
&gt; 3232 |     it(&quot;should preserve leading spaces inside macro argument&quot;, function() {
       |    ^ Unknown Test
  3233 |         expect&#x60;\text{\foo{ x}}&#x60;.toParseLike(r&#x60;\text{ x}&#x60;,
  3234 |             new Settings({macros: {&quot;\\foo&quot;: &quot;#1&quot;}}));
  3235 |     });</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  3235 |     });
  3236 |
&gt; 3237 |     it(&quot;should ignore expanded spaces in math mode&quot;, function() {
       |    ^ Unknown Test
  3238 |         expect&#x60;\foo&#x60;.toParseLike(&quot;x&quot;, new Settings({macros: {&quot;\\foo&quot;: &quot; x&quot;}}));
  3239 |     });
  3240 |</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  3239 |     });
  3240 |
&gt; 3241 |     it(&quot;should consume spaces after control-word macro&quot;, function() {
       |    ^ Unknown Test
  3242 |         expect&#x60;\text{\foo }&#x60;.toParseLike(r&#x60;\text{x}&#x60;,
  3243 |             new Settings({macros: {&quot;\\foo&quot;: &quot;x&quot;}}));
  3244 |     });</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  3244 |     });
  3245 |
&gt; 3246 |     it(&quot;should consume spaces after macro with \\relax&quot;, function() {
       |    ^ Unknown Test
  3247 |         expect&#x60;\text{\foo }&#x60;.toParseLike(r&#x60;\text{}&#x60;,
  3248 |             new Settings({macros: {&quot;\\foo&quot;: &quot;\\relax&quot;}}));
  3249 |     });</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  3249 |     });
  3250 |
&gt; 3251 |     it(&quot;should not consume spaces after control-word expansion&quot;, function() {
       |    ^ Unknown Test
  3252 |         expect&#x60;\text{\\ }&#x60;.toParseLike(r&#x60;\text{ }&#x60;,
  3253 |             new Settings({macros: {&quot;\\\\&quot;: &quot;\\relax&quot;}}));
  3254 |     });</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  3254 |     });
  3255 |
&gt; 3256 |     it(&quot;should consume spaces after \\relax&quot;, function() {
       |    ^ Unknown Test
  3257 |         expect&#x60;\text{\relax }&#x60;.toParseLike&#x60;\text{}&#x60;;
  3258 |     });
  3259 |</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  3258 |     });
  3259 |
&gt; 3260 |     it(&quot;should consume spaces after control-word function&quot;, function() {
       |    ^ Unknown Test
  3261 |         expect&#x60;\text{\KaTeX }&#x60;.toParseLike&#x60;\text{\KaTeX}&#x60;;
  3262 |     });
  3263 |</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  3262 |     });
  3263 |
&gt; 3264 |     it(&quot;should preserve spaces after control-symbol macro&quot;, function() {
       |    ^ Unknown Test
  3265 |         expect&#x60;\text{\% y}&#x60;.toParseLike(r&#x60;\text{x y}&#x60;,
  3266 |             new Settings({macros: {&quot;\\%&quot;: &quot;x&quot;}}));
  3267 |     });</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  3267 |     });
  3268 |
&gt; 3269 |     it(&quot;should preserve spaces after control-symbol function&quot;, function() {
       |    ^ Unknown Test
  3270 |         expect&#x60;\text{\&#39; }&#x60;.toParse();
  3271 |     });
  3272 |</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  3271 |     });
  3272 |
&gt; 3273 |     it(&quot;should consume spaces between arguments&quot;, function() {
       |    ^ Unknown Test
  3274 |         expect&#x60;\text{\foo 1 2}&#x60;.toParseLike(r&#x60;\text{12end}&#x60;,
  3275 |             new Settings({macros: {&quot;\\foo&quot;: &quot;#1#2end&quot;}}));
  3276 |         expect&#x60;\text{\foo {1} {2}}&#x60;.toParseLike(r&#x60;\text{12end}&#x60;,</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  3278 |     });
  3279 |
&gt; 3280 |     it(&quot;should allow for multiple expansion&quot;, function() {
       |    ^ Unknown Test
  3281 |         expect&#x60;1\foo2&#x60;.toParseLike(&quot;1aa2&quot;, new Settings({macros: {
  3282 |             &quot;\\foo&quot;: &quot;\\bar\\bar&quot;,
  3283 |             &quot;\\bar&quot;: &quot;a&quot;,</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  3285 |     });
  3286 |
&gt; 3287 |     it(&quot;should allow for multiple expansion with argument&quot;, function() {
       |    ^ Unknown Test
  3288 |         expect&#x60;1\foo2&#x60;.toParseLike(&quot;12222&quot;, new Settings({macros: {
  3289 |             &quot;\\foo&quot;: &quot;\\bar{#1}\\bar{#1}&quot;,
  3290 |             &quot;\\bar&quot;: &quot;#1#1&quot;,</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  3292 |     });
  3293 |
&gt; 3294 |     it(&quot;should allow for macro argument&quot;, function() {
       |    ^ Unknown Test
  3295 |         expect&#x60;\foo\bar&#x60;.toParseLike(&quot;(xyz)&quot;, new Settings({macros: {
  3296 |             &quot;\\foo&quot;: &quot;(#1)&quot;,
  3297 |             &quot;\\bar&quot;: &quot;xyz&quot;,</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  3299 |     });
  3300 |
&gt; 3301 |     it(&quot;should allow properly nested group for macro argument&quot;, function() {
       |    ^ Unknown Test
  3302 |         expect&#x60;\foo{e^{x_{12}+3}}&#x60;.toParseLike(&quot;(e^{x_{12}+3})&quot;,
  3303 |             new Settings({macros: {&quot;\\foo&quot;: &quot;(#1)&quot;}}));
  3304 |     });</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  3304 |     });
  3305 |
&gt; 3306 |     it(&quot;should delay expansion if preceded by \\expandafter&quot;, function() {
       |    ^ Unknown Test
  3307 |         expect&#x60;\expandafter\foo\bar&#x60;.toParseLike(&quot;x+y&quot;, new Settings({macros: {
  3308 |             &quot;\\foo&quot;: &quot;#1+#2&quot;,
  3309 |             &quot;\\bar&quot;: &quot;xy&quot;,</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  3314 |     });
  3315 |
&gt; 3316 |     it(&quot;should not expand if preceded by \\noexpand&quot;, function() {
       |    ^ Unknown Test
  3317 |         &#x2F;&#x2F; \foo is not expanded and interpreted as if its meaning were \relax
  3318 |         expect&#x60;\noexpand\foo y&#x60;.toParseLike(&quot;y&quot;,
  3319 |             new Settings({macros: {&quot;\\foo&quot;: &quot;x&quot;}}));</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  3327 |     });
  3328 |
&gt; 3329 |     it(&quot;should allow for space macro argument (text version)&quot;, function() {
       |    ^ Unknown Test
  3330 |         expect&#x60;\text{\foo\bar}&#x60;.toParseLike(r&#x60;\text{( )}&#x60;, new Settings({macros: {
  3331 |             &quot;\\foo&quot;: &quot;(#1)&quot;,
  3332 |             &quot;\\bar&quot;: &quot; &quot;,</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  3334 |     });
  3335 |
&gt; 3336 |     it(&quot;should allow for space macro argument (math version)&quot;, function() {
       |    ^ Unknown Test
  3337 |         expect&#x60;\foo\bar&#x60;.toParseLike(&quot;()&quot;, new Settings({macros: {
  3338 |             &quot;\\foo&quot;: &quot;(#1)&quot;,
  3339 |             &quot;\\bar&quot;: &quot; &quot;,</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  3341 |     });
  3342 |
&gt; 3343 |     it(&quot;should allow for space second argument (text version)&quot;, function() {
       |    ^ Unknown Test
  3344 |         expect&#x60;\text{\foo\bar\bar}&#x60;.toParseLike(r&#x60;\text{( , )}&#x60;, new Settings({macros: {
  3345 |             &quot;\\foo&quot;: &quot;(#1,#2)&quot;,
  3346 |             &quot;\\bar&quot;: &quot; &quot;,</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  3348 |     });
  3349 |
&gt; 3350 |     it(&quot;should treat \\relax as empty argument&quot;, function() {
       |    ^ Unknown Test
  3351 |         expect&#x60;\text{\foo\relax x}&#x60;.toParseLike(r&#x60;\text{(,x)}&#x60;, new Settings({macros: {
  3352 |             &quot;\\foo&quot;: &quot;(#1,#2)&quot;,
  3353 |         }}));</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  3354 |     });
  3355 |
&gt; 3356 |     it(&quot;should allow for space second argument (math version)&quot;, function() {
       |    ^ Unknown Test
  3357 |         expect&#x60;\foo\bar\bar&#x60;.toParseLike(&quot;(,)&quot;, new Settings({macros: {
  3358 |             &quot;\\foo&quot;: &quot;(#1,#2)&quot;,
  3359 |             &quot;\\bar&quot;: &quot; &quot;,</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  3361 |     });
  3362 |
&gt; 3363 |     it(&quot;should allow for empty macro argument&quot;, function() {
       |    ^ Unknown Test
  3364 |         expect&#x60;\foo\bar&#x60;.toParseLike(&quot;()&quot;, new Settings({macros: {
  3365 |             &quot;\\foo&quot;: &quot;(#1)&quot;,
  3366 |             &quot;\\bar&quot;: &quot;&quot;,</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  3368 |     });
  3369 |
&gt; 3370 |     it(&quot;should allow for space function arguments&quot;, function() {
       |    ^ Unknown Test
  3371 |         expect&#x60;\frac\bar\bar&#x60;.toParseLike(r&#x60;\frac{}{}&#x60;, new Settings({macros: {
  3372 |             &quot;\\bar&quot;: &quot; &quot;,
  3373 |         }}));</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  3374 |     });
  3375 |
&gt; 3376 |     it(&quot;should build \\overset and \\underset&quot;, function() {
       |    ^ Unknown Test
  3377 |         expect&#x60;\overset{f}{\rightarrow} Y&#x60;.toBuild();
  3378 |         expect&#x60;\underset{f}{\rightarrow} Y&#x60;.toBuild();
  3379 |     });</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  3379 |     });
  3380 |
&gt; 3381 |     it(&quot;should build \\iff, \\implies, \\impliedby&quot;, function() {
       |    ^ Unknown Test
  3382 |         expect&#x60;X \iff Y&#x60;.toBuild();
  3383 |         expect&#x60;X \implies Y&#x60;.toBuild();
  3384 |         expect&#x60;X \impliedby Y&#x60;.toBuild();</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  3385 |     });
  3386 |
&gt; 3387 |     it(&quot;should allow aliasing characters&quot;, function() {
       |    ^ Unknown Test
  3388 |         expect&#x60;x’&#x3D;c&#x60;.toParseLike(&quot;x&#39;&#x3D;c&quot;, new Settings({macros: {
  3389 |             &quot;’&quot;: &quot;&#39;&quot;,
  3390 |         }}));</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  3391 |     });
  3392 |
&gt; 3393 |     it(&quot;\\@firstoftwo should consume both, and avoid errors&quot;, function() {
       |    ^ Unknown Test
  3394 |         expect&#x60;\@firstoftwo{yes}{no}&#x60;.toParseLike&#x60;yes&#x60;;
  3395 |         expect&#x60;\@firstoftwo{yes}{1&#39;_2^3}&#x60;.toParseLike&#x60;yes&#x60;;
  3396 |     });</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  3396 |     });
  3397 |
&gt; 3398 |     it(&quot;\\@ifstar should consume star but nothing else&quot;, function() {
       |    ^ Unknown Test
  3399 |         expect&#x60;\@ifstar{yes}{no}*!&#x60;.toParseLike&#x60;yes!&#x60;;
  3400 |         expect&#x60;\@ifstar{yes}{no}?!&#x60;.toParseLike&#x60;no?!&#x60;;
  3401 |     });</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  3401 |     });
  3402 |
&gt; 3403 |     it(&quot;\\@ifnextchar should not consume nonspaces&quot;, function() {
       |    ^ Unknown Test
  3404 |         expect&#x60;\@ifnextchar!{yes}{no}!!&#x60;.toParseLike&#x60;yes!!&#x60;;
  3405 |         expect&#x60;\@ifnextchar!{yes}{no}?!&#x60;.toParseLike&#x60;no?!&#x60;;
  3406 |     });</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  3406 |     });
  3407 |
&gt; 3408 |     it(&quot;\\@ifnextchar should consume spaces&quot;, function() {
       |    ^ Unknown Test
  3409 |         expect&#x60;\def\x#1{\@ifnextchar x{yes}{no}}\x{}x\x{} x&#x60;
  3410 |             .toParseLike&#x60;yesxyesx&#x60;;
  3411 |     });</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  3411 |     });
  3412 |
&gt; 3413 |     it(&quot;\\@ifstar should consume star but nothing else&quot;, function() {
       |    ^ Unknown Test
  3414 |         expect&#x60;\@ifstar{yes}{no}*!&#x60;.toParseLike&#x60;yes!&#x60;;
  3415 |         expect&#x60;\@ifstar{yes}{no}?!&#x60;.toParseLike&#x60;no?!&#x60;;
  3416 |     });</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  3416 |     });
  3417 |
&gt; 3418 |     it(&quot;\\TextOrMath should work immediately&quot;, function() {
       |    ^ Unknown Test
  3419 |         expect&#x60;\TextOrMath{text}{math}&#x60;.toParseLike&#x60;math&#x60;;
  3420 |     });
  3421 |</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  3420 |     });
  3421 |
&gt; 3422 |     it(&quot;\\TextOrMath should work after other math&quot;, function() {
       |    ^ Unknown Test
  3423 |         expect&#x60;x+\TextOrMath{text}{math}&#x60;.toParseLike&#x60;x+math&#x60;;
  3424 |     });
  3425 |</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  3424 |     });
  3425 |
&gt; 3426 |     it(&quot;\\TextOrMath should work immediately after \\text&quot;, function() {
       |    ^ Unknown Test
  3427 |         expect&#x60;\text{\TextOrMath{text}{math}}&#x60;.toParseLike&#x60;\text{text}&#x60;;
  3428 |     });
  3429 |</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  3428 |     });
  3429 |
&gt; 3430 |     it(&quot;\\TextOrMath should work later after \\text&quot;, function() {
       |    ^ Unknown Test
  3431 |         expect&#x60;\text{hello \TextOrMath{text}{math}}&#x60;.toParseLike&#x60;\text{hello text}&#x60;;
  3432 |     });
  3433 |</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  3432 |     });
  3433 |
&gt; 3434 |     it(&quot;\\TextOrMath should work immediately after \\text ends&quot;, function() {
       |    ^ Unknown Test
  3435 |         expect&#x60;\text{\TextOrMath{text}{math}}\TextOrMath{text}{math}&#x60;
  3436 |             .toParseLike&#x60;\text{text}math&#x60;;
  3437 |     });</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  3437 |     });
  3438 |
&gt; 3439 |     it(&quot;\\TextOrMath should work immediately after $&quot;, function() {
       |    ^ Unknown Test
  3440 |         expect&#x60;\text{$\TextOrMath{text}{math}$}&#x60;.toParseLike&#x60;\text{$math$}&#x60;;
  3441 |     });
  3442 |</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  3441 |     });
  3442 |
&gt; 3443 |     it(&quot;\\TextOrMath should work later after $&quot;, function() {
       |    ^ Unknown Test
  3444 |         expect&#x60;\text{$x+\TextOrMath{text}{math}$}&#x60;.toParseLike&#x60;\text{$x+math$}&#x60;;
  3445 |     });
  3446 |</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  3445 |     });
  3446 |
&gt; 3447 |     it(&quot;\\TextOrMath should work immediately after $ ends&quot;, function() {
       |    ^ Unknown Test
  3448 |         expect&#x60;\text{$\TextOrMath{text}{math}$\TextOrMath{text}{math}}&#x60;
  3449 |             .toParseLike&#x60;\text{$math$text}&#x60;;
  3450 |     });</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  3450 |     });
  3451 |
&gt; 3452 |     it(&quot;\\TextOrMath should work in a macro&quot;, function() {
       |    ^ Unknown Test
  3453 |         expect&#x60;\mode\text{\mode$\mode$\mode}\mode&#x60;
  3454 |             .toParseLike(r&#x60;math\text{text$math$text}math&#x60;, new Settings({macros: {
  3455 |                 &quot;\\mode&quot;: &quot;\\TextOrMath{text}{math}&quot;,</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  3457 |     });
  3458 |
&gt; 3459 |     it(&quot;\\TextOrMath should work in a macro passed to \\text&quot;, function() {
       |    ^ Unknown Test
  3460 |         expect&#x60;\text\mode&#x60;.toParseLike(r&#x60;\text t&#x60;, new Settings({macros:
  3461 |             {&quot;\\mode&quot;: &quot;\\TextOrMath{t}{m}&quot;}}));
  3462 |     });</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  3489 |     });
  3490 |
&gt; 3491 |     it(&quot;should build Unicode private area characters&quot;, function() {
       |    ^ Unknown Test
  3492 |         expect&#x60;\gvertneqq\lvertneqq\ngeqq\ngeqslant\nleqq&#x60;.toBuild();
  3493 |         expect&#x60;\nleqslant\nshortmid\nshortparallel\varsubsetneq&#x60;.toBuild();
  3494 |         expect&#x60;\varsubsetneqq\varsupsetneq\varsupsetneqq&#x60;.toBuild();</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  3495 |     });
  3496 |
&gt; 3497 |     it(&quot;\\TextOrMath should work in a macro passed to \\text&quot;, function() {
       |    ^ Unknown Test
  3498 |         expect&#x60;\text\mode&#x60;.toParseLike(r&#x60;\text{text}&#x60;, new Settings({macros:
  3499 |             {&quot;\\mode&quot;: &quot;\\TextOrMath{text}{math}&quot;}}));
  3500 |     });</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  3500 |     });
  3501 |
&gt; 3502 |     it(&quot;\\gdef defines macros&quot;, function() {
       |    ^ Unknown Test
  3503 |         expect&#x60;\gdef\foo{x^2}\foo+\foo&#x60;.toParseLike&#x60;x^2+x^2&#x60;;
  3504 |         expect&#x60;\gdef\foo{hi}\foo+\text\foo&#x60;.toParseLike&#x60;hi+\text{hi}&#x60;;
  3505 |         expect&#x60;\gdef\foo#1{hi #1}\text{\foo{Alice}, \foo{Bob}}&#x60;</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  3518 |     });
  3519 |
&gt; 3520 |     it(&quot;\\gdef defines macros with delimited parameter&quot;, function() {
       |    ^ Unknown Test
  3521 |         expect&#x60;\gdef\foo|#1||{#1}\text{\foo| x y ||}&#x60;.toParseLike&#x60;\text{ x y }&#x60;;
  3522 |         expect&#x60;\gdef\foo#1|#2{#1+#2}\foo 1 2 |34&#x60;.toParseLike&#x60;12+34&#x60;;
  3523 |         expect&#x60;\gdef\foo#1#{#1}\foo1^{23}&#x60;.toParseLike&#x60;1^{23}&#x60;;</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  3527 |     });
  3528 |
&gt; 3529 |     it(&quot;\\xdef should expand definition&quot;, function() {
       |    ^ Unknown Test
  3530 |         expect&#x60;\def\foo{a}\xdef\bar{\foo}\def\foo{}\bar&#x60;.toParseLike&#x60;a&#x60;;
  3531 |         &#x2F;&#x2F; \def\noexpand\foo{} expands into \def\foo{}
  3532 |         expect&#x60;\def\foo{a}\xdef\bar{\def\noexpand\foo{}}\foo\bar\foo&#x60;.toParseLike&#x60;a&#x60;;</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  3537 |     });
  3538 |
&gt; 3539 |     it(&quot;\\def should be handled in Parser&quot;, () &#x3D;&gt; {
       |    ^ Unknown Test
  3540 |         expect&#x60;\gdef\foo{1}&#x60;.toParse(new Settings({maxExpand: 0}));
  3541 |         expect&#x60;2^\def\foo{1}2&#x60;.not.toParse();
  3542 |     });</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  3542 |     });
  3543 |
&gt; 3544 |     it(&quot;\\def works locally&quot;, () &#x3D;&gt; {
       |    ^ Unknown Test
  3545 |         expect&#x60;\def\x{1}\x{\def\x{2}\x{\def\x{3}\x}\x}\x&#x60;
  3546 |             .toParseLike&#x60;1{2{3}2}1&#x60;;
  3547 |         expect&#x60;\def\x{1}\x\def\x{2}\x{\def\x{3}\x\def\x{4}\x}\x&#x60;</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  3549 |     });
  3550 |
&gt; 3551 |     it(&quot;\\gdef overrides at all levels&quot;, () &#x3D;&gt; {
       |    ^ Unknown Test
  3552 |         expect&#x60;\def\x{1}\x{\def\x{2}\x{\gdef\x{3}\x}\x}\x&#x60;
  3553 |             .toParseLike&#x60;1{2{3}3}3&#x60;;
  3554 |         expect&#x60;\def\x{1}\x{\def\x{2}\x{\global\def\x{3}\x}\x}\x&#x60;</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  3558 |     });
  3559 |
&gt; 3560 |     it(&quot;\\global needs to followed by macro prefixes, \\def or \\edef&quot;, () &#x3D;&gt; {
       |    ^ Unknown Test
  3561 |         expect&#x60;\global\def\foo{}\foo&#x60;.toParseLike&#x60;&#x60;;
  3562 |         expect&#x60;\global\edef\foo{}\foo&#x60;.toParseLike&#x60;&#x60;;
  3563 |         expect&#x60;\def\DEF{\def}\global\DEF\foo{}\foo&#x60;.toParseLike&#x60;&#x60;;</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  3568 |     });
  3569 |
&gt; 3570 |     it(&quot;\\long needs to followed by macro prefixes, \\def or \\edef&quot;, () &#x3D;&gt; {
       |    ^ Unknown Test
  3571 |         expect&#x60;\long\def\foo{}\foo&#x60;.toParseLike&#x60;&#x60;;
  3572 |         expect&#x60;\long\edef\foo{}\foo&#x60;.toParseLike&#x60;&#x60;;
  3573 |         expect&#x60;\long\global\def\foo{}\foo&#x60;.toParseLike&#x60;&#x60;;</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  3575 |     });
  3576 |
&gt; 3577 |     it(&quot;Macro arguments do not generate groups&quot;, () &#x3D;&gt; {
       |    ^ Unknown Test
  3578 |         expect&#x60;\def\x{1}\x\def\foo#1{#1}\foo{\x\def\x{2}\x}\x&#x60;
  3579 |             .toParseLike&#x60;1122&#x60;;
  3580 |     });</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  3580 |     });
  3581 |
&gt; 3582 |     it(&quot;\\textbf arguments do generate groups&quot;, () &#x3D;&gt; {
       |    ^ Unknown Test
  3583 |         expect&#x60;\def\x{1}\x\textbf{\x\def\x{2}\x}\x&#x60;.toParseLike&#x60;1\textbf{12}1&#x60;;
  3584 |     });
  3585 |</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  3584 |     });
  3585 |
&gt; 3586 |     it(&quot;\\sqrt optional arguments generate groups&quot;, () &#x3D;&gt; {
       |    ^ Unknown Test
  3587 |         expect&#x60;\def\x{1}\def\y{1}\x\y\sqrt[\def\x{2}\x]{\def\y{2}\y}\x\y&#x60;
  3588 |             .toParseLike&#x60;11\sqrt[2]{2}11&#x60;;
  3589 |     });</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  3589 |     });
  3590 |
&gt; 3591 |     it(&quot;array cells generate groups&quot;, () &#x3D;&gt; {
       |    ^ Unknown Test
  3592 |         expect&#x60;\def\x{1}\begin{matrix}\x&amp;\def\x{2}\x&amp;\x\end{matrix}\x&#x60;
  3593 |             .toParseLike&#x60;\begin{matrix}1&amp;2&amp;1\end{matrix}1&#x60;;
  3594 |         expect&#x60;\def\x{1}\begin{matrix}\def\x{2}\x&amp;\x\end{matrix}\x&#x60;</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  3620 |     });
  3621 |
&gt; 3622 |     it(&quot;\\let copies the definition&quot;, () &#x3D;&gt; {
       |    ^ Unknown Test
  3623 |         expect&#x60;\let\foo&#x3D;\frac\def\frac{}\foo12&#x60;.toParseLike&#x60;\frac12&#x60;;
  3624 |         expect&#x60;\def\foo{1}\let\bar\foo\def\foo{2}\bar&#x60;.toParseLike&#x60;1&#x60;;
  3625 |         expect&#x60;\let\foo&#x3D;\kern\edef\bar{\foo1em}\let\kern&#x3D;\relax\bar&#x60;.toParseLike&#x60;\kern1em&#x60;;</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  3640 |     });
  3641 |
&gt; 3642 |     it(&quot;\\futurelet should parse correctly&quot;, () &#x3D;&gt; {
       |    ^ Unknown Test
  3643 |         expect&#x60;\futurelet\foo\frac1{2+\foo}&#x60;.toParseLike&#x60;\frac1{2+1}&#x60;;
  3644 |     });
  3645 |</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  3644 |     });
  3645 |
&gt; 3646 |     it(&quot;macros argument can simulate \\let&quot;, () &#x3D;&gt; {
       |    ^ Unknown Test
  3647 |         expect&#x60;\int&#x60;.toParseLike(&quot;\\int\\limits&quot;, {macros: {
  3648 |             &quot;\\Oldint&quot;: {
  3649 |                 tokens: [{text: &quot;\\int&quot;, noexpand: true}],</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  3671 |     });
  3672 |
&gt; 3673 |     it(&quot;\\newcommand defines new macros&quot;, () &#x3D;&gt; {
       |    ^ Unknown Test
  3674 |         expect&#x60;\newcommand\foo{x^2}\foo+\foo&#x60;.toParseLike&#x60;x^2+x^2&#x60;;
  3675 |         expect&#x60;\newcommand{\foo}{x^2}\foo+\foo&#x60;.toParseLike&#x60;x^2+x^2&#x60;;
  3676 |         &#x2F;&#x2F; Function detection</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  3686 |     });
  3687 |
&gt; 3688 |     it(&quot;\\renewcommand redefines macros&quot;, () &#x3D;&gt; {
       |    ^ Unknown Test
  3689 |         expect&#x60;\renewcommand\foo{x^2}\foo+\foo&#x60;.not.toParse();
  3690 |         expect&#x60;\renewcommand{\foo}{x^2}\foo+\foo&#x60;.not.toParse();
  3691 |         expect&#x60;\renewcommand\bar{x^2}\bar+\bar&#x60;.toParseLike&#x60;x^2+x^2&#x60;;</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  3694 |     });
  3695 |
&gt; 3696 |     it(&quot;\\providecommand defines but does not redefine macros&quot;, () &#x3D;&gt; {
       |    ^ Unknown Test
  3697 |         expect&#x60;\providecommand\foo{x^2}\foo+\foo&#x60;.toParseLike&#x60;x^2+x^2&#x60;;
  3698 |         expect&#x60;\providecommand{\foo}{x^2}\foo+\foo&#x60;.toParseLike&#x60;x^2+x^2&#x60;;
  3699 |         expect&#x60;\newcommand{\foo}{1}\foo\providecommand{\foo}{2}\foo&#x60;</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  3705 |     });
  3706 |
&gt; 3707 |     it(&quot;\\newcommand is local&quot;, () &#x3D;&gt; {
       |    ^ Unknown Test
  3708 |         expect&#x60;\newcommand\foo{1}\foo{\renewcommand\foo{2}\foo}\foo&#x60;
  3709 |             .toParseLike&#x60;1{2}1&#x60;;
  3710 |     });</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  3710 |     });
  3711 |
&gt; 3712 |     it(&quot;\\newcommand accepts number of arguments&quot;, () &#x3D;&gt; {
       |    ^ Unknown Test
  3713 |         expect&#x60;\newcommand\foo[1]{#1^2}\foo x+\foo{y}&#x60;.toParseLike&#x60;x^2+y^2&#x60;;
  3714 |         expect&#x60;\newcommand\foo[10]{#1^2}\foo 0123456789&#x60;.toParseLike&#x60;0^2&#x60;;
  3715 |         expect&#x60;\newcommand\foo[x]{}&#x60;.not.toParse();</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  3719 |     &#x2F;&#x2F; This may change in the future, if we support the extra features of
  3720 |     &#x2F;&#x2F; \hspace.
&gt; 3721 |     it(&quot;should treat \\hspace, \\hskip like \\kern&quot;, function() {
       |    ^ Unknown Test
  3722 |         expect&#x60;\hspace{1em}&#x60;.toParseLike&#x60;\kern1em&#x60;;
  3723 |         expect&#x60;\hskip{1em}&#x60;.toParseLike&#x60;\kern1em&#x60;;
  3724 |     });</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  3724 |     });
  3725 |
&gt; 3726 |     it(&quot;should expand \\limsup as expected&quot;, () &#x3D;&gt; {
       |    ^ Unknown Test
  3727 |         expect&#x60;\limsup&#x60;.toParseLike&#x60;\operatorname*{lim\,sup}&#x60;;
  3728 |     });
  3729 |</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  3728 |     });
  3729 |
&gt; 3730 |     it(&quot;should expand \\liminf as expected&quot;, () &#x3D;&gt; {
       |    ^ Unknown Test
  3731 |         expect&#x60;\liminf&#x60;.toParseLike&#x60;\operatorname*{lim\,inf}&#x60;;
  3732 |     });
  3733 |</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  3732 |     });
  3733 |
&gt; 3734 |     it(&quot;should expand AMS log-like symbols as expected&quot;, () &#x3D;&gt; {
       |    ^ Unknown Test
  3735 |         expect&#x60;\injlim&#x60;.toParseLike&#x60;\operatorname*{inj\,lim}&#x60;;
  3736 |         expect&#x60;\projlim&#x60;.toParseLike&#x60;\operatorname*{proj\,lim}&#x60;;
  3737 |         expect&#x60;\varlimsup&#x60;.toParseLike&#x60;\operatorname*{\overline{lim}}&#x60;;</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  3742 |     });
  3743 |
&gt; 3744 |     it(&quot;should expand \\plim as expected&quot;, () &#x3D;&gt; {
       |    ^ Unknown Test
  3745 |         expect&#x60;\plim&#x60;.toParseLike&#x60;\mathop{\operatorname{plim}}\limits&#x60;;
  3746 |     });
  3747 |</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  3746 |     });
  3747 |
&gt; 3748 |     it(&quot;should expand \\argmin as expected&quot;, () &#x3D;&gt; {
       |    ^ Unknown Test
  3749 |         expect&#x60;\argmin&#x60;.toParseLike&#x60;\operatorname*{arg\,min}&#x60;;
  3750 |     });
  3751 |</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  3750 |     });
  3751 |
&gt; 3752 |     it(&quot;should expand \\argmax as expected&quot;, () &#x3D;&gt; {
       |    ^ Unknown Test
  3753 |         expect&#x60;\argmax&#x60;.toParseLike&#x60;\operatorname*{arg\,max}&#x60;;
  3754 |     });
  3755 |</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  3754 |     });
  3755 |
&gt; 3756 |     it(&quot;should expand \\bra as expected&quot;, () &#x3D;&gt; {
       |    ^ Unknown Test
  3757 |         expect&#x60;\bra{\phi}&#x60;.toParseLike&#x60;\mathinner{\langle{\phi}|}&#x60;;
  3758 |     });
  3759 |</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  3758 |     });
  3759 |
&gt; 3760 |     it(&quot;should expand \\ket as expected&quot;, () &#x3D;&gt; {
       |    ^ Unknown Test
  3761 |         expect&#x60;\ket{\psi}&#x60;.toParseLike&#x60;\mathinner{|{\psi}\rangle}&#x60;;
  3762 |     });
  3763 |</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  3762 |     });
  3763 |
&gt; 3764 |     it(&quot;should expand \\braket as expected&quot;, () &#x3D;&gt; {
       |    ^ Unknown Test
  3765 |         expect&#x60;\braket{\phi|\psi}&#x60;.toParseLike&#x60;\mathinner{\langle{\phi|\psi}\rangle}&#x60;;
  3766 |     });
  3767 |</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  3766 |     });
  3767 |
&gt; 3768 |     it(&quot;should expand \\Bra as expected&quot;, () &#x3D;&gt; {
       |    ^ Unknown Test
  3769 |         expect&#x60;\Bra{\phi}&#x60;.toParseLike&#x60;\left\langle\phi\right|&#x60;;
  3770 |     });
  3771 |</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  3770 |     });
  3771 |
&gt; 3772 |     it(&quot;should expand \\Ket as expected&quot;, () &#x3D;&gt; {
       |    ^ Unknown Test
  3773 |         expect&#x60;\Ket{\psi}&#x60;.toParseLike&#x60;\left|\psi\right\rangle&#x60;;
  3774 |     });
  3775 |</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  3774 |     });
  3775 |
&gt; 3776 |     it(&quot;should expand \\Braket as expected&quot;, () &#x3D;&gt; {
       |    ^ Unknown Test
  3777 |         expect&#x60;\Braket{ ϕ | \frac{∂^2}{∂ t^2} | ψ }&#x60;.toParseLike&#x60;\left\langle ϕ\,\middle\vert\,\frac{∂^2}{∂ t^2}\,\middle\vert\, ψ\right\rangle&#x60;;
  3778 |     });
  3779 |</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  3778 |     });
  3779 |
&gt; 3780 |     it(&quot;should expand \\set as expected&quot;, () &#x3D;&gt; {
       |    ^ Unknown Test
  3781 |         expect&#x60;\set{x|x&lt;5|S|}&#x60;.toParseLike&#x60;\{\,x\mid x&lt;5|S|\,\}&#x60;;
  3782 |         &#x2F;&#x2F; \set doesn&#39;t support special || or \| handling
  3783 |         expect&#x60;\set{x||x&lt;5|S|}&#x60;.toParseLike&#x60;\{\,x\mid |x&lt;5|S|\,\}&#x60;;</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  3785 |     });
  3786 |
&gt; 3787 |     it(&quot;should expand \\Set as expected&quot;, () &#x3D;&gt; {
       |    ^ Unknown Test
  3788 |         expect&#x60;\Set{ x | x&lt;\frac 1 2 |S| }&#x60;
  3789 |         .toParseLike&#x60;\left\{\: x\;\middle\vert\; x&lt;\frac 1 2 |S| \:\right\}&#x60;;
  3790 |         expect&#x60;\Set{ x || x&lt;\frac 1 2 |S| }&#x60;</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  3798 |     const displayMode &#x3D; new Settings({displayMode: true});
  3799 |
&gt; 3800 |     it(&quot;should fail outside display mode&quot;, () &#x3D;&gt; {
       |    ^ Unknown Test
  3801 |         expect&#x60;\tag{hi}x+y&#x60;.not.toParse();
  3802 |     });
  3803 |</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  3802 |     });
  3803 |
&gt; 3804 |     it(&quot;should fail with multiple tags&quot;, () &#x3D;&gt; {
       |    ^ Unknown Test
  3805 |         expect&#x60;\tag{1}\tag{2}x+y&#x60;.not.toParse(displayMode);
  3806 |     });
  3807 |</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  3806 |     });
  3807 |
&gt; 3808 |     it(&quot;should fail with multiple tags in one row&quot;, () &#x3D;&gt; {
       |    ^ Unknown Test
  3809 |         expect&#x60;\begin{align}\tag{1}x+y\tag{2}\end{align}&#x60;.not.toParse(displayMode);
  3810 |     });
  3811 |</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  3810 |     });
  3811 |
&gt; 3812 |     it(&quot;should work with one tag per row&quot;, () &#x3D;&gt; {
       |    ^ Unknown Test
  3813 |         expect&#x60;\begin{align}\tag{1}x\\&amp;+y\tag{2}\end{align}&#x60;.toParse(displayMode);
  3814 |     });
  3815 |</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  3814 |     });
  3815 |
&gt; 3816 |     it(&quot;should work with \\nonumber&#x2F;\\notag&quot;, () &#x3D;&gt; {
       |    ^ Unknown Test
  3817 |         expect&#x60;\begin{align}\tag{1}\nonumber x\\&amp;+y\notag\end{align}&#x60;
  3818 |         .toParseLike(r&#x60;\begin{align}\tag{1}x\\&amp;+y\nonumber\end{align}&#x60;, displayMode);
  3819 |     });</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  3819 |     });
  3820 |
&gt; 3821 |     it(&quot;should build&quot;, () &#x3D;&gt; {
       |    ^ Unknown Test
  3822 |         expect&#x60;\tag{hi}x+y&#x60;.toBuild(displayMode);
  3823 |     });
  3824 |</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  3823 |     });
  3824 |
&gt; 3825 |     it(&quot;should ignore location of \\tag&quot;, () &#x3D;&gt; {
       |    ^ Unknown Test
  3826 |         expect&#x60;\tag{hi}x+y&#x60;.toParseLike(r&#x60;x+y\tag{hi}&#x60;, displayMode);
  3827 |     });
  3828 |</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  3827 |     });
  3828 |
&gt; 3829 |     it(&quot;should handle \\tag* like \\tag&quot;, () &#x3D;&gt; {
       |    ^ Unknown Test
  3830 |         expect&#x60;\tag{hi}x+y&#x60;.toParseLike(r&#x60;\tag*{({hi})}x+y&#x60;, displayMode);
  3831 |     });
  3832 | });</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  3856 |
  3857 | describe(&quot;\\@binrel automatic bin&#x2F;rel&#x2F;ord&quot;, () &#x3D;&gt; {
&gt; 3858 |     it(&quot;should generate proper class&quot;, () &#x3D;&gt; {
       |    ^ Unknown Test
  3859 |         expect&#x60;L\@binrel+xR&#x60;.toParseLike&#x60;L\mathbin xR&#x60;;
  3860 |         expect&#x60;L\@binrel&#x3D;xR&#x60;.toParseLike&#x60;L\mathrel xR&#x60;;
  3861 |         expect&#x60;L\@binrel xxR&#x60;.toParseLike&#x60;L\mathord xR&#x60;;</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  3865 |     });
  3866 |
&gt; 3867 |     it(&quot;should base on just first character in group&quot;, () &#x3D;&gt; {
       |    ^ Unknown Test
  3868 |         expect&#x60;L\@binrel{+x}xR&#x60;.toParseLike&#x60;L\mathbin xR&#x60;;
  3869 |         expect&#x60;L\@binrel{&#x3D;x}xR&#x60;.toParseLike&#x60;L\mathrel xR&#x60;;
  3870 |         expect&#x60;L\@binrel{xx}xR&#x60;.toParseLike&#x60;L\mathord xR&#x60;;</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  3885 |
  3886 | describe(&quot;Unicode accents&quot;, function() {
&gt; 3887 |     it(&quot;should parse Latin-1 letters in math mode&quot;, function() {
       |    ^ Unknown Test
  3888 |         &#x2F;&#x2F; TODO(edemaine): Unsupported Latin-1 letters in math: ÇÐÞçðþ
  3889 |         expect&#x60;ÀÁÂÃÄÅÈÉÊËÌÍÎÏÑÒÓÔÕÖÙÚÛÜÝàáâãäåèéêëìíîïñòóôõöùúûüýÿ&#x60;
  3890 |         .toParseLike(</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  3905 |     });
  3906 |
&gt; 3907 |     it(&quot;should parse Latin-1 letters in text mode&quot;, function() {
       |    ^ Unknown Test
  3908 |         &#x2F;&#x2F; TODO(edemaine): Unsupported Latin-1 letters in text: ÇÐÞçðþ
  3909 |         expect&#x60;\text{ÀÁÂÃÄÅÈÉÊËÌÍÎÏÑÒÓÔÕÖÙÚÛÜÝàáâãäåèéêëìíîïñòóôõöùúûüýÿ}&#x60;
  3910 |         .toParseLike(</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  3925 |     });
  3926 |
&gt; 3927 |     it(&quot;should support \\aa in text mode&quot;, function() {
       |    ^ Unknown Test
  3928 |         expect&#x60;\text{\aa\AA}&#x60;.toParseLike(r&#x60;\text{\r a\r A}&#x60;, strictSettings);
  3929 |         expect&#x60;\aa&#x60;.not.toParse(strictSettings);
  3930 |         expect&#x60;\Aa&#x60;.not.toParse(strictSettings);</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  3936 |     });
  3937 |
&gt; 3938 |     it(&quot;should parse multi-accented characters&quot;, function() {
       |    ^ Unknown Test
  3939 |         expect&#x60;ấā́ắ\text{ấā́ắ}&#x60;.toParse(nonstrictSettings);
  3940 |         &#x2F;&#x2F; Doesn&#39;t parse quite the same as
  3941 |         &#x2F;&#x2F; &quot;\\text{\\&#39;{\\^a}\\&#39;{\\&#x3D;a}\\&#39;{\\u a}}&quot; because of the ordgroups.</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  3942 |     });
  3943 |
&gt; 3944 |     it(&quot;should parse accented i&#39;s and j&#39;s&quot;, function() {
       |    ^ Unknown Test
  3945 |         expect&#x60;íȷ́&#x60;.toParseLike(r&#x60;\acute ı\acute ȷ&#x60;, nonstrictSettings);
  3946 |         expect&#x60;ấā́ắ\text{ấā́ắ}&#x60;.toParse(nonstrictSettings);
  3947 |     });</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  3949 |
  3950 | describe(&quot;Unicode&quot;, function() {
&gt; 3951 |     it(&quot;should parse negated relations&quot;, function() {
       |    ^ Unknown Test
  3952 |         expect&#x60;∉∤∦≁≆≠≨≩≮≯≰≱⊀⊁⊈⊉⊊⊋⊬⊭⊮⊯⋠⋡⋦⋧⋨⋩⋬⋭⪇⪈⪉⪊⪵⪶⪹⪺⫋⫌&#x60;.toParse(strictSettings);
  3953 |     });
  3954 |</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  3953 |     });
  3954 |
&gt; 3955 |     it(&quot;should build relations&quot;, function() {
       |    ^ Unknown Test
  3956 |         expect&#x60;∈∋∝∼∽≂≃≅≈≊≍≎≏≐≑≒≓≖≗≜≡≤≥≦≧≪≫≬≳≷≺≻≼≽≾≿∴∵∣≔≕⩴⋘⋙⟂⊨∌&#x60;.toBuild(strictSettings);
  3957 |     });
  3958 |</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  3957 |     });
  3958 |
&gt; 3959 |     it(&quot;should parse relations&quot;, function() {
       |    ^ Unknown Test
  3960 |         &#x2F;&#x2F; These characters are not in the KaTeX fonts. So they build with an error message.
  3961 |         expect&#x60;⊶⊷&#x60;.toParse();
  3962 |     });</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  3962 |     });
  3963 |
&gt; 3964 |     it(&quot;should build big operators&quot;, function() {
       |    ^ Unknown Test
  3965 |         expect&#x60;∏∐∑∫∬∭∮⋀⋁⋂⋃⨀⨁⨂⨄⨆&#x60;.toBuild(strictSettings);
  3966 |     });
  3967 |</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  3966 |     });
  3967 |
&gt; 3968 |     it(&quot;should build more relations&quot;, function() {
       |    ^ Unknown Test
  3969 |         expect&#x60;⊂⊃⊆⊇⊏⊐⊑⊒⊢⊣⊩⊪⊸⋈⋍⋐⋑⋔⋛⋞⋟⌢⌣⩾⪆⪌⪕⪖⪯⪰⪷⪸⫅⫆≘≙≚≛≝≞≟≲⩽⪅≶⋚⪋&#x60;.toBuild(strictSettings);
  3970 |     });
  3971 |</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  3980 |     });
  3981 |
&gt; 3982 |     it(&quot;should build arrows&quot;, function() {
       |    ^ Unknown Test
  3983 |         expect&#x60;←↑→↓↔↕↖↗↘↙↚↛↞↠↢↣↦↩↪↫↬↭↮↰↱↶↷↼↽↾↾↿⇀⇁⇂⇃⇄⇆⇇⇈⇉&#x60;.toBuild(strictSettings);
  3984 |     });
  3985 |</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  3984 |     });
  3985 |
&gt; 3986 |     it(&quot;should build more arrows&quot;, function() {
       |    ^ Unknown Test
  3987 |         expect&#x60;⇊⇋⇌⇍⇎⇏⇐⇑⇒⇓⇔⇕⇚⇛⇝⟵⟶⟷⟸⟹⟺⟼&#x60;.toBuild(strictSettings);
  3988 |     });
  3989 |</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  4070 |
  4071 | describe(&quot;The maxExpand setting&quot;, () &#x3D;&gt; {
&gt; 4072 |     it(&quot;should prevent expansion&quot;, () &#x3D;&gt; {
       |    ^ Unknown Test
  4073 |         expect&#x60;\gdef\foo{1}\foo&#x60;.toParse();
  4074 |         expect&#x60;\gdef\foo{1}\foo&#x60;.toParse(new Settings({maxExpand: 1}));
  4075 |         expect&#x60;\gdef\foo{1}\foo&#x60;.not.toParse(new Settings({maxExpand: 0}));</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  4076 |     });
  4077 |
&gt; 4078 |     it(&quot;should prevent infinite loops&quot;, () &#x3D;&gt; {
       |    ^ Unknown Test
  4079 |         expect&#x60;\gdef\foo{\foo}\foo&#x60;.not.toParse(
  4080 |             new Settings({maxExpand: 10}));
  4081 |     });</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  4081 |     });
  4082 |
&gt; 4083 |     it(&quot;should prevent exponential blowup via \\edef&quot;, () &#x3D;&gt; {
       |    ^ Unknown Test
  4084 |         expect&#x60;\edef0{x}\edef0{00}\edef0{00}\edef0{00}\edef0{00}&#x60;.not.toParse(
  4085 |             new Settings({maxExpand: 10}));
  4086 |     });</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  4132 |
  4133 | describe(&quot;Newlines via \\\\ and \\newline&quot;, function() {
&gt; 4134 |     it(&quot;should build \\\\ without the optional argument and \\newline the same&quot;, () &#x3D;&gt; {
       |    ^ Unknown Test
  4135 |         expect&#x60;hello \\ world&#x60;.toBuildLike&#x60;hello \newline world&#x60;;
  4136 |     });
  4137 |</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  4136 |     });
  4137 |
&gt; 4138 |     it(&quot;should not allow \\newline to scan for an optional size argument&quot;, () &#x3D;&gt; {
       |    ^ Unknown Test
  4139 |         expect&#x60;hello \newline[w]orld&#x60;.toBuild();
  4140 |     });
  4141 |</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  4140 |     });
  4141 |
&gt; 4142 |     it(&quot;should not allow \\cr at top level&quot;, () &#x3D;&gt; {
       |    ^ Unknown Test
  4143 |         expect&#x60;hello \cr world&#x60;.not.toBuild();
  4144 |     });
  4145 |</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  4155 |
  4156 | describe(&quot;Symbols&quot;, function() {
&gt; 4157 |     it(&quot;should parse \\text{\\i\\j}&quot;, () &#x3D;&gt; {
       |    ^ Unknown Test
  4158 |         expect&#x60;\text{\i\j}&#x60;.toBuild(strictSettings);
  4159 |     });
  4160 |</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  4159 |     });
  4160 |
&gt; 4161 |     it(&quot;should parse spacing functions in math or text mode&quot;, () &#x3D;&gt; {
       |    ^ Unknown Test
  4162 |         expect&#x60;A\;B\,C\nobreakspace \text{A\;B\,C\nobreakspace}&#x60;.toBuild(strictSettings);
  4163 |     });
  4164 |</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  4163 |     });
  4164 |
&gt; 4165 |     it(&quot;should build \\minuso&quot;, () &#x3D;&gt; {
       |    ^ Unknown Test
  4166 |         expect&#x60;\\minuso&#x60;.toBuild(strictSettings);
  4167 |     });
  4168 |</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  4167 |     });
  4168 |
&gt; 4169 |     it(&quot;should render ligature commands like their unicode characters&quot;, () &#x3D;&gt; {
       |    ^ Unknown Test
  4170 |         expect&#x60;\text{\ae\AE\oe\OE\o\O\ss}&#x60;.toBuildLike(r&#x60;\text{æÆœŒøØß}&#x60;, strictSettings);
  4171 |     });
  4172 | });</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  4173 |
  4174 | describe(&quot;strict setting&quot;, function() {
&gt; 4175 |     it(&quot;should allow unicode text when not strict&quot;, () &#x3D;&gt; {
       |    ^ Unknown Test
  4176 |         expect&#x60;é&#x60;.toParse(new Settings(nonstrictSettings));
  4177 |         expect&#x60;試&#x60;.toParse(new Settings(nonstrictSettings));
  4178 |         expect&#x60;é&#x60;.toParse(new Settings({strict: &quot;ignore&quot;}));</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  4184 |     });
  4185 |
&gt; 4186 |     it(&quot;should forbid unicode text when strict&quot;, () &#x3D;&gt; {
       |    ^ Unknown Test
  4187 |         expect&#x60;é&#x60;.not.toParse(new Settings({strict: true}));
  4188 |         expect&#x60;試&#x60;.not.toParse(new Settings({strict: true}));
  4189 |         expect&#x60;é&#x60;.not.toParse(new Settings({strict: &quot;error&quot;}));</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  4195 |     });
  4196 |
&gt; 4197 |     it(&quot;should warn about unicode text when default&quot;, () &#x3D;&gt; {
       |    ^ Unknown Test
  4198 |         expect&#x60;é&#x60;.toWarn(new Settings());
  4199 |         expect&#x60;試&#x60;.toWarn(new Settings());
  4200 |     });</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  4200 |     });
  4201 |
&gt; 4202 |     it(&quot;should always allow unicode text in text mode&quot;, () &#x3D;&gt; {
       |    ^ Unknown Test
  4203 |         expect&#x60;\text{é試}&#x60;.toParse(nonstrictSettings);
  4204 |         expect&#x60;\text{é試}&#x60;.toParse(strictSettings);
  4205 |         expect&#x60;\text{é試}&#x60;.toParse();</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  4206 |     });
  4207 |
&gt; 4208 |     it(&quot;should warn about top-level \\newline in display mode&quot;, () &#x3D;&gt; {
       |    ^ Unknown Test
  4209 |         expect&#x60;x\\y&#x60;.toWarn(new Settings({displayMode: true}));
  4210 |         expect&#x60;x\\y&#x60;.toParse(new Settings({displayMode: false}));
  4211 |     });</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  4255 |         }).toThrow(errorMessage);
  4256 |     });
&gt; 4257 |     it(&quot;should add font metrics to metrics map and render successfully&quot;, () &#x3D;&gt; {
       |    ^ Unknown Test
  4258 |         const mockMetrics &#x3D; {};
  4259 |         &#x2F;&#x2F; mock font metrics for the symbols that we added previously
  4260 |         for (let number &#x3D; 0; number &lt;&#x3D; 9; number++) {</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  4291 |
  4292 | describe(&quot;\\relax&quot;, () &#x3D;&gt; {
&gt; 4293 |     it(&quot;should stop the expansion&quot;, () &#x3D;&gt; {
       |    ^ Unknown Test
  4294 |         expect&#x60;\kern2\relax em&#x60;.not.toParse();
  4295 |     });
  4296 | });</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  4297 |
  4298 | describe(&quot;\\emph&quot;, () &#x3D;&gt; {
&gt; 4299 |     it(&quot;should toggle italics&quot;, () &#x3D;&gt; {
       |    ^ Unknown Test
  4300 |         expect&#x60;\emph{foo \emph{bar}}&#x60;.toBuildLike&#x60;\textit{foo \textup{bar}}&#x60;;
  4301 |     });
  4302 |</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  4301 |     });
  4302 |
&gt; 4303 |     it(&quot;should toggle italics within text&quot;, () &#x3D;&gt; {
       |    ^ Unknown Test
  4304 |         expect&#x60;\text{\emph{foo \emph{bar}}}&#x60;.toBuildLike&#x60;\text{\textit{foo \textup{bar}}}&#x60;;
  4305 |     });
  4306 |</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  4305 |     });
  4306 |
&gt; 4307 |     it(&quot;should toggle italics within textup&quot;, () &#x3D;&gt; {
       |    ^ Unknown Test
  4308 |         expect&#x60;\textup{\emph{foo \emph{bar}}}&#x60;.toBuildLike&#x60;\textup{\textit{foo \textup{bar}}}&#x60;;
  4309 |     });
  4310 |</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  4309 |     });
  4310 |
&gt; 4311 |     it(&quot;should toggle italics within textit&quot;, () &#x3D;&gt; {
       |    ^ Unknown Test
  4312 |         expect&#x60;\textit{\emph{foo \emph{bar}}}&#x60;.toBuildLike&#x60;\textit{\textup{foo \textit{bar}}}&#x60;;
  4313 |     });
  4314 | });</code></pre><br>
                      </td>
                    </tr>
                  </tbody>
                </table>
              </td>
            </tr>
            <tr>
              <td>
                <a class="toggle-link" href="javascript:;" onclick="toggleDetails(this)">+ &#x2F;home&#x2F;gabriel&#x2F;Desktop&#x2F;research&#x2F;projects&#x2F;katex&#x2F;test&#x2F;errors-spec.js</a>
              </td>
              <td class="has-text-right">50</td>
            </tr>
            <tr class="details-row hidden">
              <td colspan="2">
                <div class="columns is-multiline is-centered">
                  <div class="column is-one-quarter">
                    <div class="box px-4 py-4">
                      <div class="heading">Physical SLOC</div>
                      <div class="title has-text-weight-light is-size-4">332</div>
                    </div>
                  </div>
                  <div class="column is-one-quarter">
                    <div class="box px-4 py-4">
                      <div class="heading">Logical SLOC</div>
                      <div class="title has-text-weight-light is-size-4">262</div>
                    </div>
                  </div>
                  <div class="column is-one-quarter">
                    <div class="box px-4 py-4">
                      <div class="heading">Cyclomatic</div>
                      <div class="title has-text-weight-light is-size-4">77</div>
                    </div>
                  </div>
                  <div class="column is-one-quarter">
                    <div class="box px-4 py-4">
                      <div class="heading">Cyclomatic Density</div>
                      <div class="title has-text-weight-light is-size-4">29.389</div>
                    </div>
                  </div>
                  <div class="column is-one-quarter">
                    <div class="box px-4 py-4">
                      <div class="heading">Halstead Bugs</div>
                      <div class="title has-text-weight-light is-size-4">1.961</div>
                    </div>
                  </div>
                  <div class="column is-one-quarter">
                    <div class="box px-4 py-4">
                      <div class="heading">Halstead Difficulty</div>
                      <div class="title has-text-weight-light is-size-4">5.692</div>
                    </div>
                  </div>
                  <div class="column is-one-quarter">
                    <div class="box px-4 py-4">
                      <div class="heading">Halstead effort</div>
                      <div class="title has-text-weight-light is-size-4">33481.955</div>
                    </div>
                  </div>
                  <div class="column is-one-quarter">
                    <div class="box px-4 py-4">
                      <div class="heading">Halstead Length</div>
                      <div class="title has-text-weight-light is-size-4">756</div>
                    </div>
                  </div>
                  <div class="column is-one-quarter">
                    <div class="box px-4 py-4">
                      <div class="heading">Halstead Time</div>
                      <div class="title has-text-weight-light is-size-4">1860.109</div>
                    </div>
                  </div>
                  <div class="column is-one-quarter">
                    <div class="box px-4 py-4">
                      <div class="heading">Halstead Vocabulary</div>
                      <div class="title has-text-weight-light is-size-4">220</div>
                    </div>
                  </div>
                  <div class="column is-one-quarter">
                    <div class="box px-4 py-4">
                      <div class="heading">Halstead Volume</div>
                      <div class="title has-text-weight-light is-size-4">5882.708</div>
                    </div>
                  </div>
                  <div class="column is-one-quarter">
                    <div class="box px-4 py-4">
                      <div class="heading">Maintainability</div>
                      <div class="title has-text-weight-light is-size-4">130.386</div>
                    </div>
                  </div>
                </div>
                <hr>
                <table class="table is-fullwidth" id="table-of-smell">
                  <thead>
                    <tr>
                      <td>Redundant Assertion</td>
                    </tr>
                  </thead>
                  <tbody>
                    <tr>
                      <td>
                        <pre><code>  130 |         });
  131 |         it(&quot;complains about mismatched \\verb with end of line&quot;, function() {
&gt; 132 |             expect(&quot;\\verb|hello\nworld|&quot;).toFailWithParseError(
      |            ^ Redundant Assertion
  133 |                 &quot;\\verb ended by end of line instead of matching delimiter&quot;);
  134 |         });
  135 |     });</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  289 |     describe(&quot;#_innerLex&quot;, function() {
  290 |         it(&quot;rejects lone surrogate char&quot;, function() {
&gt; 291 |             expect(&quot;\udcba &quot;).toFailWithParseError(
      |            ^ Redundant Assertion
  292 |                    &quot;Unexpected character: &#39;\udcba&#39; at position 1:&quot; +
  293 |                     &quot; \udcba\u0332 &quot;);
  294 |         });</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  294 |         });
  295 |         it(&quot;rejects lone backslash at end of input&quot;, function() {
&gt; 296 |             expect(&quot;\\&quot;).toFailWithParseError(
      |            ^ Redundant Assertion
  297 |                    &quot;Unexpected character: &#39;\\&#39; at position 1: \\̲&quot;);
  298 |         });
  299 |     });</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  326 | describe(&quot;Unicode accents&quot;, function() {
  327 |     it(&quot;should return error for invalid combining characters&quot;, function() {
&gt; 328 |         expect(&quot;A\u0328&quot;).toFailWithParseError(
      |        ^ Redundant Assertion
  329 |             &quot;Unknown accent &#39; ̨&#39; at position 1: Ą̲̲&quot;);
  330 |     });
  331 | });</code></pre><br>
                      </td>
                    </tr>
                  </tbody>
                </table>
                <hr>
                <table class="table is-fullwidth" id="table-of-smell">
                  <thead>
                    <tr>
                      <td>Unknown Test</td>
                    </tr>
                  </thead>
                  <tbody>
                    <tr>
                      <td>
                        <pre><code>  4 |
  5 |     describe(&quot;#handleInfixNodes&quot;, function() {
&gt; 6 |         it(&quot;rejects repeated infix operators&quot;, function() {
    |        ^ Unknown Test
  7 |             expect&#x60;1\over 2\over 3&#x60;.toFailWithParseError(
  8 |                    &quot;only one infix operator per group at position 9: &quot; +
  9 |                    &quot;1\\over 2\\̲o̲v̲e̲r̲ ̲3&quot;);</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>   9 |                    &quot;1\\over 2\\̲o̲v̲e̲r̲ ̲3&quot;);
  10 |         });
&gt; 11 |         it(&quot;rejects conflicting infix operators&quot;, function() {
     |        ^ Unknown Test
  12 |             expect&#x60;1\over 2\choose 3&#x60;.toFailWithParseError(
  13 |                    &quot;only one infix operator per group at position 9: &quot; +
  14 |                    &quot;1\\over 2\\̲c̲h̲o̲o̲s̲e̲ ̲3&quot;);</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  17 |
  18 |     describe(&quot;#handleSupSubscript&quot;, function() {
&gt; 19 |         it(&quot;rejects ^ at end of group&quot;, function() {
     |        ^ Unknown Test
  20 |             expect&#x60;{1^}&#x60;.toFailWithParseError(
  21 |                    &quot;Expected group after &#39;^&#39; at position 3: {1^̲}&quot;);
  22 |         });</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  21 |                    &quot;Expected group after &#39;^&#39; at position 3: {1^̲}&quot;);
  22 |         });
&gt; 23 |         it(&quot;rejects _ at end of input&quot;, function() {
     |        ^ Unknown Test
  24 |             expect&#x60;1_&#x60;.toFailWithParseError(
  25 |                    &quot;Expected group after &#39;_&#39; at position 2: 1_̲&quot;);
  26 |         });</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  25 |                    &quot;Expected group after &#39;_&#39; at position 2: 1_̲&quot;);
  26 |         });
&gt; 27 |         it(&quot;rejects \\sqrt as argument to ^&quot;, function() {
     |        ^ Unknown Test
  28 |             expect&#x60;1^\sqrt{2}&#x60;.toFailWithParseError(
  29 |                    &quot;Got function &#39;\\sqrt&#39; with no arguments as superscript&quot; +
  30 |                    &quot; at position 3: 1^\\̲s̲q̲r̲t̲{2}&quot;);</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  33 |
  34 |     describe(&quot;#parseAtom&quot;, function() {
&gt; 35 |         it(&quot;rejects \\limits without operator&quot;, function() {
     |        ^ Unknown Test
  36 |             expect&#x60;\alpha\limits\omega&#x60;.toFailWithParseError(
  37 |                    &quot;Limit controls must follow a math operator&quot; +
  38 |                    &quot; at position 7: \\alpha\\̲l̲i̲m̲i̲t̲s̲\\omega&quot;);</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  38 |                    &quot; at position 7: \\alpha\\̲l̲i̲m̲i̲t̲s̲\\omega&quot;);
  39 |         });
&gt; 40 |         it(&quot;rejects \\limits at the beginning of the input&quot;, function() {
     |        ^ Unknown Test
  41 |             expect&#x60;\limits\omega&#x60;.toFailWithParseError(
  42 |                    &quot;Limit controls must follow a math operator&quot; +
  43 |                    &quot; at position 1: \\̲l̲i̲m̲i̲t̲s̲\\omega&quot;);</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  43 |                    &quot; at position 1: \\̲l̲i̲m̲i̲t̲s̲\\omega&quot;);
  44 |         });
&gt; 45 |         it(&quot;rejects double superscripts&quot;, function() {
     |        ^ Unknown Test
  46 |             expect&#x60;1^2^3&#x60;.toFailWithParseError(
  47 |                    &quot;Double superscript at position 4: 1^2^̲3&quot;);
  48 |             expect&#x60;1^{2+3}_4^5&#x60;.toFailWithParseError(</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  49 |                    &quot;Double superscript at position 10: 1^{2+3}_4^̲5&quot;);
  50 |         });
&gt; 51 |         it(&quot;rejects double superscripts involving primes&quot;, function() {
     |        ^ Unknown Test
  52 |             expect&#x60;1&#39;_2^3&#x60;.toFailWithParseError(
  53 |                    &quot;Double superscript at position 5: 1&#39;_2^̲3&quot;);
  54 |             expect&#x60;1^2&#39;&#x60;.toFailWithParseError(</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  59 |                    &quot;Double superscript at position 5: 1&#39;_2&#39;̲&quot;);
  60 |         });
&gt; 61 |         it(&quot;rejects double subscripts&quot;, function() {
     |        ^ Unknown Test
  62 |             expect&#x60;1_2_3&#x60;.toFailWithParseError(
  63 |                    &quot;Double subscript at position 4: 1_2_̲3&quot;);
  64 |             expect&#x60;1_{2+3}^4_5&#x60;.toFailWithParseError(</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  68 |
  69 |     describe(&quot;#parseImplicitGroup&quot;, function() {
&gt; 70 |         it(&quot;reports unknown environments&quot;, function() {
     |        ^ Unknown Test
  71 |             expect&#x60;\begin{foo}bar\end{foo}&#x60;.toFailWithParseError(
  72 |                    &quot;No such environment: foo at position 7:&quot; +
  73 |                    &quot; \\begin{̲f̲o̲o̲}̲bar\\end{foo}&quot;);</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  73 |                    &quot; \\begin{̲f̲o̲o̲}̲bar\\end{foo}&quot;);
  74 |         });
&gt; 75 |         it(&quot;reports mismatched environments&quot;, function() {
     |        ^ Unknown Test
  76 |             expect&#x60;\begin{pmatrix}1&amp;2\\3&amp;4\end{bmatrix}+5&#x60;
  77 |                 .toFailWithParseError(
  78 |                    &quot;Mismatch: \\begin{pmatrix} matched by \\end{bmatrix}&quot; +</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  82 |
  83 |     describe(&quot;#parseFunction&quot;, function() {
&gt; 84 |         it(&quot;rejects math-mode functions in text mode&quot;, function() {
     |        ^ Unknown Test
  85 |             expect&#x60;\text{\sqrt2 is irrational}&#x60;.toFailWithParseError(
  86 |                 &quot;Can&#39;t use function &#39;\\sqrt&#39; in text mode&quot; +
  87 |                 &quot; at position 7: \\text{\\̲s̲q̲r̲t̲2 is irrational…&quot;);</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  87 |                 &quot; at position 7: \\text{\\̲s̲q̲r̲t̲2 is irrational…&quot;);
  88 |         });
&gt; 89 |         it(&quot;rejects text-mode-only functions in math mode&quot;, () &#x3D;&gt; {
     |        ^ Unknown Test
  90 |             expect&#x60;$&#x60;.toFailWithParseError(
  91 |                 &quot;Can&#39;t use function &#39;$&#39; in math mode at position 1: $̲&quot;);
  92 |         });</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  91 |                 &quot;Can&#39;t use function &#39;$&#39; in math mode at position 1: $̲&quot;);
  92 |         });
&gt; 93 |         it(&quot;rejects strict-mode text-mode-only functions in math mode&quot;, () &#x3D;&gt; {
     |        ^ Unknown Test
  94 |             expect&#x60;\&#39;echec&#x60;.toFailWithParseError(&quot;LaTeX-incompatible input &quot; +
  95 |                 &quot;and strict mode is set to &#39;error&#39;: LaTeX&#39;s accent \\&#39; works &quot; +
  96 |                 &quot;only in text mode [mathVsTextAccents]&quot;, strictSettings);</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>   99 |
  100 |     describe(&quot;#parseArguments&quot;, function() {
&gt; 101 |         it(&quot;complains about missing argument at end of input&quot;, function() {
      |        ^ Unknown Test
  102 |             expect&#x60;2\sqrt&#x60;.toFailWithParseError(
  103 |                    &quot;Expected group as argument to &#39;\\sqrt&#39;&quot; +
  104 |                    &quot; at end of input: 2\\sqrt&quot;);</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  104 |                    &quot; at end of input: 2\\sqrt&quot;);
  105 |         });
&gt; 106 |         it(&quot;complains about missing argument at end of group&quot;, function() {
      |        ^ Unknown Test
  107 |             expect&#x60;1^{2\sqrt}&#x60;.toFailWithParseError(
  108 |                    &quot;Expected group as argument to &#39;\\sqrt&#39;&quot; +
  109 |                    &quot; at position 10: 1^{2\\sqrt}̲&quot;);</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  109 |                    &quot; at position 10: 1^{2\\sqrt}̲&quot;);
  110 |         });
&gt; 111 |         it(&quot;complains about functions as arguments to others&quot;, function() {
      |        ^ Unknown Test
  112 |             expect&#x60;\sqrt\over2&#x60;.toFailWithParseError(
  113 |                    &quot;Got function &#39;\\over&#39; with no arguments as argument to&quot; +
  114 |                    &quot; &#39;\\sqrt&#39; at position 6: \\sqrt\\̲o̲v̲e̲r̲2&quot;);</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  117 |
  118 |     describe(&quot;#parseGroup&quot;, function() {
&gt; 119 |         it(&quot;complains about undefined control sequence&quot;, function() {
      |        ^ Unknown Test
  120 |             expect&#x60;\xyz&#x60;.toFailWithParseError(
  121 |                    &quot;Undefined control sequence: \\xyz&quot; +
  122 |                    &quot; at position 1: \\̲x̲y̲z̲&quot;);</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  125 |
  126 |     describe(&quot;#verb&quot;, function() {
&gt; 127 |         it(&quot;complains about mismatched \\verb with end of string&quot;, function() {
      |        ^ Unknown Test
  128 |             expect&#x60;\verb|hello&#x60;.toFailWithParseError(
  129 |                 &quot;\\verb ended by end of line instead of matching delimiter&quot;);
  130 |         });</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  140 |
  141 |     describe(&quot;#parseInput expecting EOF&quot;, function() {
&gt; 142 |         it(&quot;complains about extra }&quot;, function() {
      |        ^ Unknown Test
  143 |             expect&#x60;{1+2}}&#x60;.toFailWithParseError(
  144 |                    &quot;Expected &#39;EOF&#39;, got &#39;}&#39; at position 6: {1+2}}̲&quot;);
  145 |         });</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  144 |                    &quot;Expected &#39;EOF&#39;, got &#39;}&#39; at position 6: {1+2}}̲&quot;);
  145 |         });
&gt; 146 |         it(&quot;complains about extra \\end&quot;, function() {
      |        ^ Unknown Test
  147 |             expect&#x60;x\end{matrix}&#x60;.toFailWithParseError(
  148 |                    &quot;Expected &#39;EOF&#39;, got &#39;\\end&#39; at position 2:&quot; +
  149 |                    &quot; x\\̲e̲n̲d̲{matrix}&quot;);</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  149 |                    &quot; x\\̲e̲n̲d̲{matrix}&quot;);
  150 |         });
&gt; 151 |         it(&quot;complains about top-level &amp;&quot;, function() {
      |        ^ Unknown Test
  152 |             expect&#x60;1&amp;2&#x60;.toFailWithParseError(
  153 |                    &quot;Expected &#39;EOF&#39;, got &#39;&amp;&#39; at position 2: 1&amp;̲2&quot;);
  154 |         });</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  156 |
  157 |     describe(&quot;#parseImplicitGroup expecting \\right&quot;, function() {
&gt; 158 |         it(&quot;rejects missing \\right&quot;, function() {
      |        ^ Unknown Test
  159 |             expect&#x60;\left(1+2)&#x60;.toFailWithParseError(
  160 |                    &quot;Expected &#39;\\right&#39;, got &#39;EOF&#39; at end of input:&quot; +
  161 |                    &quot; \\left(1+2)&quot;);</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  161 |                    &quot; \\left(1+2)&quot;);
  162 |         });
&gt; 163 |         it(&quot;rejects incorrectly scoped \\right&quot;, function() {
      |        ^ Unknown Test
  164 |             expect&#x60;{\left(1+2}\right)&#x60;.toFailWithParseError(
  165 |                    &quot;Expected &#39;\\right&#39;, got &#39;}&#39; at position 11:&quot; +
  166 |                    &quot; {\\left(1+2}̲\\right)&quot;);</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  172 |
  173 |     describe(&quot;#parseSpecialGroup expecting braces&quot;, function() {
&gt; 174 |         it(&quot;complains about missing { for color&quot;, function() {
      |        ^ Unknown Test
  175 |             expect&#x60;\textcolor#ffffff{text}&#x60;.toFailWithParseError(
  176 |                    &quot;Invalid color: &#39;#&#39; at position 11:&quot; +
  177 |                    &quot; \\textcolor#̲ffffff{text}&quot;);</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  177 |                    &quot; \\textcolor#̲ffffff{text}&quot;);
  178 |         });
&gt; 179 |         it(&quot;complains about missing { for size&quot;, function() {
      |        ^ Unknown Test
  180 |             expect&#x60;\rule{1em}[2em]&#x60;.toFailWithParseError(
  181 |                    &quot;Invalid size: &#39;[&#39; at position 11: \\rule{1em}[̲2em]&quot;);
  182 |         });</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  182 |         });
  183 |         &#x2F;&#x2F; Can&#39;t test for the [ of an optional group since it&#39;s optional
&gt; 184 |         it(&quot;complains about missing } for color&quot;, function() {
      |        ^ Unknown Test
  185 |             expect&#x60;\textcolor{#ffffff{text}&#x60;.toFailWithParseError(
  186 |                    &quot;Unexpected end of input in a macro argument,&quot; +
  187 |                    &quot; expected &#39;}&#39; at end of input: …r{#ffffff{text}&quot;);</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  187 |                    &quot; expected &#39;}&#39; at end of input: …r{#ffffff{text}&quot;);
  188 |         });
&gt; 189 |         it(&quot;complains about missing ] for size&quot;, function() {
      |        ^ Unknown Test
  190 |             expect&#x60;\rule[1em{2em}{3em}&#x60;.toFailWithParseError(
  191 |                    &quot;Unexpected end of input in a macro argument,&quot; +
  192 |                    &quot; expected &#39;]&#39; at end of input: …e[1em{2em}{3em}&quot;);</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  192 |                    &quot; expected &#39;]&#39; at end of input: …e[1em{2em}{3em}&quot;);
  193 |         });
&gt; 194 |         it(&quot;complains about missing ] for size at end of input&quot;, function() {
      |        ^ Unknown Test
  195 |             expect&#x60;\rule[1em&#x60;.toFailWithParseError(
  196 |                    &quot;Unexpected end of input in a macro argument,&quot; +
  197 |                    &quot; expected &#39;]&#39; at end of input: \\rule[1em&quot;);</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  197 |                    &quot; expected &#39;]&#39; at end of input: \\rule[1em&quot;);
  198 |         });
&gt; 199 |         it(&quot;complains about missing } for color at end of input&quot;, function() {
      |        ^ Unknown Test
  200 |             expect&#x60;\textcolor{#123456&#x60;.toFailWithParseError(
  201 |                    &quot;Unexpected end of input in a macro argument,&quot; +
  202 |                    &quot; expected &#39;}&#39; at end of input: …xtcolor{#123456&quot;);</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  205 |
  206 |     describe(&quot;#parseGroup expecting }&quot;, function() {
&gt; 207 |         it(&quot;at end of file&quot;, function() {
      |        ^ Unknown Test
  208 |             expect&#x60;\sqrt{2&#x60;.toFailWithParseError(
  209 |                    &quot;Expected &#39;}&#39;, got &#39;EOF&#39; at end of input: \\sqrt{2&quot;);
  210 |         });</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  212 |
  213 |     describe(&quot;#parseOptionalGroup expecting ]&quot;, function() {
&gt; 214 |         it(&quot;at end of file&quot;, function() {
      |        ^ Unknown Test
  215 |             expect&#x60;\sqrt[3&#x60;.toFailWithParseError(
  216 |                    &quot;Unexpected end of input in a macro argument,&quot; +
  217 |                    &quot; expected &#39;]&#39; at end of input: \\sqrt[3&quot;);</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  217 |                    &quot; expected &#39;]&#39; at end of input: \\sqrt[3&quot;);
  218 |         });
&gt; 219 |         it(&quot;before group&quot;, function() {
      |        ^ Unknown Test
  220 |             expect&#x60;\sqrt[3{2}&#x60;.toFailWithParseError(
  221 |                    &quot;Unexpected end of input in a macro argument,&quot; +
  222 |                    &quot; expected &#39;]&#39; at end of input: \\sqrt[3{2}&quot;);</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  229 |
  230 |     describe(&quot;parseArray&quot;, function() {
&gt; 231 |         it(&quot;rejects missing \\end&quot;, function() {
      |        ^ Unknown Test
  232 |             expect&#x60;\begin{matrix}1&#x60;.toFailWithParseError(
  233 |                    &quot;Expected &amp; or \\\\ or \\cr or \\end at end of input:&quot; +
  234 |                    &quot; \\begin{matrix}1&quot;);</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  234 |                    &quot; \\begin{matrix}1&quot;);
  235 |         });
&gt; 236 |         it(&quot;rejects incorrectly scoped \\end&quot;, function() {
      |        ^ Unknown Test
  237 |             expect&#x60;{\begin{matrix}1}\end{matrix}&#x60;.toFailWithParseError(
  238 |                    &quot;Expected &amp; or \\\\ or \\cr or \\end at position 17:&quot; +
  239 |                    &quot; …\\begin{matrix}1}̲\\end{matrix}&quot;);</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  242 |
  243 |     describe(&quot;array environment&quot;, function() {
&gt; 244 |         it(&quot;rejects unknown column types&quot;, function() {
      |        ^ Unknown Test
  245 |             expect&#x60;\begin{array}{cba}\end{array}&#x60;.toFailWithParseError(
  246 |                    &quot;Unknown column alignment: b at position 16:&quot; +
  247 |                    &quot; \\begin{array}{cb̲a}\\end{array}&quot;);</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  254 |
  255 |     describe(&quot;delimiter functions&quot;, function() {
&gt; 256 |         it(&quot;reject invalid opening delimiters&quot;, function() {
      |        ^ Unknown Test
  257 |             expect&#x60;\bigl 1 + 2 \bigr&#x60;.toFailWithParseError(
  258 |                    &quot;Invalid delimiter &#39;1&#39; after &#39;\\bigl&#39; at position 7:&quot; +
  259 |                    &quot; \\bigl 1̲ + 2 \\bigr&quot;);</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  259 |                    &quot; \\bigl 1̲ + 2 \\bigr&quot;);
  260 |         });
&gt; 261 |         it(&quot;reject invalid closing delimiters&quot;, function() {
      |        ^ Unknown Test
  262 |             expect&#x60;\bigl(1+2\bigr&#x3D;3&#x60;.toFailWithParseError(
  263 |                    &quot;Invalid delimiter &#39;&#x3D;&#39; after &#39;\\bigr&#39; at position 15:&quot; +
  264 |                    &quot; \\bigl(1+2\\bigr&#x3D;̲3&quot;);</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  264 |                    &quot; \\bigl(1+2\\bigr&#x3D;̲3&quot;);
  265 |         });
&gt; 266 |         it(&quot;reject group opening delimiters&quot;, function() {
      |        ^ Unknown Test
  267 |             expect&#x60;\bigl{(}1+2\bigr)3&#x60;.toFailWithParseError(
  268 |                    &quot;Invalid delimiter type &#39;ordgroup&#39; at position 6:&quot; +
  269 |                    &quot; \\bigl{̲(̲}̲1+2\\bigr)3&quot;);</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  269 |                    &quot; \\bigl{̲(̲}̲1+2\\bigr)3&quot;);
  270 |         });
&gt; 271 |         it(&quot;reject group closing delimiters&quot;, function() {
      |        ^ Unknown Test
  272 |             expect&#x60;\bigl(1+2\bigr{)}3&#x60;.toFailWithParseError(
  273 |                    &quot;Invalid delimiter type &#39;ordgroup&#39; at position 15:&quot; +
  274 |                    &quot; \\bigl(1+2\\bigr{̲)̲}̲3&quot;);</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  277 |
  278 |     describe(&quot;\\begin and \\end&quot;, function() {
&gt; 279 |         it(&quot;reject invalid environment names&quot;, function() {
      |        ^ Unknown Test
  280 |             expect&#x60;\begin x\end y&#x60;.toFailWithParseError(
  281 |                    &quot;No such environment: x at position 8: \\begin x̲\\end y&quot;);
  282 |         });</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  300 |
  301 |     describe(&quot;#_innerLexColor&quot;, function() {
&gt; 302 |         it(&quot;reject 3-digit hex notation without #&quot;, function() {
      |        ^ Unknown Test
  303 |             expect&#x60;\textcolor{1a2}{foo}&#x60;.toFailWithParseError(
  304 |                    &quot;Invalid color: &#39;1a2&#39;&quot; +
  305 |                    &quot; at position 11: \\textcolor{̲1̲a̲2̲}̲{foo}&quot;);</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  308 |
  309 |     describe(&quot;#_innerLexSize&quot;, function() {
&gt; 310 |         it(&quot;reject size without unit&quot;, function() {
      |        ^ Unknown Test
  311 |             expect&#x60;\rule{0}{2em}&#x60;.toFailWithParseError(
  312 |                    &quot;Invalid size: &#39;0&#39; at position 6: \\rule{̲0̲}̲{2em}&quot;);
  313 |         });</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  312 |                    &quot;Invalid size: &#39;0&#39; at position 6: \\rule{̲0̲}̲{2em}&quot;);
  313 |         });
&gt; 314 |         it(&quot;reject size with bogus unit&quot;, function() {
      |        ^ Unknown Test
  315 |             expect&#x60;\rule{1au}{2em}&#x60;.toFailWithParseError(
  316 |                    &quot;Invalid unit: &#39;au&#39; at position 6: \\rule{̲1̲a̲u̲}̲{2em}&quot;);
  317 |         });</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  316 |                    &quot;Invalid unit: &#39;au&#39; at position 6: \\rule{̲1̲a̲u̲}̲{2em}&quot;);
  317 |         });
&gt; 318 |         it(&quot;reject size without number&quot;, function() {
      |        ^ Unknown Test
  319 |             expect&#x60;\rule{em}{2em}&#x60;.toFailWithParseError(
  320 |                    &quot;Invalid size: &#39;em&#39; at position 6: \\rule{̲e̲m̲}̲{2em}&quot;);
  321 |         });</code></pre><br>
                      </td>
                    </tr>
                  </tbody>
                </table>
              </td>
            </tr>
            <tr>
              <td>
                <a class="toggle-link" href="javascript:;" onclick="toggleDetails(this)">+ &#x2F;home&#x2F;gabriel&#x2F;Desktop&#x2F;research&#x2F;projects&#x2F;katex&#x2F;test&#x2F;dup-spec.js</a>
              </td>
              <td class="has-text-right">4</td>
            </tr>
            <tr class="details-row hidden">
              <td colspan="2">
                <div class="columns is-multiline is-centered">
                  <div class="column is-one-quarter">
                    <div class="box px-4 py-4">
                      <div class="heading">Physical SLOC</div>
                      <div class="title has-text-weight-light is-size-4">19</div>
                    </div>
                  </div>
                  <div class="column is-one-quarter">
                    <div class="box px-4 py-4">
                      <div class="heading">Logical SLOC</div>
                      <div class="title has-text-weight-light is-size-4">14</div>
                    </div>
                  </div>
                  <div class="column is-one-quarter">
                    <div class="box px-4 py-4">
                      <div class="heading">Cyclomatic</div>
                      <div class="title has-text-weight-light is-size-4">5</div>
                    </div>
                  </div>
                  <div class="column is-one-quarter">
                    <div class="box px-4 py-4">
                      <div class="heading">Cyclomatic Density</div>
                      <div class="title has-text-weight-light is-size-4">35.714</div>
                    </div>
                  </div>
                  <div class="column is-one-quarter">
                    <div class="box px-4 py-4">
                      <div class="heading">Halstead Bugs</div>
                      <div class="title has-text-weight-light is-size-4">0.069</div>
                    </div>
                  </div>
                  <div class="column is-one-quarter">
                    <div class="box px-4 py-4">
                      <div class="heading">Halstead Difficulty</div>
                      <div class="title has-text-weight-light is-size-4">9.625</div>
                    </div>
                  </div>
                  <div class="column is-one-quarter">
                    <div class="box px-4 py-4">
                      <div class="heading">Halstead effort</div>
                      <div class="title has-text-weight-light is-size-4">2002.807</div>
                    </div>
                  </div>
                  <div class="column is-one-quarter">
                    <div class="box px-4 py-4">
                      <div class="heading">Halstead Length</div>
                      <div class="title has-text-weight-light is-size-4">46</div>
                    </div>
                  </div>
                  <div class="column is-one-quarter">
                    <div class="box px-4 py-4">
                      <div class="heading">Halstead Time</div>
                      <div class="title has-text-weight-light is-size-4">111.267</div>
                    </div>
                  </div>
                  <div class="column is-one-quarter">
                    <div class="box px-4 py-4">
                      <div class="heading">Halstead Vocabulary</div>
                      <div class="title has-text-weight-light is-size-4">23</div>
                    </div>
                  </div>
                  <div class="column is-one-quarter">
                    <div class="box px-4 py-4">
                      <div class="heading">Halstead Volume</div>
                      <div class="title has-text-weight-light is-size-4">208.084</div>
                    </div>
                  </div>
                  <div class="column is-one-quarter">
                    <div class="box px-4 py-4">
                      <div class="heading">Maintainability</div>
                      <div class="title has-text-weight-light is-size-4">123.291</div>
                    </div>
                  </div>
                </div>
                <hr>
                <table class="table is-fullwidth" id="table-of-smell">
                  <thead>
                    <tr>
                      <td>Conditional Test Logic</td>
                    </tr>
                  </thead>
                  <tbody>
                    <tr>
                      <td>
                        <pre><code>  3 |
  4 | describe(&quot;Symbols and macros&quot;, () &#x3D;&gt; {
&gt; 5 |     for (const macro in macros) {
    |    ^ Conditional Test Logic
  6 |         if (!macros.hasOwnProperty(macro)) {
  7 |             continue;
  8 |         }</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  4 | describe(&quot;Symbols and macros&quot;, () &#x3D;&gt; {
  5 |     for (const macro in macros) {
&gt; 6 |         if (!macros.hasOwnProperty(macro)) {
    |        ^ Conditional Test Logic
  7 |             continue;
  8 |         }
  9 |         it(&#x60;macro ${macro} should not shadow a symbol&#x60;, () &#x3D;&gt; {</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>   8 |         }
   9 |         it(&#x60;macro ${macro} should not shadow a symbol&#x60;, () &#x3D;&gt; {
&gt; 10 |             for (const kind in symbols) {
     |            ^ Conditional Test Logic
  11 |                 if (!symbols.hasOwnProperty(kind)) {
  12 |                     continue;
  13 |                 }</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>   9 |         it(&#x60;macro ${macro} should not shadow a symbol&#x60;, () &#x3D;&gt; {
  10 |             for (const kind in symbols) {
&gt; 11 |                 if (!symbols.hasOwnProperty(kind)) {
     |                ^ Conditional Test Logic
  12 |                     continue;
  13 |                 }
  14 |                 expect(symbols[kind][macro]).toBeFalsy();</code></pre><br>
                      </td>
                    </tr>
                  </tbody>
                </table>
              </td>
            </tr>
            <tr>
              <td>
                <a class="toggle-link" href="javascript:;" onclick="toggleDetails(this)">+ &#x2F;home&#x2F;gabriel&#x2F;Desktop&#x2F;research&#x2F;projects&#x2F;katex&#x2F;contrib&#x2F;auto-render&#x2F;test&#x2F;auto-render-spec.js</a>
              </td>
              <td class="has-text-right">23</td>
            </tr>
            <tr class="details-row hidden">
              <td colspan="2">
                <div class="columns is-multiline is-centered">
                  <div class="column is-one-quarter">
                    <div class="box px-4 py-4">
                      <div class="heading">Physical SLOC</div>
                      <div class="title has-text-weight-light is-size-4">364</div>
                    </div>
                  </div>
                  <div class="column is-one-quarter">
                    <div class="box px-4 py-4">
                      <div class="heading">Logical SLOC</div>
                      <div class="title has-text-weight-light is-size-4">406</div>
                    </div>
                  </div>
                  <div class="column is-one-quarter">
                    <div class="box px-4 py-4">
                      <div class="heading">Cyclomatic</div>
                      <div class="title has-text-weight-light is-size-4">37</div>
                    </div>
                  </div>
                  <div class="column is-one-quarter">
                    <div class="box px-4 py-4">
                      <div class="heading">Cyclomatic Density</div>
                      <div class="title has-text-weight-light is-size-4">9.113</div>
                    </div>
                  </div>
                  <div class="column is-one-quarter">
                    <div class="box px-4 py-4">
                      <div class="heading">Halstead Bugs</div>
                      <div class="title has-text-weight-light is-size-4">3.648</div>
                    </div>
                  </div>
                  <div class="column is-one-quarter">
                    <div class="box px-4 py-4">
                      <div class="heading">Halstead Difficulty</div>
                      <div class="title has-text-weight-light is-size-4">53.951</div>
                    </div>
                  </div>
                  <div class="column is-one-quarter">
                    <div class="box px-4 py-4">
                      <div class="heading">Halstead effort</div>
                      <div class="title has-text-weight-light is-size-4">590423.74</div>
                    </div>
                  </div>
                  <div class="column is-one-quarter">
                    <div class="box px-4 py-4">
                      <div class="heading">Halstead Length</div>
                      <div class="title has-text-weight-light is-size-4">1472</div>
                    </div>
                  </div>
                  <div class="column is-one-quarter">
                    <div class="box px-4 py-4">
                      <div class="heading">Halstead Time</div>
                      <div class="title has-text-weight-light is-size-4">32801.319</div>
                    </div>
                  </div>
                  <div class="column is-one-quarter">
                    <div class="box px-4 py-4">
                      <div class="heading">Halstead Vocabulary</div>
                      <div class="title has-text-weight-light is-size-4">173</div>
                    </div>
                  </div>
                  <div class="column is-one-quarter">
                    <div class="box px-4 py-4">
                      <div class="heading">Halstead Volume</div>
                      <div class="title has-text-weight-light is-size-4">10943.773</div>
                    </div>
                  </div>
                  <div class="column is-one-quarter">
                    <div class="box px-4 py-4">
                      <div class="heading">Maintainability</div>
                      <div class="title has-text-weight-light is-size-4">93.349</div>
                    </div>
                  </div>
                </div>
                <hr>
                <table class="table is-fullwidth" id="table-of-smell">
                  <thead>
                    <tr>
                      <td>Conditional Test Logic</td>
                    </tr>
                  </thead>
                  <tbody>
                    <tr>
                      <td>
                        <pre><code>  16 |                   splitAtDelimiters(actual, delimiters);
  17 |
&gt; 18 |             if (split.length !&#x3D;&#x3D; result.length) {
     |            ^ Conditional Test Logic
  19 |                 message.pass &#x3D; false;
  20 |                 message.message &#x3D; () &#x3D;&gt; &quot;Different number of splits: &quot; +
  21 |                     split.length + &quot; vs. &quot; + result.length + &quot; (&quot; +</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  25 |             }
  26 |
&gt; 27 |             for (let i &#x3D; 0; i &lt; split.length; i++) {
     |            ^ Conditional Test Logic
  28 |                 const real &#x3D; split[i];
  29 |                 const correct &#x3D; result[i];
  30 |</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  32 |                 let diff;
  33 |
&gt; 34 |                 if (real.type !&#x3D;&#x3D; correct.type) {
     |                ^ Conditional Test Logic
  35 |                     good &#x3D; false;
  36 |                     diff &#x3D; &quot;type&quot;;
  37 |                 } else if (real.data !&#x3D;&#x3D; correct.data) {</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  35 |                     good &#x3D; false;
  36 |                     diff &#x3D; &quot;type&quot;;
&gt; 37 |                 } else if (real.data !&#x3D;&#x3D; correct.data) {
     |                       ^ Conditional Test Logic
  38 |                     good &#x3D; false;
  39 |                     diff &#x3D; &quot;data&quot;;
  40 |                 } else if (real.display !&#x3D;&#x3D; correct.display) {</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  38 |                     good &#x3D; false;
  39 |                     diff &#x3D; &quot;data&quot;;
&gt; 40 |                 } else if (real.display !&#x3D;&#x3D; correct.display) {
     |                       ^ Conditional Test Logic
  41 |                     good &#x3D; false;
  42 |                     diff &#x3D; &quot;display&quot;;
  43 |                 }</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  43 |                 }
  44 |
&gt; 45 |                 if (!good) {
     |                ^ Conditional Test Logic
  46 |                     message.pass &#x3D; false;
  47 |                     message.message &#x3D; () &#x3D;&gt; &quot;Difference at split &quot; +
  48 |                         (i + 1) + &quot;: &quot; + JSON.stringify(real) +</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  330 |             &#39;\\]&#39;];
  331 |         const el &#x3D; document.createElement(&#39;div&#39;);
&gt; 332 |         for (let i &#x3D; 0; i &lt; textNodes.length; i++) {
      |        ^ Conditional Test Logic
  333 |             const txt &#x3D; document.createTextNode(textNodes[i]);
  334 |             el.appendChild(txt);
  335 |         }</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  348 |             &#39;consectetur adipiscing elit&#39;];
  349 |         const el &#x3D; document.createElement(&#39;div&#39;);
&gt; 350 |         for (let i &#x3D; 0; i &lt; textNodes.length; i++) {
      |        ^ Conditional Test Logic
  351 |             const txt &#x3D; document.createTextNode(textNodes[i]);
  352 |             el.appendChild(txt);
  353 |         }</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  353 |         }
  354 |         const el2 &#x3D; document.createElement(&#39;div&#39;);
&gt; 355 |         for (let i &#x3D; 0; i &lt; textNodes.length; i++) {
      |        ^ Conditional Test Logic
  356 |             const txt &#x3D; document.createTextNode(textNodes[i]);
  357 |             el2.appendChild(txt);
  358 |         }</code></pre><br>
                      </td>
                    </tr>
                  </tbody>
                </table>
                <hr>
                <table class="table is-fullwidth" id="table-of-smell">
                  <thead>
                    <tr>
                      <td>Redundant Assertion</td>
                    </tr>
                  </thead>
                  <tbody>
                    <tr>
                      <td>
                        <pre><code>  60 | describe(&quot;A delimiter splitter&quot;, function() {
  61 |     it(&quot;doesn&#39;t split when there are no delimiters&quot;, function() {
&gt; 62 |         expect(&quot;hello&quot;).toSplitInto(
     |        ^ Redundant Assertion
  63 |             [
  64 |                 {type: &quot;text&quot;, data: &quot;hello&quot;},
  65 |             ],</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  70 |
  71 |     it(&quot;doesn&#39;t create a math node with only one left delimiter&quot;, function() {
&gt; 72 |         expect(&quot;hello ( world&quot;).toSplitInto(
     |        ^ Redundant Assertion
  73 |             [
  74 |                 {type: &quot;text&quot;, data: &quot;hello &quot;},
  75 |                 {type: &quot;text&quot;, data: &quot;( world&quot;},</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  81 |
  82 |     it(&quot;doesn&#39;t split when there&#39;s only a right delimiter&quot;, function() {
&gt; 83 |         expect(&quot;hello ) world&quot;).toSplitInto(
     |        ^ Redundant Assertion
  84 |             [
  85 |                 {type: &quot;text&quot;, data: &quot;hello ) world&quot;},
  86 |             ],</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  91 |
  92 |     it(&quot;splits when there are both delimiters&quot;, function() {
&gt; 93 |         expect(&quot;hello ( world ) boo&quot;).toSplitInto(
     |        ^ Redundant Assertion
  94 |             [
  95 |                 {type: &quot;text&quot;, data: &quot;hello &quot;},
  96 |                 {type: &quot;math&quot;, data: &quot; world &quot;,</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  104 |
  105 |     it(&quot;splits on multi-character delimiters&quot;, function() {
&gt; 106 |         expect(&quot;hello [[ world ]] boo&quot;).toSplitInto(
      |        ^ Redundant Assertion
  107 |             [
  108 |                 {type: &quot;text&quot;, data: &quot;hello &quot;},
  109 |                 {type: &quot;math&quot;, data: &quot; world &quot;,</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  114 |                 {left: &quot;[[&quot;, right: &quot;]]&quot;, display: false},
  115 |             ]);
&gt; 116 |         expect(&quot;hello \\begin{equation} world \\end{equation} boo&quot;).toSplitInto(
      |        ^ Redundant Assertion
  117 |             [
  118 |                 {type: &quot;text&quot;, data: &quot;hello &quot;},
  119 |                 {type: &quot;math&quot;, data: &quot;\\begin{equation} world \\end{equation}&quot;,</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  129 |
  130 |     it(&quot;splits multiple times&quot;, function() {
&gt; 131 |         expect(&quot;hello ( world ) boo ( more ) stuff&quot;).toSplitInto(
      |        ^ Redundant Assertion
  132 |             [
  133 |                 {type: &quot;text&quot;, data: &quot;hello &quot;},
  134 |                 {type: &quot;math&quot;, data: &quot; world &quot;,</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  145 |
  146 |     it(&quot;leaves the ending when there&#39;s only a left delimiter&quot;, function() {
&gt; 147 |         expect(&quot;hello ( world ) boo ( left&quot;).toSplitInto(
      |        ^ Redundant Assertion
  148 |             [
  149 |                 {type: &quot;text&quot;, data: &quot;hello &quot;},
  150 |                 {type: &quot;math&quot;, data: &quot; world &quot;,</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  159 |
  160 |     it(&quot;doesn&#39;t split when close delimiters are in {}s&quot;, function() {
&gt; 161 |         expect(&quot;hello ( world { ) } ) boo&quot;).toSplitInto(
      |        ^ Redundant Assertion
  162 |             [
  163 |                 {type: &quot;text&quot;, data: &quot;hello &quot;},
  164 |                 {type: &quot;math&quot;, data: &quot; world { ) } &quot;,</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  170 |             ]);
  171 |
&gt; 172 |         expect(&quot;hello ( world { { } ) } ) boo&quot;).toSplitInto(
      |        ^ Redundant Assertion
  173 |             [
  174 |                 {type: &quot;text&quot;, data: &quot;hello &quot;},
  175 |                 {type: &quot;math&quot;, data: &quot; world { { } ) } &quot;,</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  183 |
  184 |     it(&quot;correctly processes sequences of $..$&quot;, function() {
&gt; 185 |         expect(&quot;$hello$$world$$boo$&quot;).toSplitInto(
      |        ^ Redundant Assertion
  186 |             [
  187 |                 {type: &quot;math&quot;, data: &quot;hello&quot;,
  188 |                     rawData: &quot;$hello$&quot;, display: false},</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  198 |
  199 |     it(&quot;doesn&#39;t split at escaped delimiters&quot;, function() {
&gt; 200 |         expect(&quot;hello ( world \\) ) boo&quot;).toSplitInto(
      |        ^ Redundant Assertion
  201 |             [
  202 |                 {type: &quot;text&quot;, data: &quot;hello &quot;},
  203 |                 {type: &quot;math&quot;, data: &quot; world \\) &quot;,</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  222 |
  223 |     it(&quot;splits when the right and left delimiters are the same&quot;, function() {
&gt; 224 |         expect(&quot;hello $ world $ boo&quot;).toSplitInto(
      |        ^ Redundant Assertion
  225 |             [
  226 |                 {type: &quot;text&quot;, data: &quot;hello &quot;},
  227 |                 {type: &quot;math&quot;, data: &quot; world &quot;,</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  235 |
  236 |     it(&quot;ignores \\$&quot;, function() {
&gt; 237 |         expect(&quot;$x &#x3D; \\$5$&quot;).toSplitInto(
      |        ^ Redundant Assertion
  238 |             [
  239 |                 {type: &quot;math&quot;, data: &quot;x &#x3D; \\$5&quot;,
  240 |                     rawData: &quot;$x &#x3D; \\$5$&quot;, display: false},</code></pre><br>
                      </td>
                    </tr>
                  </tbody>
                </table>
              </td>
            </tr>
          </tbody>
        </table>
      </div>
    </div>
  </section>
  <footer class="footer">
    <div class="content has-text-centered">
      <p>Copyright © 2020 STEEL. All rights reserved.</p>
      <p>
        <strong>STEEL</strong> by Dalton N. Jorge, under the guidance of Prof. Dr. Patricia D. L. Machado & Prof. Dr.
        Wilkerson L. Andrade.
      </p>
      <p>SPLab - PPGCC - UFCG</p>
    </div>
  </footer>
  <script>
    function toggleDetails(node) {
      let parentRow = node.parentNode.parentNode;
      let path = parentRow.children[0].children[0].innerText;
      let detailsRow = parentRow.nextElementSibling;
      if (detailsRow.className === "details-row hidden") {
        parentRow.children[0].children[0].innerText = path.replace(/^\+/g, '-')
        detailsRow.className = "details-row";
      } else {
        parentRow.children[0].children[0].innerText = path.replace(/^-/g, '+')
        detailsRow.className = "details-row hidden";
      }
    }
  </script>
</body>

</html>
