<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title></title>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bulma@0.9.0/css/bulma.min.css">
  <style type="text/css">
    .details-row.hidden {
      display: none;
    }
  </style>
</head>

<body>
  <section class="hero is-dark welcome is-small is-bold">
    <div class="hero-body">
      <div class="container">
        <h1 class="title">
          STEEL - teST smElls dEtection tooL
        </h1>
        <h2 class="subtitle">
          Report for "steel" () project.
        </h2>
      </div>
    </div>
  </section>
  <section class="section">
    <div class="container">
      <div>
        <div class="columns">
          <div class="column">
            <div class="box notification is-info">
              <div class="heading">Test Suites</div>
              <div class="title">8</div>
            </div>
          </div>
          <div class="column">
            <div class="box notification is-success">
              <div class="heading">Test Cases</div>
              <div class="title">670</div>
            </div>
          </div>
          <div class="column">
            <div class="box notification is-warning">
              <div class="heading">Smelled Test Suites</div>
              <div class="title">7</div>
            </div>
          </div>
          <div class="column">
            <div class="box notification is-danger">
              <div class="heading">Detected Smells</div>
              <div class="title">679</div>
            </div>
          </div>
        </div>

        <table class="table is-fullwidth" id="table-of-suites">
          <thead>
            <tr>
              <th>File</th>
              <th class="has-text-right">smells</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td>
                <a class="toggle-link" href="javascript:;" onclick="toggleDetails(this)">+ &#x2F;home&#x2F;gabriel&#x2F;Desktop&#x2F;research&#x2F;projects&#x2F;katex&#x2F;test&#x2F;unicode-spec.js</a>
              </td>
              <td class="has-text-right">33</td>
            </tr>
            <tr class="details-row hidden">
              <td colspan="2">
                <div class="columns is-multiline is-centered">
                  <div class="column is-one-quarter">
                    <div class="box px-4 py-4">
                      <div class="heading">Physical SLOC</div>
                      <div class="title has-text-weight-light is-size-4">168</div>
                    </div>
                  </div>
                  <div class="column is-one-quarter">
                    <div class="box px-4 py-4">
                      <div class="heading">Logical SLOC</div>
                      <div class="title has-text-weight-light is-size-4">168</div>
                    </div>
                  </div>
                  <div class="column is-one-quarter">
                    <div class="box px-4 py-4">
                      <div class="heading">Cyclomatic</div>
                      <div class="title has-text-weight-light is-size-4">36</div>
                    </div>
                  </div>
                  <div class="column is-one-quarter">
                    <div class="box px-4 py-4">
                      <div class="heading">Cyclomatic Density</div>
                      <div class="title has-text-weight-light is-size-4">21.429</div>
                    </div>
                  </div>
                  <div class="column is-one-quarter">
                    <div class="box px-4 py-4">
                      <div class="heading">Halstead Bugs</div>
                      <div class="title has-text-weight-light is-size-4">1.245</div>
                    </div>
                  </div>
                  <div class="column is-one-quarter">
                    <div class="box px-4 py-4">
                      <div class="heading">Halstead Difficulty</div>
                      <div class="title has-text-weight-light is-size-4">25.636</div>
                    </div>
                  </div>
                  <div class="column is-one-quarter">
                    <div class="box px-4 py-4">
                      <div class="heading">Halstead effort</div>
                      <div class="title has-text-weight-light is-size-4">95774.883</div>
                    </div>
                  </div>
                  <div class="column is-one-quarter">
                    <div class="box px-4 py-4">
                      <div class="heading">Halstead Length</div>
                      <div class="title has-text-weight-light is-size-4">532</div>
                    </div>
                  </div>
                  <div class="column is-one-quarter">
                    <div class="box px-4 py-4">
                      <div class="heading">Halstead Time</div>
                      <div class="title has-text-weight-light is-size-4">5320.827</div>
                    </div>
                  </div>
                  <div class="column is-one-quarter">
                    <div class="box px-4 py-4">
                      <div class="heading">Halstead Vocabulary</div>
                      <div class="title has-text-weight-light is-size-4">130</div>
                    </div>
                  </div>
                  <div class="column is-one-quarter">
                    <div class="box px-4 py-4">
                      <div class="heading">Halstead Volume</div>
                      <div class="title has-text-weight-light is-size-4">3735.9</div>
                    </div>
                  </div>
                  <div class="column is-one-quarter">
                    <div class="box px-4 py-4">
                      <div class="heading">Maintainability</div>
                      <div class="title has-text-weight-light is-size-4">115.991</div>
                    </div>
                  </div>
                </div>
                <hr>
                <table class="table is-fullwidth" id="table-of-smell">
                  <thead>
                    <tr>
                      <td>Conditional Test Logic</td>
                    </tr>
                  </thead>
                  <tbody>
                    <tr>
                      <td>
                        <pre><code>  18 |     it(&quot;should not parse Latin-1 outside \\text{} with strict&quot;, function() {
  19 |         const chars &#x3D; &#39;ÀÁÂÃÄÅÈÉÊËÌÍÎÏÑÒÓÔÕÖÙÚÛÜÝàáâãäåèéêëìíîïñòóôõöùúûüýÿÇÐÞçþ&#39;;
&gt; 20 |         for (const ch of chars) {
     |        ^ Conditional Test Logic
  21 |             expect(ch).not.toParse(strictSettings);
  22 |         }
  23 |     });</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  142 |
  143 |     it(&quot;supportedCodepoint() should return the correct values&quot;, () &#x3D;&gt; {
&gt; 144 |         for (let codepoint &#x3D; 0; codepoint &lt;&#x3D; 0xffff; codepoint++) {
      |        ^ Conditional Test Logic
  145 |             expect(supportedCodepoint(codepoint)).toBe(
  146 |                 allRegExp.test(String.fromCharCode(codepoint))
  147 |             );</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  150 |
  151 |     it(&quot;scriptFromCodepoint() should return correct values&quot;, () &#x3D;&gt; {
&gt; 152 |         outer: for (let codepoint &#x3D; 0; codepoint &lt;&#x3D; 0xffff; codepoint++) {
      |               ^ Conditional Test Logic
  153 |             const character &#x3D; String.fromCharCode(codepoint);
  154 |             const script &#x3D; scriptFromCodepoint(codepoint);
  155 |</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  154 |             const script &#x3D; scriptFromCodepoint(codepoint);
  155 |
&gt; 156 |             for (const scriptName of scriptNames) {
      |            ^ Conditional Test Logic
  157 |                 if (scriptRegExps[scriptName].test(character)) {
  158 |                     expect(script).toEqual(scriptName);
  159 |                     continue outer;</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  155 |
  156 |             for (const scriptName of scriptNames) {
&gt; 157 |                 if (scriptRegExps[scriptName].test(character)) {
      |                ^ Conditional Test Logic
  158 |                     expect(script).toEqual(scriptName);
  159 |                     continue outer;
  160 |                 }</code></pre><br>
                      </td>
                    </tr>
                  </tbody>
                </table>
                <hr>
                <table class="table is-fullwidth" id="table-of-smell">
                  <thead>
                    <tr>
                      <td>Duplicate Assert</td>
                    </tr>
                  </thead>
                  <tbody>
                    <tr>
                      <td>
                        <pre><code>  156 |             for (const scriptName of scriptNames) {
  157 |                 if (scriptRegExps[scriptName].test(character)) {
&gt; 158 |                     expect(script).toEqual(scriptName);
      |                    ^ Duplicate Assert
  159 |                     continue outer;
  160 |                 }
  161 |             }</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  161 |             }
  162 |
&gt; 163 |             expect(script).toBe(null);
      |            ^ Duplicate Assert
  164 |             expect(supportedCodepoint(codepoint)).toBe(false);
  165 |         }
  166 |     });</code></pre><br>
                      </td>
                    </tr>
                  </tbody>
                </table>
                <hr>
                <table class="table is-fullwidth" id="table-of-smell">
                  <thead>
                    <tr>
                      <td>Eager Test</td>
                    </tr>
                  </thead>
                  <tbody>
                    <tr>
                      <td>
                        <pre><code>  152 |         outer: for (let codepoint &#x3D; 0; codepoint &lt;&#x3D; 0xffff; codepoint++) {
  153 |             const character &#x3D; String.fromCharCode(codepoint);
&gt; 154 |             const script &#x3D; scriptFromCodepoint(codepoint);
      |                           ^ Eager Test
  155 |
  156 |             for (const scriptName of scriptNames) {
  157 |                 if (scriptRegExps[scriptName].test(character)) {</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  162 |
  163 |             expect(script).toBe(null);
&gt; 164 |             expect(supportedCodepoint(codepoint)).toBe(false);
      |                   ^ Eager Test
  165 |         }
  166 |     });
  167 | });</code></pre><br>
                      </td>
                    </tr>
                  </tbody>
                </table>
                <hr>
                <table class="table is-fullwidth" id="table-of-smell">
                  <thead>
                    <tr>
                      <td>Lazy Test</td>
                    </tr>
                  </thead>
                  <tbody>
                    <tr>
                      <td>
                        <pre><code>  143 |     it(&quot;supportedCodepoint() should return the correct values&quot;, () &#x3D;&gt; {
  144 |         for (let codepoint &#x3D; 0; codepoint &lt;&#x3D; 0xffff; codepoint++) {
&gt; 145 |             expect(supportedCodepoint(codepoint)).toBe(
      |                   ^ Lazy Test
  146 |                 allRegExp.test(String.fromCharCode(codepoint))
  147 |             );
  148 |         }</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  162 |
  163 |             expect(script).toBe(null);
&gt; 164 |             expect(supportedCodepoint(codepoint)).toBe(false);
      |                   ^ Lazy Test
  165 |         }
  166 |     });
  167 | });</code></pre><br>
                      </td>
                    </tr>
                  </tbody>
                </table>
                <hr>
                <table class="table is-fullwidth" id="table-of-smell">
                  <thead>
                    <tr>
                      <td>Unknown Test</td>
                    </tr>
                  </thead>
                  <tbody>
                    <tr>
                      <td>
                        <pre><code>   5 |
   6 | describe(&quot;unicode&quot;, function() {
&gt;  7 |     it(&quot;should build Latin-1 inside \\text{}&quot;, function() {
     |    ^ Unknown Test
   8 |         expect&#x60;\text{ÀÁÂÃÄÅÈÉÊËÌÍÎÏÑÒÓÔÕÖÙÚÛÜÝàáâãäåèéêëìíîïñòóôõöùúûüýÿÆÇÐØÞßæçðøþ}&#x60;
   9 |             .toBuild();
  10 |     });</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  10 |     });
  11 |
&gt; 12 |     it(&quot;should build Latin-1 inside \\text{} like accent commands&quot;, function() {
     |    ^ Unknown Test
  13 |         expect&#x60;\text{ÀÁÂÃÄÅÈÉÊËÌÍÎÏÑÒÓÔÕÖÙÚÛÜÝàáâãäåèéêëìíîïñòóôõöùúûüýÿÇç}&#x60;
  14 |             .toParseLike&#x60;\text{\&#x60;A\&#39;A\^A\~A\&quot;A\r A\&#x60;E\&#39;E\^E\&quot;E\&#x60;I\&#39;I\^I\&quot;I\~N\&#x60;O\&#39;O\^O\~O\&quot;O\&#x60;U\&#39;U\^U\&quot;U\&#39;Y\&#x60;a\&#39;a\^a\~a\&quot;a\r a\&#x60;e\&#39;e\^e\&quot;e\&#x60;ı\&#39;ı\^ı\&quot;ı\~n\&#x60;o\&#39;o\^o\~o\&quot;o\&#x60;u\&#39;u\^u\&quot;u\&#39;y\&quot;y\c C\c c}&#x60;;
  15 |         &#x2F;&#x2F; TODO(edemaine): A few characters don&#39;t have analogs yet.</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  23 |     });
  24 |
&gt; 25 |     it(&quot;should build Latin-1 outside \\text{}&quot;, function() {
     |    ^ Unknown Test
  26 |         expect&#x60;ÀÁÂÃÄÅÈÉÊËÌÍÎÏÑÒÓÔÕÖÙÚÛÜÝàáâãäåèéêëìíîïñòóôõöùúûüýÿÇÐÞçðþ&#x60;
  27 |             .toBuild(nonstrictSettings);
  28 |     });</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  28 |     });
  29 |
&gt; 30 |     it(&quot;should build all lower case Greek letters&quot;, function() {
     |    ^ Unknown Test
  31 |         expect&#x60;αβγδεϵζηθϑικλμνξοπϖρϱςστυφϕχψω&#x60;.toBuild();
  32 |     });
  33 |</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  32 |     });
  33 |
&gt; 34 |     it(&quot;should build math upper case Greek letters&quot;, function() {
     |    ^ Unknown Test
  35 |         expect&#x60;ΓΔΘΛΞΠΣΥΦΨΩ&#x60;.toBuild();
  36 |     });
  37 |</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  36 |     });
  37 |
&gt; 38 |     it(&quot;should build Cyrillic inside \\text{}&quot;, function() {
     |    ^ Unknown Test
  39 |         expect&#x60;\text{БГДЖЗЙЛФЦШЫЮЯ}&#x60;.toBuild();
  40 |     });
  41 |</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  40 |     });
  41 |
&gt; 42 |     it(&quot;should build Cyrillic outside \\text{}&quot;, function() {
     |    ^ Unknown Test
  43 |         expect&#x60;БГДЖЗЙЛФЦШЫЮЯ&#x60;.toBuild(nonstrictSettings);
  44 |     });
  45 |</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  44 |     });
  45 |
&gt; 46 |     it(&quot;should not parse Cyrillic outside \\text{} with strict&quot;, function() {
     |    ^ Unknown Test
  47 |         expect&#x60;БГДЖЗЙЛФЦШЫЮЯ&#x60;.not.toParse(strictSettings);
  48 |     });
  49 |</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  48 |     });
  49 |
&gt; 50 |     it(&quot;should build CJK inside \\text{}&quot;, function() {
     |    ^ Unknown Test
  51 |         expect&#x60;\text{私はバナナです}&#x60;.toBuild();
  52 |         expect&#x60;\text{여보세요}&#x60;.toBuild();
  53 |     });</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  53 |     });
  54 |
&gt; 55 |     it(&quot;should build CJK outside \\text{}&quot;, function() {
     |    ^ Unknown Test
  56 |         expect&#x60;私はバナナです&#x60;.toBuild(nonstrictSettings);
  57 |         expect&#x60;여보세요&#x60;.toBuild(nonstrictSettings);
  58 |     });</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  58 |     });
  59 |
&gt; 60 |     it(&quot;should not parse CJK outside \\text{} with strict&quot;, function() {
     |    ^ Unknown Test
  61 |         expect&#x60;私はバナナです。&#x60;.not.toParse(strictSettings);
  62 |         expect&#x60;여보세요&#x60;.not.toParse(strictSettings);
  63 |     });</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  63 |     });
  64 |
&gt; 65 |     it(&quot;should build Devanagari inside \\text{}&quot;, function() {
     |    ^ Unknown Test
  66 |         expect&#x60;\text{नमस्ते}&#x60;.toBuild();
  67 |     });
  68 |</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  67 |     });
  68 |
&gt; 69 |     it(&quot;should build Devanagari outside \\text{}&quot;, function() {
     |    ^ Unknown Test
  70 |         expect&#x60;नमस्ते&#x60;.toBuild(nonstrictSettings);
  71 |     });
  72 |</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  71 |     });
  72 |
&gt; 73 |     it(&quot;should not parse Devanagari outside \\text{} with strict&quot;, function() {
     |    ^ Unknown Test
  74 |         expect&#x60;नमस्ते&#x60;.not.toParse(strictSettings);
  75 |     });
  76 |</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  75 |     });
  76 |
&gt; 77 |     it(&quot;should build Georgian inside \\text{}&quot;, function() {
     |    ^ Unknown Test
  78 |         expect&#x60;\text{გამარჯობა}&#x60;.toBuild();
  79 |     });
  80 |</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  79 |     });
  80 |
&gt; 81 |     it(&quot;should build Georgian outside \\text{}&quot;, function() {
     |    ^ Unknown Test
  82 |         expect&#x60;გამარჯობა&#x60;.toBuild(nonstrictSettings);
  83 |     });
  84 |</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  83 |     });
  84 |
&gt; 85 |     it(&quot;should not parse Georgian outside \\text{} with strict&quot;, function() {
     |    ^ Unknown Test
  86 |         expect&#x60;გამარჯობა&#x60;.not.toParse(strictSettings);
  87 |     });
  88 |</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  87 |     });
  88 |
&gt; 89 |     it(&quot;should build Armenian both inside and outside \\text{}&quot;, function() {
     |    ^ Unknown Test
  90 |         expect&#x60;ԱԲԳաբգ&#x60;.toBuild(nonstrictSettings);
  91 |         expect&#x60;\text{ԱԲԳաբգ}&#x60;.toBuild(nonstrictSettings);
  92 |     });</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  92 |     });
  93 |
&gt; 94 |     it(&quot;should build extended Latin characters inside \\text{}&quot;, function() {
     |    ^ Unknown Test
  95 |         expect&#x60;\text{ěščřžůřťďňőİı}&#x60;.toBuild();
  96 |     });
  97 |</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>   96 |     });
   97 |
&gt;  98 |     it(&quot;should not parse extended Latin outside \\text{} with strict&quot;, function() {
      |    ^ Unknown Test
   99 |         expect&#x60;ěščřžůřťďňőİı&#x60;.not.toParse(strictSettings);
  100 |     });
  101 |</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  100 |     });
  101 |
&gt; 102 |     it(&quot;should not allow emoji in strict mode&quot;, function() {
      |    ^ Unknown Test
  103 |         expect&#x60;✌&#x60;.not.toParse(strictSettings);
  104 |         expect&#x60;\text{✌}&#x60;.not.toParse(strictSettings);
  105 |         const settings &#x3D; new Settings({</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  111 |     });
  112 |
&gt; 113 |     it(&quot;should allow emoji outside strict mode&quot;, function() {
      |    ^ Unknown Test
  114 |         expect&#x60;✌&#x60;.toWarn();
  115 |         expect&#x60;\text{✌}&#x60;.toWarn();
  116 |         const settings &#x3D; new Settings({</code></pre><br>
                      </td>
                    </tr>
                  </tbody>
                </table>
              </td>
            </tr>
            <tr>
              <td>
                <a class="toggle-link" href="javascript:;" onclick="toggleDetails(this)">+ &#x2F;home&#x2F;gabriel&#x2F;Desktop&#x2F;research&#x2F;projects&#x2F;katex&#x2F;test&#x2F;screenshotter-spec.js</a>
              </td>
              <td class="has-text-right">2</td>
            </tr>
            <tr class="details-row hidden">
              <td colspan="2">
                <div class="columns is-multiline is-centered">
                  <div class="column is-one-quarter">
                    <div class="box px-4 py-4">
                      <div class="heading">Physical SLOC</div>
                      <div class="title has-text-weight-light is-size-4">20</div>
                    </div>
                  </div>
                  <div class="column is-one-quarter">
                    <div class="box px-4 py-4">
                      <div class="heading">Logical SLOC</div>
                      <div class="title has-text-weight-light is-size-4">18</div>
                    </div>
                  </div>
                  <div class="column is-one-quarter">
                    <div class="box px-4 py-4">
                      <div class="heading">Cyclomatic</div>
                      <div class="title has-text-weight-light is-size-4">4</div>
                    </div>
                  </div>
                  <div class="column is-one-quarter">
                    <div class="box px-4 py-4">
                      <div class="heading">Cyclomatic Density</div>
                      <div class="title has-text-weight-light is-size-4">22.222</div>
                    </div>
                  </div>
                  <div class="column is-one-quarter">
                    <div class="box px-4 py-4">
                      <div class="heading">Halstead Bugs</div>
                      <div class="title has-text-weight-light is-size-4">0.125</div>
                    </div>
                  </div>
                  <div class="column is-one-quarter">
                    <div class="box px-4 py-4">
                      <div class="heading">Halstead Difficulty</div>
                      <div class="title has-text-weight-light is-size-4">10.292</div>
                    </div>
                  </div>
                  <div class="column is-one-quarter">
                    <div class="box px-4 py-4">
                      <div class="heading">Halstead effort</div>
                      <div class="title has-text-weight-light is-size-4">3860.205</div>
                    </div>
                  </div>
                  <div class="column is-one-quarter">
                    <div class="box px-4 py-4">
                      <div class="heading">Halstead Length</div>
                      <div class="title has-text-weight-light is-size-4">72</div>
                    </div>
                  </div>
                  <div class="column is-one-quarter">
                    <div class="box px-4 py-4">
                      <div class="heading">Halstead Time</div>
                      <div class="title has-text-weight-light is-size-4">214.456</div>
                    </div>
                  </div>
                  <div class="column is-one-quarter">
                    <div class="box px-4 py-4">
                      <div class="heading">Halstead Vocabulary</div>
                      <div class="title has-text-weight-light is-size-4">37</div>
                    </div>
                  </div>
                  <div class="column is-one-quarter">
                    <div class="box px-4 py-4">
                      <div class="heading">Halstead Volume</div>
                      <div class="title has-text-weight-light is-size-4">375.081</div>
                    </div>
                  </div>
                  <div class="column is-one-quarter">
                    <div class="box px-4 py-4">
                      <div class="heading">Maintainability</div>
                      <div class="title has-text-weight-light is-size-4">117.199</div>
                    </div>
                  </div>
                </div>
                <hr>
                <table class="table is-fullwidth" id="table-of-smell">
                  <thead>
                    <tr>
                      <td>Conditional Test Logic</td>
                    </tr>
                  </thead>
                  <tbody>
                    <tr>
                      <td>
                        <pre><code>  2 |
  3 | describe(&quot;Screenshotter item&quot;, function() {
&gt; 4 |     for (const key in data) {
    |    ^ Conditional Test Logic
  5 |         if (data.hasOwnProperty(key)) {
  6 |             const item &#x3D; data[key];
  7 |             it(&#x60;&quot;${item.tex}&quot; should build successfully&#x60;, function() {</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  3 | describe(&quot;Screenshotter item&quot;, function() {
  4 |     for (const key in data) {
&gt; 5 |         if (data.hasOwnProperty(key)) {
    |        ^ Conditional Test Logic
  6 |             const item &#x3D; data[key];
  7 |             it(&#x60;&quot;${item.tex}&quot; should build successfully&#x60;, function() {
  8 |                 expect(item.tex).toBuild({</code></pre><br>
                      </td>
                    </tr>
                  </tbody>
                </table>
              </td>
            </tr>
            <tr>
              <td>
                <a class="toggle-link" href="javascript:;" onclick="toggleDetails(this)">+ &#x2F;home&#x2F;gabriel&#x2F;Desktop&#x2F;research&#x2F;projects&#x2F;katex&#x2F;test&#x2F;mathml-spec.js</a>
              </td>
              <td class="has-text-right">1</td>
            </tr>
            <tr class="details-row hidden">
              <td colspan="2">
                <div class="columns is-multiline is-centered">
                  <div class="column is-one-quarter">
                    <div class="box px-4 py-4">
                      <div class="heading">Physical SLOC</div>
                      <div class="title has-text-weight-light is-size-4">154</div>
                    </div>
                  </div>
                  <div class="column is-one-quarter">
                    <div class="box px-4 py-4">
                      <div class="heading">Logical SLOC</div>
                      <div class="title has-text-weight-light is-size-4">156</div>
                    </div>
                  </div>
                  <div class="column is-one-quarter">
                    <div class="box px-4 py-4">
                      <div class="heading">Cyclomatic</div>
                      <div class="title has-text-weight-light is-size-4">27</div>
                    </div>
                  </div>
                  <div class="column is-one-quarter">
                    <div class="box px-4 py-4">
                      <div class="heading">Cyclomatic Density</div>
                      <div class="title has-text-weight-light is-size-4">17.308</div>
                    </div>
                  </div>
                  <div class="column is-one-quarter">
                    <div class="box px-4 py-4">
                      <div class="heading">Halstead Bugs</div>
                      <div class="title has-text-weight-light is-size-4">1.081</div>
                    </div>
                  </div>
                  <div class="column is-one-quarter">
                    <div class="box px-4 py-4">
                      <div class="heading">Halstead Difficulty</div>
                      <div class="title has-text-weight-light is-size-4">18.851</div>
                    </div>
                  </div>
                  <div class="column is-one-quarter">
                    <div class="box px-4 py-4">
                      <div class="heading">Halstead effort</div>
                      <div class="title has-text-weight-light is-size-4">61131.825</div>
                    </div>
                  </div>
                  <div class="column is-one-quarter">
                    <div class="box px-4 py-4">
                      <div class="heading">Halstead Length</div>
                      <div class="title has-text-weight-light is-size-4">472</div>
                    </div>
                  </div>
                  <div class="column is-one-quarter">
                    <div class="box px-4 py-4">
                      <div class="heading">Halstead Time</div>
                      <div class="title has-text-weight-light is-size-4">3396.213</div>
                    </div>
                  </div>
                  <div class="column is-one-quarter">
                    <div class="box px-4 py-4">
                      <div class="heading">Halstead Vocabulary</div>
                      <div class="title has-text-weight-light is-size-4">117</div>
                    </div>
                  </div>
                  <div class="column is-one-quarter">
                    <div class="box px-4 py-4">
                      <div class="heading">Halstead Volume</div>
                      <div class="title has-text-weight-light is-size-4">3242.812</div>
                    </div>
                  </div>
                  <div class="column is-one-quarter">
                    <div class="box px-4 py-4">
                      <div class="heading">Maintainability</div>
                      <div class="title has-text-weight-light is-size-4">115.387</div>
                    </div>
                  </div>
                </div>
                <hr>
                <table class="table is-fullwidth" id="table-of-smell">
                  <thead>
                    <tr>
                      <td>Conditional Test Logic</td>
                    </tr>
                  </thead>
                  <tbody>
                    <tr>
                      <td>
                        <pre><code>   7 | const getMathML &#x3D; function(expr, settings &#x3D; new Settings()) {
   8 |     let startStyle &#x3D; Style.TEXT;
&gt;  9 |     if (settings.displayMode) {
     |    ^ Conditional Test Logic
  10 |         startStyle &#x3D; Style.DISPLAY;
  11 |     }
  12 |</code></pre><br>
                      </td>
                    </tr>
                  </tbody>
                </table>
              </td>
            </tr>
            <tr>
              <td>
                <a class="toggle-link" href="javascript:;" onclick="toggleDetails(this)">+ &#x2F;home&#x2F;gabriel&#x2F;Desktop&#x2F;research&#x2F;projects&#x2F;katex&#x2F;test&#x2F;katex-spec.js</a>
              </td>
              <td class="has-text-right">566</td>
            </tr>
            <tr class="details-row hidden">
              <td colspan="2">
                <div class="columns is-multiline is-centered">
                  <div class="column is-one-quarter">
                    <div class="box px-4 py-4">
                      <div class="heading">Physical SLOC</div>
                      <div class="title has-text-weight-light is-size-4">4314</div>
                    </div>
                  </div>
                  <div class="column is-one-quarter">
                    <div class="box px-4 py-4">
                      <div class="heading">Logical SLOC</div>
                      <div class="title has-text-weight-light is-size-4">5523</div>
                    </div>
                  </div>
                  <div class="column is-one-quarter">
                    <div class="box px-4 py-4">
                      <div class="heading">Cyclomatic</div>
                      <div class="title has-text-weight-light is-size-4">730</div>
                    </div>
                  </div>
                  <div class="column is-one-quarter">
                    <div class="box px-4 py-4">
                      <div class="heading">Cyclomatic Density</div>
                      <div class="title has-text-weight-light is-size-4">13.217</div>
                    </div>
                  </div>
                  <div class="column is-one-quarter">
                    <div class="box px-4 py-4">
                      <div class="heading">Halstead Bugs</div>
                      <div class="title has-text-weight-light is-size-4">67.09</div>
                    </div>
                  </div>
                  <div class="column is-one-quarter">
                    <div class="box px-4 py-4">
                      <div class="heading">Halstead Difficulty</div>
                      <div class="title has-text-weight-light is-size-4">65.757</div>
                    </div>
                  </div>
                  <div class="column is-one-quarter">
                    <div class="box px-4 py-4">
                      <div class="heading">Halstead effort</div>
                      <div class="title has-text-weight-light is-size-4">13234748.707</div>
                    </div>
                  </div>
                  <div class="column is-one-quarter">
                    <div class="box px-4 py-4">
                      <div class="heading">Halstead Length</div>
                      <div class="title has-text-weight-light is-size-4">18069</div>
                    </div>
                  </div>
                  <div class="column is-one-quarter">
                    <div class="box px-4 py-4">
                      <div class="heading">Halstead Time</div>
                      <div class="title has-text-weight-light is-size-4">735263.817</div>
                    </div>
                  </div>
                  <div class="column is-one-quarter">
                    <div class="box px-4 py-4">
                      <div class="heading">Halstead Vocabulary</div>
                      <div class="title has-text-weight-light is-size-4">2255</div>
                    </div>
                  </div>
                  <div class="column is-one-quarter">
                    <div class="box px-4 py-4">
                      <div class="heading">Halstead Volume</div>
                      <div class="title has-text-weight-light is-size-4">201268.996</div>
                    </div>
                  </div>
                  <div class="column is-one-quarter">
                    <div class="box px-4 py-4">
                      <div class="heading">Maintainability</div>
                      <div class="title has-text-weight-light is-size-4">104.197</div>
                    </div>
                  </div>
                </div>
                <hr>
                <table class="table is-fullwidth" id="table-of-smell">
                  <thead>
                    <tr>
                      <td>Conditional Test Logic</td>
                    </tr>
                  </thead>
                  <tbody>
                    <tr>
                      <td>
                        <pre><code>  44 |         const parse &#x3D; getParsed(expression);
  45 |
&gt; 46 |         for (let i &#x3D; 0; i &lt; parse.length; i++) {
     |        ^ Conditional Test Logic
  47 |             const group &#x3D; parse[i];
  48 |             expect(group.type).toMatch(&quot;ord&quot;);
  49 |         }</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  67 |         const parse &#x3D; getParsed(expression);
  68 |
&gt; 69 |         for (let i &#x3D; 0; i &lt; parse.length; i++) {
     |        ^ Conditional Test Logic
  70 |             const group &#x3D; parse[i];
  71 |             expect(group.type).toEqual(&quot;atom&quot;);
  72 |             expect(group.family).toEqual(&quot;bin&quot;);</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  87 |         const parse &#x3D; getParsed(expression);
  88 |
&gt; 89 |         for (let i &#x3D; 0; i &lt; parse.length; i++) {
     |        ^ Conditional Test Logic
  90 |             let group &#x3D; parse[i];
  91 |             if (group.type &#x3D;&#x3D;&#x3D; &quot;htmlmathml&quot;) {
  92 |                 expect(group.html).toHaveLength(1);</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  89 |         for (let i &#x3D; 0; i &lt; parse.length; i++) {
  90 |             let group &#x3D; parse[i];
&gt; 91 |             if (group.type &#x3D;&#x3D;&#x3D; &quot;htmlmathml&quot;) {
     |            ^ Conditional Test Logic
  92 |                 expect(group.html).toHaveLength(1);
  93 |                 group &#x3D; group.html[0];
  94 |             }</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  93 |                 group &#x3D; group.html[0];
  94 |             }
&gt; 95 |             if (group.type &#x3D;&#x3D;&#x3D; &quot;mclass&quot;) {
     |            ^ Conditional Test Logic
  96 |                 expect(group.mclass).toEqual(&quot;mrel&quot;);
  97 |             } else {
  98 |                 expect(group.type).toEqual(&quot;atom&quot;);</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  126 |         const parse &#x3D; getParsed(expression);
  127 |
&gt; 128 |         for (let i &#x3D; 0; i &lt; parse.length; i++) {
      |        ^ Conditional Test Logic
  129 |             const group &#x3D; parse[i];
  130 |             expect(group.type).toEqual(&quot;atom&quot;);
  131 |             expect(group.family).toEqual(&quot;punct&quot;);</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  144 |         const parse &#x3D; getParsed(expression);
  145 |
&gt; 146 |         for (let i &#x3D; 0; i &lt; parse.length; i++) {
      |        ^ Conditional Test Logic
  147 |             const group &#x3D; parse[i];
  148 |             expect(group.type).toEqual(&quot;atom&quot;);
  149 |             expect(group.family).toEqual(&quot;open&quot;);</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  162 |         const parse &#x3D; getParsed(expression);
  163 |
&gt; 164 |         for (let i &#x3D; 0; i &lt; parse.length; i++) {
      |        ^ Conditional Test Logic
  165 |             const group &#x3D; parse[i];
  166 |             expect(group.type).toEqual(&quot;atom&quot;);
  167 |             expect(group.family).toEqual(&quot;close&quot;);</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  1260 |     ];
  1261 |
&gt; 1262 |     for (const [actual, expected] of cases) {
       |    ^ Conditional Test Logic
  1263 |         it(&#x60;should build &quot;${actual}&quot; like &quot;${expected}&quot;&#x60;, () &#x3D;&gt; {
  1264 |             expect(actual).toBuildLike(expected);
  1265 |         });</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  1409 |         ];
  1410 |
&gt; 1411 |         for (let i &#x3D; 0; i &lt; missingGroups.length; i++) {
       |        ^ Conditional Test Logic
  1412 |             expect(missingGroups[i]).not.toParse();
  1413 |         }
  1414 |     });</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  1436 |         ];
  1437 |
&gt; 1438 |         for (let i &#x3D; 0; i &lt; badArguments.length; i++) {
       |        ^ Conditional Test Logic
  1439 |             expect(badArguments[i]).not.toParse();
  1440 |         }
  1441 |     });</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  1454 |         ];
  1455 |
&gt; 1456 |         for (let i &#x3D; 0; i &lt; goodArguments.length; i++) {
       |        ^ Conditional Test Logic
  1457 |             expect(goodArguments[i]).toParse();
  1458 |         }
  1459 |     });</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  1467 |         ];
  1468 |
&gt; 1469 |         for (let i &#x3D; 0; i &lt; badSupSubscripts.length; i++) {
       |        ^ Conditional Test Logic
  1470 |             expect(badSupSubscripts[i]).not.toParse();
  1471 |         }
  1472 |     });</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  1480 |         ];
  1481 |
&gt; 1482 |         for (let i &#x3D; 0; i &lt; goodSupSubscripts.length; i++) {
       |        ^ Conditional Test Logic
  1483 |             expect(goodSupSubscripts[i]).toParse();
  1484 |         }
  1485 |     });</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  1518 |         ];
  1519 |
&gt; 1520 |         for (let i &#x3D; 0; i &lt; badLeftArguments.length; i++) {
       |        ^ Conditional Test Logic
  1521 |             expect(badLeftArguments[i]).not.toParse();
  1522 |         }
  1523 |     });</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  1532 |         ];
  1533 |
&gt; 1534 |         for (let i &#x3D; 0; i &lt; goodLeftArguments.length; i++) {
       |        ^ Conditional Test Logic
  1535 |             expect(goodLeftArguments[i]).toParse();
  1536 |         }
  1537 |     });</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  2170 |
  2171 |     it(&quot;should throw Error when HTML attribute name is invalid&quot;, function() {
&gt; 2172 |         for (const char of [&quot;&gt;&quot;, &quot; &quot;, &quot;\t&quot;, &quot;\n&quot;, &quot;\r&quot;, &quot;\&quot;&quot;, &quot;&#39;&quot;, &quot;&#x2F;&quot;]) {
       |        ^ Conditional Test Logic
  2173 |             try {
  2174 |                 katex.renderToString(
  2175 |                     &#x60;\\htmlData{a${char}b&#x3D;foo}{bar}&#x60;, trustNonStrictSettings);</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  3833 | describe(&quot;leqno and fleqn rendering options&quot;, () &#x3D;&gt; {
  3834 |     const expr &#x3D; r&#x60;\tag{hi}x+y&#x60;;
&gt; 3835 |     for (const opt of [&quot;leqno&quot;, &quot;fleqn&quot;]) {
       |    ^ Conditional Test Logic
  3836 |         it(&#x60;should not add ${opt} class by default&#x60;, () &#x3D;&gt; {
  3837 |             const settings &#x3D; new Settings({displayMode: true});
  3838 |             const built &#x3D; katex.__renderToDomTree(expr, settings);</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  4238 |         &#x2F;&#x2F; add eastern arabic numbers to symbols table
  4239 |         &#x2F;&#x2F; these symbols are ۰۱۲۳۴۵۶۷۸۹ and ٠١٢٣٤٥٦٧٨٩
&gt; 4240 |         for (let number &#x3D; 0; number &lt;&#x3D; 9; number++) {
       |        ^ Conditional Test Logic
  4241 |             const persianNum &#x3D; String.fromCharCode(0x0660 + number);
  4242 |             katex.__defineSymbol(
  4243 |                 &quot;math&quot;, fontName, &quot;textord&quot;, persianNum, persianNum);</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  4257 |         const mockMetrics &#x3D; {};
  4258 |         &#x2F;&#x2F; mock font metrics for the symbols that we added previously
&gt; 4259 |         for (let number &#x3D; 0; number &lt;&#x3D; 9; number++) {
       |        ^ Conditional Test Logic
  4260 |             mockMetrics[0x0660 + number] &#x3D; [-0.00244140625, 0.6875, 0, 0];
  4261 |             mockMetrics[0x06F0 + number] &#x3D; [-0.00244140625, 0.6875, 0, 0];
  4262 |         }</code></pre><br>
                      </td>
                    </tr>
                  </tbody>
                </table>
                <hr>
                <table class="table is-fullwidth" id="table-of-smell">
                  <thead>
                    <tr>
                      <td>Duplicate Assert</td>
                    </tr>
                  </thead>
                  <tbody>
                    <tr>
                      <td>
                        <pre><code>  572 |         parse &#x3D; getParsed(simpleOver)[0];
  573 |
&gt; 574 |         expect(parse.type).toEqual(&quot;genfrac&quot;);
      |        ^ Duplicate Assert
  575 |         expect(parse.numer).toBeDefined();
  576 |         expect(parse.denom).toBeDefined();
  577 |</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  572 |         parse &#x3D; getParsed(simpleOver)[0];
  573 |
&gt; 574 |         expect(parse.type).toEqual(&quot;genfrac&quot;);
      |        ^ Duplicate Assert
  575 |         expect(parse.numer).toBeDefined();
  576 |         expect(parse.denom).toBeDefined();
  577 |</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  573 |
  574 |         expect(parse.type).toEqual(&quot;genfrac&quot;);
&gt; 575 |         expect(parse.numer).toBeDefined();
      |        ^ Duplicate Assert
  576 |         expect(parse.denom).toBeDefined();
  577 |
  578 |         parse &#x3D; getParsed(complexOver)[0];</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  573 |
  574 |         expect(parse.type).toEqual(&quot;genfrac&quot;);
&gt; 575 |         expect(parse.numer).toBeDefined();
      |        ^ Duplicate Assert
  576 |         expect(parse.denom).toBeDefined();
  577 |
  578 |         parse &#x3D; getParsed(complexOver)[0];</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  574 |         expect(parse.type).toEqual(&quot;genfrac&quot;);
  575 |         expect(parse.numer).toBeDefined();
&gt; 576 |         expect(parse.denom).toBeDefined();
      |        ^ Duplicate Assert
  577 |
  578 |         parse &#x3D; getParsed(complexOver)[0];
  579 |</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  574 |         expect(parse.type).toEqual(&quot;genfrac&quot;);
  575 |         expect(parse.numer).toBeDefined();
&gt; 576 |         expect(parse.denom).toBeDefined();
      |        ^ Duplicate Assert
  577 |
  578 |         parse &#x3D; getParsed(complexOver)[0];
  579 |</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  578 |         parse &#x3D; getParsed(complexOver)[0];
  579 |
&gt; 580 |         expect(parse.type).toEqual(&quot;genfrac&quot;);
      |        ^ Duplicate Assert
  581 |         expect(parse.numer).toBeDefined();
  582 |         expect(parse.denom).toBeDefined();
  583 |</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  578 |         parse &#x3D; getParsed(complexOver)[0];
  579 |
&gt; 580 |         expect(parse.type).toEqual(&quot;genfrac&quot;);
      |        ^ Duplicate Assert
  581 |         expect(parse.numer).toBeDefined();
  582 |         expect(parse.denom).toBeDefined();
  583 |</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  579 |
  580 |         expect(parse.type).toEqual(&quot;genfrac&quot;);
&gt; 581 |         expect(parse.numer).toBeDefined();
      |        ^ Duplicate Assert
  582 |         expect(parse.denom).toBeDefined();
  583 |
  584 |         const parseBraceFrac &#x3D; getParsed(braceFrac)[0];</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  579 |
  580 |         expect(parse.type).toEqual(&quot;genfrac&quot;);
&gt; 581 |         expect(parse.numer).toBeDefined();
      |        ^ Duplicate Assert
  582 |         expect(parse.denom).toBeDefined();
  583 |
  584 |         const parseBraceFrac &#x3D; getParsed(braceFrac)[0];</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  580 |         expect(parse.type).toEqual(&quot;genfrac&quot;);
  581 |         expect(parse.numer).toBeDefined();
&gt; 582 |         expect(parse.denom).toBeDefined();
      |        ^ Duplicate Assert
  583 |
  584 |         const parseBraceFrac &#x3D; getParsed(braceFrac)[0];
  585 |</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  580 |         expect(parse.type).toEqual(&quot;genfrac&quot;);
  581 |         expect(parse.numer).toBeDefined();
&gt; 582 |         expect(parse.denom).toBeDefined();
      |        ^ Duplicate Assert
  583 |
  584 |         const parseBraceFrac &#x3D; getParsed(braceFrac)[0];
  585 |</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  1637 |         expect(bbBody).toHaveLength(3);
  1638 |         expect(bbBody[0].type).toEqual(&quot;mathord&quot;);
&gt; 1639 |         expect(bbBody[2].type).toEqual(&quot;font&quot;);
       |        ^ Duplicate Assert
  1640 |         expect(bbBody[2].font).toEqual(&quot;mathrm&quot;);
  1641 |         expect(bbBody[2].type).toEqual(&quot;font&quot;);
  1642 |     });</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  1637 |         expect(bbBody).toHaveLength(3);
  1638 |         expect(bbBody[0].type).toEqual(&quot;mathord&quot;);
&gt; 1639 |         expect(bbBody[2].type).toEqual(&quot;font&quot;);
       |        ^ Duplicate Assert
  1640 |         expect(bbBody[2].font).toEqual(&quot;mathrm&quot;);
  1641 |         expect(bbBody[2].type).toEqual(&quot;font&quot;);
  1642 |     });</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  1639 |         expect(bbBody[2].type).toEqual(&quot;font&quot;);
  1640 |         expect(bbBody[2].font).toEqual(&quot;mathrm&quot;);
&gt; 1641 |         expect(bbBody[2].type).toEqual(&quot;font&quot;);
       |        ^ Duplicate Assert
  1642 |     });
  1643 |
  1644 |     it(&quot;should work with \\textcolor&quot;, function() {</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  1639 |         expect(bbBody[2].type).toEqual(&quot;font&quot;);
  1640 |         expect(bbBody[2].font).toEqual(&quot;mathrm&quot;);
&gt; 1641 |         expect(bbBody[2].type).toEqual(&quot;font&quot;);
       |        ^ Duplicate Assert
  1642 |     });
  1643 |
  1644 |     it(&quot;should work with \\textcolor&quot;, function() {</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  1832 |     it(&quot;should render \\text{R\\textit{S}T} with the correct fonts&quot;, function() {
  1833 |         const markup &#x3D; katex.renderToString(r&#x60;\text{R\textit{S}T}&#x60;);
&gt; 1834 |         expect(markup).toContain(&quot;&lt;span class&#x3D;\&quot;mord\&quot;&gt;R&lt;&#x2F;span&gt;&quot;);
       |        ^ Duplicate Assert
  1835 |         expect(markup).toContain(&quot;&lt;span class&#x3D;\&quot;mord textit\&quot;&gt;S&lt;&#x2F;span&gt;&quot;);
  1836 |         expect(markup).toContain(&quot;&lt;span class&#x3D;\&quot;mord\&quot;&gt;T&lt;&#x2F;span&gt;&quot;);
  1837 |     });</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  1833 |         const markup &#x3D; katex.renderToString(r&#x60;\text{R\textit{S}T}&#x60;);
  1834 |         expect(markup).toContain(&quot;&lt;span class&#x3D;\&quot;mord\&quot;&gt;R&lt;&#x2F;span&gt;&quot;);
&gt; 1835 |         expect(markup).toContain(&quot;&lt;span class&#x3D;\&quot;mord textit\&quot;&gt;S&lt;&#x2F;span&gt;&quot;);
       |        ^ Duplicate Assert
  1836 |         expect(markup).toContain(&quot;&lt;span class&#x3D;\&quot;mord\&quot;&gt;T&lt;&#x2F;span&gt;&quot;);
  1837 |     });
  1838 |</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  1834 |         expect(markup).toContain(&quot;&lt;span class&#x3D;\&quot;mord\&quot;&gt;R&lt;&#x2F;span&gt;&quot;);
  1835 |         expect(markup).toContain(&quot;&lt;span class&#x3D;\&quot;mord textit\&quot;&gt;S&lt;&#x2F;span&gt;&quot;);
&gt; 1836 |         expect(markup).toContain(&quot;&lt;span class&#x3D;\&quot;mord\&quot;&gt;T&lt;&#x2F;span&gt;&quot;);
       |        ^ Duplicate Assert
  1837 |     });
  1838 |
  1839 |     it(&quot;should render \\textbf{R } with the correct font&quot;, function() {</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  1858 |     it(&quot;should render \\textsf{\\textit{R}G\\textbf{B}} with the correct font&quot;, function() {
  1859 |         const markup &#x3D; katex.renderToString(r&#x60;\textsf{\textit{R}G\textbf{B}}&#x60;);
&gt; 1860 |         expect(markup).toContain(&quot;&lt;span class&#x3D;\&quot;mord textsf textit\&quot;&gt;R&lt;&#x2F;span&gt;&quot;);
       |        ^ Duplicate Assert
  1861 |         expect(markup).toContain(&quot;&lt;span class&#x3D;\&quot;mord textsf\&quot;&gt;G&lt;&#x2F;span&gt;&quot;);
  1862 |         expect(markup).toContain(&quot;&lt;span class&#x3D;\&quot;mord textsf textbf\&quot;&gt;B&lt;&#x2F;span&gt;&quot;);
  1863 |     });</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  1859 |         const markup &#x3D; katex.renderToString(r&#x60;\textsf{\textit{R}G\textbf{B}}&#x60;);
  1860 |         expect(markup).toContain(&quot;&lt;span class&#x3D;\&quot;mord textsf textit\&quot;&gt;R&lt;&#x2F;span&gt;&quot;);
&gt; 1861 |         expect(markup).toContain(&quot;&lt;span class&#x3D;\&quot;mord textsf\&quot;&gt;G&lt;&#x2F;span&gt;&quot;);
       |        ^ Duplicate Assert
  1862 |         expect(markup).toContain(&quot;&lt;span class&#x3D;\&quot;mord textsf textbf\&quot;&gt;B&lt;&#x2F;span&gt;&quot;);
  1863 |     });
  1864 |</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  1860 |         expect(markup).toContain(&quot;&lt;span class&#x3D;\&quot;mord textsf textit\&quot;&gt;R&lt;&#x2F;span&gt;&quot;);
  1861 |         expect(markup).toContain(&quot;&lt;span class&#x3D;\&quot;mord textsf\&quot;&gt;G&lt;&#x2F;span&gt;&quot;);
&gt; 1862 |         expect(markup).toContain(&quot;&lt;span class&#x3D;\&quot;mord textsf textbf\&quot;&gt;B&lt;&#x2F;span&gt;&quot;);
       |        ^ Duplicate Assert
  1863 |     });
  1864 |
  1865 |     it(&quot;should render \\textsf{\\textbf{$\\mathrm{A}$}} with the correct font&quot;, function() {</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  1881 |         let markup &#x3D; katex.renderToString(r&#x60;\textcolor{blue}{\mathbb R}&#x60;);
  1882 |         let span &#x3D; &quot;&lt;span class&#x3D;\&quot;mord mathbb\&quot; style&#x3D;\&quot;color:blue;\&quot;&gt;R&lt;&#x2F;span&gt;&quot;;
&gt; 1883 |         expect(markup).toContain(span);
       |        ^ Duplicate Assert
  1884 |
  1885 |         markup &#x3D; katex.renderToString(r&#x60;\mathbb{\textcolor{blue}{R}}&#x60;);
  1886 |         span &#x3D; &quot;&lt;span class&#x3D;\&quot;mord mathbb\&quot; style&#x3D;\&quot;color:blue;\&quot;&gt;R&lt;&#x2F;span&gt;&quot;;</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  1881 |         let markup &#x3D; katex.renderToString(r&#x60;\textcolor{blue}{\mathbb R}&#x60;);
  1882 |         let span &#x3D; &quot;&lt;span class&#x3D;\&quot;mord mathbb\&quot; style&#x3D;\&quot;color:blue;\&quot;&gt;R&lt;&#x2F;span&gt;&quot;;
&gt; 1883 |         expect(markup).toContain(span);
       |        ^ Duplicate Assert
  1884 |
  1885 |         markup &#x3D; katex.renderToString(r&#x60;\mathbb{\textcolor{blue}{R}}&#x60;);
  1886 |         span &#x3D; &quot;&lt;span class&#x3D;\&quot;mord mathbb\&quot; style&#x3D;\&quot;color:blue;\&quot;&gt;R&lt;&#x2F;span&gt;&quot;;</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  1885 |         markup &#x3D; katex.renderToString(r&#x60;\mathbb{\textcolor{blue}{R}}&#x60;);
  1886 |         span &#x3D; &quot;&lt;span class&#x3D;\&quot;mord mathbb\&quot; style&#x3D;\&quot;color:blue;\&quot;&gt;R&lt;&#x2F;span&gt;&quot;;
&gt; 1887 |         expect(markup).toContain(span);
       |        ^ Duplicate Assert
  1888 |     });
  1889 |
  1890 |     it(&quot;should render wide characters with mord and with the correct font&quot;, function() {</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  1885 |         markup &#x3D; katex.renderToString(r&#x60;\mathbb{\textcolor{blue}{R}}&#x60;);
  1886 |         span &#x3D; &quot;&lt;span class&#x3D;\&quot;mord mathbb\&quot; style&#x3D;\&quot;color:blue;\&quot;&gt;R&lt;&#x2F;span&gt;&quot;;
&gt; 1887 |         expect(markup).toContain(span);
       |        ^ Duplicate Assert
  1888 |     });
  1889 |
  1890 |     it(&quot;should render wide characters with mord and with the correct font&quot;, function() {</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  2078 |             &quot;&lt;mi mathvariant&#x3D;\&quot;double-struck\&quot;&gt;R&lt;&#x2F;mi&gt;&quot; +
  2079 |             &quot;&lt;&#x2F;mstyle&gt;&quot;;
&gt; 2080 |         expect(markup).toContain(node);
       |        ^ Duplicate Assert
  2081 |
  2082 |         &#x2F;&#x2F; reverse the order of the commands
  2083 |         tex &#x3D; r&#x60;\mathbb{\textcolor{blue}{R}}&#x60;;</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  2078 |             &quot;&lt;mi mathvariant&#x3D;\&quot;double-struck\&quot;&gt;R&lt;&#x2F;mi&gt;&quot; +
  2079 |             &quot;&lt;&#x2F;mstyle&gt;&quot;;
&gt; 2080 |         expect(markup).toContain(node);
       |        ^ Duplicate Assert
  2081 |
  2082 |         &#x2F;&#x2F; reverse the order of the commands
  2083 |         tex &#x3D; r&#x60;\mathbb{\textcolor{blue}{R}}&#x60;;</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  2087 |             &quot;&lt;mi mathvariant&#x3D;\&quot;double-struck\&quot;&gt;R&lt;&#x2F;mi&gt;&quot; +
  2088 |             &quot;&lt;&#x2F;mstyle&gt;&quot;;
&gt; 2089 |         expect(markup).toContain(node);
       |        ^ Duplicate Assert
  2090 |     });
  2091 |
  2092 |     it(&quot;should render text as &lt;mtext&gt;&quot;, function() {</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  2087 |             &quot;&lt;mi mathvariant&#x3D;\&quot;double-struck\&quot;&gt;R&lt;&#x2F;mi&gt;&quot; +
  2088 |             &quot;&lt;&#x2F;mstyle&gt;&quot;;
&gt; 2089 |         expect(markup).toContain(node);
       |        ^ Duplicate Assert
  2090 |     });
  2091 |
  2092 |     it(&quot;should render text as &lt;mtext&gt;&quot;, function() {</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  2101 |         const tree &#x3D; getParsed(tex);
  2102 |         const markup &#x3D; buildMathML(tree, tex, defaultOptions).toMarkup();
&gt; 2103 |         expect(markup).toContain(&quot;&lt;mrow&gt;&lt;mtext&gt;graph:\u00a0&lt;&#x2F;mtext&gt;&quot;);
       |        ^ Duplicate Assert
  2104 |         expect(markup).toContain(
  2105 |             &quot;&lt;mi&gt;y&lt;&#x2F;mi&gt;&lt;mo&gt;&#x3D;&lt;&#x2F;mo&gt;&lt;mi&gt;m&lt;&#x2F;mi&gt;&lt;mi&gt;x&lt;&#x2F;mi&gt;&lt;mo&gt;+&lt;&#x2F;mo&gt;&lt;mi&gt;b&lt;&#x2F;mi&gt;&quot;);
  2106 |     });</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  2102 |         const markup &#x3D; buildMathML(tree, tex, defaultOptions).toMarkup();
  2103 |         expect(markup).toContain(&quot;&lt;mrow&gt;&lt;mtext&gt;graph:\u00a0&lt;&#x2F;mtext&gt;&quot;);
&gt; 2104 |         expect(markup).toContain(
       |        ^ Duplicate Assert
  2105 |             &quot;&lt;mi&gt;y&lt;&#x2F;mi&gt;&lt;mo&gt;&#x3D;&lt;&#x2F;mo&gt;&lt;mi&gt;m&lt;&#x2F;mi&gt;&lt;mi&gt;x&lt;&#x2F;mi&gt;&lt;mo&gt;+&lt;&#x2F;mo&gt;&lt;mi&gt;b&lt;&#x2F;mi&gt;&quot;);
  2106 |     });
  2107 | });</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  2199 |         const built &#x3D; getBuilt&#x60;+ x&#x60;;
  2200 |
&gt; 2201 |         expect(built[0].classes).toContain(&quot;mord&quot;);
       |        ^ Duplicate Assert
  2202 |         expect(built[0].classes).not.toContain(&quot;mbin&quot;);
  2203 |     });
  2204 |</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  2200 |
  2201 |         expect(built[0].classes).toContain(&quot;mord&quot;);
&gt; 2202 |         expect(built[0].classes).not.toContain(&quot;mbin&quot;);
       |        ^ Duplicate Assert
  2203 |     });
  2204 |
  2205 |     it(&quot;should create ords after some other objects&quot;, function() {</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  2234 |         const markup &#x3D; katex.renderToString(r&#x60;\sigma^2&#x60;);
  2235 |         expect(markup.indexOf(&quot;&lt;span&quot;)).toBe(0);
&gt; 2236 |         expect(markup).toContain(&quot;\u03c3&quot;);  &#x2F;&#x2F; sigma
       |        ^ Duplicate Assert
  2237 |         expect(markup).toContain(&quot;margin-right&quot;);
  2238 |         expect(markup).not.toContain(&quot;marginRight&quot;);
  2239 |     });</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  2235 |         expect(markup.indexOf(&quot;&lt;span&quot;)).toBe(0);
  2236 |         expect(markup).toContain(&quot;\u03c3&quot;);  &#x2F;&#x2F; sigma
&gt; 2237 |         expect(markup).toContain(&quot;margin-right&quot;);
       |        ^ Duplicate Assert
  2238 |         expect(markup).not.toContain(&quot;marginRight&quot;);
  2239 |     });
  2240 |</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  2236 |         expect(markup).toContain(&quot;\u03c3&quot;);  &#x2F;&#x2F; sigma
  2237 |         expect(markup).toContain(&quot;margin-right&quot;);
&gt; 2238 |         expect(markup).not.toContain(&quot;marginRight&quot;);
       |        ^ Duplicate Assert
  2239 |     });
  2240 |
  2241 |     it(&quot;generates both MathML and HTML&quot;, function() {</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  2242 |         const markup &#x3D; katex.renderToString(&quot;a&quot;);
  2243 |
&gt; 2244 |         expect(markup).toContain(&quot;&lt;span&quot;);
       |        ^ Duplicate Assert
  2245 |         expect(markup).toContain(&quot;&lt;math&quot;);
  2246 |     });
  2247 | });</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  2243 |
  2244 |         expect(markup).toContain(&quot;&lt;span&quot;);
&gt; 2245 |         expect(markup).toContain(&quot;&lt;math&quot;);
       |        ^ Duplicate Assert
  2246 |     });
  2247 | });
  2248 |</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  2295 |     it(&quot;should produce mords&quot;, function() {
  2296 |         expect(getBuilt&#x60;\vec x&#x60;[0].classes).toContain(&quot;mord&quot;);
&gt; 2297 |         expect(getBuilt&#x60;\vec +&#x60;[0].classes).toContain(&quot;mord&quot;);
       |        ^ Duplicate Assert
  2298 |         expect(getBuilt&#x60;\vec +&#x60;[0].classes).not.toContain(&quot;mbin&quot;);
  2299 |         expect(getBuilt&#x60;\vec )^2&#x60;[0].classes).toContain(&quot;mord&quot;);
  2300 |         expect(getBuilt&#x60;\vec )^2&#x60;[0].classes).not.toContain(&quot;mclose&quot;);</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  2296 |         expect(getBuilt&#x60;\vec x&#x60;[0].classes).toContain(&quot;mord&quot;);
  2297 |         expect(getBuilt&#x60;\vec +&#x60;[0].classes).toContain(&quot;mord&quot;);
&gt; 2298 |         expect(getBuilt&#x60;\vec +&#x60;[0].classes).not.toContain(&quot;mbin&quot;);
       |        ^ Duplicate Assert
  2299 |         expect(getBuilt&#x60;\vec )^2&#x60;[0].classes).toContain(&quot;mord&quot;);
  2300 |         expect(getBuilt&#x60;\vec )^2&#x60;[0].classes).not.toContain(&quot;mclose&quot;);
  2301 |     });</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  2297 |         expect(getBuilt&#x60;\vec +&#x60;[0].classes).toContain(&quot;mord&quot;);
  2298 |         expect(getBuilt&#x60;\vec +&#x60;[0].classes).not.toContain(&quot;mbin&quot;);
&gt; 2299 |         expect(getBuilt&#x60;\vec )^2&#x60;[0].classes).toContain(&quot;mord&quot;);
       |        ^ Duplicate Assert
  2300 |         expect(getBuilt&#x60;\vec )^2&#x60;[0].classes).not.toContain(&quot;mclose&quot;);
  2301 |     });
  2302 | });</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  2298 |         expect(getBuilt&#x60;\vec +&#x60;[0].classes).not.toContain(&quot;mbin&quot;);
  2299 |         expect(getBuilt&#x60;\vec )^2&#x60;[0].classes).toContain(&quot;mord&quot;);
&gt; 2300 |         expect(getBuilt&#x60;\vec )^2&#x60;[0].classes).not.toContain(&quot;mclose&quot;);
       |        ^ Duplicate Assert
  2301 |     });
  2302 | });
  2303 |</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  2313 |     it(&quot;should produce mords&quot;, function() {
  2314 |         expect(getBuilt&#x60;\widehat{AB}&#x60;[0].classes).toContain(&quot;mord&quot;);
&gt; 2315 |         expect(getBuilt&#x60;\widehat +&#x60;[0].classes).toContain(&quot;mord&quot;);
       |        ^ Duplicate Assert
  2316 |         expect(getBuilt&#x60;\widehat +&#x60;[0].classes).not.toContain(&quot;mbin&quot;);
  2317 |         expect(getBuilt&#x60;\widehat )^2&#x60;[0].classes).toContain(&quot;mord&quot;);
  2318 |         expect(getBuilt&#x60;\widehat )^2&#x60;[0].classes).not.toContain(&quot;mclose&quot;);</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  2314 |         expect(getBuilt&#x60;\widehat{AB}&#x60;[0].classes).toContain(&quot;mord&quot;);
  2315 |         expect(getBuilt&#x60;\widehat +&#x60;[0].classes).toContain(&quot;mord&quot;);
&gt; 2316 |         expect(getBuilt&#x60;\widehat +&#x60;[0].classes).not.toContain(&quot;mbin&quot;);
       |        ^ Duplicate Assert
  2317 |         expect(getBuilt&#x60;\widehat )^2&#x60;[0].classes).toContain(&quot;mord&quot;);
  2318 |         expect(getBuilt&#x60;\widehat )^2&#x60;[0].classes).not.toContain(&quot;mclose&quot;);
  2319 |     });</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  2315 |         expect(getBuilt&#x60;\widehat +&#x60;[0].classes).toContain(&quot;mord&quot;);
  2316 |         expect(getBuilt&#x60;\widehat +&#x60;[0].classes).not.toContain(&quot;mbin&quot;);
&gt; 2317 |         expect(getBuilt&#x60;\widehat )^2&#x60;[0].classes).toContain(&quot;mord&quot;);
       |        ^ Duplicate Assert
  2318 |         expect(getBuilt&#x60;\widehat )^2&#x60;[0].classes).not.toContain(&quot;mclose&quot;);
  2319 |     });
  2320 | });</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  2316 |         expect(getBuilt&#x60;\widehat +&#x60;[0].classes).not.toContain(&quot;mbin&quot;);
  2317 |         expect(getBuilt&#x60;\widehat )^2&#x60;[0].classes).toContain(&quot;mord&quot;);
&gt; 2318 |         expect(getBuilt&#x60;\widehat )^2&#x60;[0].classes).not.toContain(&quot;mclose&quot;);
       |        ^ Duplicate Assert
  2319 |     });
  2320 | });
  2321 |</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  2330 |     it(&quot;should produce mords&quot;, function() {
  2331 |         expect(getBuilt&#x60;\overrightarrow{AB}&#x60;[0].classes).toContain(&quot;mord&quot;);
&gt; 2332 |         expect(getBuilt&#x60;\overrightarrow +&#x60;[0].classes).toContain(&quot;mord&quot;);
       |        ^ Duplicate Assert
  2333 |         expect(getBuilt&#x60;\overrightarrow +&#x60;[0].classes).not.toContain(&quot;mbin&quot;);
  2334 |         expect(getBuilt&#x60;\overrightarrow )^2&#x60;[0].classes).toContain(&quot;mord&quot;);
  2335 |         expect(getBuilt&#x60;\overrightarrow )^2&#x60;[0].classes).not.toContain(&quot;mclose&quot;);</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  2331 |         expect(getBuilt&#x60;\overrightarrow{AB}&#x60;[0].classes).toContain(&quot;mord&quot;);
  2332 |         expect(getBuilt&#x60;\overrightarrow +&#x60;[0].classes).toContain(&quot;mord&quot;);
&gt; 2333 |         expect(getBuilt&#x60;\overrightarrow +&#x60;[0].classes).not.toContain(&quot;mbin&quot;);
       |        ^ Duplicate Assert
  2334 |         expect(getBuilt&#x60;\overrightarrow )^2&#x60;[0].classes).toContain(&quot;mord&quot;);
  2335 |         expect(getBuilt&#x60;\overrightarrow )^2&#x60;[0].classes).not.toContain(&quot;mclose&quot;);
  2336 |     });</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  2332 |         expect(getBuilt&#x60;\overrightarrow +&#x60;[0].classes).toContain(&quot;mord&quot;);
  2333 |         expect(getBuilt&#x60;\overrightarrow +&#x60;[0].classes).not.toContain(&quot;mbin&quot;);
&gt; 2334 |         expect(getBuilt&#x60;\overrightarrow )^2&#x60;[0].classes).toContain(&quot;mord&quot;);
       |        ^ Duplicate Assert
  2335 |         expect(getBuilt&#x60;\overrightarrow )^2&#x60;[0].classes).not.toContain(&quot;mclose&quot;);
  2336 |     });
  2337 | });</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  2333 |         expect(getBuilt&#x60;\overrightarrow +&#x60;[0].classes).not.toContain(&quot;mbin&quot;);
  2334 |         expect(getBuilt&#x60;\overrightarrow )^2&#x60;[0].classes).toContain(&quot;mord&quot;);
&gt; 2335 |         expect(getBuilt&#x60;\overrightarrow )^2&#x60;[0].classes).not.toContain(&quot;mclose&quot;);
       |        ^ Duplicate Assert
  2336 |     });
  2337 | });
  2338 |</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  2377 |     it(&quot;should produce mords&quot;, function() {
  2378 |         expect(getBuilt&#x60;\underrightarrow x&#x60;[0].classes).toContain(&quot;mord&quot;);
&gt; 2379 |         expect(getBuilt&#x60;\underrightarrow +&#x60;[0].classes).toContain(&quot;mord&quot;);
       |        ^ Duplicate Assert
  2380 |         expect(getBuilt&#x60;\underrightarrow +&#x60;[0].classes).not.toContain(&quot;mbin&quot;);
  2381 |         expect(getBuilt&#x60;\underrightarrow )^2&#x60;[0].classes).toContain(&quot;mord&quot;);
  2382 |         expect(getBuilt&#x60;\underrightarrow )^2&#x60;[0].classes)</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  2378 |         expect(getBuilt&#x60;\underrightarrow x&#x60;[0].classes).toContain(&quot;mord&quot;);
  2379 |         expect(getBuilt&#x60;\underrightarrow +&#x60;[0].classes).toContain(&quot;mord&quot;);
&gt; 2380 |         expect(getBuilt&#x60;\underrightarrow +&#x60;[0].classes).not.toContain(&quot;mbin&quot;);
       |        ^ Duplicate Assert
  2381 |         expect(getBuilt&#x60;\underrightarrow )^2&#x60;[0].classes).toContain(&quot;mord&quot;);
  2382 |         expect(getBuilt&#x60;\underrightarrow )^2&#x60;[0].classes)
  2383 |             .not.toContain(&quot;mclose&quot;);</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  2379 |         expect(getBuilt&#x60;\underrightarrow +&#x60;[0].classes).toContain(&quot;mord&quot;);
  2380 |         expect(getBuilt&#x60;\underrightarrow +&#x60;[0].classes).not.toContain(&quot;mbin&quot;);
&gt; 2381 |         expect(getBuilt&#x60;\underrightarrow )^2&#x60;[0].classes).toContain(&quot;mord&quot;);
       |        ^ Duplicate Assert
  2382 |         expect(getBuilt&#x60;\underrightarrow )^2&#x60;[0].classes)
  2383 |             .not.toContain(&quot;mclose&quot;);
  2384 |     });</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  2380 |         expect(getBuilt&#x60;\underrightarrow +&#x60;[0].classes).not.toContain(&quot;mbin&quot;);
  2381 |         expect(getBuilt&#x60;\underrightarrow )^2&#x60;[0].classes).toContain(&quot;mord&quot;);
&gt; 2382 |         expect(getBuilt&#x60;\underrightarrow )^2&#x60;[0].classes)
       |        ^ Duplicate Assert
  2383 |             .not.toContain(&quot;mclose&quot;);
  2384 |     });
  2385 | });</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  2419 |         expect(getBuilt&#x60;\xrightarrow x&#x60;[0].classes).toContain(&quot;mrel&quot;);
  2420 |         expect(getBuilt&#x60;\xrightarrow [under]{over}&#x60;[0].classes).toContain(&quot;mrel&quot;);
&gt; 2421 |         expect(getBuilt&#x60;\xrightarrow +&#x60;[0].classes).toContain(&quot;mrel&quot;);
       |        ^ Duplicate Assert
  2422 |         expect(getBuilt&#x60;\xrightarrow +&#x60;[0].classes).not.toContain(&quot;mbin&quot;);
  2423 |         expect(getBuilt&#x60;\xrightarrow )^2&#x60;[0].classes).toContain(&quot;mrel&quot;);
  2424 |         expect(getBuilt&#x60;\xrightarrow )^2&#x60;[0].classes).not.toContain(&quot;mclose&quot;);</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  2420 |         expect(getBuilt&#x60;\xrightarrow [under]{over}&#x60;[0].classes).toContain(&quot;mrel&quot;);
  2421 |         expect(getBuilt&#x60;\xrightarrow +&#x60;[0].classes).toContain(&quot;mrel&quot;);
&gt; 2422 |         expect(getBuilt&#x60;\xrightarrow +&#x60;[0].classes).not.toContain(&quot;mbin&quot;);
       |        ^ Duplicate Assert
  2423 |         expect(getBuilt&#x60;\xrightarrow )^2&#x60;[0].classes).toContain(&quot;mrel&quot;);
  2424 |         expect(getBuilt&#x60;\xrightarrow )^2&#x60;[0].classes).not.toContain(&quot;mclose&quot;);
  2425 |     });</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  2421 |         expect(getBuilt&#x60;\xrightarrow +&#x60;[0].classes).toContain(&quot;mrel&quot;);
  2422 |         expect(getBuilt&#x60;\xrightarrow +&#x60;[0].classes).not.toContain(&quot;mbin&quot;);
&gt; 2423 |         expect(getBuilt&#x60;\xrightarrow )^2&#x60;[0].classes).toContain(&quot;mrel&quot;);
       |        ^ Duplicate Assert
  2424 |         expect(getBuilt&#x60;\xrightarrow )^2&#x60;[0].classes).not.toContain(&quot;mclose&quot;);
  2425 |     });
  2426 | });</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  2422 |         expect(getBuilt&#x60;\xrightarrow +&#x60;[0].classes).not.toContain(&quot;mbin&quot;);
  2423 |         expect(getBuilt&#x60;\xrightarrow )^2&#x60;[0].classes).toContain(&quot;mrel&quot;);
&gt; 2424 |         expect(getBuilt&#x60;\xrightarrow )^2&#x60;[0].classes).not.toContain(&quot;mclose&quot;);
       |        ^ Duplicate Assert
  2425 |     });
  2426 | });
  2427 |</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  2460 |         expect(getBuilt&#x60;\overbrace x&#x60;[0].classes).toContain(&quot;mord&quot;);
  2461 |         expect(getBuilt&#x60;\overbrace{x}^2&#x60;[0].classes).toContain(&quot;mord&quot;);
&gt; 2462 |         expect(getBuilt&#x60;\overbrace +&#x60;[0].classes).toContain(&quot;mord&quot;);
       |        ^ Duplicate Assert
  2463 |         expect(getBuilt&#x60;\overbrace +&#x60;[0].classes).not.toContain(&quot;mbin&quot;);
  2464 |         expect(getBuilt&#x60;\overbrace )^2&#x60;[0].classes).toContain(&quot;mord&quot;);
  2465 |         expect(getBuilt&#x60;\overbrace )^2&#x60;[0].classes).not.toContain(&quot;mclose&quot;);</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  2461 |         expect(getBuilt&#x60;\overbrace{x}^2&#x60;[0].classes).toContain(&quot;mord&quot;);
  2462 |         expect(getBuilt&#x60;\overbrace +&#x60;[0].classes).toContain(&quot;mord&quot;);
&gt; 2463 |         expect(getBuilt&#x60;\overbrace +&#x60;[0].classes).not.toContain(&quot;mbin&quot;);
       |        ^ Duplicate Assert
  2464 |         expect(getBuilt&#x60;\overbrace )^2&#x60;[0].classes).toContain(&quot;mord&quot;);
  2465 |         expect(getBuilt&#x60;\overbrace )^2&#x60;[0].classes).not.toContain(&quot;mclose&quot;);
  2466 |     });</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  2462 |         expect(getBuilt&#x60;\overbrace +&#x60;[0].classes).toContain(&quot;mord&quot;);
  2463 |         expect(getBuilt&#x60;\overbrace +&#x60;[0].classes).not.toContain(&quot;mbin&quot;);
&gt; 2464 |         expect(getBuilt&#x60;\overbrace )^2&#x60;[0].classes).toContain(&quot;mord&quot;);
       |        ^ Duplicate Assert
  2465 |         expect(getBuilt&#x60;\overbrace )^2&#x60;[0].classes).not.toContain(&quot;mclose&quot;);
  2466 |     });
  2467 | });</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  2463 |         expect(getBuilt&#x60;\overbrace +&#x60;[0].classes).not.toContain(&quot;mbin&quot;);
  2464 |         expect(getBuilt&#x60;\overbrace )^2&#x60;[0].classes).toContain(&quot;mord&quot;);
&gt; 2465 |         expect(getBuilt&#x60;\overbrace )^2&#x60;[0].classes).not.toContain(&quot;mclose&quot;);
       |        ^ Duplicate Assert
  2466 |     });
  2467 | });
  2468 |</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  2492 |     it(&quot;should produce mords&quot;, function() {
  2493 |         expect(getBuilt&#x60;\boxed x&#x60;[0].classes).toContain(&quot;mord&quot;);
&gt; 2494 |         expect(getBuilt&#x60;\boxed +&#x60;[0].classes).toContain(&quot;mord&quot;);
       |        ^ Duplicate Assert
  2495 |         expect(getBuilt&#x60;\boxed +&#x60;[0].classes).not.toContain(&quot;mbin&quot;);
  2496 |         expect(getBuilt&#x60;\boxed )^2&#x60;[0].classes).toContain(&quot;mord&quot;);
  2497 |         expect(getBuilt&#x60;\boxed )^2&#x60;[0].classes).not.toContain(&quot;mclose&quot;);</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  2493 |         expect(getBuilt&#x60;\boxed x&#x60;[0].classes).toContain(&quot;mord&quot;);
  2494 |         expect(getBuilt&#x60;\boxed +&#x60;[0].classes).toContain(&quot;mord&quot;);
&gt; 2495 |         expect(getBuilt&#x60;\boxed +&#x60;[0].classes).not.toContain(&quot;mbin&quot;);
       |        ^ Duplicate Assert
  2496 |         expect(getBuilt&#x60;\boxed )^2&#x60;[0].classes).toContain(&quot;mord&quot;);
  2497 |         expect(getBuilt&#x60;\boxed )^2&#x60;[0].classes).not.toContain(&quot;mclose&quot;);
  2498 |     });</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  2494 |         expect(getBuilt&#x60;\boxed +&#x60;[0].classes).toContain(&quot;mord&quot;);
  2495 |         expect(getBuilt&#x60;\boxed +&#x60;[0].classes).not.toContain(&quot;mbin&quot;);
&gt; 2496 |         expect(getBuilt&#x60;\boxed )^2&#x60;[0].classes).toContain(&quot;mord&quot;);
       |        ^ Duplicate Assert
  2497 |         expect(getBuilt&#x60;\boxed )^2&#x60;[0].classes).not.toContain(&quot;mclose&quot;);
  2498 |     });
  2499 | });</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  2495 |         expect(getBuilt&#x60;\boxed +&#x60;[0].classes).not.toContain(&quot;mbin&quot;);
  2496 |         expect(getBuilt&#x60;\boxed )^2&#x60;[0].classes).toContain(&quot;mord&quot;);
&gt; 2497 |         expect(getBuilt&#x60;\boxed )^2&#x60;[0].classes).not.toContain(&quot;mclose&quot;);
       |        ^ Duplicate Assert
  2498 |     });
  2499 | });
  2500 |</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  2612 |     it(&quot;should produce mords&quot;, function() {
  2613 |         expect(getBuilt&#x60;\cancel x&#x60;[0].classes).toContain(&quot;mord&quot;);
&gt; 2614 |         expect(getBuilt&#x60;\cancel +&#x60;[0].classes).toContain(&quot;mord&quot;);
       |        ^ Duplicate Assert
  2615 |         expect(getBuilt&#x60;\cancel +&#x60;[0].classes).not.toContain(&quot;mbin&quot;);
  2616 |         expect(getBuilt&#x60;\cancel )^2&#x60;[0].classes).toContain(&quot;mord&quot;);
  2617 |         expect(getBuilt&#x60;\cancel )^2&#x60;[0].classes).not.toContain(&quot;mclose&quot;);</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  2613 |         expect(getBuilt&#x60;\cancel x&#x60;[0].classes).toContain(&quot;mord&quot;);
  2614 |         expect(getBuilt&#x60;\cancel +&#x60;[0].classes).toContain(&quot;mord&quot;);
&gt; 2615 |         expect(getBuilt&#x60;\cancel +&#x60;[0].classes).not.toContain(&quot;mbin&quot;);
       |        ^ Duplicate Assert
  2616 |         expect(getBuilt&#x60;\cancel )^2&#x60;[0].classes).toContain(&quot;mord&quot;);
  2617 |         expect(getBuilt&#x60;\cancel )^2&#x60;[0].classes).not.toContain(&quot;mclose&quot;);
  2618 |     });</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  2614 |         expect(getBuilt&#x60;\cancel +&#x60;[0].classes).toContain(&quot;mord&quot;);
  2615 |         expect(getBuilt&#x60;\cancel +&#x60;[0].classes).not.toContain(&quot;mbin&quot;);
&gt; 2616 |         expect(getBuilt&#x60;\cancel )^2&#x60;[0].classes).toContain(&quot;mord&quot;);
       |        ^ Duplicate Assert
  2617 |         expect(getBuilt&#x60;\cancel )^2&#x60;[0].classes).not.toContain(&quot;mclose&quot;);
  2618 |     });
  2619 | });</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  2615 |         expect(getBuilt&#x60;\cancel +&#x60;[0].classes).not.toContain(&quot;mbin&quot;);
  2616 |         expect(getBuilt&#x60;\cancel )^2&#x60;[0].classes).toContain(&quot;mord&quot;);
&gt; 2617 |         expect(getBuilt&#x60;\cancel )^2&#x60;[0].classes).not.toContain(&quot;mclose&quot;);
       |        ^ Duplicate Assert
  2618 |     });
  2619 | });
  2620 |</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  3463 |     it(&quot;\\char produces literal characters&quot;, () &#x3D;&gt; {
  3464 |         expect(&quot;\\char&#x60;a&quot;).toParseLike(&quot;\\char&#x60;\\a&quot;);
&gt; 3465 |         expect(&quot;\\char&#x60;\\%&quot;).toParseLike&#x60;\char37&#x60;;
       |        ^ Duplicate Assert
  3466 |         expect(&quot;\\char&#x60;\\%&quot;).toParseLike&#x60;\char&#39;45&#x60;;
  3467 |         expect(&quot;\\char&#x60;\\%&quot;).toParseLike&#x60;\char&quot;25&#x60;;
  3468 |         expect&#x60;\char&#x60;.not.toParse();</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  3464 |         expect(&quot;\\char&#x60;a&quot;).toParseLike(&quot;\\char&#x60;\\a&quot;);
  3465 |         expect(&quot;\\char&#x60;\\%&quot;).toParseLike&#x60;\char37&#x60;;
&gt; 3466 |         expect(&quot;\\char&#x60;\\%&quot;).toParseLike&#x60;\char&#39;45&#x60;;
       |        ^ Duplicate Assert
  3467 |         expect(&quot;\\char&#x60;\\%&quot;).toParseLike&#x60;\char&quot;25&#x60;;
  3468 |         expect&#x60;\char&#x60;.not.toParse();
  3469 |         expect(&quot;\\char&#x60;&quot;).not.toParse();</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  3465 |         expect(&quot;\\char&#x60;\\%&quot;).toParseLike&#x60;\char37&#x60;;
  3466 |         expect(&quot;\\char&#x60;\\%&quot;).toParseLike&#x60;\char&#39;45&#x60;;
&gt; 3467 |         expect(&quot;\\char&#x60;\\%&quot;).toParseLike&#x60;\char&quot;25&#x60;;
       |        ^ Duplicate Assert
  3468 |         expect&#x60;\char&#x60;.not.toParse();
  3469 |         expect(&quot;\\char&#x60;&quot;).not.toParse();
  3470 |         expect&#x60;\char&#39;&#x60;.not.toParse();</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  4097 |         const example &#x3D; exp32 + r&#x60;\a{1}&#x60;;
  4098 |         const count &#x3D; 1 + 2 + 4 + 8 + 16 + 32;
&gt; 4099 |         expect(example).toParse(new Settings({maxExpand: count}));
       |        ^ Duplicate Assert
  4100 |         expect(example).not.toParse(new Settings({maxExpand: count - 1}));
  4101 |     });
  4102 |</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  4098 |         const count &#x3D; 1 + 2 + 4 + 8 + 16 + 32;
  4099 |         expect(example).toParse(new Settings({maxExpand: count}));
&gt; 4100 |         expect(example).not.toParse(new Settings({maxExpand: count - 1}));
       |        ^ Duplicate Assert
  4101 |     });
  4102 |
  4103 |     it(&quot;should count correctly with Unicode sub&#x2F;superscripts&quot;, () &#x3D;&gt; {</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  4104 |         const example &#x3D; exp32 + r&#x60;\def+{\a{1}}x⁺x⁺x⁺x⁺&#x60;;
  4105 |         const count &#x3D; (1 + 2 + 4 + 8 + 16 + 32) * 4 + 4;
&gt; 4106 |         expect(example).toParse(new Settings({maxExpand: count}));
       |        ^ Duplicate Assert
  4107 |         expect(example).not.toParse(new Settings({maxExpand: count - 1}));
  4108 |     });
  4109 | });</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  4105 |         const count &#x3D; (1 + 2 + 4 + 8 + 16 + 32) * 4 + 4;
  4106 |         expect(example).toParse(new Settings({maxExpand: count}));
&gt; 4107 |         expect(example).not.toParse(new Settings({maxExpand: count - 1}));
       |        ^ Duplicate Assert
  4108 |     });
  4109 | });
  4110 |</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  4147 |         &#x2F;&#x2F; Ensure newlines appear outside base spans (because, in this regexp,
  4148 |         &#x2F;&#x2F; base span occurs immediately after each newline span).
&gt; 4149 |         expect(markup).toMatch(
       |        ^ Duplicate Assert
  4150 |             &#x2F;(&lt;span class&#x3D;&quot;base&quot;&gt;.*?&lt;\&#x2F;span&gt;&lt;span class&#x3D;&quot;mspace newline&quot;&gt;&lt;\&#x2F;span&gt;){3}&lt;span class&#x3D;&quot;base&quot;&gt;&#x2F;);
  4151 |         expect(markup).toMatchSnapshot();
  4152 |     });</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  4149 |         expect(markup).toMatch(
  4150 |             &#x2F;(&lt;span class&#x3D;&quot;base&quot;&gt;.*?&lt;\&#x2F;span&gt;&lt;span class&#x3D;&quot;mspace newline&quot;&gt;&lt;\&#x2F;span&gt;){3}&lt;span class&#x3D;&quot;base&quot;&gt;&#x2F;);
&gt; 4151 |         expect(markup).toMatchSnapshot();
       |        ^ Duplicate Assert
  4152 |     });
  4153 | });
  4154 |</code></pre><br>
                      </td>
                    </tr>
                  </tbody>
                </table>
                <hr>
                <table class="table is-fullwidth" id="table-of-smell">
                  <thead>
                    <tr>
                      <td>Eager Test</td>
                    </tr>
                  </thead>
                  <tbody>
                    <tr>
                      <td>
                        <pre><code>  507 |
  508 |     it(&quot;should parse cfrac, dfrac, tfrac, and genfrac as fracs&quot;, function() {
&gt; 509 |         const dfracParse &#x3D; getParsed(dfracExpression)[0];
      |                           ^ Eager Test
  510 |
  511 |         expect(dfracParse.type).toEqual(&quot;genfrac&quot;);
  512 |         expect(dfracParse.numer).toBeDefined();</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  513 |         expect(dfracParse.denom).toBeDefined();
  514 |
&gt; 515 |         const tfracParse &#x3D; getParsed(tfracExpression)[0];
      |                           ^ Eager Test
  516 |
  517 |         expect(tfracParse.type).toEqual(&quot;genfrac&quot;);
  518 |         expect(tfracParse.numer).toBeDefined();</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  519 |         expect(tfracParse.denom).toBeDefined();
  520 |
&gt; 521 |         const cfracParse &#x3D; getParsed(cfracExpression)[0];
      |                           ^ Eager Test
  522 |
  523 |         expect(cfracParse.type).toEqual(&quot;genfrac&quot;);
  524 |         expect(cfracParse.numer).toBeDefined();</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  525 |         expect(cfracParse.denom).toBeDefined();
  526 |
&gt; 527 |         const genfracParse &#x3D; getParsed(genfrac1)[0];
      |                             ^ Eager Test
  528 |
  529 |         expect(genfracParse.type).toEqual(&quot;genfrac&quot;);
  530 |         expect(genfracParse.numer).toBeDefined();</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  570 |         let parse;
  571 |
&gt; 572 |         parse &#x3D; getParsed(simpleOver)[0];
      |                ^ Eager Test
  573 |
  574 |         expect(parse.type).toEqual(&quot;genfrac&quot;);
  575 |         expect(parse.numer).toBeDefined();</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  576 |         expect(parse.denom).toBeDefined();
  577 |
&gt; 578 |         parse &#x3D; getParsed(complexOver)[0];
      |                ^ Eager Test
  579 |
  580 |         expect(parse.type).toEqual(&quot;genfrac&quot;);
  581 |         expect(parse.numer).toBeDefined();</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  582 |         expect(parse.denom).toBeDefined();
  583 |
&gt; 584 |         const parseBraceFrac &#x3D; getParsed(braceFrac)[0];
      |                               ^ Eager Test
  585 |
  586 |         expect(parseBraceFrac.type).toEqual(&quot;genfrac&quot;);
  587 |         expect(parseBraceFrac.numer).toBeDefined();</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  590 |         expect(parseBraceFrac.rightDelim).toBeDefined();
  591 |
&gt; 592 |         const parseBrackFrac &#x3D; getParsed(brackFrac)[0];
      |                               ^ Eager Test
  593 |
  594 |         expect(parseBrackFrac.type).toEqual(&quot;genfrac&quot;);
  595 |         expect(parseBrackFrac.numer).toBeDefined();</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  867 |
  868 |     it(&quot;should correctly extract the custom color&quot;, function() {
&gt; 869 |         const parse1 &#x3D; getParsed(customColorExpression1)[0];
      |                       ^ Eager Test
  870 |         const parse2 &#x3D; getParsed(customColorExpression2)[0];
  871 |         const parse3 &#x3D; getParsed(customColorExpression3)[0];
  872 |</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  868 |     it(&quot;should correctly extract the custom color&quot;, function() {
  869 |         const parse1 &#x3D; getParsed(customColorExpression1)[0];
&gt; 870 |         const parse2 &#x3D; getParsed(customColorExpression2)[0];
      |                       ^ Eager Test
  871 |         const parse3 &#x3D; getParsed(customColorExpression3)[0];
  872 |
  873 |         expect(parse1.color).toEqual(&quot;#fA6&quot;);</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  869 |         const parse1 &#x3D; getParsed(customColorExpression1)[0];
  870 |         const parse2 &#x3D; getParsed(customColorExpression2)[0];
&gt; 871 |         const parse3 &#x3D; getParsed(customColorExpression3)[0];
      |                       ^ Eager Test
  872 |
  873 |         expect(parse1.color).toEqual(&quot;#fA6&quot;);
  874 |         expect(parse2.color).toEqual(&quot;#fA6fA6&quot;);</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  967 |
  968 |     it(&quot;should produce the correct direction delimiter&quot;, function() {
&gt; 969 |         const leftParse &#x3D; getParsed(normalDelim)[0];
      |                          ^ Eager Test
  970 |         const rightParse &#x3D; getParsed(bigDelim)[0];
  971 |
  972 |         expect(leftParse.mclass).toEqual(&quot;mopen&quot;);</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  968 |     it(&quot;should produce the correct direction delimiter&quot;, function() {
  969 |         const leftParse &#x3D; getParsed(normalDelim)[0];
&gt; 970 |         const rightParse &#x3D; getParsed(bigDelim)[0];
      |                           ^ Eager Test
  971 |
  972 |         expect(leftParse.mclass).toEqual(&quot;mopen&quot;);
  973 |         expect(rightParse.mclass).toEqual(&quot;mclose&quot;);</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  975 |
  976 |     it(&quot;should parse the correct size delimiter&quot;, function() {
&gt; 977 |         const smallParse &#x3D; getParsed(normalDelim)[0];
      |                           ^ Eager Test
  978 |         const bigParse &#x3D; getParsed(bigDelim)[0];
  979 |
  980 |         expect(smallParse.size).toEqual(1);</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  976 |     it(&quot;should parse the correct size delimiter&quot;, function() {
  977 |         const smallParse &#x3D; getParsed(normalDelim)[0];
&gt; 978 |         const bigParse &#x3D; getParsed(bigDelim)[0];
      |                         ^ Eager Test
  979 |
  980 |         expect(smallParse.size).toEqual(1);
  981 |         expect(bigParse.size).toEqual(4);</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  1056 |
  1057 |     it(&quot;should list the correct units&quot;, function() {
&gt; 1058 |         const emParse &#x3D; getParsed(emRule)[0];
       |                        ^ Eager Test
  1059 |         const exParse &#x3D; getParsed(exRule)[0];
  1060 |
  1061 |         expect(emParse.width.unit).toEqual(&quot;em&quot;);</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  1057 |     it(&quot;should list the correct units&quot;, function() {
  1058 |         const emParse &#x3D; getParsed(emRule)[0];
&gt; 1059 |         const exParse &#x3D; getParsed(exRule)[0];
       |                        ^ Eager Test
  1060 |
  1061 |         expect(emParse.width.unit).toEqual(&quot;em&quot;);
  1062 |         expect(emParse.height.unit).toEqual(&quot;em&quot;);</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  1094 |
  1095 |     it(&quot;should list the correct units&quot;, function() {
&gt; 1096 |         const emParse &#x3D; getParsed(emKern)[0];
       |                        ^ Eager Test
  1097 |         const exParse &#x3D; getParsed(exKern)[0];
  1098 |         const muParse &#x3D; getParsed(muKern)[0];
  1099 |         const abParse &#x3D; getParsed(abKern)[1];</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  1095 |     it(&quot;should list the correct units&quot;, function() {
  1096 |         const emParse &#x3D; getParsed(emKern)[0];
&gt; 1097 |         const exParse &#x3D; getParsed(exKern)[0];
       |                        ^ Eager Test
  1098 |         const muParse &#x3D; getParsed(muKern)[0];
  1099 |         const abParse &#x3D; getParsed(abKern)[1];
  1100 |</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  1096 |         const emParse &#x3D; getParsed(emKern)[0];
  1097 |         const exParse &#x3D; getParsed(exKern)[0];
&gt; 1098 |         const muParse &#x3D; getParsed(muKern)[0];
       |                        ^ Eager Test
  1099 |         const abParse &#x3D; getParsed(abKern)[1];
  1100 |
  1101 |         expect(emParse.dimension.unit).toEqual(&quot;em&quot;);</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  1097 |         const exParse &#x3D; getParsed(exKern)[0];
  1098 |         const muParse &#x3D; getParsed(muKern)[0];
&gt; 1099 |         const abParse &#x3D; getParsed(abKern)[1];
       |                        ^ Eager Test
  1100 |
  1101 |         expect(emParse.dimension.unit).toEqual(&quot;em&quot;);
  1102 |         expect(exParse.dimension.unit).toEqual(&quot;ex&quot;);</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  1132 |
  1133 |     it(&quot;should list the correct units&quot;, function() {
&gt; 1134 |         const emParse &#x3D; getParsed(emKern)[0];
       |                        ^ Eager Test
  1135 |         const exParse &#x3D; getParsed(exKern)[0];
  1136 |         const muParse &#x3D; getParsed(muKern)[0];
  1137 |         const abParse1 &#x3D; getParsed(abKern1)[1];</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  1133 |     it(&quot;should list the correct units&quot;, function() {
  1134 |         const emParse &#x3D; getParsed(emKern)[0];
&gt; 1135 |         const exParse &#x3D; getParsed(exKern)[0];
       |                        ^ Eager Test
  1136 |         const muParse &#x3D; getParsed(muKern)[0];
  1137 |         const abParse1 &#x3D; getParsed(abKern1)[1];
  1138 |         const abParse2 &#x3D; getParsed(abKern2)[1];</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  1134 |         const emParse &#x3D; getParsed(emKern)[0];
  1135 |         const exParse &#x3D; getParsed(exKern)[0];
&gt; 1136 |         const muParse &#x3D; getParsed(muKern)[0];
       |                        ^ Eager Test
  1137 |         const abParse1 &#x3D; getParsed(abKern1)[1];
  1138 |         const abParse2 &#x3D; getParsed(abKern2)[1];
  1139 |         const abParse3 &#x3D; getParsed(abKern3)[1];</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  1135 |         const exParse &#x3D; getParsed(exKern)[0];
  1136 |         const muParse &#x3D; getParsed(muKern)[0];
&gt; 1137 |         const abParse1 &#x3D; getParsed(abKern1)[1];
       |                         ^ Eager Test
  1138 |         const abParse2 &#x3D; getParsed(abKern2)[1];
  1139 |         const abParse3 &#x3D; getParsed(abKern3)[1];
  1140 |</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  1136 |         const muParse &#x3D; getParsed(muKern)[0];
  1137 |         const abParse1 &#x3D; getParsed(abKern1)[1];
&gt; 1138 |         const abParse2 &#x3D; getParsed(abKern2)[1];
       |                         ^ Eager Test
  1139 |         const abParse3 &#x3D; getParsed(abKern3)[1];
  1140 |
  1141 |         expect(emParse.dimension.unit).toEqual(&quot;em&quot;);</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  1137 |         const abParse1 &#x3D; getParsed(abKern1)[1];
  1138 |         const abParse2 &#x3D; getParsed(abKern2)[1];
&gt; 1139 |         const abParse3 &#x3D; getParsed(abKern3)[1];
       |                         ^ Eager Test
  1140 |
  1141 |         expect(emParse.dimension.unit).toEqual(&quot;em&quot;);
  1142 |         expect(exParse.dimension.unit).toEqual(&quot;ex&quot;);</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  1148 |
  1149 |     it(&quot;should parse elements on either side of a kern&quot;, function() {
&gt; 1150 |         const abParse1 &#x3D; getParsed(abKern1);
       |                         ^ Eager Test
  1151 |         const abParse2 &#x3D; getParsed(abKern2);
  1152 |         const abParse3 &#x3D; getParsed(abKern3);
  1153 |</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  1149 |     it(&quot;should parse elements on either side of a kern&quot;, function() {
  1150 |         const abParse1 &#x3D; getParsed(abKern1);
&gt; 1151 |         const abParse2 &#x3D; getParsed(abKern2);
       |                         ^ Eager Test
  1152 |         const abParse3 &#x3D; getParsed(abKern3);
  1153 |
  1154 |         expect(abParse1).toHaveLength(3);</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  1150 |         const abParse1 &#x3D; getParsed(abKern1);
  1151 |         const abParse2 &#x3D; getParsed(abKern2);
&gt; 1152 |         const abParse3 &#x3D; getParsed(abKern3);
       |                         ^ Eager Test
  1153 |
  1154 |         expect(abParse1).toHaveLength(3);
  1155 |         expect(abParse1[0].text).toEqual(&quot;a&quot;);</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  2073 |     it(&quot;should render a combination of font and color changes&quot;, function() {
  2074 |         let tex &#x3D; r&#x60;\textcolor{blue}{\mathbb R}&#x60;;
&gt; 2075 |         let tree &#x3D; getParsed(tex);
       |                   ^ Eager Test
  2076 |         let markup &#x3D; buildMathML(tree, tex, defaultOptions).toMarkup();
  2077 |         let node &#x3D; &quot;&lt;mstyle mathcolor&#x3D;\&quot;blue\&quot;&gt;&quot; +
  2078 |             &quot;&lt;mi mathvariant&#x3D;\&quot;double-struck\&quot;&gt;R&lt;&#x2F;mi&gt;&quot; +</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  2082 |         &#x2F;&#x2F; reverse the order of the commands
  2083 |         tex &#x3D; r&#x60;\mathbb{\textcolor{blue}{R}}&#x60;;
&gt; 2084 |         tree &#x3D; getParsed(tex);
       |               ^ Eager Test
  2085 |         markup &#x3D; buildMathML(tree, tex, defaultOptions).toMarkup();
  2086 |         node &#x3D; &quot;&lt;mstyle mathcolor&#x3D;\&quot;blue\&quot;&gt;&quot; +
  2087 |             &quot;&lt;mi mathvariant&#x3D;\&quot;double-struck\&quot;&gt;R&lt;&#x2F;mi&gt;&quot; +</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  2990 |     it(&quot;should allow letters [#$%&amp;~_^] without escaping&quot;, function() {
  2991 |         const url &#x3D; &quot;http:&#x2F;&#x2F;example.org&#x2F;~bar&#x2F;#top?foo&#x3D;$foo&amp;bar&#x3D;ba^r_boo%20baz&quot;;
&gt; 2992 |         const parsed1 &#x3D; getParsed(&#x60;\\href{${url}}{\\alpha}&#x60;, trustSettings)[0];
       |                        ^ Eager Test
  2993 |         expect(parsed1.href).toBe(url);
  2994 |         const parsed2 &#x3D; getParsed(&#x60;\\url{${url}}&#x60;, trustSettings)[0];
  2995 |         expect(parsed2.href).toBe(url);</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  2992 |         const parsed1 &#x3D; getParsed(&#x60;\\href{${url}}{\\alpha}&#x60;, trustSettings)[0];
  2993 |         expect(parsed1.href).toBe(url);
&gt; 2994 |         const parsed2 &#x3D; getParsed(&#x60;\\url{${url}}&#x60;, trustSettings)[0];
       |                        ^ Eager Test
  2995 |         expect(parsed2.href).toBe(url);
  2996 |     });
  2997 |</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  2998 |     it(&quot;should allow balanced braces in url&quot;, function() {
  2999 |         const url &#x3D; &quot;http:&#x2F;&#x2F;example.org&#x2F;{{}t{oo}}&quot;;
&gt; 3000 |         const parsed1 &#x3D; getParsed(&#x60;\\href{${url}}{\\alpha}&#x60;, trustSettings)[0];
       |                        ^ Eager Test
  3001 |         expect(parsed1.href).toBe(url);
  3002 |         const parsed2 &#x3D; getParsed(&#x60;\\url{${url}}&#x60;, trustSettings)[0];
  3003 |         expect(parsed2.href).toBe(url);</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  3000 |         const parsed1 &#x3D; getParsed(&#x60;\\href{${url}}{\\alpha}&#x60;, trustSettings)[0];
  3001 |         expect(parsed1.href).toBe(url);
&gt; 3002 |         const parsed2 &#x3D; getParsed(&#x60;\\url{${url}}&#x60;, trustSettings)[0];
       |                        ^ Eager Test
  3003 |         expect(parsed2.href).toBe(url);
  3004 |     });
  3005 |</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  3014 |         const url &#x3D; &quot;http:&#x2F;&#x2F;example.org&#x2F;~bar&#x2F;#top?foo&#x3D;$}foo{&amp;bar&#x3D;bar^r_boo%20baz&quot;;
  3015 |         const input &#x3D; url.replace(&#x2F;([#$%&amp;~_^{}])&#x2F;g, &#39;\\$1&#39;);
&gt; 3016 |         const parsed1 &#x3D; getParsed(&#x60;\\href{${input}}{\\alpha}&#x60;, trustSettings)[0];
       |                        ^ Eager Test
  3017 |         expect(parsed1.href).toBe(url);
  3018 |         const parsed2 &#x3D; getParsed(&#x60;\\url{${input}}&#x60;, trustSettings)[0];
  3019 |         expect(parsed2.href).toBe(url);</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  3016 |         const parsed1 &#x3D; getParsed(&#x60;\\href{${input}}{\\alpha}&#x60;, trustSettings)[0];
  3017 |         expect(parsed1.href).toBe(url);
&gt; 3018 |         const parsed2 &#x3D; getParsed(&#x60;\\url{${input}}&#x60;, trustSettings)[0];
       |                        ^ Eager Test
  3019 |         expect(parsed2.href).toBe(url);
  3020 |     });
  3021 |</code></pre><br>
                      </td>
                    </tr>
                  </tbody>
                </table>
                <hr>
                <table class="table is-fullwidth" id="table-of-smell">
                  <thead>
                    <tr>
                      <td>Exception Handling</td>
                    </tr>
                  </thead>
                  <tbody>
                    <tr>
                      <td>
                        <pre><code>  2171 |     it(&quot;should throw Error when HTML attribute name is invalid&quot;, function() {
  2172 |         for (const char of [&quot;&gt;&quot;, &quot; &quot;, &quot;\t&quot;, &quot;\n&quot;, &quot;\r&quot;, &quot;\&quot;&quot;, &quot;&#39;&quot;, &quot;&#x2F;&quot;]) {
&gt; 2173 |             try {
       |            ^ Exception Handling
  2174 |                 katex.renderToString(
  2175 |                     &#x60;\\htmlData{a${char}b&#x3D;foo}{bar}&#x60;, trustNonStrictSettings);
  2176 |</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  2736 | describe(&quot;A parser error&quot;, function() {
  2737 |     it(&quot;should report the position of an error&quot;, function() {
&gt; 2738 |         try {
       |        ^ Exception Handling
  2739 |             parseTree(r&#x60;\sqrt}&#x60;, new Settings());
  2740 |         } catch (e) {
  2741 |             expect(e.position).toEqual(5);</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  3155 | describe(&quot;ParseError properties&quot;, function() {
  3156 |     it(&quot;should contain affected position and length information&quot;, function() {
&gt; 3157 |         try {
       |        ^ Exception Handling
  3158 |             katex.renderToString(&quot;1 + \\fraq{}{}&quot;);
  3159 |
  3160 |             &#x2F;&#x2F; Render is expected to throw, so this should not be called.</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  3170 |
  3171 |     it(&quot;should contain position and length information at end of input&quot;, function() {
&gt; 3172 |         try {
       |        ^ Exception Handling
  3173 |             katex.renderToString(&quot;\\frac{}&quot;);
  3174 |
  3175 |             &#x2F;&#x2F; Render is expected to throw, so this should not be called.</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  3185 |
  3186 |     it(&quot;should contain no position and length information if unavailable&quot;, function() {
&gt; 3187 |         try {
       |        ^ Exception Handling
  3188 |             katex.renderToString(&quot;\\verb|hello\nworld|&quot;);
  3189 |
  3190 |             &#x2F;&#x2F; Render is expected to throw, so this should not be called.</code></pre><br>
                      </td>
                    </tr>
                  </tbody>
                </table>
                <hr>
                <table class="table is-fullwidth" id="table-of-smell">
                  <thead>
                    <tr>
                      <td>Lazy Test</td>
                    </tr>
                  </thead>
                  <tbody>
                    <tr>
                      <td>
                        <pre><code>  42 |
  43 |     it(&quot;should build a list of ords&quot;, function() {
&gt; 44 |         const parse &#x3D; getParsed(expression);
     |                      ^ Lazy Test
  45 |
  46 |         for (let i &#x3D; 0; i &lt; parse.length; i++) {
  47 |             const group &#x3D; parse[i];</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  51 |
  52 |     it(&quot;should parse the right number of ords&quot;, function() {
&gt; 53 |         const parse &#x3D; getParsed(expression);
     |                      ^ Lazy Test
  54 |
  55 |         expect(parse).toHaveLength(expression.length);
  56 |     });</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  65 |
  66 |     it(&quot;should build a list of bins&quot;, function() {
&gt; 67 |         const parse &#x3D; getParsed(expression);
     |                      ^ Lazy Test
  68 |
  69 |         for (let i &#x3D; 0; i &lt; parse.length; i++) {
  70 |             const group &#x3D; parse[i];</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  85 |
  86 |     it(&quot;should build a list of rels&quot;, function() {
&gt; 87 |         const parse &#x3D; getParsed(expression);
     |                      ^ Lazy Test
  88 |
  89 |         for (let i &#x3D; 0; i &lt; parse.length; i++) {
  90 |             let group &#x3D; parse[i];</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  111 |     it(&quot;should return one group, not a fragment&quot;, function() {
  112 |         const contents &#x3D; &quot;\\mathinner{\\langle{\\psi}\\rangle}&quot;;
&gt; 113 |         const mml &#x3D; buildMathML(getParsed(contents), contents, defaultOptions);
      |                                ^ Lazy Test
  114 |         expect(mml.children.length).toEqual(1);
  115 |     });
  116 | });</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  124 |
  125 |     it(&quot;should build a list of puncts&quot;, function() {
&gt; 126 |         const parse &#x3D; getParsed(expression);
      |                      ^ Lazy Test
  127 |
  128 |         for (let i &#x3D; 0; i &lt; parse.length; i++) {
  129 |             const group &#x3D; parse[i];</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  142 |
  143 |     it(&quot;should build a list of opens&quot;, function() {
&gt; 144 |         const parse &#x3D; getParsed(expression);
      |                      ^ Lazy Test
  145 |
  146 |         for (let i &#x3D; 0; i &lt; parse.length; i++) {
  147 |             const group &#x3D; parse[i];</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  160 |
  161 |     it(&quot;should build a list of closes&quot;, function() {
&gt; 162 |         const parse &#x3D; getParsed(expression);
      |                      ^ Lazy Test
  163 |
  164 |         for (let i &#x3D; 0; i &lt; parse.length; i++) {
  165 |             const group &#x3D; parse[i];</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  491 |
  492 |     it(&quot;should produce a frac&quot;, function() {
&gt; 493 |         const parse &#x3D; getParsed(expression)[0];
      |                      ^ Lazy Test
  494 |
  495 |         expect(parse.type).toEqual(&quot;genfrac&quot;);
  496 |         expect(parse.numer).toBeDefined();</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  507 |
  508 |     it(&quot;should parse cfrac, dfrac, tfrac, and genfrac as fracs&quot;, function() {
&gt; 509 |         const dfracParse &#x3D; getParsed(dfracExpression)[0];
      |                           ^ Lazy Test
  510 |
  511 |         expect(dfracParse.type).toEqual(&quot;genfrac&quot;);
  512 |         expect(dfracParse.numer).toBeDefined();</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  570 |         let parse;
  571 |
&gt; 572 |         parse &#x3D; getParsed(simpleOver)[0];
      |                ^ Lazy Test
  573 |
  574 |         expect(parse.type).toEqual(&quot;genfrac&quot;);
  575 |         expect(parse.numer).toBeDefined();</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  600 |
  601 |     it(&quot;should create a numerator from the atoms before \\over&quot;, function() {
&gt; 602 |         const parse &#x3D; getParsed(complexOver)[0];
      |                      ^ Lazy Test
  603 |
  604 |         const numer &#x3D; parse.numer;
  605 |         expect(numer.body).toHaveLength(4);</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  607 |
  608 |     it(&quot;should create a denominator from the atoms after \\over&quot;, function() {
&gt; 609 |         const parse &#x3D; getParsed(complexOver)[0];
      |                      ^ Lazy Test
  610 |
  611 |         const denom &#x3D; parse.denom;
  612 |         expect(denom.body).toHaveLength(4);</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  615 |     it(&quot;should handle empty numerators&quot;, function() {
  616 |         const emptyNumerator &#x3D; r&#x60;\over x&#x60;;
&gt; 617 |         const parse &#x3D; getParsed(emptyNumerator)[0];
      |                      ^ Lazy Test
  618 |         expect(parse.type).toEqual(&quot;genfrac&quot;);
  619 |         expect(parse.numer).toBeDefined();
  620 |         expect(parse.denom).toBeDefined();</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  623 |     it(&quot;should handle empty denominators&quot;, function() {
  624 |         const emptyDenominator &#x3D; r&#x60;1 \over&#x60;;
&gt; 625 |         const parse &#x3D; getParsed(emptyDenominator)[0];
      |                      ^ Lazy Test
  626 |         expect(parse.type).toEqual(&quot;genfrac&quot;);
  627 |         expect(parse.numer).toBeDefined();
  628 |         expect(parse.denom).toBeDefined();</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  631 |     it(&quot;should handle \\displaystyle correctly&quot;, function() {
  632 |         const displaystyleExpression &#x3D; r&#x60;\displaystyle 1 \over 2&#x60;;
&gt; 633 |         const parse &#x3D; getParsed(displaystyleExpression)[0];
      |                      ^ Lazy Test
  634 |         expect(parse.type).toEqual(&quot;genfrac&quot;);
  635 |         expect(parse.numer.body[0].type).toEqual(&quot;styling&quot;);
  636 |         expect(parse.denom).toBeDefined();</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  644 |     it(&quot;should handle nested factions&quot;, function() {
  645 |         const nestedOverExpression &#x3D; r&#x60;{1 \over 2} \over 3&#x60;;
&gt; 646 |         const parse &#x3D; getParsed(nestedOverExpression)[0];
      |                      ^ Lazy Test
  647 |         expect(parse.type).toEqual(&quot;genfrac&quot;);
  648 |         expect(parse.numer.body[0].type).toEqual(&quot;genfrac&quot;);
  649 |         expect(parse.numer.body[0].numer.body[0].text).toEqual(&quot;1&quot;);</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  693 |
  694 |     it(&quot;should produce a sizing node&quot;, function() {
&gt; 695 |         const parse &#x3D; getParsed(sizeExpression)[0];
      |                      ^ Lazy Test
  696 |
  697 |         expect(parse.type).toEqual(&quot;sizing&quot;);
  698 |         expect(parse.size).toBeDefined();</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  717 |
  718 |     it(&quot;should produce a text&quot;, function() {
&gt; 719 |         const parse &#x3D; getParsed(textExpression)[0];
      |                      ^ Lazy Test
  720 |
  721 |         expect(parse.type).toEqual(&quot;text&quot;);
  722 |         expect(parse.body).toBeDefined();</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  724 |
  725 |     it(&quot;should produce textords instead of mathords&quot;, function() {
&gt; 726 |         const parse &#x3D; getParsed(textExpression)[0];
      |                      ^ Lazy Test
  727 |         const group &#x3D; parse.body;
  728 |
  729 |         expect(group[0].type).toEqual(&quot;textord&quot;);</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  747 |
  748 |     it(&quot;should contract spaces&quot;, function() {
&gt; 749 |         const parse &#x3D; getParsed(spaceTextExpression)[0];
      |                      ^ Lazy Test
  750 |         const group &#x3D; parse.body;
  751 |
  752 |         expect(group.length).toEqual(4);</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  766 |
  767 |     it(&quot;should ignore a space before the text group&quot;, function() {
&gt; 768 |         const parse &#x3D; getParsed(leadingSpaceTextExpression)[0];
      |                      ^ Lazy Test
  769 |         &#x2F;&#x2F; [m, o, o]
  770 |         expect(parse.body).toHaveLength(3);
  771 |         expect(parse.body.map(n &#x3D;&gt; n.text).join(&quot;&quot;)).toBe(&quot;moo&quot;);</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  853 |
  854 |     it(&quot;should build a color node&quot;, function() {
&gt; 855 |         const parse &#x3D; getParsed(colorExpression)[0];
      |                      ^ Lazy Test
  856 |
  857 |         expect(parse.type).toEqual(&quot;color&quot;);
  858 |         expect(parse.color).toBeDefined();</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  867 |
  868 |     it(&quot;should correctly extract the custom color&quot;, function() {
&gt; 869 |         const parse1 &#x3D; getParsed(customColorExpression1)[0];
      |                       ^ Lazy Test
  870 |         const parse2 &#x3D; getParsed(customColorExpression2)[0];
  871 |         const parse3 &#x3D; getParsed(customColorExpression3)[0];
  872 |</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  926 |
  927 |     it(&quot;should produce spacing in math mode&quot;, function() {
&gt; 928 |         const parse &#x3D; getParsed(mathTie);
      |                      ^ Lazy Test
  929 |
  930 |         expect(parse[1].type).toEqual(&quot;spacing&quot;);
  931 |     });</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  932 |
  933 |     it(&quot;should produce spacing in text mode&quot;, function() {
&gt; 934 |         const text &#x3D; getParsed(textTie)[0];
      |                     ^ Lazy Test
  935 |         const parse &#x3D; text.body;
  936 |
  937 |         expect(parse[1].type).toEqual(&quot;spacing&quot;);</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  939 |
  940 |     it(&quot;should not contract with spaces in text mode&quot;, function() {
&gt; 941 |         const text &#x3D; getParsed(textTie)[0];
      |                     ^ Lazy Test
  942 |         const parse &#x3D; text.body;
  943 |
  944 |         expect(parse[2].type).toEqual(&quot;spacing&quot;);</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  961 |
  962 |     it(&quot;should produce a delimsizing&quot;, function() {
&gt; 963 |         const parse &#x3D; getParsed(normalDelim)[0];
      |                      ^ Lazy Test
  964 |
  965 |         expect(parse.type).toEqual(&quot;delimsizing&quot;);
  966 |     });</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  967 |
  968 |     it(&quot;should produce the correct direction delimiter&quot;, function() {
&gt; 969 |         const leftParse &#x3D; getParsed(normalDelim)[0];
      |                          ^ Lazy Test
  970 |         const rightParse &#x3D; getParsed(bigDelim)[0];
  971 |
  972 |         expect(leftParse.mclass).toEqual(&quot;mopen&quot;);</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  975 |
  976 |     it(&quot;should parse the correct size delimiter&quot;, function() {
&gt; 977 |         const smallParse &#x3D; getParsed(normalDelim)[0];
      |                           ^ Lazy Test
  978 |         const bigParse &#x3D; getParsed(bigDelim)[0];
  979 |
  980 |         expect(smallParse.size).toEqual(1);</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  991 |
  992 |     it(&quot;should produce an overline&quot;, function() {
&gt; 993 |         const parse &#x3D; getParsed(overline)[0];
      |                      ^ Lazy Test
  994 |
  995 |         expect(parse.type).toEqual(&quot;overline&quot;);
  996 |     });</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  1050 |
  1051 |     it(&quot;should produce a rule&quot;, function() {
&gt; 1052 |         const parse &#x3D; getParsed(emRule)[0];
       |                      ^ Lazy Test
  1053 |
  1054 |         expect(parse.type).toEqual(&quot;rule&quot;);
  1055 |     });</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  1056 |
  1057 |     it(&quot;should list the correct units&quot;, function() {
&gt; 1058 |         const emParse &#x3D; getParsed(emRule)[0];
       |                        ^ Lazy Test
  1059 |         const exParse &#x3D; getParsed(exRule)[0];
  1060 |
  1061 |         expect(emParse.width.unit).toEqual(&quot;em&quot;);</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  1067 |
  1068 |     it(&quot;should parse the number correctly&quot;, function() {
&gt; 1069 |         const hardNumberParse &#x3D; getParsed(hardNumberRule)[0];
       |                                ^ Lazy Test
  1070 |
  1071 |         expect(hardNumberParse.width.number).toBeCloseTo(1.24);
  1072 |         expect(hardNumberParse.height.number).toBeCloseTo(2.45);</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  1094 |
  1095 |     it(&quot;should list the correct units&quot;, function() {
&gt; 1096 |         const emParse &#x3D; getParsed(emKern)[0];
       |                        ^ Lazy Test
  1097 |         const exParse &#x3D; getParsed(exKern)[0];
  1098 |         const muParse &#x3D; getParsed(muKern)[0];
  1099 |         const abParse &#x3D; getParsed(abKern)[1];</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  1132 |
  1133 |     it(&quot;should list the correct units&quot;, function() {
&gt; 1134 |         const emParse &#x3D; getParsed(emKern)[0];
       |                        ^ Lazy Test
  1135 |         const exParse &#x3D; getParsed(exKern)[0];
  1136 |         const muParse &#x3D; getParsed(muKern)[0];
  1137 |         const abParse1 &#x3D; getParsed(abKern1)[1];</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  1148 |
  1149 |     it(&quot;should parse elements on either side of a kern&quot;, function() {
&gt; 1150 |         const abParse1 &#x3D; getParsed(abKern1);
       |                         ^ Lazy Test
  1151 |         const abParse2 &#x3D; getParsed(abKern2);
  1152 |         const abParse3 &#x3D; getParsed(abKern3);
  1153 |</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  1179 |
  1180 |     it(&quot;should handle whitespace&quot;, function() {
&gt; 1181 |         const abParse &#x3D; getParsed(&quot;a\\mkern\t-\r1  \n mu\nb&quot;);
       |                        ^ Lazy Test
  1182 |
  1183 |         expect(abParse).toHaveLength(3);
  1184 |         expect(abParse[0].text).toEqual(&quot;a&quot;);</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  1197 |
  1198 |     it(&quot;should produce a leftright&quot;, function() {
&gt; 1199 |         const parse &#x3D; getParsed(normalLeftRight)[0];
       |                      ^ Lazy Test
  1200 |
  1201 |         expect(parse.type).toEqual(&quot;leftright&quot;);
  1202 |         expect(parse.left).toEqual(&quot;(&quot;);</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  1374 |
  1375 |     it(&quot;should produce sqrts&quot;, function() {
&gt; 1376 |         const parse &#x3D; getParsed(sqrt)[0];
       |                      ^ Lazy Test
  1377 |
  1378 |         expect(parse.type).toEqual(&quot;sqrt&quot;);
  1379 |     });</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  1573 |     it(&quot;should only change the style within its group&quot;, function() {
  1574 |         const text &#x3D; r&#x60;a b { c d \displaystyle e f } g h&#x60;;
&gt; 1575 |         const parse &#x3D; getParsed(text);
       |                      ^ Lazy Test
  1576 |
  1577 |         const displayNode &#x3D; parse[2].body[2];
  1578 |</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  2073 |     it(&quot;should render a combination of font and color changes&quot;, function() {
  2074 |         let tex &#x3D; r&#x60;\textcolor{blue}{\mathbb R}&#x60;;
&gt; 2075 |         let tree &#x3D; getParsed(tex);
       |                   ^ Lazy Test
  2076 |         let markup &#x3D; buildMathML(tree, tex, defaultOptions).toMarkup();
  2077 |         let node &#x3D; &quot;&lt;mstyle mathcolor&#x3D;\&quot;blue\&quot;&gt;&quot; +
  2078 |             &quot;&lt;mi mathvariant&#x3D;\&quot;double-struck\&quot;&gt;R&lt;&#x2F;mi&gt;&quot; +</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  2092 |     it(&quot;should render text as &lt;mtext&gt;&quot;, function() {
  2093 |         const tex &#x3D; r&#x60;\text{for }&#x60;;
&gt; 2094 |         const tree &#x3D; getParsed(tex);
       |                     ^ Lazy Test
  2095 |         const markup &#x3D; buildMathML(tree, tex, defaultOptions).toMarkup();
  2096 |         expect(markup).toContain(&quot;&lt;mtext&gt;for\u00a0&lt;&#x2F;mtext&gt;&quot;);
  2097 |     });</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  2099 |     it(&quot;should render math within text as side-by-side children&quot;, function() {
  2100 |         const tex &#x3D; r&#x60;\text{graph: $y &#x3D; mx + b$}&#x60;;
&gt; 2101 |         const tree &#x3D; getParsed(tex);
       |                     ^ Lazy Test
  2102 |         const markup &#x3D; buildMathML(tree, tex, defaultOptions).toMarkup();
  2103 |         expect(markup).toContain(&quot;&lt;mrow&gt;&lt;mtext&gt;graph:\u00a0&lt;&#x2F;mtext&gt;&quot;);
  2104 |         expect(markup).toContain(</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  2114 |
  2115 |     it(&quot;should produce mords&quot;, function() {
&gt; 2116 |         expect(getBuilt(img, trustSettings)[0].classes).toContain(&quot;mord&quot;);
       |               ^ Lazy Test
  2117 |     });
  2118 |
  2119 |     it(&quot;should not render without trust setting&quot;, function() {</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  2118 |
  2119 |     it(&quot;should not render without trust setting&quot;, function() {
&gt; 2120 |         const built &#x3D; getBuilt(img);
       |                      ^ Lazy Test
  2121 |         expect(built).toMatchSnapshot();
  2122 |     });
  2123 |</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  2123 |
  2124 |     it(&quot;should render with trust setting&quot;, function() {
&gt; 2125 |         const built &#x3D; getBuilt(img, trustSettings);
       |                      ^ Lazy Test
  2126 |         expect(built).toMatchSnapshot();
  2127 |     });
  2128 |</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  2149 |
  2150 |     it(&quot;should set HTML attributes&quot;, function() {
&gt; 2151 |         const built &#x3D; getBuilt(html, trustNonStrictSettings);
       |                      ^ Lazy Test
  2152 |         expect(built[0].attributes.id).toMatch(&quot;bar&quot;);
  2153 |         expect(built[1].classes).toContain(&quot;foo&quot;);
  2154 |         expect(built[2].attributes.style).toMatch(&quot;color: red&quot;);</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  2160 |
  2161 |     it(&quot;should not affect spacing&quot;, function() {
&gt; 2162 |         const built &#x3D; getBuilt(&quot;\\htmlId{a}{x+}y&quot;, trustNonStrictSettings);
       |                      ^ Lazy Test
  2163 |         expect(built).toMatchSnapshot();
  2164 |     });
  2165 |</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  2165 |
  2166 |     it(&quot;should render with trust and strict setting&quot;, function() {
&gt; 2167 |         const built &#x3D; getBuilt(html, trustNonStrictSettings);
       |                      ^ Lazy Test
  2168 |         expect(built).toMatchSnapshot();
  2169 |     });
  2170 |</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  2340 |     it(&quot;should properly render stretchy accents&quot;, function() {
  2341 |         const tex &#x3D; &#x60;\\widetilde{ABCD}&#x60;;
&gt; 2342 |         const tree &#x3D; getParsed(tex);
       |                     ^ Lazy Test
  2343 |         const markup &#x3D; buildMathML(tree, tex, defaultOptions).toMarkup();
  2344 |         expect(markup).toContain(&#39;&lt;mo stretchy&#x3D;&quot;true&quot;&gt;~&lt;&#x2F;mo&gt;&#39;);
  2345 |     });</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  2990 |     it(&quot;should allow letters [#$%&amp;~_^] without escaping&quot;, function() {
  2991 |         const url &#x3D; &quot;http:&#x2F;&#x2F;example.org&#x2F;~bar&#x2F;#top?foo&#x3D;$foo&amp;bar&#x3D;ba^r_boo%20baz&quot;;
&gt; 2992 |         const parsed1 &#x3D; getParsed(&#x60;\\href{${url}}{\\alpha}&#x60;, trustSettings)[0];
       |                        ^ Lazy Test
  2993 |         expect(parsed1.href).toBe(url);
  2994 |         const parsed2 &#x3D; getParsed(&#x60;\\url{${url}}&#x60;, trustSettings)[0];
  2995 |         expect(parsed2.href).toBe(url);</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  2998 |     it(&quot;should allow balanced braces in url&quot;, function() {
  2999 |         const url &#x3D; &quot;http:&#x2F;&#x2F;example.org&#x2F;{{}t{oo}}&quot;;
&gt; 3000 |         const parsed1 &#x3D; getParsed(&#x60;\\href{${url}}{\\alpha}&#x60;, trustSettings)[0];
       |                        ^ Lazy Test
  3001 |         expect(parsed1.href).toBe(url);
  3002 |         const parsed2 &#x3D; getParsed(&#x60;\\url{${url}}&#x60;, trustSettings)[0];
  3003 |         expect(parsed2.href).toBe(url);</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  3014 |         const url &#x3D; &quot;http:&#x2F;&#x2F;example.org&#x2F;~bar&#x2F;#top?foo&#x3D;$}foo{&amp;bar&#x3D;bar^r_boo%20baz&quot;;
  3015 |         const input &#x3D; url.replace(&#x2F;([#$%&amp;~_^{}])&#x2F;g, &#39;\\$1&#39;);
&gt; 3016 |         const parsed1 &#x3D; getParsed(&#x60;\\href{${input}}{\\alpha}&#x60;, trustSettings)[0];
       |                        ^ Lazy Test
  3017 |         expect(parsed1.href).toBe(url);
  3018 |         const parsed2 &#x3D; getParsed(&#x60;\\url{${input}}&#x60;, trustSettings)[0];
  3019 |         expect(parsed2.href).toBe(url);</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  3030 |
  3031 |     it(&quot;should not affect spacing around&quot;, function() {
&gt; 3032 |         const built &#x3D; getBuilt(&quot;a\\href{http:&#x2F;&#x2F;example.com&#x2F;}{+b}&quot;, trustSettings);
       |                      ^ Lazy Test
  3033 |         expect(built).toMatchSnapshot();
  3034 |     });
  3035 |</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  3040 |
  3041 |     it(&quot;should allow explicitly allowed protocols&quot;, () &#x3D;&gt; {
&gt; 3042 |         const parsed &#x3D; getParsed(
       |                       ^ Lazy Test
  3043 |             &quot;\\href{ftp:&#x2F;&#x2F;x}{foo}&quot;,
  3044 |             new Settings({trust: (context) &#x3D;&gt; context.protocol &#x3D;&#x3D;&#x3D; &quot;ftp&quot;}),
  3045 |         );</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  3048 |
  3049 |     it(&quot;should allow all protocols when trust option is true&quot;, () &#x3D;&gt; {
&gt; 3050 |         const parsed &#x3D; getParsed(&quot;\\href{ftp:&#x2F;&#x2F;x}{foo}&quot;, trustSettings);
       |                       ^ Lazy Test
  3051 |         expect(parsed).toMatchSnapshot();
  3052 |     });
  3053 |</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  3053 |
  3054 |     it(&quot;should not allow explicitly disallowed protocols&quot;, () &#x3D;&gt; {
&gt; 3055 |         const parsed &#x3D; getParsed(
       |                       ^ Lazy Test
  3056 |             &quot;\\href{javascript:alert(&#39;x&#39;)}{foo}&quot;,
  3057 |             new Settings({trust: context &#x3D;&gt; context.protocol !&#x3D;&#x3D; &quot;javascript&quot;}),
  3058 |         );</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  3061 |
  3062 |     it(&quot;should not allow explicitly uppercased disallowed protocols&quot;, () &#x3D;&gt; {
&gt; 3063 |         const parsed &#x3D; getParsed(
       |                       ^ Lazy Test
  3064 |             &quot;\\href{JavaScript:alert(&#39;x&#39;)}{foo}&quot;,
  3065 |             new Settings({trust: context &#x3D;&gt; context.protocol !&#x3D;&#x3D; &quot;javascript&quot;}),
  3066 |         );</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  3137 |
  3138 |     it(&quot;should produce color nodes with a color value given by errorColor&quot;, function() {
&gt; 3139 |         const parsedInput &#x3D; getParsed(r&#x60;\error&#x60;, noThrowSettings);
       |                            ^ Lazy Test
  3140 |         expect(parsedInput[0].type).toBe(&quot;color&quot;);
  3141 |         expect(parsedInput[0].color).toBe(errorColor);
  3142 |     });</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  3143 |
  3144 |     it(&quot;should build katex-error span for other type of KaTeX error&quot;, function() {
&gt; 3145 |         const built &#x3D; getBuilt(&#x60;2^2^2&#x60;, noThrowSettings);
       |                      ^ Lazy Test
  3146 |         expect(built).toMatchSnapshot();
  3147 |     });
  3148 |</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  3478 |         const parsedBare &#x3D; getParsed&#x60;~&#x60;;
  3479 |         expect(parsedBare[0].type).toEqual(&quot;spacing&quot;);
&gt; 3480 |         const parsedChar &#x3D; getParsed(&quot;\\char&#x60;\\~&quot;);
       |                           ^ Lazy Test
  3481 |         expect(parsedChar[0].type).toEqual(&quot;textord&quot;);
  3482 |     });
  3483 |</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  4050 |
  4051 |     it(&quot;should clamp size when set&quot;, function() {
&gt; 4052 |         const built &#x3D; getBuilt(rule, new Settings({maxSize: 5}))[0];
       |                      ^ Lazy Test
  4053 |         expect(built.style.borderRightWidth).toEqual(&quot;5em&quot;);
  4054 |         expect(built.style.borderTopWidth).toEqual(&quot;5em&quot;);
  4055 |     });</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  4056 |
  4057 |     it(&quot;should not clamp size when not set&quot;, function() {
&gt; 4058 |         const built &#x3D; getBuilt(rule)[0];
       |                      ^ Lazy Test
  4059 |         expect(built.style.borderRightWidth).toEqual(&quot;999em&quot;);
  4060 |         expect(built.style.borderTopWidth).toEqual(&quot;999em&quot;);
  4061 |     });</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  4062 |
  4063 |     it(&quot;should make zero-width rules if a negative maxSize is passed&quot;, function() {
&gt; 4064 |         const built &#x3D; getBuilt(rule, new Settings({maxSize: -5}))[0];
       |                      ^ Lazy Test
  4065 |         expect(built.style.borderRightWidth).toEqual(&quot;0em&quot;);
  4066 |         expect(built.style.borderTopWidth).toEqual(&quot;0em&quot;);
  4067 |     });</code></pre><br>
                      </td>
                    </tr>
                  </tbody>
                </table>
                <hr>
                <table class="table is-fullwidth" id="table-of-smell">
                  <thead>
                    <tr>
                      <td>Magic Number</td>
                    </tr>
                  </thead>
                  <tbody>
                    <tr>
                      <td>
                        <pre><code>  90 |             let group &#x3D; parse[i];
  91 |             if (group.type &#x3D;&#x3D;&#x3D; &quot;htmlmathml&quot;) {
&gt; 92 |                 expect(group.html).toHaveLength(1);
     |                                                ^ Magic Number
  93 |                 group &#x3D; group.html[0];
  94 |             }
  95 |             if (group.type &#x3D;&#x3D;&#x3D; &quot;mclass&quot;) {</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  112 |         const contents &#x3D; &quot;\\mathinner{\\langle{\\psi}\\rangle}&quot;;
  113 |         const mml &#x3D; buildMathML(getParsed(contents), contents, defaultOptions);
&gt; 114 |         expect(mml.children.length).toEqual(1);
      |                                            ^ Magic Number
  115 |     });
  116 | });
  117 |</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  344 |         const parse &#x3D; getParsed&#x60;{xy}&#x60;;
  345 |
&gt; 346 |         expect(parse).toHaveLength(1);
      |                                   ^ Magic Number
  347 |
  348 |         const ord &#x3D; parse[0];
  349 |</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  366 |         const parse &#x3D; getParsed&#x60;\begingroup xy \endgroup&#x60;;
  367 |
&gt; 368 |         expect(parse).toHaveLength(1);
      |                                   ^ Magic Number
  369 |
  370 |         const ord &#x3D; parse[0];
  371 |</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  389 |         const parse &#x3D; getParsed&#x60;\Large abc&#x60;;
  390 |
&gt; 391 |         expect(parse).toHaveLength(1);
      |                                   ^ Magic Number
  392 |
  393 |         const sizing &#x3D; parse[0];
  394 |</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  401 |         const parse &#x3D; getParsed&#x60;a \Large abc&#x60;;
  402 |
&gt; 403 |         expect(parse).toHaveLength(2);
      |                                   ^ Magic Number
  404 |
  405 |         const sizing &#x3D; parse[1];
  406 |</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  406 |
  407 |         expect(sizing.type).toEqual(&quot;sizing&quot;);
&gt; 408 |         expect(sizing.body).toHaveLength(3);
      |                                         ^ Magic Number
  409 |     });
  410 |
  411 |     it(&quot;should stop at the ends of groups&quot;, function() {</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  416 |
  417 |         expect(sizing.type).toEqual(&quot;sizing&quot;);
&gt; 418 |         expect(sizing.body).toHaveLength(1);
      |                                         ^ Magic Number
  419 |     });
  420 |
  421 |     describe(&quot;within optional groups&quot;, () &#x3D;&gt; {</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  603 |
  604 |         const numer &#x3D; parse.numer;
&gt; 605 |         expect(numer.body).toHaveLength(4);
      |                                        ^ Magic Number
  606 |     });
  607 |
  608 |     it(&quot;should create a denominator from the atoms after \\over&quot;, function() {</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  610 |
  611 |         const denom &#x3D; parse.denom;
&gt; 612 |         expect(denom.body).toHaveLength(4);
      |                                        ^ Magic Number
  613 |     });
  614 |
  615 |     it(&quot;should handle empty numerators&quot;, function() {</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  750 |         const group &#x3D; parse.body;
  751 |
&gt; 752 |         expect(group.length).toEqual(4);
      |                                     ^ Magic Number
  753 |         expect(group[0].type).toEqual(&quot;spacing&quot;);
  754 |         expect(group[1].type).toEqual(&quot;textord&quot;);
  755 |         expect(group[2].type).toEqual(&quot;spacing&quot;);</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  768 |         const parse &#x3D; getParsed(leadingSpaceTextExpression)[0];
  769 |         &#x2F;&#x2F; [m, o, o]
&gt; 770 |         expect(parse.body).toHaveLength(3);
      |                                        ^ Magic Number
  771 |         expect(parse.body.map(n &#x3D;&gt; n.text).join(&quot;&quot;)).toBe(&quot;moo&quot;);
  772 |     });
  773 |</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  978 |         const bigParse &#x3D; getParsed(bigDelim)[0];
  979 |
&gt; 980 |         expect(smallParse.size).toEqual(1);
      |                                        ^ Magic Number
  981 |         expect(bigParse.size).toEqual(4);
  982 |     });
  983 | });</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  979 |
  980 |         expect(smallParse.size).toEqual(1);
&gt; 981 |         expect(bigParse.size).toEqual(4);
      |                                      ^ Magic Number
  982 |     });
  983 | });
  984 |</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  1069 |         const hardNumberParse &#x3D; getParsed(hardNumberRule)[0];
  1070 |
&gt; 1071 |         expect(hardNumberParse.width.number).toBeCloseTo(1.24);
       |                                                         ^ Magic Number
  1072 |         expect(hardNumberParse.height.number).toBeCloseTo(2.45);
  1073 |     });
  1074 |</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  1070 |
  1071 |         expect(hardNumberParse.width.number).toBeCloseTo(1.24);
&gt; 1072 |         expect(hardNumberParse.height.number).toBeCloseTo(2.45);
       |                                                          ^ Magic Number
  1073 |     });
  1074 |
  1075 |     it(&quot;should parse negative sizes&quot;, function() {</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  1117 |     it(&quot;should parse positive sizes&quot;, function() {
  1118 |         const parse &#x3D; getParsed&#x60;\kern{+1em}&#x60;[0];
&gt; 1119 |         expect(parse.dimension.number).toBeCloseTo(1);
       |                                                   ^ Magic Number
  1120 |     });
  1121 | });
  1122 |</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  1152 |         const abParse3 &#x3D; getParsed(abKern3);
  1153 |
&gt; 1154 |         expect(abParse1).toHaveLength(3);
       |                                      ^ Magic Number
  1155 |         expect(abParse1[0].text).toEqual(&quot;a&quot;);
  1156 |         expect(abParse1[2].text).toEqual(&quot;b&quot;);
  1157 |         expect(abParse2).toHaveLength(3);</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  1155 |         expect(abParse1[0].text).toEqual(&quot;a&quot;);
  1156 |         expect(abParse1[2].text).toEqual(&quot;b&quot;);
&gt; 1157 |         expect(abParse2).toHaveLength(3);
       |                                      ^ Magic Number
  1158 |         expect(abParse2[0].text).toEqual(&quot;a&quot;);
  1159 |         expect(abParse2[2].text).toEqual(&quot;b&quot;);
  1160 |         expect(abParse3).toHaveLength(3);</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  1158 |         expect(abParse2[0].text).toEqual(&quot;a&quot;);
  1159 |         expect(abParse2[2].text).toEqual(&quot;b&quot;);
&gt; 1160 |         expect(abParse3).toHaveLength(3);
       |                                      ^ Magic Number
  1161 |         expect(abParse3[0].text).toEqual(&quot;a&quot;);
  1162 |         expect(abParse3[2].text).toEqual(&quot;b&quot;);
  1163 |     });</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  1175 |     it(&quot;should parse positive sizes&quot;, function() {
  1176 |         const parse &#x3D; getParsed&#x60;\kern+1em&#x60;[0];
&gt; 1177 |         expect(parse.dimension.number).toBeCloseTo(1);
       |                                                   ^ Magic Number
  1178 |     });
  1179 |
  1180 |     it(&quot;should handle whitespace&quot;, function() {</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  1181 |         const abParse &#x3D; getParsed(&quot;a\\mkern\t-\r1  \n mu\nb&quot;);
  1182 |
&gt; 1183 |         expect(abParse).toHaveLength(3);
       |                                     ^ Magic Number
  1184 |         expect(abParse[0].text).toEqual(&quot;a&quot;);
  1185 |         expect(abParse[1].dimension.unit).toEqual(&quot;mu&quot;);
  1186 |         expect(abParse[2].text).toEqual(&quot;b&quot;);</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  1334 |     it(&quot;should eat a final newline&quot;, function() {
  1335 |         const m3 &#x3D; getParsed&#x60;\begin{matrix}a&amp;b\\ c&amp;d \\ \end{matrix}&#x60;[0];
&gt; 1336 |         expect(m3.body).toHaveLength(2);
       |                                     ^ Magic Number
  1337 |     });
  1338 |
  1339 |     it(&quot;should grab \\arraystretch&quot;, function() {</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  1581 |         const displayBody &#x3D; displayNode.body;
  1582 |
&gt; 1583 |         expect(displayBody).toHaveLength(2);
       |                                         ^ Magic Number
  1584 |         expect(displayBody[0].text).toEqual(&quot;e&quot;);
  1585 |     });
  1586 | });</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  1635 |
  1636 |         const bbBody &#x3D; nestedParse.body.body;
&gt; 1637 |         expect(bbBody).toHaveLength(3);
       |                                    ^ Magic Number
  1638 |         expect(bbBody[0].type).toEqual(&quot;mathord&quot;);
  1639 |         expect(bbBody[2].type).toEqual(&quot;font&quot;);
  1640 |         expect(bbBody[2].font).toEqual(&quot;mathrm&quot;);</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  1647 |         expect(colorMathbbParse.color).toEqual(&quot;blue&quot;);
  1648 |         const body &#x3D; colorMathbbParse.body;
&gt; 1649 |         expect(body).toHaveLength(1);
       |                                  ^ Magic Number
  1650 |         expect(body[0].type).toEqual(&quot;font&quot;);
  1651 |         expect(body[0].font).toEqual(&quot;mathbb&quot;);
  1652 |     });</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  1660 |         expect(bf.type).toEqual(&quot;font&quot;);
  1661 |         expect(bf.font).toEqual(&quot;mathbf&quot;);
&gt; 1662 |         expect(bf.body.body).toHaveLength(3);
       |                                          ^ Magic Number
  1663 |         expect(bf.body.body[0].text).toEqual(&quot;a&quot;);
  1664 |         expect(bf.body.body[1].type).toEqual(&quot;font&quot;);
  1665 |         expect(bf.body.body[1].font).toEqual(&quot;mathrm&quot;);</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  2233 |         &#x2F;&#x2F; Just a few quick sanity checks here...
  2234 |         const markup &#x3D; katex.renderToString(r&#x60;\sigma^2&#x60;);
&gt; 2235 |         expect(markup.indexOf(&quot;&lt;span&quot;)).toBe(0);
       |                                             ^ Magic Number
  2236 |         expect(markup).toContain(&quot;\u03c3&quot;);  &#x2F;&#x2F; sigma
  2237 |         expect(markup).toContain(&quot;margin-right&quot;);
  2238 |         expect(markup).not.toContain(&quot;marginRight&quot;);</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  2739 |             parseTree(r&#x60;\sqrt}&#x60;, new Settings());
  2740 |         } catch (e) {
&gt; 2741 |             expect(e.position).toEqual(5);
       |                                       ^ Magic Number
  2742 |         }
  2743 |     });
  2744 | });</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  2873 |     it(&quot;should not eat the last row when its first cell is empty&quot;, function() {
  2874 |         const ae &#x3D; getParsed&#x60;\begin{aligned}&amp;E_1 &amp; (1)\\&amp;E_2 &amp; (2)\\&amp;E_3 &amp; (3)\end{aligned}&#x60;[0];
&gt; 2875 |         expect(ae.body).toHaveLength(3);
       |                                     ^ Magic Number
  2876 |     });
  2877 | });
  2878 |</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  3164 |             expect(error.message).toBe(&quot;KaTeX parse error: Undefined control sequence: \\fraq at position 5: 1 + \\̲f̲r̲a̲q̲{}{}&quot;);
  3165 |             expect(error.rawMessage).toBe(&quot;Undefined control sequence: \\fraq&quot;);
&gt; 3166 |             expect(error.position).toBe(4);
       |                                        ^ Magic Number
  3167 |             expect(error.length).toBe(5);
  3168 |         }
  3169 |     });</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  3165 |             expect(error.rawMessage).toBe(&quot;Undefined control sequence: \\fraq&quot;);
  3166 |             expect(error.position).toBe(4);
&gt; 3167 |             expect(error.length).toBe(5);
       |                                      ^ Magic Number
  3168 |         }
  3169 |     });
  3170 |</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  3179 |             expect(error.message).toBe(&quot;KaTeX parse error: Unexpected end of input in a macro argument, expected &#39;}&#39; at end of input: \\frac{}&quot;);
  3180 |             expect(error.rawMessage).toBe(&quot;Unexpected end of input in a macro argument, expected &#39;}&#39;&quot;);
&gt; 3181 |             expect(error.position).toBe(7);
       |                                        ^ Magic Number
  3182 |             expect(error.length).toBe(0);
  3183 |         }
  3184 |     });</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  3180 |             expect(error.rawMessage).toBe(&quot;Unexpected end of input in a macro argument, expected &#39;}&#39;&quot;);
  3181 |             expect(error.position).toBe(7);
&gt; 3182 |             expect(error.length).toBe(0);
       |                                      ^ Magic Number
  3183 |         }
  3184 |     });
  3185 |</code></pre><br>
                      </td>
                    </tr>
                  </tbody>
                </table>
                <hr>
                <table class="table is-fullwidth" id="table-of-smell">
                  <thead>
                    <tr>
                      <td>Redundant Assertion</td>
                    </tr>
                  </thead>
                  <tbody>
                    <tr>
                      <td>
                        <pre><code>  758 |
  759 |     it(&quot;should handle backslash followed by newline&quot;, () &#x3D;&gt; {
&gt; 760 |         expect(&quot;\\text{\\ \t\r \n \t\r  }&quot;).toParseLike&#x60;\text{\ }&#x60;;
      |        ^ Redundant Assertion
  761 |     });
  762 |
  763 |     it(&quot;should accept math mode tokens after its argument&quot;, function() {</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  1729 | describe(&quot;A comment parser&quot;, function() {
  1730 |     it(&quot;should parse comments at the end of a line&quot;, () &#x3D;&gt; {
&gt; 1731 |         expect(&quot;a^2 + b^2 &#x3D; c^2 % Pythagoras&#39; Theorem\n&quot;).toParse();
       |        ^ Redundant Assertion
  1732 |     });
  1733 |
  1734 |     it(&quot;should parse comments at the start of a line&quot;, () &#x3D;&gt; {</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  1733 |
  1734 |     it(&quot;should parse comments at the start of a line&quot;, () &#x3D;&gt; {
&gt; 1735 |         expect(&quot;% comment\n&quot;).toParse();
       |        ^ Redundant Assertion
  1736 |     });
  1737 |
  1738 |     it(&quot;should parse multiple lines of comments in a row&quot;, () &#x3D;&gt; {</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  1737 |
  1738 |     it(&quot;should parse multiple lines of comments in a row&quot;, () &#x3D;&gt; {
&gt; 1739 |         expect(&quot;% comment 1\n% comment 2\n&quot;).toParse();
       |        ^ Redundant Assertion
  1740 |     });
  1741 |
  1742 |     it(&quot;should parse comments between subscript and superscript&quot;, () &#x3D;&gt; {</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  1741 |
  1742 |     it(&quot;should parse comments between subscript and superscript&quot;, () &#x3D;&gt; {
&gt; 1743 |         expect(&quot;x_3 %comment\n^2&quot;).toParseLike&#x60;x_3^2&#x60;;
       |        ^ Redundant Assertion
  1744 |         expect(&quot;x^ %comment\n{2}&quot;).toParseLike&#x60;x^{2}&#x60;;
  1745 |         expect(&quot;x^ %comment\n\\frac{1}{2}&quot;).toParseLike&#x60;x^\frac{1}{2}&#x60;;
  1746 |     });</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  1742 |     it(&quot;should parse comments between subscript and superscript&quot;, () &#x3D;&gt; {
  1743 |         expect(&quot;x_3 %comment\n^2&quot;).toParseLike&#x60;x_3^2&#x60;;
&gt; 1744 |         expect(&quot;x^ %comment\n{2}&quot;).toParseLike&#x60;x^{2}&#x60;;
       |        ^ Redundant Assertion
  1745 |         expect(&quot;x^ %comment\n\\frac{1}{2}&quot;).toParseLike&#x60;x^\frac{1}{2}&#x60;;
  1746 |     });
  1747 |</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  1743 |         expect(&quot;x_3 %comment\n^2&quot;).toParseLike&#x60;x_3^2&#x60;;
  1744 |         expect(&quot;x^ %comment\n{2}&quot;).toParseLike&#x60;x^{2}&#x60;;
&gt; 1745 |         expect(&quot;x^ %comment\n\\frac{1}{2}&quot;).toParseLike&#x60;x^\frac{1}{2}&#x60;;
       |        ^ Redundant Assertion
  1746 |     });
  1747 |
  1748 |     it(&quot;should parse comments in size and color groups&quot;, () &#x3D;&gt; {</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  1747 |
  1748 |     it(&quot;should parse comments in size and color groups&quot;, () &#x3D;&gt; {
&gt; 1749 |         expect(&quot;\\kern{1 %kern\nem}&quot;).toParse();
       |        ^ Redundant Assertion
  1750 |         expect(&quot;\\kern1 %kern\nem&quot;).toParse();
  1751 |         expect(&quot;\\color{#f00%red\n}&quot;).toParse();
  1752 |     });</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  1748 |     it(&quot;should parse comments in size and color groups&quot;, () &#x3D;&gt; {
  1749 |         expect(&quot;\\kern{1 %kern\nem}&quot;).toParse();
&gt; 1750 |         expect(&quot;\\kern1 %kern\nem&quot;).toParse();
       |        ^ Redundant Assertion
  1751 |         expect(&quot;\\color{#f00%red\n}&quot;).toParse();
  1752 |     });
  1753 |</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  1749 |         expect(&quot;\\kern{1 %kern\nem}&quot;).toParse();
  1750 |         expect(&quot;\\kern1 %kern\nem&quot;).toParse();
&gt; 1751 |         expect(&quot;\\color{#f00%red\n}&quot;).toParse();
       |        ^ Redundant Assertion
  1752 |     });
  1753 |
  1754 |     it(&quot;should parse comments before an expression&quot;, () &#x3D;&gt; {</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  1753 |
  1754 |     it(&quot;should parse comments before an expression&quot;, () &#x3D;&gt; {
&gt; 1755 |         expect(&quot;%comment\n{2}&quot;).toParseLike&#x60;{2}&#x60;;
       |        ^ Redundant Assertion
  1756 |     });
  1757 |
  1758 |     it(&quot;should parse comments before and between \\hline&quot;, () &#x3D;&gt; {</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  1763 |
  1764 |     it(&quot;should parse comments in the macro definition&quot;, () &#x3D;&gt; {
&gt; 1765 |         expect(&quot;\\def\\foo{1 %}\n2}\n\\foo&quot;).toParseLike&#x60;12&#x60;;
       |        ^ Redundant Assertion
  1766 |     });
  1767 |
  1768 |     it(&quot;should not expand nor ignore spaces after a command sequence in a comment&quot;, () &#x3D;&gt; {</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  1767 |
  1768 |     it(&quot;should not expand nor ignore spaces after a command sequence in a comment&quot;, () &#x3D;&gt; {
&gt; 1769 |         expect(&quot;\\def\\foo{1\n2}\nx %\\foo\n&quot;).toParseLike&#x60;x&#x60;;
       |        ^ Redundant Assertion
  1770 |     });
  1771 |
  1772 |     it(&quot;should not parse a comment without newline in strict mode&quot;, () &#x3D;&gt; {</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  1776 |
  1777 |     it(&quot;should not produce or consume space&quot;, () &#x3D;&gt; {
&gt; 1778 |         expect(&quot;\\text{hello% comment 1\nworld}&quot;).toParseLike&#x60;\text{helloworld}&#x60;;
       |        ^ Redundant Assertion
  1779 |         expect(&quot;\\text{hello% comment\n\nworld}&quot;).toParseLike&#x60;\text{hello world}&#x60;;
  1780 |     });
  1781 |</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  1777 |     it(&quot;should not produce or consume space&quot;, () &#x3D;&gt; {
  1778 |         expect(&quot;\\text{hello% comment 1\nworld}&quot;).toParseLike&#x60;\text{helloworld}&#x60;;
&gt; 1779 |         expect(&quot;\\text{hello% comment\n\nworld}&quot;).toParseLike&#x60;\text{hello world}&#x60;;
       |        ^ Redundant Assertion
  1780 |     });
  1781 |
  1782 |     it(&quot;should not include comments in the output&quot;, () &#x3D;&gt; {</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  1781 |
  1782 |     it(&quot;should not include comments in the output&quot;, () &#x3D;&gt; {
&gt; 1783 |         expect(&quot;5 % comment\n&quot;).toParseLike&#x60;5&#x60;;
       |        ^ Redundant Assertion
  1784 |     });
  1785 | });
  1786 |</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  2176 |
  2177 |                 &#x2F;&#x2F; Render is expected to throw, so this should not be called.
&gt; 2178 |                 expect(true).toBe(false);
       |                ^ Redundant Assertion
  2179 |             } catch (error) {
  2180 |                 expect(error).toBeInstanceOf(ParseError);
  2181 |                 const message &#x3D;</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  2978 |         expect&#x60;\href%end&#x60;.toParseLike(&quot;\\href{%}end&quot;, trustSettings);
  2979 |         expect&#x60;\url%end&#x60;.toParseLike(&quot;\\url{%}end&quot;, trustSettings);
&gt; 2980 |         expect(&quot;\\url%%end\n&quot;).toParseLike(&quot;\\url{%}&quot;, trustSettings);
       |        ^ Redundant Assertion
  2981 |         expect&#x60;\url end&#x60;.toParseLike(&quot;\\url{e}nd&quot;, trustSettings);
  2982 |         expect&#x60;\url%end&#x60;.toParseLike(&quot;\\url {%}end&quot;, trustSettings);
  2983 |     });</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  3021 |
  3022 |     it(&quot;should allow comments after URLs&quot;, function() {
&gt; 3023 |         expect(&quot;\\url{http:&#x2F;&#x2F;example.com&#x2F;}%comment\n&quot;).toBuild();
       |        ^ Redundant Assertion
  3024 |     });
  3025 |
  3026 |     it(&quot;should be marked up correctly&quot;, function() {</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  3159 |
  3160 |             &#x2F;&#x2F; Render is expected to throw, so this should not be called.
&gt; 3161 |             expect(true).toBe(false);
       |            ^ Redundant Assertion
  3162 |         } catch (error) {
  3163 |             expect(error).toBeInstanceOf(ParseError);
  3164 |             expect(error.message).toBe(&quot;KaTeX parse error: Undefined control sequence: \\fraq at position 5: 1 + \\̲f̲r̲a̲q̲{}{}&quot;);</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  3174 |
  3175 |             &#x2F;&#x2F; Render is expected to throw, so this should not be called.
&gt; 3176 |             expect(true).toBe(false);
       |            ^ Redundant Assertion
  3177 |         } catch (error) {
  3178 |             expect(error).toBeInstanceOf(ParseError);
  3179 |             expect(error.message).toBe(&quot;KaTeX parse error: Unexpected end of input in a macro argument, expected &#39;}&#39; at end of input: \\frac{}&quot;);</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  3189 |
  3190 |             &#x2F;&#x2F; Render is expected to throw, so this should not be called.
&gt; 3191 |             expect(true).toBe(false);
       |            ^ Redundant Assertion
  3192 |         } catch (error) {
  3193 |             expect(error).toBeInstanceOf(ParseError);
  3194 |             expect(error.message).toBe(&quot;KaTeX parse error: \\verb ended by end of line instead of matching delimiter&quot;);</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  3462 |
  3463 |     it(&quot;\\char produces literal characters&quot;, () &#x3D;&gt; {
&gt; 3464 |         expect(&quot;\\char&#x60;a&quot;).toParseLike(&quot;\\char&#x60;\\a&quot;);
       |        ^ Redundant Assertion
  3465 |         expect(&quot;\\char&#x60;\\%&quot;).toParseLike&#x60;\char37&#x60;;
  3466 |         expect(&quot;\\char&#x60;\\%&quot;).toParseLike&#x60;\char&#39;45&#x60;;
  3467 |         expect(&quot;\\char&#x60;\\%&quot;).toParseLike&#x60;\char&quot;25&#x60;;</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  3463 |     it(&quot;\\char produces literal characters&quot;, () &#x3D;&gt; {
  3464 |         expect(&quot;\\char&#x60;a&quot;).toParseLike(&quot;\\char&#x60;\\a&quot;);
&gt; 3465 |         expect(&quot;\\char&#x60;\\%&quot;).toParseLike&#x60;\char37&#x60;;
       |        ^ Redundant Assertion
  3466 |         expect(&quot;\\char&#x60;\\%&quot;).toParseLike&#x60;\char&#39;45&#x60;;
  3467 |         expect(&quot;\\char&#x60;\\%&quot;).toParseLike&#x60;\char&quot;25&#x60;;
  3468 |         expect&#x60;\char&#x60;.not.toParse();</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  3464 |         expect(&quot;\\char&#x60;a&quot;).toParseLike(&quot;\\char&#x60;\\a&quot;);
  3465 |         expect(&quot;\\char&#x60;\\%&quot;).toParseLike&#x60;\char37&#x60;;
&gt; 3466 |         expect(&quot;\\char&#x60;\\%&quot;).toParseLike&#x60;\char&#39;45&#x60;;
       |        ^ Redundant Assertion
  3467 |         expect(&quot;\\char&#x60;\\%&quot;).toParseLike&#x60;\char&quot;25&#x60;;
  3468 |         expect&#x60;\char&#x60;.not.toParse();
  3469 |         expect(&quot;\\char&#x60;&quot;).not.toParse();</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  3465 |         expect(&quot;\\char&#x60;\\%&quot;).toParseLike&#x60;\char37&#x60;;
  3466 |         expect(&quot;\\char&#x60;\\%&quot;).toParseLike&#x60;\char&#39;45&#x60;;
&gt; 3467 |         expect(&quot;\\char&#x60;\\%&quot;).toParseLike&#x60;\char&quot;25&#x60;;
       |        ^ Redundant Assertion
  3468 |         expect&#x60;\char&#x60;.not.toParse();
  3469 |         expect(&quot;\\char&#x60;&quot;).not.toParse();
  3470 |         expect&#x60;\char&#39;&#x60;.not.toParse();</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  3467 |         expect(&quot;\\char&#x60;\\%&quot;).toParseLike&#x60;\char&quot;25&#x60;;
  3468 |         expect&#x60;\char&#x60;.not.toParse();
&gt; 3469 |         expect(&quot;\\char&#x60;&quot;).not.toParse();
       |        ^ Redundant Assertion
  3470 |         expect&#x60;\char&#39;&#x60;.not.toParse();
  3471 |         expect&#x60;\char&quot;&#x60;.not.toParse();
  3472 |         expect&#x60;\char&#39;a&#x60;.not.toParse();</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  3931 |
  3932 |     it(&quot;should parse combining characters&quot;, function() {
&gt; 3933 |         expect(&quot;A\u0301C\u0301&quot;).toParseLike(r&#x60;Á\acute C&#x60;, nonstrictSettings);
       |        ^ Redundant Assertion
  3934 |         expect(&quot;\\text{A\u0301C\u0301}&quot;).toParseLike(r&#x60;\text{Á\&#39;C}&#x60;, strictSettings);
  3935 |     });
  3936 |</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  3932 |     it(&quot;should parse combining characters&quot;, function() {
  3933 |         expect(&quot;A\u0301C\u0301&quot;).toParseLike(r&#x60;Á\acute C&#x60;, nonstrictSettings);
&gt; 3934 |         expect(&quot;\\text{A\u0301C\u0301}&quot;).toParseLike(r&#x60;\text{Á\&#39;C}&#x60;, strictSettings);
       |        ^ Redundant Assertion
  3935 |     });
  3936 |
  3937 |     it(&quot;should parse multi-accented characters&quot;, function() {</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  3970 |
  3971 |     it(&quot;should parse symbols&quot;, function() {
&gt; 3972 |         expect(&quot;£¥ℂℍℑℎℓℕ℘ℙℚℜℝℤℲℵðℶℷℸ⅁∀∁∂∃∇∞∠∡∢♠♡♢♣♭♮♯✓°¬‼⋮\u00B7\u00A9&quot;).toBuild(strictSettings);
       |        ^ Redundant Assertion
  3973 |         expect(&quot;\\text{£¥ℂℍℎ\u00A9\u00AE\uFE0F}&quot;).toBuild(strictSettings);
  3974 |     });
  3975 |</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  3971 |     it(&quot;should parse symbols&quot;, function() {
  3972 |         expect(&quot;£¥ℂℍℑℎℓℕ℘ℙℚℜℝℤℲℵðℶℷℸ⅁∀∁∂∃∇∞∠∡∢♠♡♢♣♭♮♯✓°¬‼⋮\u00B7\u00A9&quot;).toBuild(strictSettings);
&gt; 3973 |         expect(&quot;\\text{£¥ℂℍℎ\u00A9\u00AE\uFE0F}&quot;).toBuild(strictSettings);
       |        ^ Redundant Assertion
  3974 |     });
  3975 |
  3976 |     it(&quot;should build Greek capital letters&quot;, function() {</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  3988 |
  3989 |     it(&quot;should build binary operators&quot;, function() {
&gt; 3990 |         expect(&quot;±×÷∓∔∧∨∩∪≀⊎⊓⊔⊕⊖⊗⊘⊙⊚⊛⊝◯⊞⊟⊠⊡⊺⊻⊼⋇⋉⋊⋋⋌⋎⋏⋒⋓⩞\u22C5\u2218\u2216\u2219&quot;).toBuild(strictSettings);
       |        ^ Redundant Assertion
  3991 |     });
  3992 |
  3993 |     it(&quot;should build common ords&quot;, function() {</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  3992 |
  3993 |     it(&quot;should build common ords&quot;, function() {
&gt; 3994 |         expect(&quot;§¶£¥∇∞⋅∠∡∢♠♡♢♣♭♮♯✓…⋮⋯⋱! ‼ ⦵&quot;).toBuild(strictSettings);
       |        ^ Redundant Assertion
  3995 |     });
  3996 |
  3997 |     it(&quot;should build delimiters&quot;, function() {</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  3996 |
  3997 |     it(&quot;should build delimiters&quot;, function() {
&gt; 3998 |         expect(&quot;\\left\u230A\\frac{a}{b}\\right\u230B&quot;).toBuild();
       |        ^ Redundant Assertion
  3999 |         expect(&quot;\\left\u2308\\frac{a}{b}\\right\u2308&quot;).toBuild();
  4000 |         expect(&quot;\\left\u27ee\\frac{a}{b}\\right\u27ef&quot;).toBuild();
  4001 |         expect(&quot;\\left\u27e8\\frac{a}{b}\\right\u27e9&quot;).toBuild();</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  3997 |     it(&quot;should build delimiters&quot;, function() {
  3998 |         expect(&quot;\\left\u230A\\frac{a}{b}\\right\u230B&quot;).toBuild();
&gt; 3999 |         expect(&quot;\\left\u2308\\frac{a}{b}\\right\u2308&quot;).toBuild();
       |        ^ Redundant Assertion
  4000 |         expect(&quot;\\left\u27ee\\frac{a}{b}\\right\u27ef&quot;).toBuild();
  4001 |         expect(&quot;\\left\u27e8\\frac{a}{b}\\right\u27e9&quot;).toBuild();
  4002 |         expect(&quot;\\left\u23b0\\frac{a}{b}\\right\u23b1&quot;).toBuild();</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  3998 |         expect(&quot;\\left\u230A\\frac{a}{b}\\right\u230B&quot;).toBuild();
  3999 |         expect(&quot;\\left\u2308\\frac{a}{b}\\right\u2308&quot;).toBuild();
&gt; 4000 |         expect(&quot;\\left\u27ee\\frac{a}{b}\\right\u27ef&quot;).toBuild();
       |        ^ Redundant Assertion
  4001 |         expect(&quot;\\left\u27e8\\frac{a}{b}\\right\u27e9&quot;).toBuild();
  4002 |         expect(&quot;\\left\u23b0\\frac{a}{b}\\right\u23b1&quot;).toBuild();
  4003 |         expect&#x60;┌x┐ └x┘&#x60;.toBuild();</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  3999 |         expect(&quot;\\left\u2308\\frac{a}{b}\\right\u2308&quot;).toBuild();
  4000 |         expect(&quot;\\left\u27ee\\frac{a}{b}\\right\u27ef&quot;).toBuild();
&gt; 4001 |         expect(&quot;\\left\u27e8\\frac{a}{b}\\right\u27e9&quot;).toBuild();
       |        ^ Redundant Assertion
  4002 |         expect(&quot;\\left\u23b0\\frac{a}{b}\\right\u23b1&quot;).toBuild();
  4003 |         expect&#x60;┌x┐ └x┘&#x60;.toBuild();
  4004 |         expect(&quot;\u231Cx\u231D \u231Ex\u231F&quot;).toBuild();</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  4000 |         expect(&quot;\\left\u27ee\\frac{a}{b}\\right\u27ef&quot;).toBuild();
  4001 |         expect(&quot;\\left\u27e8\\frac{a}{b}\\right\u27e9&quot;).toBuild();
&gt; 4002 |         expect(&quot;\\left\u23b0\\frac{a}{b}\\right\u23b1&quot;).toBuild();
       |        ^ Redundant Assertion
  4003 |         expect&#x60;┌x┐ └x┘&#x60;.toBuild();
  4004 |         expect(&quot;\u231Cx\u231D \u231Ex\u231F&quot;).toBuild();
  4005 |         expect(&quot;\u27E6x\u27E7&quot;).toBuild();</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  4002 |         expect(&quot;\\left\u23b0\\frac{a}{b}\\right\u23b1&quot;).toBuild();
  4003 |         expect&#x60;┌x┐ └x┘&#x60;.toBuild();
&gt; 4004 |         expect(&quot;\u231Cx\u231D \u231Ex\u231F&quot;).toBuild();
       |        ^ Redundant Assertion
  4005 |         expect(&quot;\u27E6x\u27E7&quot;).toBuild();
  4006 |         expect(&quot;\\llbracket \\rrbracket&quot;).toBuild();
  4007 |         expect(&quot;\\lBrace \\rBrace&quot;).toBuild();</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  4003 |         expect&#x60;┌x┐ └x┘&#x60;.toBuild();
  4004 |         expect(&quot;\u231Cx\u231D \u231Ex\u231F&quot;).toBuild();
&gt; 4005 |         expect(&quot;\u27E6x\u27E7&quot;).toBuild();
       |        ^ Redundant Assertion
  4006 |         expect(&quot;\\llbracket \\rrbracket&quot;).toBuild();
  4007 |         expect(&quot;\\lBrace \\rBrace&quot;).toBuild();
  4008 |     });</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  4004 |         expect(&quot;\u231Cx\u231D \u231Ex\u231F&quot;).toBuild();
  4005 |         expect(&quot;\u27E6x\u27E7&quot;).toBuild();
&gt; 4006 |         expect(&quot;\\llbracket \\rrbracket&quot;).toBuild();
       |        ^ Redundant Assertion
  4007 |         expect(&quot;\\lBrace \\rBrace&quot;).toBuild();
  4008 |     });
  4009 |</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  4005 |         expect(&quot;\u27E6x\u27E7&quot;).toBuild();
  4006 |         expect(&quot;\\llbracket \\rrbracket&quot;).toBuild();
&gt; 4007 |         expect(&quot;\\lBrace \\rBrace&quot;).toBuild();
       |        ^ Redundant Assertion
  4008 |     });
  4009 |
  4010 |     it(&quot;should build some surrogate pairs&quot;, function() {</code></pre><br>
                      </td>
                    </tr>
                  </tbody>
                </table>
                <hr>
                <table class="table is-fullwidth" id="table-of-smell">
                  <thead>
                    <tr>
                      <td>Redundant Print</td>
                    </tr>
                  </thead>
                  <tbody>
                    <tr>
                      <td>
                        <pre><code>  4275 |             expect&#x60;\message{Hello, world}&#x60;.toParse();
  4276 |             &#x2F;&#x2F; eslint-disable-next-line no-console
&gt; 4277 |             expect(console.log).toHaveBeenCalledWith(&quot;Hello, world&quot;);
       |                   ^ Redundant Print
  4278 |         });
  4279 |     });
  4280 |</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  4284 |             expect&#x60;\errmessage{Hello, world}&#x60;.toParse();
  4285 |             &#x2F;&#x2F; eslint-disable-next-line no-console
&gt; 4286 |             expect(console.error).toHaveBeenCalledWith(&quot;Hello, world&quot;);
       |                   ^ Redundant Print
  4287 |         });
  4288 |     });
  4289 | });</code></pre><br>
                      </td>
                    </tr>
                  </tbody>
                </table>
                <hr>
                <table class="table is-fullwidth" id="table-of-smell">
                  <thead>
                    <tr>
                      <td>Unknown Test</td>
                    </tr>
                  </thead>
                  <tbody>
                    <tr>
                      <td>
                        <pre><code>  21 |
  22 | describe(&quot;A parser&quot;, function() {
&gt; 23 |     it(&quot;should not fail on an empty string&quot;, function() {
     |    ^ Unknown Test
  24 |         expect&#x60;&#x60;.toParse(strictSettings);
  25 |     });
  26 |</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  25 |     });
  26 |
&gt; 27 |     it(&quot;should ignore whitespace&quot;, function() {
     |    ^ Unknown Test
  28 |         expect&#x60;    x    y    &#x60;.toParseLike(&quot;xy&quot;, strictSettings);
  29 |     });
  30 |</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  29 |     });
  30 |
&gt; 31 |     it(&quot;should ignore whitespace in atom&quot;, function() {
     |    ^ Unknown Test
  32 |         expect&#x60;    x   ^ y    &#x60;.toParseLike(&quot;x^y&quot;, strictSettings);
  33 |     });
  34 | });</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  104 |
  105 | describe(&quot;A mathinner parser&quot;, function() {
&gt; 106 |     it(&quot;should not fail&quot;, function() {
      |    ^ Unknown Test
  107 |         expect&#x60;\mathinner{\langle{\psi}\rangle}&#x60;.toParse();
  108 |         expect&#x60;\frac 1 {\mathinner{\langle{\psi}\rangle}}&#x60;.toParse();
  109 |     });</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  171 |
  172 | describe(&quot;A \\KaTeX parser&quot;, function() {
&gt; 173 |     it(&quot;should not fail&quot;, function() {
      |    ^ Unknown Test
  174 |         expect&#x60;\KaTeX&#x60;.toParse();
  175 |     });
  176 | });</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  177 |
  178 | describe(&quot;A subscript and superscript parser&quot;, function() {
&gt; 179 |     it(&quot;should not fail on superscripts&quot;, function() {
      |    ^ Unknown Test
  180 |         expect&#x60;x^2&#x60;.toParse();
  181 |     });
  182 |</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  181 |     });
  182 |
&gt; 183 |     it(&quot;should not fail on subscripts&quot;, function() {
      |    ^ Unknown Test
  184 |         expect&#x60;x_3&#x60;.toParse();
  185 |     });
  186 |</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  185 |     });
  186 |
&gt; 187 |     it(&quot;should not fail on both subscripts and superscripts&quot;, function() {
      |    ^ Unknown Test
  188 |         expect&#x60;x^2_3&#x60;.toParse();
  189 |
  190 |         expect&#x60;x_2^3&#x60;.toParse();</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  191 |     });
  192 |
&gt; 193 |     it(&quot;should not fail when there is no nucleus&quot;, function() {
      |    ^ Unknown Test
  194 |         expect&#x60;^3&#x60;.toParse();
  195 |         expect&#x60;^3+&#x60;.toParse();
  196 |         expect&#x60;_2&#x60;.toParse();</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  235 |     });
  236 |
&gt; 237 |     it(&quot;should produce the same thing regardless of order&quot;, function() {
      |    ^ Unknown Test
  238 |         expect&#x60;x^2_3&#x60;.toParseLike&#x60;x_3^2&#x60;;
  239 |     });
  240 |</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  239 |     });
  240 |
&gt; 241 |     it(&quot;should not parse double subscripts or superscripts&quot;, function() {
      |    ^ Unknown Test
  242 |         expect&#x60;x^x^x&#x60;.not.toParse();
  243 |
  244 |         expect&#x60;x_x_x&#x60;.not.toParse();</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  253 |     });
  254 |
&gt; 255 |     it(&quot;should work correctly with {}s&quot;, function() {
      |    ^ Unknown Test
  256 |         expect&#x60;x^{2+3}&#x60;.toParse();
  257 |
  258 |         expect&#x60;x_{3-2}&#x60;.toParse();</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  271 |     });
  272 |
&gt; 273 |     it(&quot;should work with nested super&#x2F;subscripts&quot;, function() {
      |    ^ Unknown Test
  274 |         expect&#x60;x^{x^x}&#x60;.toParse();
  275 |         expect&#x60;x^{x_x}&#x60;.toParse();
  276 |         expect&#x60;x_{x^x}&#x60;.toParse();</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  278 |     });
  279 |
&gt; 280 |     it(&quot;should work with Unicode (sub|super)script characters&quot;, function() {
      |    ^ Unknown Test
  281 |         expect&#x60;A² + B²⁺³ + ¹²C + E₂³ + F₂₊₃&#x60;.toParseLike&#x60;A^{2} + B^{2+3} + ^{12}C + E_{2}^{3} + F_{2+3}&#x60;;
  282 |     });
  283 |</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  282 |     });
  283 |
&gt; 284 |     it(&quot;should not fail if \\relax is in an atom&quot;, function() {
      |    ^ Unknown Test
  285 |         expect&#x60;\hskip1em\relax^2&#x60;.toParse(strictSettings);
  286 |     });
  287 |</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  286 |     });
  287 |
&gt; 288 |     it(&quot;should skip \\relax in super&#x2F;subscripts&quot;, function() {
      |    ^ Unknown Test
  289 |         expect&#x60;x^\relax 2&#x60;.toParseLike&#x60;x^2&#x60;;
  290 |         expect&#x60;x_\relax 2&#x60;.toParseLike&#x60;x_2&#x60;;
  291 |     });</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  293 |
  294 | describe(&quot;A subscript and superscript tree-builder&quot;, function() {
&gt; 295 |     it(&quot;should not fail when there is no nucleus&quot;, function() {
      |    ^ Unknown Test
  296 |         expect&#x60;^3&#x60;.toBuild();
  297 |         expect&#x60;_2&#x60;.toBuild();
  298 |         expect&#x60;^3_2&#x60;.toBuild();</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  302 |
  303 | describe(&quot;A parser with limit controls&quot;, function() {
&gt; 304 |     it(&quot;should fail when the limit control is not preceded by an op node&quot;, function() {
      |    ^ Unknown Test
  305 |         expect&#x60;3\nolimits_2^2&#x60;.not.toParse();
  306 |         expect&#x60;\sqrt\limits_2^2&#x60;.not.toParse();
  307 |         expect&#x60;45 +\nolimits 45&#x60;.not.toParse();</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  308 |     });
  309 |
&gt; 310 |     it(&quot;should parse when the limit control directly follows an op node&quot;, function() {
      |    ^ Unknown Test
  311 |         expect&#x60;\int\limits_2^2 3&#x60;.toParse();
  312 |         expect&#x60;\sum\nolimits_3^4 4&#x60;.toParse();
  313 |     });</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  313 |     });
  314 |
&gt; 315 |     it(&quot;should parse when the limit control is in the sup&#x2F;sub area of an op node&quot;, function() {
      |    ^ Unknown Test
  316 |         expect&#x60;\int_2^2\limits&#x60;.toParse();
  317 |         expect&#x60;\int^2\nolimits_2&#x60;.toParse();
  318 |         expect&#x60;\int_2\limits^2&#x60;.toParse();</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  319 |     });
  320 |
&gt; 321 |     it(&quot;should allow multiple limit controls in the sup&#x2F;sub area of an op node&quot;, function() {
      |    ^ Unknown Test
  322 |         expect&#x60;\int_2\nolimits^2\limits 3&#x60;.toParse();
  323 |         expect&#x60;\int\nolimits\limits_2^2&#x60;.toParse();
  324 |         expect&#x60;\int\limits\limits\limits_2^2&#x60;.toParse();</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  337 |
  338 | describe(&quot;A group parser&quot;, function() {
&gt; 339 |     it(&quot;should not fail&quot;, function() {
      |    ^ Unknown Test
  340 |         expect&#x60;{xy}&#x60;.toParse();
  341 |     });
  342 |</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  354 |
  355 | describe(&quot;A \\begingroup...\\endgroup parser&quot;, function() {
&gt; 356 |     it(&quot;should not fail&quot;, function() {
      |    ^ Unknown Test
  357 |         expect&#x60;\begingroup xy \endgroup&#x60;.toParse();
  358 |     });
  359 |</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  358 |     });
  359 |
&gt; 360 |     it(&quot;should fail when it is mismatched&quot;, function() {
      |    ^ Unknown Test
  361 |         expect&#x60;\begingroup xy&#x60;.not.toParse();
  362 |         expect&#x60;\begingroup xy }&#x60;.not.toParse();
  363 |     });</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  375 |     });
  376 |
&gt; 377 |     it(&quot;should not affect spacing in math mode&quot;, function() {
      |    ^ Unknown Test
  378 |         expect&#x60;\begingroup x+ \endgroup y&#x60;.toBuildLike&#x60;x+y&#x60;;
  379 |     });
  380 | });</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  381 |
  382 | describe(&quot;An implicit group parser&quot;, function() {
&gt; 383 |     it(&quot;should not fail&quot;, function() {
      |    ^ Unknown Test
  384 |         expect&#x60;\Large x&#x60;.toParse();
  385 |         expect&#x60;abc {abc \Large xyz} abc&#x60;.toParse();
  386 |     });</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  443 |
  444 | describe(&quot;A function parser&quot;, function() {
&gt; 445 |     it(&quot;should parse no argument functions&quot;, function() {
      |    ^ Unknown Test
  446 |         expect&#x60;\div&#x60;.toParse();
  447 |     });
  448 |</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  447 |     });
  448 |
&gt; 449 |     it(&quot;should parse 1 argument functions&quot;, function() {
      |    ^ Unknown Test
  450 |         expect&#x60;\blue x&#x60;.toParse();
  451 |     });
  452 |</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  451 |     });
  452 |
&gt; 453 |     it(&quot;should parse 2 argument functions&quot;, function() {
      |    ^ Unknown Test
  454 |         expect&#x60;\frac 1 2&#x60;.toParse();
  455 |     });
  456 |</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  455 |     });
  456 |
&gt; 457 |     it(&quot;should not parse 1 argument functions with no arguments&quot;, function() {
      |    ^ Unknown Test
  458 |         expect&#x60;\blue&#x60;.not.toParse();
  459 |     });
  460 |</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  459 |     });
  460 |
&gt; 461 |     it(&quot;should not parse 2 argument functions with 0 or 1 arguments&quot;, function() {
      |    ^ Unknown Test
  462 |         expect&#x60;\frac&#x60;.not.toParse();
  463 |
  464 |         expect&#x60;\frac 1&#x60;.not.toParse();</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  465 |     });
  466 |
&gt; 467 |     it(&quot;should not parse a function with text right after it&quot;, function() {
      |    ^ Unknown Test
  468 |         expect&#x60;\redx&#x60;.not.toParse();
  469 |     });
  470 |</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  469 |     });
  470 |
&gt; 471 |     it(&quot;should parse a function with a number right after it&quot;, function() {
      |    ^ Unknown Test
  472 |         expect&#x60;\frac12&#x60;.toParse();
  473 |     });
  474 |</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  473 |     });
  474 |
&gt; 475 |     it(&quot;should parse some functions with text right after it&quot;, function() {
      |    ^ Unknown Test
  476 |         expect&#x60;\;x&#x60;.toParse();
  477 |     });
  478 | });</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  637 |     });
  638 |
&gt; 639 |     it(&quot;should handle \\textstyle correctly&quot;, function() {
      |    ^ Unknown Test
  640 |         expect&#x60;\textstyle 1 \over 2&#x60;.toParseLike&#x60;\frac{\textstyle 1}{2}&#x60;;
  641 |         expect&#x60;{\textstyle 1} \over 2&#x60;.toParseLike&#x60;\frac{\textstyle 1}{2}&#x60;;
  642 |     });</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  663 |
  664 | describe(&quot;A genfrac builder&quot;, function() {
&gt; 665 |     it(&quot;should not fail&quot;, function() {
      |    ^ Unknown Test
  666 |         expect&#x60;\frac{x}{y}&#x60;.toBuild();
  667 |         expect&#x60;\dfrac{x}{y}&#x60;.toBuild();
  668 |         expect&#x60;\tfrac{x}{y}&#x60;.toBuild();</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  676 |
  677 | describe(&quot;A infix builder&quot;, function() {
&gt; 678 |     it(&quot;should not fail&quot;, function() {
      |    ^ Unknown Test
  679 |         expect&#x60;a \over b&#x60;.toBuild();
  680 |         expect&#x60;a \atop b&#x60;.toBuild();
  681 |         expect&#x60;a \choose b&#x60;.toBuild();</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  772 |     });
  773 |
&gt; 774 |     it(&quot;should parse math within text group&quot;, function() {
      |    ^ Unknown Test
  775 |         expect&#x60;\text{graph: $y &#x3D; mx + b$}&#x60;.toParse(strictSettings);
  776 |         expect&#x60;\text{graph: \(y &#x3D; mx + b\)}&#x60;.toParse(strictSettings);
  777 |     });</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  777 |     });
  778 |
&gt; 779 |     it(&quot;should parse math within text within math within text&quot;, function() {
      |    ^ Unknown Test
  780 |         expect&#x60;\text{hello $x + \text{world $y$} + z$}&#x60;.toParse(strictSettings);
  781 |         expect&#x60;\text{hello \(x + \text{world $y$} + z\)}&#x60;.toParse(strictSettings);
  782 |         expect&#x60;\text{hello $x + \text{world \(y\)} + z$}&#x60;.toParse(strictSettings);</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  784 |     });
  785 |
&gt; 786 |     it(&quot;should forbid \\( within math mode&quot;, function() {
      |    ^ Unknown Test
  787 |         expect&#x60;\(&#x60;.not.toParse();
  788 |         expect&#x60;\text{$\(x\)$}&#x60;.not.toParse();
  789 |     });</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  789 |     });
  790 |
&gt; 791 |     it(&quot;should forbid $ within math mode&quot;, function() {
      |    ^ Unknown Test
  792 |         expect&#x60;$x$&#x60;.not.toParse();
  793 |         expect&#x60;\text{\($x$\)}&#x60;.not.toParse();
  794 |     });</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  794 |     });
  795 |
&gt; 796 |     it(&quot;should detect unbalanced \\)&quot;, function() {
      |    ^ Unknown Test
  797 |         expect&#x60;\)&#x60;.not.toParse();
  798 |         expect&#x60;\text{\)}&#x60;.not.toParse();
  799 |     });</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  799 |     });
  800 |
&gt; 801 |     it(&quot;should detect unbalanced $&quot;, function() {
      |    ^ Unknown Test
  802 |         expect&#x60;$&#x60;.not.toParse();
  803 |         expect&#x60;\text{$}&#x60;.not.toParse();
  804 |     });</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  804 |     });
  805 |
&gt; 806 |     it(&quot;should not mix $ and \\(..\\)&quot;, function() {
      |    ^ Unknown Test
  807 |         expect&#x60;\text{$x\)}&#x60;.not.toParse();
  808 |         expect&#x60;\text{\(x$}&#x60;.not.toParse();
  809 |     });</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  809 |     });
  810 |
&gt; 811 |     it(&quot;should parse spacing functions&quot;, function() {
      |    ^ Unknown Test
  812 |         expect&#x60;a b\, \; \! \: \&gt; ~ \thinspace \medspace \quad \ &#x60;.toBuild();
  813 |         expect&#x60;\enspace \thickspace \qquad \space \nobreakspace&#x60;.toBuild();
  814 |     });</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  814 |     });
  815 |
&gt; 816 |     it(&quot;should omit spaces after commands&quot;, function() {
      |    ^ Unknown Test
  817 |         expect&#x60;\text{\textellipsis !}&#x60;.toParseLike&#x60;\text{\textellipsis!}&#x60;;
  818 |     });
  819 |</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  818 |     });
  819 |
&gt; 820 |     it(&quot;should handle ⋮ and \\vdots&quot;, function() {
      |    ^ Unknown Test
  821 |         expect&#x60;\text{a \vdots b ⋮ d}&#x60;.toParse();
  822 |     });
  823 | });</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  824 |
  825 | describe(&quot;A texvc builder&quot;, function() {
&gt; 826 |     it(&quot;should not fail&quot;, function() {
      |    ^ Unknown Test
  827 |         expect&#x60;\lang\N\darr\R\dArr\Z\Darr\alef\rang&#x60;.toBuild();
  828 |         expect&#x60;\alefsym\uarr\Alpha\uArr\Beta\Uarr\Chi&#x60;.toBuild();
  829 |         expect&#x60;\clubs\diamonds\hearts\spades\cnums\Complex&#x60;.toBuild();</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>   998 |
   999 | describe(&quot;An lap parser&quot;, function() {
&gt; 1000 |     it(&quot;should not fail on a text argument&quot;, function() {
       |    ^ Unknown Test
  1001 |         expect&#x60;\rlap{\,&#x2F;}{&#x3D;}&#x60;.toParse();
  1002 |         expect&#x60;\mathrlap{\,&#x2F;}{&#x3D;}&#x60;.toParse();
  1003 |         expect&#x60;{&#x3D;}\llap{&#x2F;\,}&#x60;.toParse();</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  1007 |     });
  1008 |
&gt; 1009 |     it(&quot;should not fail if math version is used&quot;, function() {
       |    ^ Unknown Test
  1010 |         expect&#x60;\mathrlap{\frac{a}{b}}{&#x3D;}&#x60;.toParse();
  1011 |         expect&#x60;{&#x3D;}\mathllap{\frac{a}{b}}&#x60;.toParse();
  1012 |         expect&#x60;\sum_{\mathclap{\frac{a}{b}}}&#x60;.toParse();</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  1013 |     });
  1014 |
&gt; 1015 |     it(&quot;should fail on math if AMS version is used&quot;, function() {
       |    ^ Unknown Test
  1016 |         expect&#x60;\rlap{\frac{a}{b}}{&#x3D;}&#x60;.not.toParse();
  1017 |         expect&#x60;{&#x3D;}\llap{\frac{a}{b}}&#x60;.not.toParse();
  1018 |         expect&#x60;\sum_{\clap{\frac{a}{b}}}&#x60;.not.toParse();</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  1269 | describe(&quot;A begin&#x2F;end parser&quot;, function() {
  1270 |
&gt; 1271 |     it(&quot;should parse a simple environment&quot;, function() {
       |    ^ Unknown Test
  1272 |         expect&#x60;\begin{matrix}a&amp;b\\c&amp;d\end{matrix}&#x60;.toParse();
  1273 |     });
  1274 |</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  1273 |     });
  1274 |
&gt; 1275 |     it(&quot;should parse an environment with argument&quot;, function() {
       |    ^ Unknown Test
  1276 |         expect&#x60;\begin{array}{cc}a&amp;b\\c&amp;d\end{array}&#x60;.toParse();
  1277 |     });
  1278 |</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  1277 |     });
  1278 |
&gt; 1279 |     it(&quot;should parse and build an empty environment&quot;, function() {
       |    ^ Unknown Test
  1280 |         expect&#x60;\begin{aligned}\end{aligned}&#x60;.toBuild();
  1281 |         expect&#x60;\begin{matrix}\end{matrix}&#x60;.toBuild();
  1282 |     });</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  1282 |     });
  1283 |
&gt; 1284 |     it(&quot;should parse an environment with hlines&quot;, function() {
       |    ^ Unknown Test
  1285 |         expect&#x60;\begin{matrix}\hline a&amp;b\\ \hline c&amp;d\end{matrix}&#x60;.toParse();
  1286 |         expect&#x60;\begin{matrix}\hline a&amp;b\cr \hline c&amp;d\end{matrix}&#x60;.toParse();
  1287 |         expect&#x60;\begin{matrix}\hdashline a&amp;b\\ \hdashline c&amp;d\end{matrix}&#x60;.toParse();</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  1288 |     });
  1289 |
&gt; 1290 |     it(&quot;should forbid hlines outside array environment&quot;, () &#x3D;&gt; {
       |    ^ Unknown Test
  1291 |         expect&#x60;\hline&#x60;.not.toParse();
  1292 |     });
  1293 |</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  1292 |     });
  1293 |
&gt; 1294 |     it(&quot;should error when name is mismatched&quot;, function() {
       |    ^ Unknown Test
  1295 |         expect&#x60;\begin{matrix}a&amp;b\\c&amp;d\end{pmatrix}&#x60;.not.toParse();
  1296 |     });
  1297 |</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  1296 |     });
  1297 |
&gt; 1298 |     it(&quot;should error when commands are mismatched&quot;, function() {
       |    ^ Unknown Test
  1299 |         expect&#x60;\begin{matrix}a&amp;b\\c&amp;d\right{pmatrix}&#x60;.not.toParse();
  1300 |     });
  1301 |</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  1300 |     });
  1301 |
&gt; 1302 |     it(&quot;should error when end is missing&quot;, function() {
       |    ^ Unknown Test
  1303 |         expect&#x60;\begin{matrix}a&amp;b\\c&amp;d&#x60;.not.toParse();
  1304 |     });
  1305 |</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  1304 |     });
  1305 |
&gt; 1306 |     it(&quot;should error when braces are mismatched&quot;, function() {
       |    ^ Unknown Test
  1307 |         expect&#x60;{\begin{matrix}a&amp;b\\c&amp;d}\end{matrix}&#x60;.not.toParse();
  1308 |     });
  1309 |</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  1308 |     });
  1309 |
&gt; 1310 |     it(&quot;should cooperate with infix notation&quot;, function() {
       |    ^ Unknown Test
  1311 |         expect&#x60;\begin{matrix}0&amp;1\over2&amp;3\\4&amp;5&amp;6\end{matrix}&#x60;.toParse();
  1312 |     });
  1313 |</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  1318 |     });
  1319 |
&gt; 1320 |     it(&quot;should allow \\cr and \\\\ as a line terminator&quot;, function() {
       |    ^ Unknown Test
  1321 |         expect&#x60;\begin{matrix}a&amp;b\cr c&amp;d\end{matrix}&#x60;.toParse();
  1322 |         expect&#x60;\begin{matrix}a&amp;b\\c&amp;d\end{matrix}&#x60;.toParse();
  1323 |     });</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  1323 |     });
  1324 |
&gt; 1325 |     it(&quot;should not allow \\cr to scan for an optional size argument&quot;, function() {
       |    ^ Unknown Test
  1326 |         expect&#x60;\begin{matrix}a&amp;b\cr[c]&amp;d\end{matrix}&#x60;.toParse();
  1327 |     });
  1328 |</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  1327 |     });
  1328 |
&gt; 1329 |     it(&quot;should not treat [ after space as optional argument to \\\\&quot;, function() {
       |    ^ Unknown Test
  1330 |         expect&#x60;\begin{matrix}a&amp;b\\ [c]&amp;d\end{matrix}&#x60;.toParse();
  1331 |         expect&#x60;a\\ [b]&#x60;.toParse();
  1332 |     });</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  1342 |     });
  1343 |
&gt; 1344 |     it(&quot;should allow an optional argument in {matrix*} and company.&quot;, function() {
       |    ^ Unknown Test
  1345 |         expect&#x60;\begin{matrix*}[r] a &amp; -1 \\ -1 &amp; d \end{matrix*}&#x60;.toBuild();
  1346 |         expect&#x60;\begin{pmatrix*}[r] a &amp; -1 \\ -1 &amp; d \end{pmatrix*}&#x60;.toBuild();
  1347 |         expect&#x60;\begin{bmatrix*}[r] a &amp; -1 \\ -1 &amp; d \end{bmatrix*}&#x60;.toBuild();</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  1379 |     });
  1380 |
&gt; 1381 |     it(&quot;should build sized square roots&quot;, function() {
       |    ^ Unknown Test
  1382 |         expect&#x60;\Large\sqrt[3]{x}&#x60;.toBuild();
  1383 |     });
  1384 |</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  1383 |     });
  1384 |
&gt; 1385 |     it(&quot;should expand argument if optional argument doesn&#39;t exist&quot;, function() {
       |    ^ Unknown Test
  1386 |         expect&#x60;\sqrt\foo&#x60;.toParseLike(&quot;\\sqrt123&quot;,
  1387 |             new Settings({macros: {&quot;\\foo&quot;: &quot;123&quot;}}));
  1388 |     });</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  1388 |     });
  1389 |
&gt; 1390 |     it(&quot;should not expand argument if optional argument exists&quot;, function() {
       |    ^ Unknown Test
  1391 |         expect&#x60;\sqrt[2]\foo&#x60;.toParseLike(&quot;\\sqrt[2]{123}&quot;,
  1392 |             new Settings({macros: {&quot;\\foo&quot;: &quot;123&quot;}}));
  1393 |     });</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  1395 |
  1396 | describe(&quot;A TeX-compliant parser&quot;, function() {
&gt; 1397 |     it(&quot;should work&quot;, function() {
       |    ^ Unknown Test
  1398 |         expect&#x60;\frac 2 3&#x60;.toParse();
  1399 |     });
  1400 |</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  1414 |     });
  1415 |
&gt; 1416 |     it(&quot;should fail when there are missing sup&#x2F;subscripts&quot;, function() {
       |    ^ Unknown Test
  1417 |         expect&#x60;x^&#x60;.not.toParse();
  1418 |         expect&#x60;x_&#x60;.not.toParse();
  1419 |     });</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  1485 |     });
  1486 |
&gt; 1487 |     it(&quot;should parse multiple primes correctly&quot;, function() {
       |    ^ Unknown Test
  1488 |         expect&#x60;x&#39;&#39;&#39;&#39;&#x60;.toParse();
  1489 |         expect&#x60;x_2&#39;&#39;&#x60;.toParse();
  1490 |         expect&#x60;x&#39;&#39;_2&#x60;.toParse();</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  1491 |     });
  1492 |
&gt; 1493 |     it(&quot;should fail when sup&#x2F;subscripts are interspersed with arguments&quot;, function() {
       |    ^ Unknown Test
  1494 |         expect&#x60;\sqrt^23&#x60;.not.toParse();
  1495 |         expect&#x60;\frac^234&#x60;.not.toParse();
  1496 |         expect&#x60;\frac2^34&#x60;.not.toParse();</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  1497 |     });
  1498 |
&gt; 1499 |     it(&quot;should succeed when sup&#x2F;subscripts come after whole functions&quot;, function() {
       |    ^ Unknown Test
  1500 |         expect&#x60;\sqrt2^3&#x60;.toParse();
  1501 |         expect&#x60;\frac23^4&#x60;.toParse();
  1502 |     });</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  1502 |     });
  1503 |
&gt; 1504 |     it(&quot;should succeed with a sqrt around a text&#x2F;frac&quot;, function() {
       |    ^ Unknown Test
  1505 |         expect&#x60;\sqrt \frac x y&#x60;.toParse();
  1506 |         expect&#x60;\sqrt \text x&#x60;.toParse();
  1507 |         expect&#x60;x^\frac x y&#x60;.toParse();</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  1539 |
  1540 | describe(&quot;An op symbol builder&quot;, function() {
&gt; 1541 |     it(&quot;should not fail&quot;, function() {
       |    ^ Unknown Test
  1542 |         expect&#x60;\int_i^n&#x60;.toBuild();
  1543 |         expect&#x60;\iint_i^n&#x60;.toBuild();
  1544 |         expect&#x60;\iiint_i^n&#x60;.toBuild();</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  1556 |
  1557 | describe(&quot;A style change parser&quot;, function() {
&gt; 1558 |     it(&quot;should not fail&quot;, function() {
       |    ^ Unknown Test
  1559 |         expect&#x60;\displaystyle x&#x60;.toParse();
  1560 |         expect&#x60;\textstyle x&#x60;.toParse();
  1561 |         expect&#x60;\scriptstyle x&#x60;.toParse();</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  1587 |
  1588 | describe(&quot;A font parser&quot;, function() {
&gt; 1589 |     it(&quot;should parse \\mathrm, \\mathbb, \\mathit, and \\mathnormal&quot;, function() {
       |    ^ Unknown Test
  1590 |         expect&#x60;\mathrm x&#x60;.toParse();
  1591 |         expect&#x60;\mathbb x&#x60;.toParse();
  1592 |         expect&#x60;\mathit x&#x60;.toParse();</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  1598 |     });
  1599 |
&gt; 1600 |     it(&quot;should parse \\mathcal and \\mathfrak&quot;, function() {
       |    ^ Unknown Test
  1601 |         expect&#x60;\mathcal{ABC123}&#x60;.toParse();
  1602 |         expect&#x60;\mathfrak{abcABC123}&#x60;.toParse();
  1603 |     });</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  1652 |     });
  1653 |
&gt; 1654 |     it(&quot;should not parse a series of font commands&quot;, function() {
       |    ^ Unknown Test
  1655 |         expect&#x60;\mathbb \mathrm R&#x60;.not.toParse();
  1656 |     });
  1657 |</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  1667 |     });
  1668 |
&gt; 1669 |     it(&quot;should be allowed in the argument&quot;, function() {
       |    ^ Unknown Test
  1670 |         expect&#x60;e^\mathbf{x}&#x60;.toParse();
  1671 |     });
  1672 |</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  1676 |     });
  1677 |
&gt; 1678 |     it(&quot;old-style fonts work like new-style fonts&quot;, () &#x3D;&gt; {
       |    ^ Unknown Test
  1679 |         expect&#x60;\rm xyz&#x60;.toParseLike&#x60;\mathrm{xyz}&#x60;;
  1680 |         expect&#x60;\sf xyz&#x60;.toParseLike&#x60;\mathsf{xyz}&#x60;;
  1681 |         expect&#x60;\tt xyz&#x60;.toParseLike&#x60;\mathtt{xyz}&#x60;;</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  1687 |
  1688 | describe(&quot;A \\pmb builder&quot;, function() {
&gt; 1689 |     it(&quot;should not fail&quot;, function() {
       |    ^ Unknown Test
  1690 |         expect&#x60;\pmb{\mu}&#x60;.toBuild();
  1691 |         expect&#x60;\pmb{&#x3D;}&#x60;.toBuild();
  1692 |         expect&#x60;\pmb{+}&#x60;.toBuild();</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  1698 |
  1699 | describe(&quot;A raise parser&quot;, function() {
&gt; 1700 |     it(&quot;should parse and build text in \\raisebox&quot;, function() {
       |    ^ Unknown Test
  1701 |         expect&#x60;\raisebox{5pt}{text}&#x60;.toBuild(strictSettings);
  1702 |         expect&#x60;\raisebox{-5pt}{text}&#x60;.toBuild(strictSettings);
  1703 |     });</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  1703 |     });
  1704 |
&gt; 1705 |     it(&quot;should parse and build math in non-strict \\vcenter&quot;, function() {
       |    ^ Unknown Test
  1706 |         expect&#x60;\vcenter{\frac a b}&#x60;.toBuild(nonstrictSettings);
  1707 |     });
  1708 |</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  1707 |     });
  1708 |
&gt; 1709 |     it(&quot;should fail to parse math in \\raisebox&quot;, function() {
       |    ^ Unknown Test
  1710 |         expect&#x60;\raisebox{5pt}{\frac a b}&#x60;.not.toParse(nonstrictSettings);
  1711 |         expect&#x60;\raisebox{-5pt}{\frac a b}&#x60;.not.toParse(nonstrictSettings);
  1712 |     });</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  1712 |     });
  1713 |
&gt; 1714 |     it(&quot;should fail to parse math in an \\hbox&quot;, function() {
       |    ^ Unknown Test
  1715 |         expect&#x60;\hbox{\frac a b}&#x60;.not.toParse(nonstrictSettings);
  1716 |     });
  1717 |</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  1716 |     });
  1717 |
&gt; 1718 |     it(&quot;should fail to build, given an unbraced length&quot;, function() {
       |    ^ Unknown Test
  1719 |         expect&#x60;\raisebox5pt{text}&#x60;.not.toBuild(strictSettings);
  1720 |         expect&#x60;\raisebox-5pt{text}&#x60;.not.toBuild(strictSettings);
  1721 |     });</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  1721 |     });
  1722 |
&gt; 1723 |     it(&quot;should build math in an hbox when math mode is set&quot;, function() {
       |    ^ Unknown Test
  1724 |         expect&#x60;a + \vcenter{\hbox{$\frac{\frac a b}c$}}&#x60;
  1725 |             .toBuild(strictSettings);
  1726 |     });</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  1770 |     });
  1771 |
&gt; 1772 |     it(&quot;should not parse a comment without newline in strict mode&quot;, () &#x3D;&gt; {
       |    ^ Unknown Test
  1773 |         expect&#x60;x%y&#x60;.not.toParse(strictSettings);
  1774 |         expect&#x60;x%y&#x60;.toParse(nonstrictSettings);
  1775 |     });</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  2255 |
  2256 | describe(&quot;An accent parser&quot;, function() {
&gt; 2257 |     it(&quot;should not fail&quot;, function() {
       |    ^ Unknown Test
  2258 |         expect&#x60;\vec{x}&#x60;.toParse();
  2259 |         expect&#x60;\vec{x^2}&#x60;.toParse();
  2260 |         expect&#x60;\vec{x}^2&#x60;.toParse();</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  2275 |     });
  2276 |
&gt; 2277 |     it(&quot;should parse stretchy, shifty accents&quot;, function() {
       |    ^ Unknown Test
  2278 |         expect&#x60;\widehat{x}&#x60;.toParse();
  2279 |         expect&#x60;\widecheck{x}&#x60;.toParse();
  2280 |     });</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  2280 |     });
  2281 |
&gt; 2282 |     it(&quot;should parse stretchy, non-shifty accents&quot;, function() {
       |    ^ Unknown Test
  2283 |         expect&#x60;\overrightarrow{x}&#x60;.toParse();
  2284 |     });
  2285 | });</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  2286 |
  2287 | describe(&quot;An accent builder&quot;, function() {
&gt; 2288 |     it(&quot;should not fail&quot;, function() {
       |    ^ Unknown Test
  2289 |         expect&#x60;\vec{x}&#x60;.toBuild();
  2290 |         expect&#x60;\vec{x}^2&#x60;.toBuild();
  2291 |         expect&#x60;\vec{x}_2&#x60;.toBuild();</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  2303 |
  2304 | describe(&quot;A stretchy and shifty accent builder&quot;, function() {
&gt; 2305 |     it(&quot;should not fail&quot;, function() {
       |    ^ Unknown Test
  2306 |         expect&#x60;\widehat{AB}&#x60;.toBuild();
  2307 |         expect&#x60;\widecheck{AB}&#x60;.toBuild();
  2308 |         expect&#x60;\widehat{AB}^2&#x60;.toBuild();</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  2321 |
  2322 | describe(&quot;A stretchy and non-shifty accent builder&quot;, function() {
&gt; 2323 |     it(&quot;should not fail&quot;, function() {
       |    ^ Unknown Test
  2324 |         expect&#x60;\overrightarrow{AB}&#x60;.toBuild();
  2325 |         expect&#x60;\overrightarrow{AB}^2&#x60;.toBuild();
  2326 |         expect&#x60;\overrightarrow{AB}_2&#x60;.toBuild();</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  2347 |
  2348 | describe(&quot;An under-accent parser&quot;, function() {
&gt; 2349 |     it(&quot;should not fail&quot;, function() {
       |    ^ Unknown Test
  2350 |         expect&#x60;\underrightarrow{x}&#x60;.toParse();
  2351 |         expect&#x60;\underrightarrow{x^2}&#x60;.toParse();
  2352 |         expect&#x60;\underrightarrow{x}^2&#x60;.toParse();</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  2368 |
  2369 | describe(&quot;An under-accent builder&quot;, function() {
&gt; 2370 |     it(&quot;should not fail&quot;, function() {
       |    ^ Unknown Test
  2371 |         expect&#x60;\underrightarrow{x}&#x60;.toBuild();
  2372 |         expect&#x60;\underrightarrow{x}^2&#x60;.toBuild();
  2373 |         expect&#x60;\underrightarrow{x}_2&#x60;.toBuild();</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  2386 |
  2387 | describe(&quot;An extensible arrow parser&quot;, function() {
&gt; 2388 |     it(&quot;should not fail&quot;, function() {
       |    ^ Unknown Test
  2389 |         expect&#x60;\xrightarrow{x}&#x60;.toParse();
  2390 |         expect&#x60;\xrightarrow{x^2}&#x60;.toParse();
  2391 |         expect&#x60;\xrightarrow{x}^2&#x60;.toParse();</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  2408 |
  2409 | describe(&quot;An extensible arrow builder&quot;, function() {
&gt; 2410 |     it(&quot;should not fail&quot;, function() {
       |    ^ Unknown Test
  2411 |         expect&#x60;\xrightarrow{x}&#x60;.toBuild();
  2412 |         expect&#x60;\xrightarrow{x}^2&#x60;.toBuild();
  2413 |         expect&#x60;\xrightarrow{x}_2&#x60;.toBuild();</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  2427 |
  2428 | describe(&quot;A horizontal brace parser&quot;, function() {
&gt; 2429 |     it(&quot;should not fail&quot;, function() {
       |    ^ Unknown Test
  2430 |         expect&#x60;\overbrace{x}&#x60;.toParse();
  2431 |         expect&#x60;\overbrace{x^2}&#x60;.toParse();
  2432 |         expect&#x60;\overbrace{x}^2&#x60;.toParse();</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  2450 |
  2451 | describe(&quot;A horizontal brace builder&quot;, function() {
&gt; 2452 |     it(&quot;should not fail&quot;, function() {
       |    ^ Unknown Test
  2453 |         expect&#x60;\overbrace{x}&#x60;.toBuild();
  2454 |         expect&#x60;\overbrace{x}^2&#x60;.toBuild();
  2455 |         expect&#x60;\underbrace{x}_2&#x60;.toBuild();</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  2468 |
  2469 | describe(&quot;A boxed parser&quot;, function() {
&gt; 2470 |     it(&quot;should not fail&quot;, function() {
       |    ^ Unknown Test
  2471 |         expect&#x60;\boxed{x}&#x60;.toParse();
  2472 |         expect&#x60;\boxed{x^2}&#x60;.toParse();
  2473 |         expect&#x60;\boxed{x}^2&#x60;.toParse();</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  2483 |
  2484 | describe(&quot;A boxed builder&quot;, function() {
&gt; 2485 |     it(&quot;should not fail&quot;, function() {
       |    ^ Unknown Test
  2486 |         expect&#x60;\boxed{x}&#x60;.toBuild();
  2487 |         expect&#x60;\boxed{x}^2&#x60;.toBuild();
  2488 |         expect&#x60;\boxed{x}_2&#x60;.toBuild();</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  2500 |
  2501 | describe(&quot;An fbox parser, unlike a boxed parser,&quot;, function() {
&gt; 2502 |     it(&quot;should fail when given math&quot;, function() {
       |    ^ Unknown Test
  2503 |         expect&#x60;\fbox{\frac a b}&#x60;.not.toParse();
  2504 |     });
  2505 | });</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  2506 |
  2507 | describe(&quot;A colorbox parser&quot;, function() {
&gt; 2508 |     it(&quot;should not fail, given a text argument&quot;, function() {
       |    ^ Unknown Test
  2509 |         expect&#x60;\colorbox{red}{a b}&#x60;.toParse();
  2510 |         expect&#x60;\colorbox{red}{x}^2&#x60;.toParse();
  2511 |         expect&#x60;\colorbox{red} x&#x60;.toParse();</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  2512 |     });
  2513 |
&gt; 2514 |     it(&quot;should fail, given a math argument&quot;, function() {
       |    ^ Unknown Test
  2515 |         expect&#x60;\colorbox{red}{\alpha}&#x60;.not.toParse();
  2516 |         expect&#x60;\colorbox{red}{\frac{a}{b}}&#x60;.not.toParse();
  2517 |     });</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  2517 |     });
  2518 |
&gt; 2519 |     it(&quot;should parse a color&quot;, function() {
       |    ^ Unknown Test
  2520 |         expect&#x60;\colorbox{red}{a b}&#x60;.toParse();
  2521 |         expect&#x60;\colorbox{#197}{a b}&#x60;.toParse();
  2522 |         expect&#x60;\colorbox{#1a9b7c}{a b}&#x60;.toParse();</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  2530 |
  2531 | describe(&quot;A colorbox builder&quot;, function() {
&gt; 2532 |     it(&quot;should not fail&quot;, function() {
       |    ^ Unknown Test
  2533 |         expect&#x60;\colorbox{red}{a b}&#x60;.toBuild();
  2534 |         expect&#x60;\colorbox{red}{a b}^2&#x60;.toBuild();
  2535 |         expect&#x60;\colorbox{red} x&#x60;.toBuild();</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  2542 |
  2543 | describe(&quot;An fcolorbox parser&quot;, function() {
&gt; 2544 |     it(&quot;should not fail, given a text argument&quot;, function() {
       |    ^ Unknown Test
  2545 |         expect&#x60;\fcolorbox{blue}{yellow}{a b}&#x60;.toParse();
  2546 |         expect&#x60;\fcolorbox{blue}{yellow}{x}^2&#x60;.toParse();
  2547 |         expect&#x60;\fcolorbox{blue}{yellow} x&#x60;.toParse();</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  2548 |     });
  2549 |
&gt; 2550 |     it(&quot;should fail, given a math argument&quot;, function() {
       |    ^ Unknown Test
  2551 |         expect&#x60;\fcolorbox{blue}{yellow}{\alpha}&#x60;.not.toParse();
  2552 |         expect&#x60;\fcolorbox{blue}{yellow}{\frac{a}{b}}&#x60;.not.toParse();
  2553 |     });</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  2553 |     });
  2554 |
&gt; 2555 |     it(&quot;should parse a color&quot;, function() {
       |    ^ Unknown Test
  2556 |         expect&#x60;\fcolorbox{blue}{yellow}{a b}&#x60;.toParse();
  2557 |         expect&#x60;\fcolorbox{blue}{#197}{a b}&#x60;.toParse();
  2558 |         expect&#x60;\fcolorbox{blue}{#1a9b7c}{a b}&#x60;.toParse();</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  2566 |
  2567 | describe(&quot;A fcolorbox builder&quot;, function() {
&gt; 2568 |     it(&quot;should not fail&quot;, function() {
       |    ^ Unknown Test
  2569 |         expect&#x60;\fcolorbox{blue}{yellow}{a b}&#x60;.toBuild();
  2570 |         expect&#x60;\fcolorbox{blue}{yellow}{a b}^2&#x60;.toBuild();
  2571 |         expect&#x60;\fcolorbox{blue}{yellow} x&#x60;.toBuild();</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  2578 |
  2579 | describe(&quot;A strike-through parser&quot;, function() {
&gt; 2580 |     it(&quot;should not fail&quot;, function() {
       |    ^ Unknown Test
  2581 |         expect&#x60;\cancel{x}&#x60;.toParse();
  2582 |         expect&#x60;\cancel{x^2}&#x60;.toParse();
  2583 |         expect&#x60;\cancel{x}^2&#x60;.toParse();</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  2599 |
  2600 | describe(&quot;A strike-through builder&quot;, function() {
&gt; 2601 |     it(&quot;should not fail&quot;, function() {
       |    ^ Unknown Test
  2602 |         expect&#x60;\cancel{x}&#x60;.toBuild();
  2603 |         expect&#x60;\cancel{x}^2&#x60;.toBuild();
  2604 |         expect&#x60;\cancel{x}_2&#x60;.toBuild();</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  2620 |
  2621 | describe(&quot;A actuarial angle parser&quot;, function() {
&gt; 2622 |     it(&quot;should not fail in math mode&quot;, function() {
       |    ^ Unknown Test
  2623 |         expect&#x60;a_{\angl{n}}&#x60;.toParse();
  2624 |     });
  2625 |     it(&quot;should fail in text mode&quot;, function() {</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  2623 |         expect&#x60;a_{\angl{n}}&#x60;.toParse();
  2624 |     });
&gt; 2625 |     it(&quot;should fail in text mode&quot;, function() {
       |    ^ Unknown Test
  2626 |         expect&#x60;\text{a_{\angl{n}}}&#x60;.not.toParse();
  2627 |     });
  2628 | });</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  2629 |
  2630 | describe(&quot;A actuarial angle builder&quot;, function() {
&gt; 2631 |     it(&quot;should not fail&quot;, function() {
       |    ^ Unknown Test
  2632 |         expect&#x60;a_{\angl{n}}&#x60;.toBuild();
  2633 |         expect&#x60;a_{\angl{n}i}&#x60;.toBuild();
  2634 |         expect&#x60;a_{\angl n}&#x60;.toBuild();</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  2638 |
  2639 | describe(&quot;\\phase&quot;, function() {
&gt; 2640 |     it(&quot;should fail in text mode&quot;, function() {
       |    ^ Unknown Test
  2641 |         expect&#x60;\text{\phase{-78.2^\circ}}&#x60;.not.toParse();
  2642 |     });
  2643 |     it(&quot;should not fail in math mode&quot;, function() {</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  2641 |         expect&#x60;\text{\phase{-78.2^\circ}}&#x60;.not.toParse();
  2642 |     });
&gt; 2643 |     it(&quot;should not fail in math mode&quot;, function() {
       |    ^ Unknown Test
  2644 |         expect&#x60;\phase{-78.2^\circ}&#x60;.toBuild();
  2645 |     });
  2646 | });</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  2647 |
  2648 | describe(&quot;A phantom parser&quot;, function() {
&gt; 2649 |     it(&quot;should not fail&quot;, function() {
       |    ^ Unknown Test
  2650 |         expect&#x60;\phantom{x}&#x60;.toParse();
  2651 |         expect&#x60;\phantom{x^2}&#x60;.toParse();
  2652 |         expect&#x60;\phantom{x}^2&#x60;.toParse();</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  2667 |
  2668 | describe(&quot;A phantom builder&quot;, function() {
&gt; 2669 |     it(&quot;should not fail&quot;, function() {
       |    ^ Unknown Test
  2670 |         expect&#x60;\phantom{x}&#x60;.toBuild();
  2671 |         expect&#x60;\phantom{x^2}&#x60;.toBuild();
  2672 |         expect&#x60;\phantom{x}^2&#x60;.toBuild();</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  2696 |
  2697 | describe(&quot;A smash parser&quot;, function() {
&gt; 2698 |     it(&quot;should not fail&quot;, function() {
       |    ^ Unknown Test
  2699 |         expect&#x60;\smash{x}&#x60;.toParse();
  2700 |         expect&#x60;\smash{x^2}&#x60;.toParse();
  2701 |         expect&#x60;\smash{x}^2&#x60;.toParse();</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  2721 |
  2722 | describe(&quot;A smash builder&quot;, function() {
&gt; 2723 |     it(&quot;should not fail&quot;, function() {
       |    ^ Unknown Test
  2724 |         expect&#x60;\smash{x}&#x60;.toBuild(nonstrictSettings);
  2725 |         expect&#x60;\smash{x^2}&#x60;.toBuild(nonstrictSettings);
  2726 |         expect&#x60;\smash{x}^2&#x60;.toBuild(nonstrictSettings);</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  2745 |
  2746 | describe(&quot;An optional argument parser&quot;, function() {
&gt; 2747 |     it(&quot;should not fail&quot;, function() {
       |    ^ Unknown Test
  2748 |         &#x2F;&#x2F; Note this doesn&#39;t actually make an optional argument, but still
  2749 |         &#x2F;&#x2F; should work
  2750 |         expect&#x60;\frac[1]{2}{3}&#x60;.toParse();</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  2753 |     });
  2754 |
&gt; 2755 |     it(&quot;should work with sqrts with optional arguments&quot;, function() {
       |    ^ Unknown Test
  2756 |         expect&#x60;\sqrt[3]{2}&#x60;.toParse();
  2757 |     });
  2758 |</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  2757 |     });
  2758 |
&gt; 2759 |     it(&quot;should work when the optional argument is missing&quot;, function() {
       |    ^ Unknown Test
  2760 |         expect&#x60;\sqrt{2}&#x60;.toParse();
  2761 |         expect&#x60;\rule{1em}{2em}&#x60;.toParse();
  2762 |     });</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  2762 |     });
  2763 |
&gt; 2764 |     it(&quot;should fail when the optional argument is malformed&quot;, function() {
       |    ^ Unknown Test
  2765 |         expect&#x60;\rule[1]{2em}{3em}&#x60;.not.toParse();
  2766 |     });
  2767 |</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  2766 |     });
  2767 |
&gt; 2768 |     it(&quot;should not work if the optional argument isn&#39;t closed&quot;, function() {
       |    ^ Unknown Test
  2769 |         expect&#x60;\sqrt[&#x60;.not.toParse();
  2770 |     });
  2771 | });</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  2816 | describe(&quot;A substack function&quot;, function() {
  2817 |
&gt; 2818 |     it(&quot;should build&quot;, function() {
       |    ^ Unknown Test
  2819 |         expect&#x60;\sum_{\substack{ 0&lt;i&lt;m \\ 0&lt;j&lt;n }}  P(i,j)&#x60;.toBuild();
  2820 |     });
  2821 |     it(&quot;should accommodate spaces in the argument&quot;, function() {</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  2819 |         expect&#x60;\sum_{\substack{ 0&lt;i&lt;m \\ 0&lt;j&lt;n }}  P(i,j)&#x60;.toBuild();
  2820 |     });
&gt; 2821 |     it(&quot;should accommodate spaces in the argument&quot;, function() {
       |    ^ Unknown Test
  2822 |         expect&#x60;\sum_{\substack{ 0&lt;i&lt;m \\ 0&lt;j&lt;n }}  P(i,j)&#x60;.toBuild();
  2823 |     });
  2824 |     it(&quot;should accommodate macros in the argument&quot;, function() {</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  2822 |         expect&#x60;\sum_{\substack{ 0&lt;i&lt;m \\ 0&lt;j&lt;n }}  P(i,j)&#x60;.toBuild();
  2823 |     });
&gt; 2824 |     it(&quot;should accommodate macros in the argument&quot;, function() {
       |    ^ Unknown Test
  2825 |         expect&#x60;\sum_{\substack{ 0&lt;i&lt;\varPi \\ 0&lt;j&lt;\pi }}  P(i,j)&#x60;.toBuild();
  2826 |     });
  2827 |     it(&quot;should accommodate an empty argument&quot;, function() {</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  2825 |         expect&#x60;\sum_{\substack{ 0&lt;i&lt;\varPi \\ 0&lt;j&lt;\pi }}  P(i,j)&#x60;.toBuild();
  2826 |     });
&gt; 2827 |     it(&quot;should accommodate an empty argument&quot;, function() {
       |    ^ Unknown Test
  2828 |         expect&#x60;\sum_{\substack{}}  P(i,j)&#x60;.toBuild();
  2829 |     });
  2830 |</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  2833 | describe(&quot;A smallmatrix environment&quot;, function() {
  2834 |
&gt; 2835 |     it(&quot;should build&quot;, function() {
       |    ^ Unknown Test
  2836 |         expect&#x60;\begin{smallmatrix} a &amp; b \\ c &amp; d \end{smallmatrix}&#x60;.toBuild();
  2837 |     });
  2838 |</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  2841 | describe(&quot;A cases environment&quot;, function() {
  2842 |
&gt; 2843 |     it(&quot;should parse its input&quot;, function() {
       |    ^ Unknown Test
  2844 |         expect&#x60;f(a,b)&#x3D;\begin{cases}a+1&amp;\text{if }b\text{ is odd}\\a&amp;\text{if }b&#x3D;0\\a-1&amp;\text{otherwise}\end{cases}&#x60;
  2845 |             .toParse();
  2846 |     });</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  2850 | describe(&quot;An rcases environment&quot;, function() {
  2851 |
&gt; 2852 |     it(&quot;should build&quot;, function() {
       |    ^ Unknown Test
  2853 |         expect&#x60;\begin{rcases} a &amp;\text{if } b \\ c &amp;\text{if } d \end{rcases}⇒…&#x60;
  2854 |             .toBuild();
  2855 |     });</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  2859 | describe(&quot;An aligned environment&quot;, function() {
  2860 |
&gt; 2861 |     it(&quot;should parse its input&quot;, function() {
       |    ^ Unknown Test
  2862 |         expect&#x60;\begin{aligned}a&amp;&#x3D;b&amp;c&amp;&#x3D;d\\e&amp;&#x3D;f\end{aligned}&#x60;.toParse();
  2863 |     });
  2864 |</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  2863 |     });
  2864 |
&gt; 2865 |     it(&quot;should allow cells in brackets&quot;, function() {
       |    ^ Unknown Test
  2866 |         expect&#x60;\begin{aligned}[a]&amp;[b]\\ [c]&amp;[d]\end{aligned}&#x60;.toParse();
  2867 |     });
  2868 |</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  2867 |     });
  2868 |
&gt; 2869 |     it(&quot;should forbid cells in brackets without space&quot;, function() {
       |    ^ Unknown Test
  2870 |         expect&#x60;\begin{aligned}[a]&amp;[b]\\[c]&amp;[d]\end{aligned}&#x60;.not.toParse();
  2871 |     });
  2872 |</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  2878 |
  2879 | describe(&quot;AMS environments&quot;, function() {
&gt; 2880 |     it(&quot;should fail outside display mode&quot;, () &#x3D;&gt; {
       |    ^ Unknown Test
  2881 |         expect&#x60;\begin{gather}a+b\\c+d\end{gather}&#x60;.not.toParse(nonstrictSettings);
  2882 |         expect&#x60;\begin{gather*}a+b\\c+d\end{gather*}&#x60;.not.toParse(nonstrictSettings);
  2883 |         expect&#x60;\begin{align}a&amp;&#x3D;b+c\\d+e&amp;&#x3D;f\end{align}&#x60;.not.toParse(nonstrictSettings);</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  2891 |
  2892 |     const displayMode &#x3D; new Settings({displayMode: true});
&gt; 2893 |     it(&quot;should build if in display mode&quot;, () &#x3D;&gt; {
       |    ^ Unknown Test
  2894 |         expect&#x60;\begin{gather}a+b\\c+d\end{gather}&#x60;.toBuild(displayMode);
  2895 |         expect&#x60;\begin{gather*}a+b\\c+d\end{gather*}&#x60;.toBuild(displayMode);
  2896 |         expect&#x60;\begin{align}a&amp;&#x3D;b+c\\d+e&amp;&#x3D;f\end{align}&#x60;.toBuild(displayMode);</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  2904 |     });
  2905 |
&gt; 2906 |     it(&quot;should build an empty environment&quot;, () &#x3D;&gt; {
       |    ^ Unknown Test
  2907 |         expect&#x60;\begin{gather}\end{gather}&#x60;.toBuild(displayMode);
  2908 |         expect&#x60;\begin{gather*}\end{gather*}&#x60;.toBuild(displayMode);
  2909 |         expect&#x60;\begin{align}\end{align}&#x60;.toBuild(displayMode);</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  2916 |     });
  2917 |
&gt; 2918 |     it(&quot;{equation} should fail if argument contains two rows.&quot;, () &#x3D;&gt; {
       |    ^ Unknown Test
  2919 |         expect&#x60;\begin{equation}a&#x3D;\cr b+c\end{equation}&#x60;.not.toParse(displayMode);
  2920 |     });
  2921 |     it(&quot;{equation} should fail if argument contains two columns.&quot;, () &#x3D;&gt; {</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  2919 |         expect&#x60;\begin{equation}a&#x3D;\cr b+c\end{equation}&#x60;.not.toParse(displayMode);
  2920 |     });
&gt; 2921 |     it(&quot;{equation} should fail if argument contains two columns.&quot;, () &#x3D;&gt; {
       |    ^ Unknown Test
  2922 |         expect&#x60;\begin{equation}a &amp;&#x3D;b+c\end{equation}&#x60;.not.toBuild(displayMode);
  2923 |     });
  2924 |     it(&quot;{split} should fail if argument contains three columns.&quot;, () &#x3D;&gt; {</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  2922 |         expect&#x60;\begin{equation}a &amp;&#x3D;b+c\end{equation}&#x60;.not.toBuild(displayMode);
  2923 |     });
&gt; 2924 |     it(&quot;{split} should fail if argument contains three columns.&quot;, () &#x3D;&gt; {
       |    ^ Unknown Test
  2925 |         expect&#x60;\begin{equation}\begin{split}a &amp;&#x3D;b &amp;+c\\&amp;&#x3D;e &amp;+f\end{split}\end{equation}&#x60;.not.toBuild(displayMode);
  2926 |     });
  2927 |     it(&quot;{array} should fail if body contains more columns than specification.&quot;, () &#x3D;&gt; {</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  2925 |         expect&#x60;\begin{equation}\begin{split}a &amp;&#x3D;b &amp;+c\\&amp;&#x3D;e &amp;+f\end{split}\end{equation}&#x60;.not.toBuild(displayMode);
  2926 |     });
&gt; 2927 |     it(&quot;{array} should fail if body contains more columns than specification.&quot;, () &#x3D;&gt; {
       |    ^ Unknown Test
  2928 |         expect&#x60;\begin{array}{2}a &amp; b &amp; c\\d &amp; e  f\end{array}&#x60;.not.toBuild(displayMode);
  2929 |     });
  2930 | });</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  2954 |
  2955 | describe(&quot;operatorname support&quot;, function() {
&gt; 2956 |     it(&quot;should not fail&quot;, function() {
       |    ^ Unknown Test
  2957 |         expect&#x60;\operatorname{x*Π∑\Pi\sum\frac a b}&#x60;.toBuild();
  2958 |         expect&#x60;\operatorname*{x*Π∑\Pi\sum\frac a b}&#x60;.toBuild();
  2959 |         expect&#x60;\operatorname*{x*Π∑\Pi\sum\frac a b}_y x&#x60;.toBuild();</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  2965 |
  2966 | describe(&quot;href and url commands&quot;, function() {
&gt; 2967 |     it(&quot;should parse its input&quot;, function() {
       |    ^ Unknown Test
  2968 |         expect&#x60;\href{http:&#x2F;&#x2F;example.com&#x2F;}{\sin}&#x60;.toBuild(trustSettings);
  2969 |         expect&#x60;\url{http:&#x2F;&#x2F;example.com&#x2F;}&#x60;.toBuild(trustSettings);
  2970 |     });</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  2970 |     });
  2971 |
&gt; 2972 |     it(&quot;should allow empty URLs&quot;, function() {
       |    ^ Unknown Test
  2973 |         expect&#x60;\href{}{example here}&#x60;.toBuild(trustSettings);
  2974 |         expect&#x60;\url{}&#x60;.toBuild(trustSettings);
  2975 |     });</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  2983 |     });
  2984 |
&gt; 2985 |     it(&quot;should allow spaces single-character URLs&quot;, () &#x3D;&gt; {
       |    ^ Unknown Test
  2986 |         expect&#x60;\href %end&#x60;.toParseLike(&quot;\\href{%}end&quot;, trustSettings);
  2987 |         expect&#x60;\url %end&#x60;.toParseLike(&quot;\\url{%}end&quot;, trustSettings);
  2988 |     });</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  3004 |     });
  3005 |
&gt; 3006 |     it(&quot;should not allow unbalanced brace(s) in url&quot;, function() {
       |    ^ Unknown Test
  3007 |         expect&#x60;\href{http:&#x2F;&#x2F;example.com&#x2F;{a}{bar}&#x60;.not.toParse();
  3008 |         expect&#x60;\href{http:&#x2F;&#x2F;example.com&#x2F;}a}{bar}&#x60;.not.toParse();
  3009 |         expect&#x60;\url{http:&#x2F;&#x2F;example.com&#x2F;{a}&#x60;.not.toParse();</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  3095 |
  3096 | describe(&quot;A raw text parser&quot;, function() {
&gt; 3097 |     it(&quot;should return null for a omitted optional string&quot;, function() {
       |    ^ Unknown Test
  3098 |         expect&#x60;\includegraphics{https:&#x2F;&#x2F;cdn.kastatic.org&#x2F;images&#x2F;apple-touch-icon-57x57-precomposed.new.png}&#x60;.toParse();
  3099 |     });
  3100 | });</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  3110 |     });
  3111 |
&gt; 3112 |     it(&quot;should still parse on unrecognized control sequences&quot;, function() {
       |    ^ Unknown Test
  3113 |         expect&#x60;\error&#x60;.toParse(noThrowSettings);
  3114 |     });
  3115 |</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  3115 |
  3116 |     describe(&quot;should allow unrecognized controls sequences anywhere, including&quot;, function() {
&gt; 3117 |         it(&quot;in superscripts and subscripts&quot;, function() {
       |        ^ Unknown Test
  3118 |             expect&#x60;2_\error&#x60;.toBuild(noThrowSettings);
  3119 |             expect&#x60;3^{\error}_\error&#x60;.toBuild(noThrowSettings);
  3120 |             expect&#x60;\int\nolimits^\error_\error&#x60;.toBuild(noThrowSettings);</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  3121 |         });
  3122 |
&gt; 3123 |         it(&quot;in fractions&quot;, function() {
       |        ^ Unknown Test
  3124 |             expect&#x60;\frac{345}{\error}&#x60;.toBuild(noThrowSettings);
  3125 |             expect&#x60;\frac\error{\error}&#x60;.toBuild(noThrowSettings);
  3126 |         });</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  3126 |         });
  3127 |
&gt; 3128 |         it(&quot;in square roots&quot;, function() {
       |        ^ Unknown Test
  3129 |             expect&#x60;\sqrt\error&#x60;.toBuild(noThrowSettings);
  3130 |             expect&#x60;\sqrt{234\error}&#x60;.toBuild(noThrowSettings);
  3131 |         });</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  3131 |         });
  3132 |
&gt; 3133 |         it(&quot;in text boxes&quot;, function() {
       |        ^ Unknown Test
  3134 |             expect&#x60;\text{\error}&#x60;.toBuild(noThrowSettings);
  3135 |         });
  3136 |     });</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  3201 |
  3202 | describe(&quot;The symbol table integrity&quot;, function() {
&gt; 3203 |     it(&quot;should treat certain symbols as synonyms&quot;, function() {
       |    ^ Unknown Test
  3204 |         expect&#x60;&lt;&#x60;.toBuildLike&#x60;\lt&#x60;;
  3205 |         expect&#x60;&gt;&#x60;.toBuildLike&#x60;\gt&#x60;;
  3206 |         expect&#x60;\left&lt;\frac{1}{x}\right&gt;&#x60;.toBuildLike&#x60;\left\lt\frac{1}{x}\right\gt&#x60;;</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  3219 |
  3220 | describe(&quot;A macro expander&quot;, function() {
&gt; 3221 |     it(&quot;should produce individual tokens&quot;, function() {
       |    ^ Unknown Test
  3222 |         expect&#x60;e^\foo&#x60;.toParseLike(&quot;e^1 23&quot;,
  3223 |             new Settings({macros: {&quot;\\foo&quot;: &quot;123&quot;}}));
  3224 |     });</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  3224 |     });
  3225 |
&gt; 3226 |     it(&quot;should preserve leading spaces inside macro definition&quot;, function() {
       |    ^ Unknown Test
  3227 |         expect&#x60;\text{\foo}&#x60;.toParseLike(r&#x60;\text{ x}&#x60;,
  3228 |             new Settings({macros: {&quot;\\foo&quot;: &quot; x&quot;}}));
  3229 |     });</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  3229 |     });
  3230 |
&gt; 3231 |     it(&quot;should preserve leading spaces inside macro argument&quot;, function() {
       |    ^ Unknown Test
  3232 |         expect&#x60;\text{\foo{ x}}&#x60;.toParseLike(r&#x60;\text{ x}&#x60;,
  3233 |             new Settings({macros: {&quot;\\foo&quot;: &quot;#1&quot;}}));
  3234 |     });</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  3234 |     });
  3235 |
&gt; 3236 |     it(&quot;should ignore expanded spaces in math mode&quot;, function() {
       |    ^ Unknown Test
  3237 |         expect&#x60;\foo&#x60;.toParseLike(&quot;x&quot;, new Settings({macros: {&quot;\\foo&quot;: &quot; x&quot;}}));
  3238 |     });
  3239 |</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  3238 |     });
  3239 |
&gt; 3240 |     it(&quot;should consume spaces after control-word macro&quot;, function() {
       |    ^ Unknown Test
  3241 |         expect&#x60;\text{\foo }&#x60;.toParseLike(r&#x60;\text{x}&#x60;,
  3242 |             new Settings({macros: {&quot;\\foo&quot;: &quot;x&quot;}}));
  3243 |     });</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  3243 |     });
  3244 |
&gt; 3245 |     it(&quot;should consume spaces after macro with \\relax&quot;, function() {
       |    ^ Unknown Test
  3246 |         expect&#x60;\text{\foo }&#x60;.toParseLike(r&#x60;\text{}&#x60;,
  3247 |             new Settings({macros: {&quot;\\foo&quot;: &quot;\\relax&quot;}}));
  3248 |     });</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  3248 |     });
  3249 |
&gt; 3250 |     it(&quot;should not consume spaces after control-word expansion&quot;, function() {
       |    ^ Unknown Test
  3251 |         expect&#x60;\text{\\ }&#x60;.toParseLike(r&#x60;\text{ }&#x60;,
  3252 |             new Settings({macros: {&quot;\\\\&quot;: &quot;\\relax&quot;}}));
  3253 |     });</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  3253 |     });
  3254 |
&gt; 3255 |     it(&quot;should consume spaces after \\relax&quot;, function() {
       |    ^ Unknown Test
  3256 |         expect&#x60;\text{\relax }&#x60;.toParseLike&#x60;\text{}&#x60;;
  3257 |     });
  3258 |</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  3257 |     });
  3258 |
&gt; 3259 |     it(&quot;should consume spaces after control-word function&quot;, function() {
       |    ^ Unknown Test
  3260 |         expect&#x60;\text{\KaTeX }&#x60;.toParseLike&#x60;\text{\KaTeX}&#x60;;
  3261 |     });
  3262 |</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  3261 |     });
  3262 |
&gt; 3263 |     it(&quot;should preserve spaces after control-symbol macro&quot;, function() {
       |    ^ Unknown Test
  3264 |         expect&#x60;\text{\% y}&#x60;.toParseLike(r&#x60;\text{x y}&#x60;,
  3265 |             new Settings({macros: {&quot;\\%&quot;: &quot;x&quot;}}));
  3266 |     });</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  3266 |     });
  3267 |
&gt; 3268 |     it(&quot;should preserve spaces after control-symbol function&quot;, function() {
       |    ^ Unknown Test
  3269 |         expect&#x60;\text{\&#39; }&#x60;.toParse();
  3270 |     });
  3271 |</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  3270 |     });
  3271 |
&gt; 3272 |     it(&quot;should consume spaces between arguments&quot;, function() {
       |    ^ Unknown Test
  3273 |         expect&#x60;\text{\foo 1 2}&#x60;.toParseLike(r&#x60;\text{12end}&#x60;,
  3274 |             new Settings({macros: {&quot;\\foo&quot;: &quot;#1#2end&quot;}}));
  3275 |         expect&#x60;\text{\foo {1} {2}}&#x60;.toParseLike(r&#x60;\text{12end}&#x60;,</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  3277 |     });
  3278 |
&gt; 3279 |     it(&quot;should allow for multiple expansion&quot;, function() {
       |    ^ Unknown Test
  3280 |         expect&#x60;1\foo2&#x60;.toParseLike(&quot;1aa2&quot;, new Settings({macros: {
  3281 |             &quot;\\foo&quot;: &quot;\\bar\\bar&quot;,
  3282 |             &quot;\\bar&quot;: &quot;a&quot;,</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  3284 |     });
  3285 |
&gt; 3286 |     it(&quot;should allow for multiple expansion with argument&quot;, function() {
       |    ^ Unknown Test
  3287 |         expect&#x60;1\foo2&#x60;.toParseLike(&quot;12222&quot;, new Settings({macros: {
  3288 |             &quot;\\foo&quot;: &quot;\\bar{#1}\\bar{#1}&quot;,
  3289 |             &quot;\\bar&quot;: &quot;#1#1&quot;,</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  3291 |     });
  3292 |
&gt; 3293 |     it(&quot;should allow for macro argument&quot;, function() {
       |    ^ Unknown Test
  3294 |         expect&#x60;\foo\bar&#x60;.toParseLike(&quot;(xyz)&quot;, new Settings({macros: {
  3295 |             &quot;\\foo&quot;: &quot;(#1)&quot;,
  3296 |             &quot;\\bar&quot;: &quot;xyz&quot;,</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  3298 |     });
  3299 |
&gt; 3300 |     it(&quot;should allow properly nested group for macro argument&quot;, function() {
       |    ^ Unknown Test
  3301 |         expect&#x60;\foo{e^{x_{12}+3}}&#x60;.toParseLike(&quot;(e^{x_{12}+3})&quot;,
  3302 |             new Settings({macros: {&quot;\\foo&quot;: &quot;(#1)&quot;}}));
  3303 |     });</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  3303 |     });
  3304 |
&gt; 3305 |     it(&quot;should delay expansion if preceded by \\expandafter&quot;, function() {
       |    ^ Unknown Test
  3306 |         expect&#x60;\expandafter\foo\bar&#x60;.toParseLike(&quot;x+y&quot;, new Settings({macros: {
  3307 |             &quot;\\foo&quot;: &quot;#1+#2&quot;,
  3308 |             &quot;\\bar&quot;: &quot;xy&quot;,</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  3313 |     });
  3314 |
&gt; 3315 |     it(&quot;should not expand if preceded by \\noexpand&quot;, function() {
       |    ^ Unknown Test
  3316 |         &#x2F;&#x2F; \foo is not expanded and interpreted as if its meaning were \relax
  3317 |         expect&#x60;\noexpand\foo y&#x60;.toParseLike(&quot;y&quot;,
  3318 |             new Settings({macros: {&quot;\\foo&quot;: &quot;x&quot;}}));</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  3326 |     });
  3327 |
&gt; 3328 |     it(&quot;should allow for space macro argument (text version)&quot;, function() {
       |    ^ Unknown Test
  3329 |         expect&#x60;\text{\foo\bar}&#x60;.toParseLike(r&#x60;\text{( )}&#x60;, new Settings({macros: {
  3330 |             &quot;\\foo&quot;: &quot;(#1)&quot;,
  3331 |             &quot;\\bar&quot;: &quot; &quot;,</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  3333 |     });
  3334 |
&gt; 3335 |     it(&quot;should allow for space macro argument (math version)&quot;, function() {
       |    ^ Unknown Test
  3336 |         expect&#x60;\foo\bar&#x60;.toParseLike(&quot;()&quot;, new Settings({macros: {
  3337 |             &quot;\\foo&quot;: &quot;(#1)&quot;,
  3338 |             &quot;\\bar&quot;: &quot; &quot;,</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  3340 |     });
  3341 |
&gt; 3342 |     it(&quot;should allow for space second argument (text version)&quot;, function() {
       |    ^ Unknown Test
  3343 |         expect&#x60;\text{\foo\bar\bar}&#x60;.toParseLike(r&#x60;\text{( , )}&#x60;, new Settings({macros: {
  3344 |             &quot;\\foo&quot;: &quot;(#1,#2)&quot;,
  3345 |             &quot;\\bar&quot;: &quot; &quot;,</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  3347 |     });
  3348 |
&gt; 3349 |     it(&quot;should treat \\relax as empty argument&quot;, function() {
       |    ^ Unknown Test
  3350 |         expect&#x60;\text{\foo\relax x}&#x60;.toParseLike(r&#x60;\text{(,x)}&#x60;, new Settings({macros: {
  3351 |             &quot;\\foo&quot;: &quot;(#1,#2)&quot;,
  3352 |         }}));</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  3353 |     });
  3354 |
&gt; 3355 |     it(&quot;should allow for space second argument (math version)&quot;, function() {
       |    ^ Unknown Test
  3356 |         expect&#x60;\foo\bar\bar&#x60;.toParseLike(&quot;(,)&quot;, new Settings({macros: {
  3357 |             &quot;\\foo&quot;: &quot;(#1,#2)&quot;,
  3358 |             &quot;\\bar&quot;: &quot; &quot;,</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  3360 |     });
  3361 |
&gt; 3362 |     it(&quot;should allow for empty macro argument&quot;, function() {
       |    ^ Unknown Test
  3363 |         expect&#x60;\foo\bar&#x60;.toParseLike(&quot;()&quot;, new Settings({macros: {
  3364 |             &quot;\\foo&quot;: &quot;(#1)&quot;,
  3365 |             &quot;\\bar&quot;: &quot;&quot;,</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  3367 |     });
  3368 |
&gt; 3369 |     it(&quot;should allow for space function arguments&quot;, function() {
       |    ^ Unknown Test
  3370 |         expect&#x60;\frac\bar\bar&#x60;.toParseLike(r&#x60;\frac{}{}&#x60;, new Settings({macros: {
  3371 |             &quot;\\bar&quot;: &quot; &quot;,
  3372 |         }}));</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  3373 |     });
  3374 |
&gt; 3375 |     it(&quot;should build \\overset and \\underset&quot;, function() {
       |    ^ Unknown Test
  3376 |         expect&#x60;\overset{f}{\rightarrow} Y&#x60;.toBuild();
  3377 |         expect&#x60;\underset{f}{\rightarrow} Y&#x60;.toBuild();
  3378 |     });</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  3378 |     });
  3379 |
&gt; 3380 |     it(&quot;should build \\iff, \\implies, \\impliedby&quot;, function() {
       |    ^ Unknown Test
  3381 |         expect&#x60;X \iff Y&#x60;.toBuild();
  3382 |         expect&#x60;X \implies Y&#x60;.toBuild();
  3383 |         expect&#x60;X \impliedby Y&#x60;.toBuild();</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  3384 |     });
  3385 |
&gt; 3386 |     it(&quot;should allow aliasing characters&quot;, function() {
       |    ^ Unknown Test
  3387 |         expect&#x60;x’&#x3D;c&#x60;.toParseLike(&quot;x&#39;&#x3D;c&quot;, new Settings({macros: {
  3388 |             &quot;’&quot;: &quot;&#39;&quot;,
  3389 |         }}));</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  3390 |     });
  3391 |
&gt; 3392 |     it(&quot;\\@firstoftwo should consume both, and avoid errors&quot;, function() {
       |    ^ Unknown Test
  3393 |         expect&#x60;\@firstoftwo{yes}{no}&#x60;.toParseLike&#x60;yes&#x60;;
  3394 |         expect&#x60;\@firstoftwo{yes}{1&#39;_2^3}&#x60;.toParseLike&#x60;yes&#x60;;
  3395 |     });</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  3395 |     });
  3396 |
&gt; 3397 |     it(&quot;\\@ifstar should consume star but nothing else&quot;, function() {
       |    ^ Unknown Test
  3398 |         expect&#x60;\@ifstar{yes}{no}*!&#x60;.toParseLike&#x60;yes!&#x60;;
  3399 |         expect&#x60;\@ifstar{yes}{no}?!&#x60;.toParseLike&#x60;no?!&#x60;;
  3400 |     });</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  3400 |     });
  3401 |
&gt; 3402 |     it(&quot;\\@ifnextchar should not consume nonspaces&quot;, function() {
       |    ^ Unknown Test
  3403 |         expect&#x60;\@ifnextchar!{yes}{no}!!&#x60;.toParseLike&#x60;yes!!&#x60;;
  3404 |         expect&#x60;\@ifnextchar!{yes}{no}?!&#x60;.toParseLike&#x60;no?!&#x60;;
  3405 |     });</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  3405 |     });
  3406 |
&gt; 3407 |     it(&quot;\\@ifnextchar should consume spaces&quot;, function() {
       |    ^ Unknown Test
  3408 |         expect&#x60;\def\x#1{\@ifnextchar x{yes}{no}}\x{}x\x{} x&#x60;
  3409 |             .toParseLike&#x60;yesxyesx&#x60;;
  3410 |     });</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  3410 |     });
  3411 |
&gt; 3412 |     it(&quot;\\@ifstar should consume star but nothing else&quot;, function() {
       |    ^ Unknown Test
  3413 |         expect&#x60;\@ifstar{yes}{no}*!&#x60;.toParseLike&#x60;yes!&#x60;;
  3414 |         expect&#x60;\@ifstar{yes}{no}?!&#x60;.toParseLike&#x60;no?!&#x60;;
  3415 |     });</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  3415 |     });
  3416 |
&gt; 3417 |     it(&quot;\\TextOrMath should work immediately&quot;, function() {
       |    ^ Unknown Test
  3418 |         expect&#x60;\TextOrMath{text}{math}&#x60;.toParseLike&#x60;math&#x60;;
  3419 |     });
  3420 |</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  3419 |     });
  3420 |
&gt; 3421 |     it(&quot;\\TextOrMath should work after other math&quot;, function() {
       |    ^ Unknown Test
  3422 |         expect&#x60;x+\TextOrMath{text}{math}&#x60;.toParseLike&#x60;x+math&#x60;;
  3423 |     });
  3424 |</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  3423 |     });
  3424 |
&gt; 3425 |     it(&quot;\\TextOrMath should work immediately after \\text&quot;, function() {
       |    ^ Unknown Test
  3426 |         expect&#x60;\text{\TextOrMath{text}{math}}&#x60;.toParseLike&#x60;\text{text}&#x60;;
  3427 |     });
  3428 |</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  3427 |     });
  3428 |
&gt; 3429 |     it(&quot;\\TextOrMath should work later after \\text&quot;, function() {
       |    ^ Unknown Test
  3430 |         expect&#x60;\text{hello \TextOrMath{text}{math}}&#x60;.toParseLike&#x60;\text{hello text}&#x60;;
  3431 |     });
  3432 |</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  3431 |     });
  3432 |
&gt; 3433 |     it(&quot;\\TextOrMath should work immediately after \\text ends&quot;, function() {
       |    ^ Unknown Test
  3434 |         expect&#x60;\text{\TextOrMath{text}{math}}\TextOrMath{text}{math}&#x60;
  3435 |             .toParseLike&#x60;\text{text}math&#x60;;
  3436 |     });</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  3436 |     });
  3437 |
&gt; 3438 |     it(&quot;\\TextOrMath should work immediately after $&quot;, function() {
       |    ^ Unknown Test
  3439 |         expect&#x60;\text{$\TextOrMath{text}{math}$}&#x60;.toParseLike&#x60;\text{$math$}&#x60;;
  3440 |     });
  3441 |</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  3440 |     });
  3441 |
&gt; 3442 |     it(&quot;\\TextOrMath should work later after $&quot;, function() {
       |    ^ Unknown Test
  3443 |         expect&#x60;\text{$x+\TextOrMath{text}{math}$}&#x60;.toParseLike&#x60;\text{$x+math$}&#x60;;
  3444 |     });
  3445 |</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  3444 |     });
  3445 |
&gt; 3446 |     it(&quot;\\TextOrMath should work immediately after $ ends&quot;, function() {
       |    ^ Unknown Test
  3447 |         expect&#x60;\text{$\TextOrMath{text}{math}$\TextOrMath{text}{math}}&#x60;
  3448 |             .toParseLike&#x60;\text{$math$text}&#x60;;
  3449 |     });</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  3449 |     });
  3450 |
&gt; 3451 |     it(&quot;\\TextOrMath should work in a macro&quot;, function() {
       |    ^ Unknown Test
  3452 |         expect&#x60;\mode\text{\mode$\mode$\mode}\mode&#x60;
  3453 |             .toParseLike(r&#x60;math\text{text$math$text}math&#x60;, new Settings({macros: {
  3454 |                 &quot;\\mode&quot;: &quot;\\TextOrMath{text}{math}&quot;,</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  3456 |     });
  3457 |
&gt; 3458 |     it(&quot;\\TextOrMath should work in a macro passed to \\text&quot;, function() {
       |    ^ Unknown Test
  3459 |         expect&#x60;\text\mode&#x60;.toParseLike(r&#x60;\text t&#x60;, new Settings({macros:
  3460 |             {&quot;\\mode&quot;: &quot;\\TextOrMath{t}{m}&quot;}}));
  3461 |     });</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  3488 |     });
  3489 |
&gt; 3490 |     it(&quot;should build Unicode private area characters&quot;, function() {
       |    ^ Unknown Test
  3491 |         expect&#x60;\gvertneqq\lvertneqq\ngeqq\ngeqslant\nleqq&#x60;.toBuild();
  3492 |         expect&#x60;\nleqslant\nshortmid\nshortparallel\varsubsetneq&#x60;.toBuild();
  3493 |         expect&#x60;\varsubsetneqq\varsupsetneq\varsupsetneqq&#x60;.toBuild();</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  3494 |     });
  3495 |
&gt; 3496 |     it(&quot;\\TextOrMath should work in a macro passed to \\text&quot;, function() {
       |    ^ Unknown Test
  3497 |         expect&#x60;\text\mode&#x60;.toParseLike(r&#x60;\text{text}&#x60;, new Settings({macros:
  3498 |             {&quot;\\mode&quot;: &quot;\\TextOrMath{text}{math}&quot;}}));
  3499 |     });</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  3499 |     });
  3500 |
&gt; 3501 |     it(&quot;\\gdef defines macros&quot;, function() {
       |    ^ Unknown Test
  3502 |         expect&#x60;\gdef\foo{x^2}\foo+\foo&#x60;.toParseLike&#x60;x^2+x^2&#x60;;
  3503 |         expect&#x60;\gdef\foo{hi}\foo+\text\foo&#x60;.toParseLike&#x60;hi+\text{hi}&#x60;;
  3504 |         expect&#x60;\gdef\foo#1{hi #1}\text{\foo{Alice}, \foo{Bob}}&#x60;</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  3517 |     });
  3518 |
&gt; 3519 |     it(&quot;\\gdef defines macros with delimited parameter&quot;, function() {
       |    ^ Unknown Test
  3520 |         expect&#x60;\gdef\foo|#1||{#1}\text{\foo| x y ||}&#x60;.toParseLike&#x60;\text{ x y }&#x60;;
  3521 |         expect&#x60;\gdef\foo#1|#2{#1+#2}\foo 1 2 |34&#x60;.toParseLike&#x60;12+34&#x60;;
  3522 |         expect&#x60;\gdef\foo#1#{#1}\foo1^{23}&#x60;.toParseLike&#x60;1^{23}&#x60;;</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  3526 |     });
  3527 |
&gt; 3528 |     it(&quot;\\xdef should expand definition&quot;, function() {
       |    ^ Unknown Test
  3529 |         expect&#x60;\def\foo{a}\xdef\bar{\foo}\def\foo{}\bar&#x60;.toParseLike&#x60;a&#x60;;
  3530 |         &#x2F;&#x2F; \def\noexpand\foo{} expands into \def\foo{}
  3531 |         expect&#x60;\def\foo{a}\xdef\bar{\def\noexpand\foo{}}\foo\bar\foo&#x60;.toParseLike&#x60;a&#x60;;</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  3536 |     });
  3537 |
&gt; 3538 |     it(&quot;\\def should be handled in Parser&quot;, () &#x3D;&gt; {
       |    ^ Unknown Test
  3539 |         expect&#x60;\gdef\foo{1}&#x60;.toParse(new Settings({maxExpand: 0}));
  3540 |         expect&#x60;2^\def\foo{1}2&#x60;.not.toParse();
  3541 |     });</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  3541 |     });
  3542 |
&gt; 3543 |     it(&quot;\\def works locally&quot;, () &#x3D;&gt; {
       |    ^ Unknown Test
  3544 |         expect&#x60;\def\x{1}\x{\def\x{2}\x{\def\x{3}\x}\x}\x&#x60;
  3545 |             .toParseLike&#x60;1{2{3}2}1&#x60;;
  3546 |         expect&#x60;\def\x{1}\x\def\x{2}\x{\def\x{3}\x\def\x{4}\x}\x&#x60;</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  3548 |     });
  3549 |
&gt; 3550 |     it(&quot;\\gdef overrides at all levels&quot;, () &#x3D;&gt; {
       |    ^ Unknown Test
  3551 |         expect&#x60;\def\x{1}\x{\def\x{2}\x{\gdef\x{3}\x}\x}\x&#x60;
  3552 |             .toParseLike&#x60;1{2{3}3}3&#x60;;
  3553 |         expect&#x60;\def\x{1}\x{\def\x{2}\x{\global\def\x{3}\x}\x}\x&#x60;</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  3557 |     });
  3558 |
&gt; 3559 |     it(&quot;\\global needs to followed by macro prefixes, \\def or \\edef&quot;, () &#x3D;&gt; {
       |    ^ Unknown Test
  3560 |         expect&#x60;\global\def\foo{}\foo&#x60;.toParseLike&#x60;&#x60;;
  3561 |         expect&#x60;\global\edef\foo{}\foo&#x60;.toParseLike&#x60;&#x60;;
  3562 |         expect&#x60;\def\DEF{\def}\global\DEF\foo{}\foo&#x60;.toParseLike&#x60;&#x60;;</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  3567 |     });
  3568 |
&gt; 3569 |     it(&quot;\\long needs to followed by macro prefixes, \\def or \\edef&quot;, () &#x3D;&gt; {
       |    ^ Unknown Test
  3570 |         expect&#x60;\long\def\foo{}\foo&#x60;.toParseLike&#x60;&#x60;;
  3571 |         expect&#x60;\long\edef\foo{}\foo&#x60;.toParseLike&#x60;&#x60;;
  3572 |         expect&#x60;\long\global\def\foo{}\foo&#x60;.toParseLike&#x60;&#x60;;</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  3574 |     });
  3575 |
&gt; 3576 |     it(&quot;Macro arguments do not generate groups&quot;, () &#x3D;&gt; {
       |    ^ Unknown Test
  3577 |         expect&#x60;\def\x{1}\x\def\foo#1{#1}\foo{\x\def\x{2}\x}\x&#x60;
  3578 |             .toParseLike&#x60;1122&#x60;;
  3579 |     });</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  3579 |     });
  3580 |
&gt; 3581 |     it(&quot;\\textbf arguments do generate groups&quot;, () &#x3D;&gt; {
       |    ^ Unknown Test
  3582 |         expect&#x60;\def\x{1}\x\textbf{\x\def\x{2}\x}\x&#x60;.toParseLike&#x60;1\textbf{12}1&#x60;;
  3583 |     });
  3584 |</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  3583 |     });
  3584 |
&gt; 3585 |     it(&quot;\\sqrt optional arguments generate groups&quot;, () &#x3D;&gt; {
       |    ^ Unknown Test
  3586 |         expect&#x60;\def\x{1}\def\y{1}\x\y\sqrt[\def\x{2}\x]{\def\y{2}\y}\x\y&#x60;
  3587 |             .toParseLike&#x60;11\sqrt[2]{2}11&#x60;;
  3588 |     });</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  3588 |     });
  3589 |
&gt; 3590 |     it(&quot;array cells generate groups&quot;, () &#x3D;&gt; {
       |    ^ Unknown Test
  3591 |         expect&#x60;\def\x{1}\begin{matrix}\x&amp;\def\x{2}\x&amp;\x\end{matrix}\x&#x60;
  3592 |             .toParseLike&#x60;\begin{matrix}1&amp;2&amp;1\end{matrix}1&#x60;;
  3593 |         expect&#x60;\def\x{1}\begin{matrix}\def\x{2}\x&amp;\x\end{matrix}\x&#x60;</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  3619 |     });
  3620 |
&gt; 3621 |     it(&quot;\\let copies the definition&quot;, () &#x3D;&gt; {
       |    ^ Unknown Test
  3622 |         expect&#x60;\let\foo&#x3D;\frac\def\frac{}\foo12&#x60;.toParseLike&#x60;\frac12&#x60;;
  3623 |         expect&#x60;\def\foo{1}\let\bar\foo\def\foo{2}\bar&#x60;.toParseLike&#x60;1&#x60;;
  3624 |         expect&#x60;\let\foo&#x3D;\kern\edef\bar{\foo1em}\let\kern&#x3D;\relax\bar&#x60;.toParseLike&#x60;\kern1em&#x60;;</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  3639 |     });
  3640 |
&gt; 3641 |     it(&quot;\\futurelet should parse correctly&quot;, () &#x3D;&gt; {
       |    ^ Unknown Test
  3642 |         expect&#x60;\futurelet\foo\frac1{2+\foo}&#x60;.toParseLike&#x60;\frac1{2+1}&#x60;;
  3643 |     });
  3644 |</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  3643 |     });
  3644 |
&gt; 3645 |     it(&quot;macros argument can simulate \\let&quot;, () &#x3D;&gt; {
       |    ^ Unknown Test
  3646 |         expect&#x60;\int&#x60;.toParseLike(&quot;\\int\\limits&quot;, {macros: {
  3647 |             &quot;\\Oldint&quot;: {
  3648 |                 tokens: [{text: &quot;\\int&quot;, noexpand: true}],</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  3670 |     });
  3671 |
&gt; 3672 |     it(&quot;\\newcommand defines new macros&quot;, () &#x3D;&gt; {
       |    ^ Unknown Test
  3673 |         expect&#x60;\newcommand\foo{x^2}\foo+\foo&#x60;.toParseLike&#x60;x^2+x^2&#x60;;
  3674 |         expect&#x60;\newcommand{\foo}{x^2}\foo+\foo&#x60;.toParseLike&#x60;x^2+x^2&#x60;;
  3675 |         &#x2F;&#x2F; Function detection</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  3685 |     });
  3686 |
&gt; 3687 |     it(&quot;\\renewcommand redefines macros&quot;, () &#x3D;&gt; {
       |    ^ Unknown Test
  3688 |         expect&#x60;\renewcommand\foo{x^2}\foo+\foo&#x60;.not.toParse();
  3689 |         expect&#x60;\renewcommand{\foo}{x^2}\foo+\foo&#x60;.not.toParse();
  3690 |         expect&#x60;\renewcommand\bar{x^2}\bar+\bar&#x60;.toParseLike&#x60;x^2+x^2&#x60;;</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  3693 |     });
  3694 |
&gt; 3695 |     it(&quot;\\providecommand defines but does not redefine macros&quot;, () &#x3D;&gt; {
       |    ^ Unknown Test
  3696 |         expect&#x60;\providecommand\foo{x^2}\foo+\foo&#x60;.toParseLike&#x60;x^2+x^2&#x60;;
  3697 |         expect&#x60;\providecommand{\foo}{x^2}\foo+\foo&#x60;.toParseLike&#x60;x^2+x^2&#x60;;
  3698 |         expect&#x60;\newcommand{\foo}{1}\foo\providecommand{\foo}{2}\foo&#x60;</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  3704 |     });
  3705 |
&gt; 3706 |     it(&quot;\\newcommand is local&quot;, () &#x3D;&gt; {
       |    ^ Unknown Test
  3707 |         expect&#x60;\newcommand\foo{1}\foo{\renewcommand\foo{2}\foo}\foo&#x60;
  3708 |             .toParseLike&#x60;1{2}1&#x60;;
  3709 |     });</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  3709 |     });
  3710 |
&gt; 3711 |     it(&quot;\\newcommand accepts number of arguments&quot;, () &#x3D;&gt; {
       |    ^ Unknown Test
  3712 |         expect&#x60;\newcommand\foo[1]{#1^2}\foo x+\foo{y}&#x60;.toParseLike&#x60;x^2+y^2&#x60;;
  3713 |         expect&#x60;\newcommand\foo[10]{#1^2}\foo 0123456789&#x60;.toParseLike&#x60;0^2&#x60;;
  3714 |         expect&#x60;\newcommand\foo[x]{}&#x60;.not.toParse();</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  3718 |     &#x2F;&#x2F; This may change in the future, if we support the extra features of
  3719 |     &#x2F;&#x2F; \hspace.
&gt; 3720 |     it(&quot;should treat \\hspace, \\hskip like \\kern&quot;, function() {
       |    ^ Unknown Test
  3721 |         expect&#x60;\hspace{1em}&#x60;.toParseLike&#x60;\kern1em&#x60;;
  3722 |         expect&#x60;\hskip{1em}&#x60;.toParseLike&#x60;\kern1em&#x60;;
  3723 |     });</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  3723 |     });
  3724 |
&gt; 3725 |     it(&quot;should expand \\limsup as expected&quot;, () &#x3D;&gt; {
       |    ^ Unknown Test
  3726 |         expect&#x60;\limsup&#x60;.toParseLike&#x60;\operatorname*{lim\,sup}&#x60;;
  3727 |     });
  3728 |</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  3727 |     });
  3728 |
&gt; 3729 |     it(&quot;should expand \\liminf as expected&quot;, () &#x3D;&gt; {
       |    ^ Unknown Test
  3730 |         expect&#x60;\liminf&#x60;.toParseLike&#x60;\operatorname*{lim\,inf}&#x60;;
  3731 |     });
  3732 |</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  3731 |     });
  3732 |
&gt; 3733 |     it(&quot;should expand AMS log-like symbols as expected&quot;, () &#x3D;&gt; {
       |    ^ Unknown Test
  3734 |         expect&#x60;\injlim&#x60;.toParseLike&#x60;\operatorname*{inj\,lim}&#x60;;
  3735 |         expect&#x60;\projlim&#x60;.toParseLike&#x60;\operatorname*{proj\,lim}&#x60;;
  3736 |         expect&#x60;\varlimsup&#x60;.toParseLike&#x60;\operatorname*{\overline{lim}}&#x60;;</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  3741 |     });
  3742 |
&gt; 3743 |     it(&quot;should expand \\plim as expected&quot;, () &#x3D;&gt; {
       |    ^ Unknown Test
  3744 |         expect&#x60;\plim&#x60;.toParseLike&#x60;\mathop{\operatorname{plim}}\limits&#x60;;
  3745 |     });
  3746 |</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  3745 |     });
  3746 |
&gt; 3747 |     it(&quot;should expand \\argmin as expected&quot;, () &#x3D;&gt; {
       |    ^ Unknown Test
  3748 |         expect&#x60;\argmin&#x60;.toParseLike&#x60;\operatorname*{arg\,min}&#x60;;
  3749 |     });
  3750 |</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  3749 |     });
  3750 |
&gt; 3751 |     it(&quot;should expand \\argmax as expected&quot;, () &#x3D;&gt; {
       |    ^ Unknown Test
  3752 |         expect&#x60;\argmax&#x60;.toParseLike&#x60;\operatorname*{arg\,max}&#x60;;
  3753 |     });
  3754 |</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  3753 |     });
  3754 |
&gt; 3755 |     it(&quot;should expand \\bra as expected&quot;, () &#x3D;&gt; {
       |    ^ Unknown Test
  3756 |         expect&#x60;\bra{\phi}&#x60;.toParseLike&#x60;\mathinner{\langle{\phi}|}&#x60;;
  3757 |     });
  3758 |</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  3757 |     });
  3758 |
&gt; 3759 |     it(&quot;should expand \\ket as expected&quot;, () &#x3D;&gt; {
       |    ^ Unknown Test
  3760 |         expect&#x60;\ket{\psi}&#x60;.toParseLike&#x60;\mathinner{|{\psi}\rangle}&#x60;;
  3761 |     });
  3762 |</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  3761 |     });
  3762 |
&gt; 3763 |     it(&quot;should expand \\braket as expected&quot;, () &#x3D;&gt; {
       |    ^ Unknown Test
  3764 |         expect&#x60;\braket{\phi|\psi}&#x60;.toParseLike&#x60;\mathinner{\langle{\phi|\psi}\rangle}&#x60;;
  3765 |     });
  3766 |</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  3765 |     });
  3766 |
&gt; 3767 |     it(&quot;should expand \\Bra as expected&quot;, () &#x3D;&gt; {
       |    ^ Unknown Test
  3768 |         expect&#x60;\Bra{\phi}&#x60;.toParseLike&#x60;\left\langle\phi\right|&#x60;;
  3769 |     });
  3770 |</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  3769 |     });
  3770 |
&gt; 3771 |     it(&quot;should expand \\Ket as expected&quot;, () &#x3D;&gt; {
       |    ^ Unknown Test
  3772 |         expect&#x60;\Ket{\psi}&#x60;.toParseLike&#x60;\left|\psi\right\rangle&#x60;;
  3773 |     });
  3774 |</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  3773 |     });
  3774 |
&gt; 3775 |     it(&quot;should expand \\Braket as expected&quot;, () &#x3D;&gt; {
       |    ^ Unknown Test
  3776 |         expect&#x60;\Braket{ ϕ | \frac{∂^2}{∂ t^2} | ψ }&#x60;.toParseLike&#x60;\left\langle ϕ\,\middle\vert\,\frac{∂^2}{∂ t^2}\,\middle\vert\, ψ\right\rangle&#x60;;
  3777 |     });
  3778 |</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  3777 |     });
  3778 |
&gt; 3779 |     it(&quot;should expand \\set as expected&quot;, () &#x3D;&gt; {
       |    ^ Unknown Test
  3780 |         expect&#x60;\set{x|x&lt;5|S|}&#x60;.toParseLike&#x60;\{\,x\mid x&lt;5|S|\,\}&#x60;;
  3781 |         &#x2F;&#x2F; \set doesn&#39;t support special || or \| handling
  3782 |         expect&#x60;\set{x||x&lt;5|S|}&#x60;.toParseLike&#x60;\{\,x\mid |x&lt;5|S|\,\}&#x60;;</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  3784 |     });
  3785 |
&gt; 3786 |     it(&quot;should expand \\Set as expected&quot;, () &#x3D;&gt; {
       |    ^ Unknown Test
  3787 |         expect&#x60;\Set{ x | x&lt;\frac 1 2 |S| }&#x60;
  3788 |         .toParseLike&#x60;\left\{\: x\;\middle\vert\; x&lt;\frac 1 2 |S| \:\right\}&#x60;;
  3789 |         expect&#x60;\Set{ x || x&lt;\frac 1 2 |S| }&#x60;</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  3797 |     const displayMode &#x3D; new Settings({displayMode: true});
  3798 |
&gt; 3799 |     it(&quot;should fail outside display mode&quot;, () &#x3D;&gt; {
       |    ^ Unknown Test
  3800 |         expect&#x60;\tag{hi}x+y&#x60;.not.toParse();
  3801 |     });
  3802 |</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  3801 |     });
  3802 |
&gt; 3803 |     it(&quot;should fail with multiple tags&quot;, () &#x3D;&gt; {
       |    ^ Unknown Test
  3804 |         expect&#x60;\tag{1}\tag{2}x+y&#x60;.not.toParse(displayMode);
  3805 |     });
  3806 |</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  3805 |     });
  3806 |
&gt; 3807 |     it(&quot;should fail with multiple tags in one row&quot;, () &#x3D;&gt; {
       |    ^ Unknown Test
  3808 |         expect&#x60;\begin{align}\tag{1}x+y\tag{2}\end{align}&#x60;.not.toParse(displayMode);
  3809 |     });
  3810 |</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  3809 |     });
  3810 |
&gt; 3811 |     it(&quot;should work with one tag per row&quot;, () &#x3D;&gt; {
       |    ^ Unknown Test
  3812 |         expect&#x60;\begin{align}\tag{1}x\\&amp;+y\tag{2}\end{align}&#x60;.toParse(displayMode);
  3813 |     });
  3814 |</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  3813 |     });
  3814 |
&gt; 3815 |     it(&quot;should work with \\nonumber&#x2F;\\notag&quot;, () &#x3D;&gt; {
       |    ^ Unknown Test
  3816 |         expect&#x60;\begin{align}\tag{1}\nonumber x\\&amp;+y\notag\end{align}&#x60;
  3817 |         .toParseLike(r&#x60;\begin{align}\tag{1}x\\&amp;+y\nonumber\end{align}&#x60;, displayMode);
  3818 |     });</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  3818 |     });
  3819 |
&gt; 3820 |     it(&quot;should build&quot;, () &#x3D;&gt; {
       |    ^ Unknown Test
  3821 |         expect&#x60;\tag{hi}x+y&#x60;.toBuild(displayMode);
  3822 |     });
  3823 |</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  3822 |     });
  3823 |
&gt; 3824 |     it(&quot;should ignore location of \\tag&quot;, () &#x3D;&gt; {
       |    ^ Unknown Test
  3825 |         expect&#x60;\tag{hi}x+y&#x60;.toParseLike(r&#x60;x+y\tag{hi}&#x60;, displayMode);
  3826 |     });
  3827 |</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  3826 |     });
  3827 |
&gt; 3828 |     it(&quot;should handle \\tag* like \\tag&quot;, () &#x3D;&gt; {
       |    ^ Unknown Test
  3829 |         expect&#x60;\tag{hi}x+y&#x60;.toParseLike(r&#x60;\tag*{({hi})}x+y&#x60;, displayMode);
  3830 |     });
  3831 | });</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  3855 |
  3856 | describe(&quot;\\@binrel automatic bin&#x2F;rel&#x2F;ord&quot;, () &#x3D;&gt; {
&gt; 3857 |     it(&quot;should generate proper class&quot;, () &#x3D;&gt; {
       |    ^ Unknown Test
  3858 |         expect&#x60;L\@binrel+xR&#x60;.toParseLike&#x60;L\mathbin xR&#x60;;
  3859 |         expect&#x60;L\@binrel&#x3D;xR&#x60;.toParseLike&#x60;L\mathrel xR&#x60;;
  3860 |         expect&#x60;L\@binrel xxR&#x60;.toParseLike&#x60;L\mathord xR&#x60;;</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  3864 |     });
  3865 |
&gt; 3866 |     it(&quot;should base on just first character in group&quot;, () &#x3D;&gt; {
       |    ^ Unknown Test
  3867 |         expect&#x60;L\@binrel{+x}xR&#x60;.toParseLike&#x60;L\mathbin xR&#x60;;
  3868 |         expect&#x60;L\@binrel{&#x3D;x}xR&#x60;.toParseLike&#x60;L\mathrel xR&#x60;;
  3869 |         expect&#x60;L\@binrel{xx}xR&#x60;.toParseLike&#x60;L\mathord xR&#x60;;</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  3884 |
  3885 | describe(&quot;Unicode accents&quot;, function() {
&gt; 3886 |     it(&quot;should parse Latin-1 letters in math mode&quot;, function() {
       |    ^ Unknown Test
  3887 |         &#x2F;&#x2F; TODO(edemaine): Unsupported Latin-1 letters in math: ÇÐÞçðþ
  3888 |         expect&#x60;ÀÁÂÃÄÅÈÉÊËÌÍÎÏÑÒÓÔÕÖÙÚÛÜÝàáâãäåèéêëìíîïñòóôõöùúûüýÿ&#x60;
  3889 |         .toParseLike(</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  3904 |     });
  3905 |
&gt; 3906 |     it(&quot;should parse Latin-1 letters in text mode&quot;, function() {
       |    ^ Unknown Test
  3907 |         &#x2F;&#x2F; TODO(edemaine): Unsupported Latin-1 letters in text: ÇÐÞçðþ
  3908 |         expect&#x60;\text{ÀÁÂÃÄÅÈÉÊËÌÍÎÏÑÒÓÔÕÖÙÚÛÜÝàáâãäåèéêëìíîïñòóôõöùúûüýÿ}&#x60;
  3909 |         .toParseLike(</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  3924 |     });
  3925 |
&gt; 3926 |     it(&quot;should support \\aa in text mode&quot;, function() {
       |    ^ Unknown Test
  3927 |         expect&#x60;\text{\aa\AA}&#x60;.toParseLike(r&#x60;\text{\r a\r A}&#x60;, strictSettings);
  3928 |         expect&#x60;\aa&#x60;.not.toParse(strictSettings);
  3929 |         expect&#x60;\Aa&#x60;.not.toParse(strictSettings);</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  3935 |     });
  3936 |
&gt; 3937 |     it(&quot;should parse multi-accented characters&quot;, function() {
       |    ^ Unknown Test
  3938 |         expect&#x60;ấā́ắ\text{ấā́ắ}&#x60;.toParse(nonstrictSettings);
  3939 |         &#x2F;&#x2F; Doesn&#39;t parse quite the same as
  3940 |         &#x2F;&#x2F; &quot;\\text{\\&#39;{\\^a}\\&#39;{\\&#x3D;a}\\&#39;{\\u a}}&quot; because of the ordgroups.</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  3941 |     });
  3942 |
&gt; 3943 |     it(&quot;should parse accented i&#39;s and j&#39;s&quot;, function() {
       |    ^ Unknown Test
  3944 |         expect&#x60;íȷ́&#x60;.toParseLike(r&#x60;\acute ı\acute ȷ&#x60;, nonstrictSettings);
  3945 |         expect&#x60;ấā́ắ\text{ấā́ắ}&#x60;.toParse(nonstrictSettings);
  3946 |     });</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  3948 |
  3949 | describe(&quot;Unicode&quot;, function() {
&gt; 3950 |     it(&quot;should parse negated relations&quot;, function() {
       |    ^ Unknown Test
  3951 |         expect&#x60;∉∤∦≁≆≠≨≩≮≯≰≱⊀⊁⊈⊉⊊⊋⊬⊭⊮⊯⋠⋡⋦⋧⋨⋩⋬⋭⪇⪈⪉⪊⪵⪶⪹⪺⫋⫌&#x60;.toParse(strictSettings);
  3952 |     });
  3953 |</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  3952 |     });
  3953 |
&gt; 3954 |     it(&quot;should build relations&quot;, function() {
       |    ^ Unknown Test
  3955 |         expect&#x60;∈∋∝∼∽≂≃≅≈≊≍≎≏≐≑≒≓≖≗≜≡≤≥≦≧≪≫≬≳≷≺≻≼≽≾≿∴∵∣≔≕⩴⋘⋙⟂⊨∌&#x60;.toBuild(strictSettings);
  3956 |     });
  3957 |</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  3956 |     });
  3957 |
&gt; 3958 |     it(&quot;should parse relations&quot;, function() {
       |    ^ Unknown Test
  3959 |         &#x2F;&#x2F; These characters are not in the KaTeX fonts. So they build with an error message.
  3960 |         expect&#x60;⊶⊷&#x60;.toParse();
  3961 |     });</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  3961 |     });
  3962 |
&gt; 3963 |     it(&quot;should build big operators&quot;, function() {
       |    ^ Unknown Test
  3964 |         expect&#x60;∏∐∑∫∬∭∮⋀⋁⋂⋃⨀⨁⨂⨄⨆&#x60;.toBuild(strictSettings);
  3965 |     });
  3966 |</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  3965 |     });
  3966 |
&gt; 3967 |     it(&quot;should build more relations&quot;, function() {
       |    ^ Unknown Test
  3968 |         expect&#x60;⊂⊃⊆⊇⊏⊐⊑⊒⊢⊣⊩⊪⊸⋈⋍⋐⋑⋔⋛⋞⋟⌢⌣⩾⪆⪌⪕⪖⪯⪰⪷⪸⫅⫆≘≙≚≛≝≞≟≲⩽⪅≶⋚⪋&#x60;.toBuild(strictSettings);
  3969 |     });
  3970 |</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  3979 |     });
  3980 |
&gt; 3981 |     it(&quot;should build arrows&quot;, function() {
       |    ^ Unknown Test
  3982 |         expect&#x60;←↑→↓↔↕↖↗↘↙↚↛↞↠↢↣↦↩↪↫↬↭↮↰↱↶↷↼↽↾↾↿⇀⇁⇂⇃⇄⇆⇇⇈⇉&#x60;.toBuild(strictSettings);
  3983 |     });
  3984 |</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  3983 |     });
  3984 |
&gt; 3985 |     it(&quot;should build more arrows&quot;, function() {
       |    ^ Unknown Test
  3986 |         expect&#x60;⇊⇋⇌⇍⇎⇏⇐⇑⇒⇓⇔⇕⇚⇛⇝⟵⟶⟷⟸⟹⟺⟼&#x60;.toBuild(strictSettings);
  3987 |     });
  3988 |</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  4069 |
  4070 | describe(&quot;The maxExpand setting&quot;, () &#x3D;&gt; {
&gt; 4071 |     it(&quot;should prevent expansion&quot;, () &#x3D;&gt; {
       |    ^ Unknown Test
  4072 |         expect&#x60;\gdef\foo{1}\foo&#x60;.toParse();
  4073 |         expect&#x60;\gdef\foo{1}\foo&#x60;.toParse(new Settings({maxExpand: 1}));
  4074 |         expect&#x60;\gdef\foo{1}\foo&#x60;.not.toParse(new Settings({maxExpand: 0}));</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  4075 |     });
  4076 |
&gt; 4077 |     it(&quot;should prevent infinite loops&quot;, () &#x3D;&gt; {
       |    ^ Unknown Test
  4078 |         expect&#x60;\gdef\foo{\foo}\foo&#x60;.not.toParse(
  4079 |             new Settings({maxExpand: 10}));
  4080 |     });</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  4080 |     });
  4081 |
&gt; 4082 |     it(&quot;should prevent exponential blowup via \\edef&quot;, () &#x3D;&gt; {
       |    ^ Unknown Test
  4083 |         expect&#x60;\edef0{x}\edef0{00}\edef0{00}\edef0{00}\edef0{00}&#x60;.not.toParse(
  4084 |             new Settings({maxExpand: 10}));
  4085 |     });</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  4131 |
  4132 | describe(&quot;Newlines via \\\\ and \\newline&quot;, function() {
&gt; 4133 |     it(&quot;should build \\\\ without the optional argument and \\newline the same&quot;, () &#x3D;&gt; {
       |    ^ Unknown Test
  4134 |         expect&#x60;hello \\ world&#x60;.toBuildLike&#x60;hello \newline world&#x60;;
  4135 |     });
  4136 |</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  4135 |     });
  4136 |
&gt; 4137 |     it(&quot;should not allow \\newline to scan for an optional size argument&quot;, () &#x3D;&gt; {
       |    ^ Unknown Test
  4138 |         expect&#x60;hello \newline[w]orld&#x60;.toBuild();
  4139 |     });
  4140 |</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  4139 |     });
  4140 |
&gt; 4141 |     it(&quot;should not allow \\cr at top level&quot;, () &#x3D;&gt; {
       |    ^ Unknown Test
  4142 |         expect&#x60;hello \cr world&#x60;.not.toBuild();
  4143 |     });
  4144 |</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  4154 |
  4155 | describe(&quot;Symbols&quot;, function() {
&gt; 4156 |     it(&quot;should parse \\text{\\i\\j}&quot;, () &#x3D;&gt; {
       |    ^ Unknown Test
  4157 |         expect&#x60;\text{\i\j}&#x60;.toBuild(strictSettings);
  4158 |     });
  4159 |</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  4158 |     });
  4159 |
&gt; 4160 |     it(&quot;should parse spacing functions in math or text mode&quot;, () &#x3D;&gt; {
       |    ^ Unknown Test
  4161 |         expect&#x60;A\;B\,C\nobreakspace \text{A\;B\,C\nobreakspace}&#x60;.toBuild(strictSettings);
  4162 |     });
  4163 |</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  4162 |     });
  4163 |
&gt; 4164 |     it(&quot;should build \\minuso&quot;, () &#x3D;&gt; {
       |    ^ Unknown Test
  4165 |         expect&#x60;\\minuso&#x60;.toBuild(strictSettings);
  4166 |     });
  4167 |</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  4166 |     });
  4167 |
&gt; 4168 |     it(&quot;should render ligature commands like their unicode characters&quot;, () &#x3D;&gt; {
       |    ^ Unknown Test
  4169 |         expect&#x60;\text{\ae\AE\oe\OE\o\O\ss}&#x60;.toBuildLike(r&#x60;\text{æÆœŒøØß}&#x60;, strictSettings);
  4170 |     });
  4171 | });</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  4172 |
  4173 | describe(&quot;strict setting&quot;, function() {
&gt; 4174 |     it(&quot;should allow unicode text when not strict&quot;, () &#x3D;&gt; {
       |    ^ Unknown Test
  4175 |         expect&#x60;é&#x60;.toParse(new Settings(nonstrictSettings));
  4176 |         expect&#x60;試&#x60;.toParse(new Settings(nonstrictSettings));
  4177 |         expect&#x60;é&#x60;.toParse(new Settings({strict: &quot;ignore&quot;}));</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  4183 |     });
  4184 |
&gt; 4185 |     it(&quot;should forbid unicode text when strict&quot;, () &#x3D;&gt; {
       |    ^ Unknown Test
  4186 |         expect&#x60;é&#x60;.not.toParse(new Settings({strict: true}));
  4187 |         expect&#x60;試&#x60;.not.toParse(new Settings({strict: true}));
  4188 |         expect&#x60;é&#x60;.not.toParse(new Settings({strict: &quot;error&quot;}));</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  4194 |     });
  4195 |
&gt; 4196 |     it(&quot;should warn about unicode text when default&quot;, () &#x3D;&gt; {
       |    ^ Unknown Test
  4197 |         expect&#x60;é&#x60;.toWarn(new Settings());
  4198 |         expect&#x60;試&#x60;.toWarn(new Settings());
  4199 |     });</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  4199 |     });
  4200 |
&gt; 4201 |     it(&quot;should always allow unicode text in text mode&quot;, () &#x3D;&gt; {
       |    ^ Unknown Test
  4202 |         expect&#x60;\text{é試}&#x60;.toParse(nonstrictSettings);
  4203 |         expect&#x60;\text{é試}&#x60;.toParse(strictSettings);
  4204 |         expect&#x60;\text{é試}&#x60;.toParse();</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  4205 |     });
  4206 |
&gt; 4207 |     it(&quot;should warn about top-level \\newline in display mode&quot;, () &#x3D;&gt; {
       |    ^ Unknown Test
  4208 |         expect&#x60;x\\y&#x60;.toWarn(new Settings({displayMode: true}));
  4209 |         expect&#x60;x\\y&#x60;.toParse(new Settings({displayMode: false}));
  4210 |     });</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  4254 |         }).toThrow(errorMessage);
  4255 |     });
&gt; 4256 |     it(&quot;should add font metrics to metrics map and render successfully&quot;, () &#x3D;&gt; {
       |    ^ Unknown Test
  4257 |         const mockMetrics &#x3D; {};
  4258 |         &#x2F;&#x2F; mock font metrics for the symbols that we added previously
  4259 |         for (let number &#x3D; 0; number &lt;&#x3D; 9; number++) {</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  4290 |
  4291 | describe(&quot;\\relax&quot;, () &#x3D;&gt; {
&gt; 4292 |     it(&quot;should stop the expansion&quot;, () &#x3D;&gt; {
       |    ^ Unknown Test
  4293 |         expect&#x60;\kern2\relax em&#x60;.not.toParse();
  4294 |     });
  4295 | });</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  4296 |
  4297 | describe(&quot;\\emph&quot;, () &#x3D;&gt; {
&gt; 4298 |     it(&quot;should toggle italics&quot;, () &#x3D;&gt; {
       |    ^ Unknown Test
  4299 |         expect&#x60;\emph{foo \emph{bar}}&#x60;.toBuildLike&#x60;\textit{foo \textup{bar}}&#x60;;
  4300 |     });
  4301 |</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  4300 |     });
  4301 |
&gt; 4302 |     it(&quot;should toggle italics within text&quot;, () &#x3D;&gt; {
       |    ^ Unknown Test
  4303 |         expect&#x60;\text{\emph{foo \emph{bar}}}&#x60;.toBuildLike&#x60;\text{\textit{foo \textup{bar}}}&#x60;;
  4304 |     });
  4305 |</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  4304 |     });
  4305 |
&gt; 4306 |     it(&quot;should toggle italics within textup&quot;, () &#x3D;&gt; {
       |    ^ Unknown Test
  4307 |         expect&#x60;\textup{\emph{foo \emph{bar}}}&#x60;.toBuildLike&#x60;\textup{\textit{foo \textup{bar}}}&#x60;;
  4308 |     });
  4309 |</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  4308 |     });
  4309 |
&gt; 4310 |     it(&quot;should toggle italics within textit&quot;, () &#x3D;&gt; {
       |    ^ Unknown Test
  4311 |         expect&#x60;\textit{\emph{foo \emph{bar}}}&#x60;.toBuildLike&#x60;\textit{\textup{foo \textit{bar}}}&#x60;;
  4312 |     });
  4313 | });</code></pre><br>
                      </td>
                    </tr>
                  </tbody>
                </table>
              </td>
            </tr>
            <tr>
              <td>
                <a class="toggle-link" href="javascript:;" onclick="toggleDetails(this)">+ &#x2F;home&#x2F;gabriel&#x2F;Desktop&#x2F;research&#x2F;projects&#x2F;katex&#x2F;test&#x2F;errors-spec.js</a>
              </td>
              <td class="has-text-right">50</td>
            </tr>
            <tr class="details-row hidden">
              <td colspan="2">
                <div class="columns is-multiline is-centered">
                  <div class="column is-one-quarter">
                    <div class="box px-4 py-4">
                      <div class="heading">Physical SLOC</div>
                      <div class="title has-text-weight-light is-size-4">332</div>
                    </div>
                  </div>
                  <div class="column is-one-quarter">
                    <div class="box px-4 py-4">
                      <div class="heading">Logical SLOC</div>
                      <div class="title has-text-weight-light is-size-4">262</div>
                    </div>
                  </div>
                  <div class="column is-one-quarter">
                    <div class="box px-4 py-4">
                      <div class="heading">Cyclomatic</div>
                      <div class="title has-text-weight-light is-size-4">77</div>
                    </div>
                  </div>
                  <div class="column is-one-quarter">
                    <div class="box px-4 py-4">
                      <div class="heading">Cyclomatic Density</div>
                      <div class="title has-text-weight-light is-size-4">29.389</div>
                    </div>
                  </div>
                  <div class="column is-one-quarter">
                    <div class="box px-4 py-4">
                      <div class="heading">Halstead Bugs</div>
                      <div class="title has-text-weight-light is-size-4">1.961</div>
                    </div>
                  </div>
                  <div class="column is-one-quarter">
                    <div class="box px-4 py-4">
                      <div class="heading">Halstead Difficulty</div>
                      <div class="title has-text-weight-light is-size-4">5.692</div>
                    </div>
                  </div>
                  <div class="column is-one-quarter">
                    <div class="box px-4 py-4">
                      <div class="heading">Halstead effort</div>
                      <div class="title has-text-weight-light is-size-4">33481.955</div>
                    </div>
                  </div>
                  <div class="column is-one-quarter">
                    <div class="box px-4 py-4">
                      <div class="heading">Halstead Length</div>
                      <div class="title has-text-weight-light is-size-4">756</div>
                    </div>
                  </div>
                  <div class="column is-one-quarter">
                    <div class="box px-4 py-4">
                      <div class="heading">Halstead Time</div>
                      <div class="title has-text-weight-light is-size-4">1860.109</div>
                    </div>
                  </div>
                  <div class="column is-one-quarter">
                    <div class="box px-4 py-4">
                      <div class="heading">Halstead Vocabulary</div>
                      <div class="title has-text-weight-light is-size-4">220</div>
                    </div>
                  </div>
                  <div class="column is-one-quarter">
                    <div class="box px-4 py-4">
                      <div class="heading">Halstead Volume</div>
                      <div class="title has-text-weight-light is-size-4">5882.708</div>
                    </div>
                  </div>
                  <div class="column is-one-quarter">
                    <div class="box px-4 py-4">
                      <div class="heading">Maintainability</div>
                      <div class="title has-text-weight-light is-size-4">130.386</div>
                    </div>
                  </div>
                </div>
                <hr>
                <table class="table is-fullwidth" id="table-of-smell">
                  <thead>
                    <tr>
                      <td>Redundant Assertion</td>
                    </tr>
                  </thead>
                  <tbody>
                    <tr>
                      <td>
                        <pre><code>  130 |         });
  131 |         it(&quot;complains about mismatched \\verb with end of line&quot;, function() {
&gt; 132 |             expect(&quot;\\verb|hello\nworld|&quot;).toFailWithParseError(
      |            ^ Redundant Assertion
  133 |                 &quot;\\verb ended by end of line instead of matching delimiter&quot;);
  134 |         });
  135 |     });</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  289 |     describe(&quot;#_innerLex&quot;, function() {
  290 |         it(&quot;rejects lone surrogate char&quot;, function() {
&gt; 291 |             expect(&quot;\udcba &quot;).toFailWithParseError(
      |            ^ Redundant Assertion
  292 |                    &quot;Unexpected character: &#39;\udcba&#39; at position 1:&quot; +
  293 |                     &quot; \udcba\u0332 &quot;);
  294 |         });</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  294 |         });
  295 |         it(&quot;rejects lone backslash at end of input&quot;, function() {
&gt; 296 |             expect(&quot;\\&quot;).toFailWithParseError(
      |            ^ Redundant Assertion
  297 |                    &quot;Unexpected character: &#39;\\&#39; at position 1: \\̲&quot;);
  298 |         });
  299 |     });</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  326 | describe(&quot;Unicode accents&quot;, function() {
  327 |     it(&quot;should return error for invalid combining characters&quot;, function() {
&gt; 328 |         expect(&quot;A\u0328&quot;).toFailWithParseError(
      |        ^ Redundant Assertion
  329 |             &quot;Unknown accent &#39; ̨&#39; at position 1: Ą̲̲&quot;);
  330 |     });
  331 | });</code></pre><br>
                      </td>
                    </tr>
                  </tbody>
                </table>
                <hr>
                <table class="table is-fullwidth" id="table-of-smell">
                  <thead>
                    <tr>
                      <td>Unknown Test</td>
                    </tr>
                  </thead>
                  <tbody>
                    <tr>
                      <td>
                        <pre><code>  4 |
  5 |     describe(&quot;#handleInfixNodes&quot;, function() {
&gt; 6 |         it(&quot;rejects repeated infix operators&quot;, function() {
    |        ^ Unknown Test
  7 |             expect&#x60;1\over 2\over 3&#x60;.toFailWithParseError(
  8 |                    &quot;only one infix operator per group at position 9: &quot; +
  9 |                    &quot;1\\over 2\\̲o̲v̲e̲r̲ ̲3&quot;);</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>   9 |                    &quot;1\\over 2\\̲o̲v̲e̲r̲ ̲3&quot;);
  10 |         });
&gt; 11 |         it(&quot;rejects conflicting infix operators&quot;, function() {
     |        ^ Unknown Test
  12 |             expect&#x60;1\over 2\choose 3&#x60;.toFailWithParseError(
  13 |                    &quot;only one infix operator per group at position 9: &quot; +
  14 |                    &quot;1\\over 2\\̲c̲h̲o̲o̲s̲e̲ ̲3&quot;);</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  17 |
  18 |     describe(&quot;#handleSupSubscript&quot;, function() {
&gt; 19 |         it(&quot;rejects ^ at end of group&quot;, function() {
     |        ^ Unknown Test
  20 |             expect&#x60;{1^}&#x60;.toFailWithParseError(
  21 |                    &quot;Expected group after &#39;^&#39; at position 3: {1^̲}&quot;);
  22 |         });</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  21 |                    &quot;Expected group after &#39;^&#39; at position 3: {1^̲}&quot;);
  22 |         });
&gt; 23 |         it(&quot;rejects _ at end of input&quot;, function() {
     |        ^ Unknown Test
  24 |             expect&#x60;1_&#x60;.toFailWithParseError(
  25 |                    &quot;Expected group after &#39;_&#39; at position 2: 1_̲&quot;);
  26 |         });</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  25 |                    &quot;Expected group after &#39;_&#39; at position 2: 1_̲&quot;);
  26 |         });
&gt; 27 |         it(&quot;rejects \\sqrt as argument to ^&quot;, function() {
     |        ^ Unknown Test
  28 |             expect&#x60;1^\sqrt{2}&#x60;.toFailWithParseError(
  29 |                    &quot;Got function &#39;\\sqrt&#39; with no arguments as superscript&quot; +
  30 |                    &quot; at position 3: 1^\\̲s̲q̲r̲t̲{2}&quot;);</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  33 |
  34 |     describe(&quot;#parseAtom&quot;, function() {
&gt; 35 |         it(&quot;rejects \\limits without operator&quot;, function() {
     |        ^ Unknown Test
  36 |             expect&#x60;\alpha\limits\omega&#x60;.toFailWithParseError(
  37 |                    &quot;Limit controls must follow a math operator&quot; +
  38 |                    &quot; at position 7: \\alpha\\̲l̲i̲m̲i̲t̲s̲\\omega&quot;);</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  38 |                    &quot; at position 7: \\alpha\\̲l̲i̲m̲i̲t̲s̲\\omega&quot;);
  39 |         });
&gt; 40 |         it(&quot;rejects \\limits at the beginning of the input&quot;, function() {
     |        ^ Unknown Test
  41 |             expect&#x60;\limits\omega&#x60;.toFailWithParseError(
  42 |                    &quot;Limit controls must follow a math operator&quot; +
  43 |                    &quot; at position 1: \\̲l̲i̲m̲i̲t̲s̲\\omega&quot;);</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  43 |                    &quot; at position 1: \\̲l̲i̲m̲i̲t̲s̲\\omega&quot;);
  44 |         });
&gt; 45 |         it(&quot;rejects double superscripts&quot;, function() {
     |        ^ Unknown Test
  46 |             expect&#x60;1^2^3&#x60;.toFailWithParseError(
  47 |                    &quot;Double superscript at position 4: 1^2^̲3&quot;);
  48 |             expect&#x60;1^{2+3}_4^5&#x60;.toFailWithParseError(</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  49 |                    &quot;Double superscript at position 10: 1^{2+3}_4^̲5&quot;);
  50 |         });
&gt; 51 |         it(&quot;rejects double superscripts involving primes&quot;, function() {
     |        ^ Unknown Test
  52 |             expect&#x60;1&#39;_2^3&#x60;.toFailWithParseError(
  53 |                    &quot;Double superscript at position 5: 1&#39;_2^̲3&quot;);
  54 |             expect&#x60;1^2&#39;&#x60;.toFailWithParseError(</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  59 |                    &quot;Double superscript at position 5: 1&#39;_2&#39;̲&quot;);
  60 |         });
&gt; 61 |         it(&quot;rejects double subscripts&quot;, function() {
     |        ^ Unknown Test
  62 |             expect&#x60;1_2_3&#x60;.toFailWithParseError(
  63 |                    &quot;Double subscript at position 4: 1_2_̲3&quot;);
  64 |             expect&#x60;1_{2+3}^4_5&#x60;.toFailWithParseError(</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  68 |
  69 |     describe(&quot;#parseImplicitGroup&quot;, function() {
&gt; 70 |         it(&quot;reports unknown environments&quot;, function() {
     |        ^ Unknown Test
  71 |             expect&#x60;\begin{foo}bar\end{foo}&#x60;.toFailWithParseError(
  72 |                    &quot;No such environment: foo at position 7:&quot; +
  73 |                    &quot; \\begin{̲f̲o̲o̲}̲bar\\end{foo}&quot;);</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  73 |                    &quot; \\begin{̲f̲o̲o̲}̲bar\\end{foo}&quot;);
  74 |         });
&gt; 75 |         it(&quot;reports mismatched environments&quot;, function() {
     |        ^ Unknown Test
  76 |             expect&#x60;\begin{pmatrix}1&amp;2\\3&amp;4\end{bmatrix}+5&#x60;
  77 |                 .toFailWithParseError(
  78 |                    &quot;Mismatch: \\begin{pmatrix} matched by \\end{bmatrix}&quot; +</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  82 |
  83 |     describe(&quot;#parseFunction&quot;, function() {
&gt; 84 |         it(&quot;rejects math-mode functions in text mode&quot;, function() {
     |        ^ Unknown Test
  85 |             expect&#x60;\text{\sqrt2 is irrational}&#x60;.toFailWithParseError(
  86 |                 &quot;Can&#39;t use function &#39;\\sqrt&#39; in text mode&quot; +
  87 |                 &quot; at position 7: \\text{\\̲s̲q̲r̲t̲2 is irrational…&quot;);</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  87 |                 &quot; at position 7: \\text{\\̲s̲q̲r̲t̲2 is irrational…&quot;);
  88 |         });
&gt; 89 |         it(&quot;rejects text-mode-only functions in math mode&quot;, () &#x3D;&gt; {
     |        ^ Unknown Test
  90 |             expect&#x60;$&#x60;.toFailWithParseError(
  91 |                 &quot;Can&#39;t use function &#39;$&#39; in math mode at position 1: $̲&quot;);
  92 |         });</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  91 |                 &quot;Can&#39;t use function &#39;$&#39; in math mode at position 1: $̲&quot;);
  92 |         });
&gt; 93 |         it(&quot;rejects strict-mode text-mode-only functions in math mode&quot;, () &#x3D;&gt; {
     |        ^ Unknown Test
  94 |             expect&#x60;\&#39;echec&#x60;.toFailWithParseError(&quot;LaTeX-incompatible input &quot; +
  95 |                 &quot;and strict mode is set to &#39;error&#39;: LaTeX&#39;s accent \\&#39; works &quot; +
  96 |                 &quot;only in text mode [mathVsTextAccents]&quot;, strictSettings);</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>   99 |
  100 |     describe(&quot;#parseArguments&quot;, function() {
&gt; 101 |         it(&quot;complains about missing argument at end of input&quot;, function() {
      |        ^ Unknown Test
  102 |             expect&#x60;2\sqrt&#x60;.toFailWithParseError(
  103 |                    &quot;Expected group as argument to &#39;\\sqrt&#39;&quot; +
  104 |                    &quot; at end of input: 2\\sqrt&quot;);</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  104 |                    &quot; at end of input: 2\\sqrt&quot;);
  105 |         });
&gt; 106 |         it(&quot;complains about missing argument at end of group&quot;, function() {
      |        ^ Unknown Test
  107 |             expect&#x60;1^{2\sqrt}&#x60;.toFailWithParseError(
  108 |                    &quot;Expected group as argument to &#39;\\sqrt&#39;&quot; +
  109 |                    &quot; at position 10: 1^{2\\sqrt}̲&quot;);</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  109 |                    &quot; at position 10: 1^{2\\sqrt}̲&quot;);
  110 |         });
&gt; 111 |         it(&quot;complains about functions as arguments to others&quot;, function() {
      |        ^ Unknown Test
  112 |             expect&#x60;\sqrt\over2&#x60;.toFailWithParseError(
  113 |                    &quot;Got function &#39;\\over&#39; with no arguments as argument to&quot; +
  114 |                    &quot; &#39;\\sqrt&#39; at position 6: \\sqrt\\̲o̲v̲e̲r̲2&quot;);</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  117 |
  118 |     describe(&quot;#parseGroup&quot;, function() {
&gt; 119 |         it(&quot;complains about undefined control sequence&quot;, function() {
      |        ^ Unknown Test
  120 |             expect&#x60;\xyz&#x60;.toFailWithParseError(
  121 |                    &quot;Undefined control sequence: \\xyz&quot; +
  122 |                    &quot; at position 1: \\̲x̲y̲z̲&quot;);</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  125 |
  126 |     describe(&quot;#verb&quot;, function() {
&gt; 127 |         it(&quot;complains about mismatched \\verb with end of string&quot;, function() {
      |        ^ Unknown Test
  128 |             expect&#x60;\verb|hello&#x60;.toFailWithParseError(
  129 |                 &quot;\\verb ended by end of line instead of matching delimiter&quot;);
  130 |         });</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  140 |
  141 |     describe(&quot;#parseInput expecting EOF&quot;, function() {
&gt; 142 |         it(&quot;complains about extra }&quot;, function() {
      |        ^ Unknown Test
  143 |             expect&#x60;{1+2}}&#x60;.toFailWithParseError(
  144 |                    &quot;Expected &#39;EOF&#39;, got &#39;}&#39; at position 6: {1+2}}̲&quot;);
  145 |         });</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  144 |                    &quot;Expected &#39;EOF&#39;, got &#39;}&#39; at position 6: {1+2}}̲&quot;);
  145 |         });
&gt; 146 |         it(&quot;complains about extra \\end&quot;, function() {
      |        ^ Unknown Test
  147 |             expect&#x60;x\end{matrix}&#x60;.toFailWithParseError(
  148 |                    &quot;Expected &#39;EOF&#39;, got &#39;\\end&#39; at position 2:&quot; +
  149 |                    &quot; x\\̲e̲n̲d̲{matrix}&quot;);</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  149 |                    &quot; x\\̲e̲n̲d̲{matrix}&quot;);
  150 |         });
&gt; 151 |         it(&quot;complains about top-level &amp;&quot;, function() {
      |        ^ Unknown Test
  152 |             expect&#x60;1&amp;2&#x60;.toFailWithParseError(
  153 |                    &quot;Expected &#39;EOF&#39;, got &#39;&amp;&#39; at position 2: 1&amp;̲2&quot;);
  154 |         });</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  156 |
  157 |     describe(&quot;#parseImplicitGroup expecting \\right&quot;, function() {
&gt; 158 |         it(&quot;rejects missing \\right&quot;, function() {
      |        ^ Unknown Test
  159 |             expect&#x60;\left(1+2)&#x60;.toFailWithParseError(
  160 |                    &quot;Expected &#39;\\right&#39;, got &#39;EOF&#39; at end of input:&quot; +
  161 |                    &quot; \\left(1+2)&quot;);</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  161 |                    &quot; \\left(1+2)&quot;);
  162 |         });
&gt; 163 |         it(&quot;rejects incorrectly scoped \\right&quot;, function() {
      |        ^ Unknown Test
  164 |             expect&#x60;{\left(1+2}\right)&#x60;.toFailWithParseError(
  165 |                    &quot;Expected &#39;\\right&#39;, got &#39;}&#39; at position 11:&quot; +
  166 |                    &quot; {\\left(1+2}̲\\right)&quot;);</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  172 |
  173 |     describe(&quot;#parseSpecialGroup expecting braces&quot;, function() {
&gt; 174 |         it(&quot;complains about missing { for color&quot;, function() {
      |        ^ Unknown Test
  175 |             expect&#x60;\textcolor#ffffff{text}&#x60;.toFailWithParseError(
  176 |                    &quot;Invalid color: &#39;#&#39; at position 11:&quot; +
  177 |                    &quot; \\textcolor#̲ffffff{text}&quot;);</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  177 |                    &quot; \\textcolor#̲ffffff{text}&quot;);
  178 |         });
&gt; 179 |         it(&quot;complains about missing { for size&quot;, function() {
      |        ^ Unknown Test
  180 |             expect&#x60;\rule{1em}[2em]&#x60;.toFailWithParseError(
  181 |                    &quot;Invalid size: &#39;[&#39; at position 11: \\rule{1em}[̲2em]&quot;);
  182 |         });</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  182 |         });
  183 |         &#x2F;&#x2F; Can&#39;t test for the [ of an optional group since it&#39;s optional
&gt; 184 |         it(&quot;complains about missing } for color&quot;, function() {
      |        ^ Unknown Test
  185 |             expect&#x60;\textcolor{#ffffff{text}&#x60;.toFailWithParseError(
  186 |                    &quot;Unexpected end of input in a macro argument,&quot; +
  187 |                    &quot; expected &#39;}&#39; at end of input: …r{#ffffff{text}&quot;);</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  187 |                    &quot; expected &#39;}&#39; at end of input: …r{#ffffff{text}&quot;);
  188 |         });
&gt; 189 |         it(&quot;complains about missing ] for size&quot;, function() {
      |        ^ Unknown Test
  190 |             expect&#x60;\rule[1em{2em}{3em}&#x60;.toFailWithParseError(
  191 |                    &quot;Unexpected end of input in a macro argument,&quot; +
  192 |                    &quot; expected &#39;]&#39; at end of input: …e[1em{2em}{3em}&quot;);</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  192 |                    &quot; expected &#39;]&#39; at end of input: …e[1em{2em}{3em}&quot;);
  193 |         });
&gt; 194 |         it(&quot;complains about missing ] for size at end of input&quot;, function() {
      |        ^ Unknown Test
  195 |             expect&#x60;\rule[1em&#x60;.toFailWithParseError(
  196 |                    &quot;Unexpected end of input in a macro argument,&quot; +
  197 |                    &quot; expected &#39;]&#39; at end of input: \\rule[1em&quot;);</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  197 |                    &quot; expected &#39;]&#39; at end of input: \\rule[1em&quot;);
  198 |         });
&gt; 199 |         it(&quot;complains about missing } for color at end of input&quot;, function() {
      |        ^ Unknown Test
  200 |             expect&#x60;\textcolor{#123456&#x60;.toFailWithParseError(
  201 |                    &quot;Unexpected end of input in a macro argument,&quot; +
  202 |                    &quot; expected &#39;}&#39; at end of input: …xtcolor{#123456&quot;);</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  205 |
  206 |     describe(&quot;#parseGroup expecting }&quot;, function() {
&gt; 207 |         it(&quot;at end of file&quot;, function() {
      |        ^ Unknown Test
  208 |             expect&#x60;\sqrt{2&#x60;.toFailWithParseError(
  209 |                    &quot;Expected &#39;}&#39;, got &#39;EOF&#39; at end of input: \\sqrt{2&quot;);
  210 |         });</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  212 |
  213 |     describe(&quot;#parseOptionalGroup expecting ]&quot;, function() {
&gt; 214 |         it(&quot;at end of file&quot;, function() {
      |        ^ Unknown Test
  215 |             expect&#x60;\sqrt[3&#x60;.toFailWithParseError(
  216 |                    &quot;Unexpected end of input in a macro argument,&quot; +
  217 |                    &quot; expected &#39;]&#39; at end of input: \\sqrt[3&quot;);</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  217 |                    &quot; expected &#39;]&#39; at end of input: \\sqrt[3&quot;);
  218 |         });
&gt; 219 |         it(&quot;before group&quot;, function() {
      |        ^ Unknown Test
  220 |             expect&#x60;\sqrt[3{2}&#x60;.toFailWithParseError(
  221 |                    &quot;Unexpected end of input in a macro argument,&quot; +
  222 |                    &quot; expected &#39;]&#39; at end of input: \\sqrt[3{2}&quot;);</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  229 |
  230 |     describe(&quot;parseArray&quot;, function() {
&gt; 231 |         it(&quot;rejects missing \\end&quot;, function() {
      |        ^ Unknown Test
  232 |             expect&#x60;\begin{matrix}1&#x60;.toFailWithParseError(
  233 |                    &quot;Expected &amp; or \\\\ or \\cr or \\end at end of input:&quot; +
  234 |                    &quot; \\begin{matrix}1&quot;);</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  234 |                    &quot; \\begin{matrix}1&quot;);
  235 |         });
&gt; 236 |         it(&quot;rejects incorrectly scoped \\end&quot;, function() {
      |        ^ Unknown Test
  237 |             expect&#x60;{\begin{matrix}1}\end{matrix}&#x60;.toFailWithParseError(
  238 |                    &quot;Expected &amp; or \\\\ or \\cr or \\end at position 17:&quot; +
  239 |                    &quot; …\\begin{matrix}1}̲\\end{matrix}&quot;);</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  242 |
  243 |     describe(&quot;array environment&quot;, function() {
&gt; 244 |         it(&quot;rejects unknown column types&quot;, function() {
      |        ^ Unknown Test
  245 |             expect&#x60;\begin{array}{cba}\end{array}&#x60;.toFailWithParseError(
  246 |                    &quot;Unknown column alignment: b at position 16:&quot; +
  247 |                    &quot; \\begin{array}{cb̲a}\\end{array}&quot;);</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  254 |
  255 |     describe(&quot;delimiter functions&quot;, function() {
&gt; 256 |         it(&quot;reject invalid opening delimiters&quot;, function() {
      |        ^ Unknown Test
  257 |             expect&#x60;\bigl 1 + 2 \bigr&#x60;.toFailWithParseError(
  258 |                    &quot;Invalid delimiter &#39;1&#39; after &#39;\\bigl&#39; at position 7:&quot; +
  259 |                    &quot; \\bigl 1̲ + 2 \\bigr&quot;);</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  259 |                    &quot; \\bigl 1̲ + 2 \\bigr&quot;);
  260 |         });
&gt; 261 |         it(&quot;reject invalid closing delimiters&quot;, function() {
      |        ^ Unknown Test
  262 |             expect&#x60;\bigl(1+2\bigr&#x3D;3&#x60;.toFailWithParseError(
  263 |                    &quot;Invalid delimiter &#39;&#x3D;&#39; after &#39;\\bigr&#39; at position 15:&quot; +
  264 |                    &quot; \\bigl(1+2\\bigr&#x3D;̲3&quot;);</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  264 |                    &quot; \\bigl(1+2\\bigr&#x3D;̲3&quot;);
  265 |         });
&gt; 266 |         it(&quot;reject group opening delimiters&quot;, function() {
      |        ^ Unknown Test
  267 |             expect&#x60;\bigl{(}1+2\bigr)3&#x60;.toFailWithParseError(
  268 |                    &quot;Invalid delimiter type &#39;ordgroup&#39; at position 6:&quot; +
  269 |                    &quot; \\bigl{̲(̲}̲1+2\\bigr)3&quot;);</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  269 |                    &quot; \\bigl{̲(̲}̲1+2\\bigr)3&quot;);
  270 |         });
&gt; 271 |         it(&quot;reject group closing delimiters&quot;, function() {
      |        ^ Unknown Test
  272 |             expect&#x60;\bigl(1+2\bigr{)}3&#x60;.toFailWithParseError(
  273 |                    &quot;Invalid delimiter type &#39;ordgroup&#39; at position 15:&quot; +
  274 |                    &quot; \\bigl(1+2\\bigr{̲)̲}̲3&quot;);</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  277 |
  278 |     describe(&quot;\\begin and \\end&quot;, function() {
&gt; 279 |         it(&quot;reject invalid environment names&quot;, function() {
      |        ^ Unknown Test
  280 |             expect&#x60;\begin x\end y&#x60;.toFailWithParseError(
  281 |                    &quot;No such environment: x at position 8: \\begin x̲\\end y&quot;);
  282 |         });</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  300 |
  301 |     describe(&quot;#_innerLexColor&quot;, function() {
&gt; 302 |         it(&quot;reject 3-digit hex notation without #&quot;, function() {
      |        ^ Unknown Test
  303 |             expect&#x60;\textcolor{1a2}{foo}&#x60;.toFailWithParseError(
  304 |                    &quot;Invalid color: &#39;1a2&#39;&quot; +
  305 |                    &quot; at position 11: \\textcolor{̲1̲a̲2̲}̲{foo}&quot;);</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  308 |
  309 |     describe(&quot;#_innerLexSize&quot;, function() {
&gt; 310 |         it(&quot;reject size without unit&quot;, function() {
      |        ^ Unknown Test
  311 |             expect&#x60;\rule{0}{2em}&#x60;.toFailWithParseError(
  312 |                    &quot;Invalid size: &#39;0&#39; at position 6: \\rule{̲0̲}̲{2em}&quot;);
  313 |         });</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  312 |                    &quot;Invalid size: &#39;0&#39; at position 6: \\rule{̲0̲}̲{2em}&quot;);
  313 |         });
&gt; 314 |         it(&quot;reject size with bogus unit&quot;, function() {
      |        ^ Unknown Test
  315 |             expect&#x60;\rule{1au}{2em}&#x60;.toFailWithParseError(
  316 |                    &quot;Invalid unit: &#39;au&#39; at position 6: \\rule{̲1̲a̲u̲}̲{2em}&quot;);
  317 |         });</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  316 |                    &quot;Invalid unit: &#39;au&#39; at position 6: \\rule{̲1̲a̲u̲}̲{2em}&quot;);
  317 |         });
&gt; 318 |         it(&quot;reject size without number&quot;, function() {
      |        ^ Unknown Test
  319 |             expect&#x60;\rule{em}{2em}&#x60;.toFailWithParseError(
  320 |                    &quot;Invalid size: &#39;em&#39; at position 6: \\rule{̲e̲m̲}̲{2em}&quot;);
  321 |         });</code></pre><br>
                      </td>
                    </tr>
                  </tbody>
                </table>
              </td>
            </tr>
            <tr>
              <td>
                <a class="toggle-link" href="javascript:;" onclick="toggleDetails(this)">+ &#x2F;home&#x2F;gabriel&#x2F;Desktop&#x2F;research&#x2F;projects&#x2F;katex&#x2F;test&#x2F;dup-spec.js</a>
              </td>
              <td class="has-text-right">4</td>
            </tr>
            <tr class="details-row hidden">
              <td colspan="2">
                <div class="columns is-multiline is-centered">
                  <div class="column is-one-quarter">
                    <div class="box px-4 py-4">
                      <div class="heading">Physical SLOC</div>
                      <div class="title has-text-weight-light is-size-4">19</div>
                    </div>
                  </div>
                  <div class="column is-one-quarter">
                    <div class="box px-4 py-4">
                      <div class="heading">Logical SLOC</div>
                      <div class="title has-text-weight-light is-size-4">14</div>
                    </div>
                  </div>
                  <div class="column is-one-quarter">
                    <div class="box px-4 py-4">
                      <div class="heading">Cyclomatic</div>
                      <div class="title has-text-weight-light is-size-4">5</div>
                    </div>
                  </div>
                  <div class="column is-one-quarter">
                    <div class="box px-4 py-4">
                      <div class="heading">Cyclomatic Density</div>
                      <div class="title has-text-weight-light is-size-4">35.714</div>
                    </div>
                  </div>
                  <div class="column is-one-quarter">
                    <div class="box px-4 py-4">
                      <div class="heading">Halstead Bugs</div>
                      <div class="title has-text-weight-light is-size-4">0.069</div>
                    </div>
                  </div>
                  <div class="column is-one-quarter">
                    <div class="box px-4 py-4">
                      <div class="heading">Halstead Difficulty</div>
                      <div class="title has-text-weight-light is-size-4">9.625</div>
                    </div>
                  </div>
                  <div class="column is-one-quarter">
                    <div class="box px-4 py-4">
                      <div class="heading">Halstead effort</div>
                      <div class="title has-text-weight-light is-size-4">2002.807</div>
                    </div>
                  </div>
                  <div class="column is-one-quarter">
                    <div class="box px-4 py-4">
                      <div class="heading">Halstead Length</div>
                      <div class="title has-text-weight-light is-size-4">46</div>
                    </div>
                  </div>
                  <div class="column is-one-quarter">
                    <div class="box px-4 py-4">
                      <div class="heading">Halstead Time</div>
                      <div class="title has-text-weight-light is-size-4">111.267</div>
                    </div>
                  </div>
                  <div class="column is-one-quarter">
                    <div class="box px-4 py-4">
                      <div class="heading">Halstead Vocabulary</div>
                      <div class="title has-text-weight-light is-size-4">23</div>
                    </div>
                  </div>
                  <div class="column is-one-quarter">
                    <div class="box px-4 py-4">
                      <div class="heading">Halstead Volume</div>
                      <div class="title has-text-weight-light is-size-4">208.084</div>
                    </div>
                  </div>
                  <div class="column is-one-quarter">
                    <div class="box px-4 py-4">
                      <div class="heading">Maintainability</div>
                      <div class="title has-text-weight-light is-size-4">123.291</div>
                    </div>
                  </div>
                </div>
                <hr>
                <table class="table is-fullwidth" id="table-of-smell">
                  <thead>
                    <tr>
                      <td>Conditional Test Logic</td>
                    </tr>
                  </thead>
                  <tbody>
                    <tr>
                      <td>
                        <pre><code>  3 |
  4 | describe(&quot;Symbols and macros&quot;, () &#x3D;&gt; {
&gt; 5 |     for (const macro in macros) {
    |    ^ Conditional Test Logic
  6 |         if (!macros.hasOwnProperty(macro)) {
  7 |             continue;
  8 |         }</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  4 | describe(&quot;Symbols and macros&quot;, () &#x3D;&gt; {
  5 |     for (const macro in macros) {
&gt; 6 |         if (!macros.hasOwnProperty(macro)) {
    |        ^ Conditional Test Logic
  7 |             continue;
  8 |         }
  9 |         it(&#x60;macro ${macro} should not shadow a symbol&#x60;, () &#x3D;&gt; {</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>   8 |         }
   9 |         it(&#x60;macro ${macro} should not shadow a symbol&#x60;, () &#x3D;&gt; {
&gt; 10 |             for (const kind in symbols) {
     |            ^ Conditional Test Logic
  11 |                 if (!symbols.hasOwnProperty(kind)) {
  12 |                     continue;
  13 |                 }</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>   9 |         it(&#x60;macro ${macro} should not shadow a symbol&#x60;, () &#x3D;&gt; {
  10 |             for (const kind in symbols) {
&gt; 11 |                 if (!symbols.hasOwnProperty(kind)) {
     |                ^ Conditional Test Logic
  12 |                     continue;
  13 |                 }
  14 |                 expect(symbols[kind][macro]).toBeFalsy();</code></pre><br>
                      </td>
                    </tr>
                  </tbody>
                </table>
              </td>
            </tr>
            <tr>
              <td>
                <a class="toggle-link" href="javascript:;" onclick="toggleDetails(this)">+ &#x2F;home&#x2F;gabriel&#x2F;Desktop&#x2F;research&#x2F;projects&#x2F;katex&#x2F;contrib&#x2F;auto-render&#x2F;test&#x2F;auto-render-spec.js</a>
              </td>
              <td class="has-text-right">23</td>
            </tr>
            <tr class="details-row hidden">
              <td colspan="2">
                <div class="columns is-multiline is-centered">
                  <div class="column is-one-quarter">
                    <div class="box px-4 py-4">
                      <div class="heading">Physical SLOC</div>
                      <div class="title has-text-weight-light is-size-4">364</div>
                    </div>
                  </div>
                  <div class="column is-one-quarter">
                    <div class="box px-4 py-4">
                      <div class="heading">Logical SLOC</div>
                      <div class="title has-text-weight-light is-size-4">406</div>
                    </div>
                  </div>
                  <div class="column is-one-quarter">
                    <div class="box px-4 py-4">
                      <div class="heading">Cyclomatic</div>
                      <div class="title has-text-weight-light is-size-4">37</div>
                    </div>
                  </div>
                  <div class="column is-one-quarter">
                    <div class="box px-4 py-4">
                      <div class="heading">Cyclomatic Density</div>
                      <div class="title has-text-weight-light is-size-4">9.113</div>
                    </div>
                  </div>
                  <div class="column is-one-quarter">
                    <div class="box px-4 py-4">
                      <div class="heading">Halstead Bugs</div>
                      <div class="title has-text-weight-light is-size-4">3.648</div>
                    </div>
                  </div>
                  <div class="column is-one-quarter">
                    <div class="box px-4 py-4">
                      <div class="heading">Halstead Difficulty</div>
                      <div class="title has-text-weight-light is-size-4">53.951</div>
                    </div>
                  </div>
                  <div class="column is-one-quarter">
                    <div class="box px-4 py-4">
                      <div class="heading">Halstead effort</div>
                      <div class="title has-text-weight-light is-size-4">590423.74</div>
                    </div>
                  </div>
                  <div class="column is-one-quarter">
                    <div class="box px-4 py-4">
                      <div class="heading">Halstead Length</div>
                      <div class="title has-text-weight-light is-size-4">1472</div>
                    </div>
                  </div>
                  <div class="column is-one-quarter">
                    <div class="box px-4 py-4">
                      <div class="heading">Halstead Time</div>
                      <div class="title has-text-weight-light is-size-4">32801.319</div>
                    </div>
                  </div>
                  <div class="column is-one-quarter">
                    <div class="box px-4 py-4">
                      <div class="heading">Halstead Vocabulary</div>
                      <div class="title has-text-weight-light is-size-4">173</div>
                    </div>
                  </div>
                  <div class="column is-one-quarter">
                    <div class="box px-4 py-4">
                      <div class="heading">Halstead Volume</div>
                      <div class="title has-text-weight-light is-size-4">10943.773</div>
                    </div>
                  </div>
                  <div class="column is-one-quarter">
                    <div class="box px-4 py-4">
                      <div class="heading">Maintainability</div>
                      <div class="title has-text-weight-light is-size-4">93.349</div>
                    </div>
                  </div>
                </div>
                <hr>
                <table class="table is-fullwidth" id="table-of-smell">
                  <thead>
                    <tr>
                      <td>Conditional Test Logic</td>
                    </tr>
                  </thead>
                  <tbody>
                    <tr>
                      <td>
                        <pre><code>  16 |                   splitAtDelimiters(actual, delimiters);
  17 |
&gt; 18 |             if (split.length !&#x3D;&#x3D; result.length) {
     |            ^ Conditional Test Logic
  19 |                 message.pass &#x3D; false;
  20 |                 message.message &#x3D; () &#x3D;&gt; &quot;Different number of splits: &quot; +
  21 |                     split.length + &quot; vs. &quot; + result.length + &quot; (&quot; +</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  25 |             }
  26 |
&gt; 27 |             for (let i &#x3D; 0; i &lt; split.length; i++) {
     |            ^ Conditional Test Logic
  28 |                 const real &#x3D; split[i];
  29 |                 const correct &#x3D; result[i];
  30 |</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  32 |                 let diff;
  33 |
&gt; 34 |                 if (real.type !&#x3D;&#x3D; correct.type) {
     |                ^ Conditional Test Logic
  35 |                     good &#x3D; false;
  36 |                     diff &#x3D; &quot;type&quot;;
  37 |                 } else if (real.data !&#x3D;&#x3D; correct.data) {</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  35 |                     good &#x3D; false;
  36 |                     diff &#x3D; &quot;type&quot;;
&gt; 37 |                 } else if (real.data !&#x3D;&#x3D; correct.data) {
     |                       ^ Conditional Test Logic
  38 |                     good &#x3D; false;
  39 |                     diff &#x3D; &quot;data&quot;;
  40 |                 } else if (real.display !&#x3D;&#x3D; correct.display) {</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  38 |                     good &#x3D; false;
  39 |                     diff &#x3D; &quot;data&quot;;
&gt; 40 |                 } else if (real.display !&#x3D;&#x3D; correct.display) {
     |                       ^ Conditional Test Logic
  41 |                     good &#x3D; false;
  42 |                     diff &#x3D; &quot;display&quot;;
  43 |                 }</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  43 |                 }
  44 |
&gt; 45 |                 if (!good) {
     |                ^ Conditional Test Logic
  46 |                     message.pass &#x3D; false;
  47 |                     message.message &#x3D; () &#x3D;&gt; &quot;Difference at split &quot; +
  48 |                         (i + 1) + &quot;: &quot; + JSON.stringify(real) +</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  330 |             &#39;\\]&#39;];
  331 |         const el &#x3D; document.createElement(&#39;div&#39;);
&gt; 332 |         for (let i &#x3D; 0; i &lt; textNodes.length; i++) {
      |        ^ Conditional Test Logic
  333 |             const txt &#x3D; document.createTextNode(textNodes[i]);
  334 |             el.appendChild(txt);
  335 |         }</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  348 |             &#39;consectetur adipiscing elit&#39;];
  349 |         const el &#x3D; document.createElement(&#39;div&#39;);
&gt; 350 |         for (let i &#x3D; 0; i &lt; textNodes.length; i++) {
      |        ^ Conditional Test Logic
  351 |             const txt &#x3D; document.createTextNode(textNodes[i]);
  352 |             el.appendChild(txt);
  353 |         }</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  353 |         }
  354 |         const el2 &#x3D; document.createElement(&#39;div&#39;);
&gt; 355 |         for (let i &#x3D; 0; i &lt; textNodes.length; i++) {
      |        ^ Conditional Test Logic
  356 |             const txt &#x3D; document.createTextNode(textNodes[i]);
  357 |             el2.appendChild(txt);
  358 |         }</code></pre><br>
                      </td>
                    </tr>
                  </tbody>
                </table>
                <hr>
                <table class="table is-fullwidth" id="table-of-smell">
                  <thead>
                    <tr>
                      <td>Redundant Assertion</td>
                    </tr>
                  </thead>
                  <tbody>
                    <tr>
                      <td>
                        <pre><code>  60 | describe(&quot;A delimiter splitter&quot;, function() {
  61 |     it(&quot;doesn&#39;t split when there are no delimiters&quot;, function() {
&gt; 62 |         expect(&quot;hello&quot;).toSplitInto(
     |        ^ Redundant Assertion
  63 |             [
  64 |                 {type: &quot;text&quot;, data: &quot;hello&quot;},
  65 |             ],</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  70 |
  71 |     it(&quot;doesn&#39;t create a math node with only one left delimiter&quot;, function() {
&gt; 72 |         expect(&quot;hello ( world&quot;).toSplitInto(
     |        ^ Redundant Assertion
  73 |             [
  74 |                 {type: &quot;text&quot;, data: &quot;hello &quot;},
  75 |                 {type: &quot;text&quot;, data: &quot;( world&quot;},</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  81 |
  82 |     it(&quot;doesn&#39;t split when there&#39;s only a right delimiter&quot;, function() {
&gt; 83 |         expect(&quot;hello ) world&quot;).toSplitInto(
     |        ^ Redundant Assertion
  84 |             [
  85 |                 {type: &quot;text&quot;, data: &quot;hello ) world&quot;},
  86 |             ],</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  91 |
  92 |     it(&quot;splits when there are both delimiters&quot;, function() {
&gt; 93 |         expect(&quot;hello ( world ) boo&quot;).toSplitInto(
     |        ^ Redundant Assertion
  94 |             [
  95 |                 {type: &quot;text&quot;, data: &quot;hello &quot;},
  96 |                 {type: &quot;math&quot;, data: &quot; world &quot;,</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  104 |
  105 |     it(&quot;splits on multi-character delimiters&quot;, function() {
&gt; 106 |         expect(&quot;hello [[ world ]] boo&quot;).toSplitInto(
      |        ^ Redundant Assertion
  107 |             [
  108 |                 {type: &quot;text&quot;, data: &quot;hello &quot;},
  109 |                 {type: &quot;math&quot;, data: &quot; world &quot;,</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  114 |                 {left: &quot;[[&quot;, right: &quot;]]&quot;, display: false},
  115 |             ]);
&gt; 116 |         expect(&quot;hello \\begin{equation} world \\end{equation} boo&quot;).toSplitInto(
      |        ^ Redundant Assertion
  117 |             [
  118 |                 {type: &quot;text&quot;, data: &quot;hello &quot;},
  119 |                 {type: &quot;math&quot;, data: &quot;\\begin{equation} world \\end{equation}&quot;,</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  129 |
  130 |     it(&quot;splits multiple times&quot;, function() {
&gt; 131 |         expect(&quot;hello ( world ) boo ( more ) stuff&quot;).toSplitInto(
      |        ^ Redundant Assertion
  132 |             [
  133 |                 {type: &quot;text&quot;, data: &quot;hello &quot;},
  134 |                 {type: &quot;math&quot;, data: &quot; world &quot;,</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  145 |
  146 |     it(&quot;leaves the ending when there&#39;s only a left delimiter&quot;, function() {
&gt; 147 |         expect(&quot;hello ( world ) boo ( left&quot;).toSplitInto(
      |        ^ Redundant Assertion
  148 |             [
  149 |                 {type: &quot;text&quot;, data: &quot;hello &quot;},
  150 |                 {type: &quot;math&quot;, data: &quot; world &quot;,</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  159 |
  160 |     it(&quot;doesn&#39;t split when close delimiters are in {}s&quot;, function() {
&gt; 161 |         expect(&quot;hello ( world { ) } ) boo&quot;).toSplitInto(
      |        ^ Redundant Assertion
  162 |             [
  163 |                 {type: &quot;text&quot;, data: &quot;hello &quot;},
  164 |                 {type: &quot;math&quot;, data: &quot; world { ) } &quot;,</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  170 |             ]);
  171 |
&gt; 172 |         expect(&quot;hello ( world { { } ) } ) boo&quot;).toSplitInto(
      |        ^ Redundant Assertion
  173 |             [
  174 |                 {type: &quot;text&quot;, data: &quot;hello &quot;},
  175 |                 {type: &quot;math&quot;, data: &quot; world { { } ) } &quot;,</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  183 |
  184 |     it(&quot;correctly processes sequences of $..$&quot;, function() {
&gt; 185 |         expect(&quot;$hello$$world$$boo$&quot;).toSplitInto(
      |        ^ Redundant Assertion
  186 |             [
  187 |                 {type: &quot;math&quot;, data: &quot;hello&quot;,
  188 |                     rawData: &quot;$hello$&quot;, display: false},</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  198 |
  199 |     it(&quot;doesn&#39;t split at escaped delimiters&quot;, function() {
&gt; 200 |         expect(&quot;hello ( world \\) ) boo&quot;).toSplitInto(
      |        ^ Redundant Assertion
  201 |             [
  202 |                 {type: &quot;text&quot;, data: &quot;hello &quot;},
  203 |                 {type: &quot;math&quot;, data: &quot; world \\) &quot;,</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  222 |
  223 |     it(&quot;splits when the right and left delimiters are the same&quot;, function() {
&gt; 224 |         expect(&quot;hello $ world $ boo&quot;).toSplitInto(
      |        ^ Redundant Assertion
  225 |             [
  226 |                 {type: &quot;text&quot;, data: &quot;hello &quot;},
  227 |                 {type: &quot;math&quot;, data: &quot; world &quot;,</code></pre><br>
                      </td>
                    </tr>
                    <tr>
                      <td>
                        <pre><code>  235 |
  236 |     it(&quot;ignores \\$&quot;, function() {
&gt; 237 |         expect(&quot;$x &#x3D; \\$5$&quot;).toSplitInto(
      |        ^ Redundant Assertion
  238 |             [
  239 |                 {type: &quot;math&quot;, data: &quot;x &#x3D; \\$5&quot;,
  240 |                     rawData: &quot;$x &#x3D; \\$5$&quot;, display: false},</code></pre><br>
                      </td>
                    </tr>
                  </tbody>
                </table>
              </td>
            </tr>
          </tbody>
        </table>
      </div>
    </div>
  </section>
  <footer class="footer">
    <div class="content has-text-centered">
      <p>Copyright © 2020 STEEL. All rights reserved.</p>
      <p>
        <strong>STEEL</strong> by Dalton N. Jorge, under the guidance of Prof. Dr. Patricia D. L. Machado & Prof. Dr.
        Wilkerson L. Andrade.
      </p>
      <p>SPLab - PPGCC - UFCG</p>
    </div>
  </footer>
  <script>
    function toggleDetails(node) {
      let parentRow = node.parentNode.parentNode;
      let path = parentRow.children[0].children[0].innerText;
      let detailsRow = parentRow.nextElementSibling;
      if (detailsRow.className === "details-row hidden") {
        parentRow.children[0].children[0].innerText = path.replace(/^\+/g, '-')
        detailsRow.className = "details-row";
      } else {
        parentRow.children[0].children[0].innerText = path.replace(/^-/g, '+')
        detailsRow.className = "details-row hidden";
      }
    }
  </script>
</body>

</html>
